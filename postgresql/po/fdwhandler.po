msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/fdwhandler.xml:3(title)
msgid "Writing A Foreign Data Wrapper"
msgstr ""

#: xml/fdwhandler.xml:5(primary)
msgid "foreign data wrapper"
msgstr ""

#: xml/fdwhandler.xml:6(secondary)
msgid "handler for"
msgstr ""

#: xml/fdwhandler.xml:8(para)
msgid "All operations on a foreign table are handled through its foreign data wrapper, which consists of a set of functions that the core server calls. The foreign data wrapper is responsible for fetching data from the remote data source and returning it to the <productname>PostgreSQL</productname>executor. If updating foreign tables is to be supported, the wrapper must handle that, too. This chapter outlines how to write a new foreign data wrapper."
msgstr ""

#: xml/fdwhandler.xml:17(para)
msgid "The foreign data wrappers included in the standard distribution are good references when trying to write your own. Look into the <filename>contrib</filename>subdirectory of the source tree. The <xref linkend=\"sql-createforeigndatawrapper\">reference page also has some useful details.</xref>"
msgstr ""

#: xml/fdwhandler.xml:24(para)
msgid "The SQL standard specifies an interface for writing foreign data wrappers. However, PostgreSQL does not implement that API, because the effort to accommodate it into PostgreSQL would be large, and the standard API hasn't gained wide adoption anyway."
msgstr ""

#: xml/fdwhandler.xml:31(title)
msgid "Foreign Data Wrapper Functions"
msgstr ""

#: xml/fdwhandler.xml:32(para)
msgid "The FDW author needs to implement a handler function, and optionally a validator function. Both functions must be written in a compiled language such as C, using the version-1 interface. For details on C language calling conventions and dynamic loading, see <xref linkend=\"xfunc-c\">.</xref>"
msgstr ""

#: xml/fdwhandler.xml:38(para)
msgid "The handler function simply returns a struct of function pointers to callback functions that will be called by the planner, executor, and various maintenance commands. Most of the effort in writing an FDW is in implementing these callback functions. The handler function must be registered with <productname>PostgreSQL</productname>as taking no arguments and returning the special pseudo-type <type>fdw_handler</type>. The callback functions are plain C functions and are not visible or callable at the SQL level. The callback functions are described in <xref linkend=\"fdw-callbacks\">.</xref>"
msgstr ""

#: xml/fdwhandler.xml:49(para)
msgid "The validator function is responsible for validating options given in <command>CREATE</command>and <command>ALTER</command>commands for its foreign data wrapper, as well as foreign servers, user mappings, and foreign tables using the wrapper. The validator function must be registered as taking two arguments, a text array containing the options to be validated, and an OID representing the type of object the options are associated with (in the form of the OID of the system catalog the object would be stored in, either <literal>ForeignDataWrapperRelationId</literal>, <literal>ForeignServerRelationId</literal>, <literal>UserMappingRelationId</literal>, or <literal>ForeignTableRelationId</literal>). If no validator function is supplied, options are not checked at object creation time or object alteration time."
msgstr ""

#: xml/fdwhandler.xml:67(title)
msgid "Foreign Data Wrapper Callback Routines"
msgstr ""

#: xml/fdwhandler.xml:68(para)
msgid "The FDW handler function returns a palloc'd <structname>FdwRoutine</structname>struct containing pointers to the callback functions described below. The scan-related functions are required, the rest are optional."
msgstr ""

#: xml/fdwhandler.xml:72(para)
msgid "The <structname>FdwRoutine</structname>struct type is declared in <filename>src/include/foreign/fdwapi.h</filename>, which see for additional details."
msgstr ""

#: xml/fdwhandler.xml:77(title)
msgid "FDW Routines For Scanning Foreign Tables"
msgstr ""

#: xml/fdwhandler.xml:79(programlisting)
#, no-wrap
msgid "void GetForeignRelSize (PlannerInfo *root,\n      RelOptInfo *baserel, Oid\n      foreigntableid);"
msgstr ""

#: xml/fdwhandler.xml:78(para)
msgid "<placeholder-1/>Obtain relation size estimates for a foreign table. This is called at the beginning of planning for a query that scans a foreign table. <literal>root</literal>is the planner's global information about the query; <literal>baserel</literal>is the planner's information about this table; and <literal>foreigntableid</literal>is the <structname>pg_class</structname>OID of the foreign table. ( <literal>foreigntableid</literal>could be obtained from the planner data structures, but it's passed explicitly to save effort.)"
msgstr ""

#: xml/fdwhandler.xml:94(para)
msgid "This function should update <literal>baserel-rows</literal>to be the expected number of rows returned by the table scan, after accounting for the filtering done by the restriction quals. The initial value of <literal>baserel-rows</literal>is just a constant default estimate, which should be replaced if at all possible. The function may also choose to update <literal>baserel-width</literal>if it can compute a better estimate of the average result row width."
msgstr ""

#: xml/fdwhandler.xml:104(para) xml/fdwhandler.xml:127(para) xml/fdwhandler.xml:152(para) xml/fdwhandler.xml:279(para) xml/fdwhandler.xml:363(para)
msgid "See <xref linkend=\"fdw-planning\">for additional information.</xref>"
msgstr ""

#: xml/fdwhandler.xml:108(programlisting)
#, no-wrap
msgid "void GetForeignPaths (PlannerInfo *root,\n      RelOptInfo *baserel, Oid\n      foreigntableid);"
msgstr ""

#: xml/fdwhandler.xml:107(para)
msgid "<placeholder-1/>Create possible access paths for a scan on a foreign table. This is called during query planning. The parameters are the same as for <function>GetForeignRelSize</function>, which has already been called."
msgstr ""

#: xml/fdwhandler.xml:115(para)
msgid "This function must generate at least one access path ( <structname>ForeignPath</structname>node) for a scan on the foreign table and must call <function>add_path</function>to add each such path to <literal>baserel-pathlist</literal>. It's recommended to use <function>create_foreignscan_path</function>to build the <structname>ForeignPath</structname>nodes. The function can generate multiple access paths, e.g., a path which has valid <literal>pathkeys</literal>to represent a pre-sorted result. Each access path must contain cost estimates, and can contain any FDW-private information that is needed to identify the specific scan method intended."
msgstr ""

#: xml/fdwhandler.xml:131(programlisting)
#, no-wrap
msgid "ForeignScan * GetForeignPlan (PlannerInfo\n      *root, RelOptInfo *baserel, Oid foreigntableid, ForeignPath\n      *best_path, List *tlist, List *scan_clauses, Plan\n      *outer_plan);"
msgstr ""

#: xml/fdwhandler.xml:130(para)
msgid "<placeholder-1/>Create a <structname>ForeignScan</structname>plan node from the selected foreign access path. This is called at the end of query planning. The parameters are as for <function>GetForeignRelSize</function>, plus the selected <structname>ForeignPath</structname>(previously produced by <function>GetForeignPaths</function>or <function>GetForeignJoinPaths</function>), the target list to be emitted by the plan node, and the restriction clauses to be enforced by the plan node. (If the path is for a join rather than a base relation, <literal>foreigntableid</literal>is <literal>InvalidOid</literal>.)"
msgstr ""

#: xml/fdwhandler.xml:147(para)
msgid "This function must create and return a <structname>ForeignScan</structname>plan node; it's recommended to use <function>make_foreignscan</function>to build the <structname>ForeignScan</structname>node."
msgstr ""

#: xml/fdwhandler.xml:156(programlisting)
#, no-wrap
msgid "void BeginForeignScan (ForeignScanState\n      *node, int eflags);"
msgstr ""

#: xml/fdwhandler.xml:155(para)
msgid "<placeholder-1/>Begin executing a foreign scan. This is called during executor startup. It should perform any initialization needed before the scan can start, but not start executing the actual scan (that should be done upon the first call to <function>IterateForeignScan</function>). The <structname>ForeignScanState</structname>node has already been created, but its <structfield>fdw_state</structfield>field is still NULL. Information about the table to scan is accessible through the <structname>ForeignScanState</structname>node (in particular, from the underlying <structname>ForeignScan</structname>plan node, which contains any FDW-private information provided by <function>GetForeignPlan</function>). <literal>eflags</literal>contains flag bits describing the executor's operating mode for this plan node."
msgstr ""

#: xml/fdwhandler.xml:175(para)
msgid "Note that when <literal>(eflags EXEC_FLAG_EXPLAIN_ONLY)</literal>is true, this function should not perform any externally-visible actions; it should only do the minimum required to make the node state valid for <function>ExplainForeignScan</function>and <function>EndForeignScan</function>."
msgstr ""

#: xml/fdwhandler.xml:183(programlisting)
#, no-wrap
msgid "TupleTableSlot * IterateForeignScan\n      (ForeignScanState *node);"
msgstr ""

#: xml/fdwhandler.xml:182(para)
msgid "<placeholder-1/>Fetch one row from the foreign source, returning it in a tuple table slot (the node's <structfield>ScanTupleSlot</structfield>should be used for this purpose). Return NULL if no more rows are available. The tuple table slot infrastructure allows either a physical or virtual tuple to be returned; in most cases the latter choice is preferable from a performance standpoint. Note that this is called in a short-lived memory context that will be reset between invocations. Create a memory context in <function>BeginForeignScan</function>if you need longer-lived storage, or use the <structfield>es_query_cxt</structfield>of the node's <structname>EState</structname>."
msgstr ""

#: xml/fdwhandler.xml:198(para)
msgid "The rows returned must match the <structfield>fdw_scan_tlist</structfield>target list if one was supplied, otherwise they must match the row type of the foreign table being scanned. If you choose to optimize away fetching columns that are not needed, you should insert nulls in those column positions, or else generate a <structfield>fdw_scan_tlist</structfield>list with those columns omitted."
msgstr ""

#: xml/fdwhandler.xml:206(para)
msgid "Note that <productname>PostgreSQL</productname>'s executor doesn't care whether the rows returned violate any constraints that were defined on the foreign table but the planner does care, and may optimize queries incorrectly if there are rows visible in the foreign table that do not satisfy a declared constraint. If a constraint is violated when the user has declared that the constraint should hold true, it may be appropriate to raise an error (just as you would need to do in the case of a data type mismatch)."
msgstr ""

#: xml/fdwhandler.xml:217(programlisting)
#, no-wrap
msgid "void ReScanForeignScan (ForeignScanState\n      *node);"
msgstr ""

#: xml/fdwhandler.xml:216(para)
msgid "<placeholder-1/>Restart the scan from the beginning. Note that any parameters the scan depends on may have changed value, so the new scan does not necessarily return exactly the same rows."
msgstr ""

#: xml/fdwhandler.xml:223(programlisting)
#, no-wrap
msgid "void EndForeignScan (ForeignScanState\n      *node);"
msgstr ""

#: xml/fdwhandler.xml:222(para)
msgid "<placeholder-1/>End the scan and release resources. It is normally not important to release palloc'd memory, but for example open files and connections to remote servers should be cleaned up."
msgstr ""

#: xml/fdwhandler.xml:230(title)
msgid "FDW Routines For Scanning Foreign Joins"
msgstr ""

#: xml/fdwhandler.xml:231(para)
msgid "If an FDW supports performing foreign joins remotely (rather than by fetching both tables' data and doing the join locally), it should provide this callback function:"
msgstr ""

#: xml/fdwhandler.xml:235(programlisting)
#, no-wrap
msgid "void GetForeignJoinPaths (PlannerInfo *root,\n      RelOptInfo *joinrel, RelOptInfo *outerrel, RelOptInfo\n      *innerrel, JoinType jointype, JoinPathExtraData\n      *extra);"
msgstr ""

#: xml/fdwhandler.xml:234(para)
msgid "<placeholder-1/>Create possible access paths for a join of two (or more) foreign tables that all belong to the same foreign server. This optional function is called during query planning. As with <function>GetForeignPaths</function>, this function should generate <structname>ForeignPath</structname>path(s) for the supplied <literal>joinrel</literal>, and call <function>add_path</function>to add these paths to the set of paths considered for the join. But unlike <function>GetForeignPaths</function>, it is not necessary that this function succeed in creating at least one path, since paths involving local joining are always possible."
msgstr ""

#: xml/fdwhandler.xml:252(para)
msgid "Note that this function will be invoked repeatedly for the same join relation, with different combinations of inner and outer relations; it is the responsibility of the FDW to minimize duplicated work."
msgstr ""

#: xml/fdwhandler.xml:256(para)
msgid "If a <structname>ForeignPath</structname>path is chosen for the join, it will represent the entire join process; paths generated for the component tables and subsidiary joins will not be used. Subsequent processing of the join path proceeds much as it does for a path scanning a single foreign table. One difference is that the <structfield>scanrelid</structfield>of the resulting <structname>ForeignScan</structname>plan node should be set to zero, since there is no single relation that it represents; instead, the <structfield>fs_relids</structfield>field of the <structname>ForeignScan</structname>node represents the set of relations that were joined. (The latter field is set up automatically by the core planner code, and need not be filled by the FDW.) Another difference is that, because the column list for a remote join cannot be found from the system catalogs, the FDW must fill <structfield>fdw_scan_tlist</structfield>with an appropriate list of <structfield>TargetEntry</structfield>nodes, representing the set of columns it will supply at run time in the tuples it returns."
msgstr ""

#: xml/fdwhandler.xml:284(title)
msgid "FDW Routines For Updating Foreign Tables"
msgstr ""

#: xml/fdwhandler.xml:285(para)
msgid "If an FDW supports writable foreign tables, it should provide some or all of the following callback functions depending on the needs and capabilities of the FDW:"
msgstr ""

#: xml/fdwhandler.xml:289(programlisting)
#, no-wrap
msgid "void AddForeignUpdateTargets (Query\n      *parsetree, RangeTblEntry *target_rte, Relation\n      target_relation);"
msgstr ""

#: xml/fdwhandler.xml:288(para)
msgid "<placeholder-1/><command>UPDATE</command>and <command>DELETE</command>operations are performed against rows previously fetched by the table-scanning functions. The FDW may need extra information, such as a row ID or the values of primary-key columns, to ensure that it can identify the exact row to update or delete. To support that, this function can add extra hidden, or <quote>junk</quote>, target columns to the list of columns that are to be retrieved from the foreign table during an <command>UPDATE</command>or <command>DELETE</command>."
msgstr ""

#: xml/fdwhandler.xml:303(para)
msgid "To do that, add <structname>TargetEntry</structname>items to <literal>parsetree-targetList</literal>, containing expressions for the extra values to be fetched. Each such entry must be marked <structfield>resjunk</structfield>= <literal>true</literal>, and must have a distinct <structfield>resname</structfield>that will identify it at execution time. Avoid using names matching <literal>ctid <replaceable>N</replaceable></literal>, <literal>wholerow</literal>, or <literal>wholerow <replaceable>N</replaceable></literal>, as the core system can generate junk columns of these names."
msgstr ""

#: xml/fdwhandler.xml:318(para)
msgid "This function is called in the rewriter, not the planner, so the information available is a bit different from that available to the planning routines. <literal>parsetree</literal>is the parse tree for the <command>UPDATE</command>or <command>DELETE</command>command, while <literal>target_rte</literal>and <literal>target_relation</literal>describe the target foreign table."
msgstr ""

#: xml/fdwhandler.xml:327(para)
msgid "If the <function>AddForeignUpdateTargets</function>pointer is set to <literal>NULL</literal>, no extra target expressions are added. (This will make it impossible to implement <command>DELETE</command>operations, though <command>UPDATE</command>may still be feasible if the FDW relies on an unchanging primary key to identify rows.)"
msgstr ""

#: xml/fdwhandler.xml:336(programlisting)
#, no-wrap
msgid "List * PlanForeignModify (PlannerInfo *root,\n      ModifyTable *plan, Index resultRelation, int\n      subplan_index);"
msgstr ""

#: xml/fdwhandler.xml:335(para)
msgid "<placeholder-1/>Perform any additional planning actions needed for an insert, update, or delete on a foreign table. This function generates the FDW-private information that will be attached to the <structname>ModifyTable</structname>plan node that performs the update action. This private information must have the form of a <literal>List</literal>, and will be delivered to <function>BeginForeignModify</function>during the execution stage."
msgstr ""

#: xml/fdwhandler.xml:348(para)
msgid "<literal>root</literal>is the planner's global information about the query. <literal>plan</literal>is the <structname>ModifyTable</structname>plan node, which is complete except for the <structfield>fdwPrivLists</structfield>field. <literal>resultRelation</literal>identifies the target foreign table by its range table index. <literal>subplan_index</literal>identifies which target of the <structname>ModifyTable</structname>plan node this is, counting from zero; use this if you want to index into <literal>plan-plans</literal>or other substructure of the <literal>plan</literal>node."
msgstr ""

#: xml/fdwhandler.xml:366(para)
msgid "If the <function>PlanForeignModify</function>pointer is set to <literal>NULL</literal>, no additional plan-time actions are taken, and the <literal>fdw_private</literal>list delivered to <function>BeginForeignModify</function>will be NIL."
msgstr ""

#: xml/fdwhandler.xml:373(programlisting)
#, no-wrap
msgid "void BeginForeignModify (ModifyTableState\n      *mtstate, ResultRelInfo *rinfo, List *fdw_private, int\n      subplan_index, int eflags);"
msgstr ""

#: xml/fdwhandler.xml:372(para)
msgid "<placeholder-1/>Begin executing a foreign table modification operation. This routine is called during executor startup. It should perform any initialization needed prior to the actual table modifications. Subsequently, <function>ExecForeignInsert</function>, <function>ExecForeignUpdate</function>or <function>ExecForeignDelete</function>will be called for each tuple to be inserted, updated, or deleted."
msgstr ""

#: xml/fdwhandler.xml:384(para)
msgid "<literal>mtstate</literal>is the overall state of the <structname>ModifyTable</structname>plan node being executed; global data about the plan and execution state is available via this structure. <literal>rinfo</literal>is the <structname>ResultRelInfo</structname>struct describing the target foreign table. (The <structfield>ri_FdwState</structfield>field of <structname>ResultRelInfo</structname>is available for the FDW to store any private state it needs for this operation.) <literal>fdw_private</literal>contains the private data generated by <function>PlanForeignModify</function>, if any. <literal>subplan_index</literal>identifies which target of the <structname>ModifyTable</structname>plan node this is. <literal>eflags</literal>contains flag bits describing the executor's operating mode for this plan node."
msgstr ""

#: xml/fdwhandler.xml:403(para)
msgid "Note that when <literal>(eflags EXEC_FLAG_EXPLAIN_ONLY)</literal>is true, this function should not perform any externally-visible actions; it should only do the minimum required to make the node state valid for <function>ExplainForeignModify</function>and <function>EndForeignModify</function>."
msgstr ""

#: xml/fdwhandler.xml:410(para)
msgid "If the <function>BeginForeignModify</function>pointer is set to <literal>NULL</literal>, no action is taken during executor startup."
msgstr ""

#: xml/fdwhandler.xml:415(programlisting)
#, no-wrap
msgid "TupleTableSlot * ExecForeignInsert (EState\n      *estate, ResultRelInfo *rinfo, TupleTableSlot *slot,\n      TupleTableSlot *planSlot);"
msgstr ""

#: xml/fdwhandler.xml:414(para)
msgid "<placeholder-1/>Insert one tuple into the foreign table. <literal>estate</literal>is global execution state for the query. <literal>rinfo</literal>is the <structname>ResultRelInfo</structname>struct describing the target foreign table. <literal>slot</literal>contains the tuple to be inserted; it will match the row-type definition of the foreign table. <literal>planSlot</literal>contains the tuple that was generated by the <structname>ModifyTable</structname>plan node's subplan; it differs from <literal>slot</literal>in possibly containing additional <quote>junk</quote>columns. (The <literal>planSlot</literal>is typically of little interest for <command>INSERT</command>cases, but is provided for completeness.)"
msgstr ""

#: xml/fdwhandler.xml:436(para)
msgid "The return value is either a slot containing the data that was actually inserted (this might differ from the data supplied, for example as a result of trigger actions), or NULL if no row was actually inserted (again, typically as a result of triggers). The passed-in <literal>slot</literal>can be re-used for this purpose."
msgstr ""

#: xml/fdwhandler.xml:443(para)
msgid "The data in the returned slot is used only if the <command>INSERT</command>query has a <literal>RETURNING</literal>clause or the foreign table has an <literal>AFTER ROW</literal>trigger. Triggers require all columns, but the FDW could choose to optimize away returning some or all columns depending on the contents of the <literal>RETURNING</literal>clause. Regardless, some slot must be returned to indicate success, or the query's reported row count will be wrong."
msgstr ""

#: xml/fdwhandler.xml:453(para)
msgid "If the <function>ExecForeignInsert</function>pointer is set to <literal>NULL</literal>, attempts to insert into the foreign table will fail with an error message."
msgstr ""

#: xml/fdwhandler.xml:458(programlisting)
#, no-wrap
msgid "TupleTableSlot * ExecForeignUpdate (EState\n      *estate, ResultRelInfo *rinfo, TupleTableSlot *slot,\n      TupleTableSlot *planSlot);"
msgstr ""

#: xml/fdwhandler.xml:457(para)
msgid "<placeholder-1/>Update one tuple in the foreign table. <literal>estate</literal>is global execution state for the query. <literal>rinfo</literal>is the <structname>ResultRelInfo</structname>struct describing the target foreign table. <literal>slot</literal>contains the new data for the tuple; it will match the row-type definition of the foreign table. <literal>planSlot</literal>contains the tuple that was generated by the <structname>ModifyTable</structname>plan node's subplan; it differs from <literal>slot</literal>in possibly containing additional <quote>junk</quote>columns. In particular, any junk columns that were requested by <function>AddForeignUpdateTargets</function>will be available from this slot."
msgstr ""

#: xml/fdwhandler.xml:478(para)
msgid "The return value is either a slot containing the row as it was actually updated (this might differ from the data supplied, for example as a result of trigger actions), or NULL if no row was actually updated (again, typically as a result of triggers). The passed-in <literal>slot</literal>can be re-used for this purpose."
msgstr ""

#: xml/fdwhandler.xml:485(para)
msgid "The data in the returned slot is used only if the <command>UPDATE</command>query has a <literal>RETURNING</literal>clause or the foreign table has an <literal>AFTER ROW</literal>trigger. Triggers require all columns, but the FDW could choose to optimize away returning some or all columns depending on the contents of the <literal>RETURNING</literal>clause. Regardless, some slot must be returned to indicate success, or the query's reported row count will be wrong."
msgstr ""

#: xml/fdwhandler.xml:495(para)
msgid "If the <function>ExecForeignUpdate</function>pointer is set to <literal>NULL</literal>, attempts to update the foreign table will fail with an error message."
msgstr ""

#: xml/fdwhandler.xml:500(programlisting)
#, no-wrap
msgid "TupleTableSlot * ExecForeignDelete (EState\n      *estate, ResultRelInfo *rinfo, TupleTableSlot *slot,\n      TupleTableSlot *planSlot);"
msgstr ""

#: xml/fdwhandler.xml:499(para)
msgid "<placeholder-1/>Delete one tuple from the foreign table. <literal>estate</literal>is global execution state for the query. <literal>rinfo</literal>is the <structname>ResultRelInfo</structname>struct describing the target foreign table. <literal>slot</literal>contains nothing useful upon call, but can be used to hold the returned tuple. <literal>planSlot</literal>contains the tuple that was generated by the <structname>ModifyTable</structname>plan node's subplan; in particular, it will carry any junk columns that were requested by <function>AddForeignUpdateTargets</function>. The junk column(s) must be used to identify the tuple to be deleted."
msgstr ""

#: xml/fdwhandler.xml:519(para)
msgid "The return value is either a slot containing the row that was deleted, or NULL if no row was deleted (typically as a result of triggers). The passed-in <literal>slot</literal>can be used to hold the tuple to be returned."
msgstr ""

#: xml/fdwhandler.xml:524(para)
msgid "The data in the returned slot is used only if the <command>DELETE</command>query has a <literal>RETURNING</literal>clause or the foreign table has an <literal>AFTER ROW</literal>trigger. Triggers require all columns, but the FDW could choose to optimize away returning some or all columns depending on the contents of the <literal>RETURNING</literal>clause. Regardless, some slot must be returned to indicate success, or the query's reported row count will be wrong."
msgstr ""

#: xml/fdwhandler.xml:534(para)
msgid "If the <function>ExecForeignDelete</function>pointer is set to <literal>NULL</literal>, attempts to delete from the foreign table will fail with an error message."
msgstr ""

#: xml/fdwhandler.xml:539(programlisting)
#, no-wrap
msgid "void EndForeignModify (EState *estate,\n      ResultRelInfo *rinfo);"
msgstr ""

#: xml/fdwhandler.xml:538(para)
msgid "<placeholder-1/>End the table update and release resources. It is normally not important to release palloc'd memory, but for example open files and connections to remote servers should be cleaned up."
msgstr ""

#: xml/fdwhandler.xml:544(para)
msgid "If the <function>EndForeignModify</function>pointer is set to <literal>NULL</literal>, no action is taken during executor shutdown."
msgstr ""

#: xml/fdwhandler.xml:549(programlisting)
#, no-wrap
msgid "int IsForeignRelUpdatable (Relation\n      rel);"
msgstr ""

#: xml/fdwhandler.xml:548(para)
msgid "<placeholder-1/>Report which update operations the specified foreign table supports. The return value should be a bit mask of rule event numbers indicating which operations are supported by the foreign table, using the <literal>CmdType</literal>enumeration; that is, <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal>for <command>UPDATE</command>, <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal>for <command>INSERT</command>, and <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal>for <command>DELETE</command>."
msgstr ""

#: xml/fdwhandler.xml:561(para)
msgid "If the <function>IsForeignRelUpdatable</function>pointer is set to <literal>NULL</literal>, foreign tables are assumed to be insertable, updatable, or deletable if the FDW provides <function>ExecForeignInsert</function>, <function>ExecForeignUpdate</function>, or <function>ExecForeignDelete</function>respectively. This function is only needed if the FDW supports some tables that are updatable and some that are not. (Even then, it's permissible to throw an error in the execution routine instead of checking in this function. However, this function is used to determine updatability for display in the <literal>information_schema</literal>views.)"
msgstr ""

#: xml/fdwhandler.xml:576(title)
msgid "FDW Routines For Row Locking"
msgstr ""

#: xml/fdwhandler.xml:577(para)
msgid "If an FDW wishes to support <firstterm>late row locking</firstterm>(as described in <xref linkend=\"fdw-row-locking\">), it must provide the following callback functions:</xref>"
msgstr ""

#: xml/fdwhandler.xml:582(programlisting)
#, no-wrap
msgid "RowMarkType GetForeignRowMarkType\n      (RangeTblEntry *rte, LockClauseStrength\n      strength);"
msgstr ""

#: xml/fdwhandler.xml:581(para)
msgid "<placeholder-1/>Report which row-marking option to use for a foreign table. <literal>rte</literal>is the <structname>RangeTblEntry</structname>node for the table and <literal>strength</literal>describes the lock strength requested by the relevant <literal>FOR UPDATE/SHARE</literal>clause, if any. The result must be a member of the <literal>RowMarkType</literal>enum type."
msgstr ""

#: xml/fdwhandler.xml:593(para)
msgid "This function is called during query planning for each foreign table that appears in an <command>UPDATE</command>, <command>DELETE</command>, or <command>SELECT FOR UPDATE/SHARE</command>query and is not the target of <command>UPDATE</command>or <command>DELETE</command>."
msgstr ""

#: xml/fdwhandler.xml:601(para)
msgid "If the <function>GetForeignRowMarkType</function>pointer is set to <literal>NULL</literal>, the <literal>ROW_MARK_COPY</literal>option is always used. (This implies that <function>RefetchForeignRow</function>will never be called, so it need not be provided either.)"
msgstr ""

#: xml/fdwhandler.xml:608(para) xml/fdwhandler.xml:660(para)
msgid "See <xref linkend=\"fdw-row-locking\">for more information.</xref>"
msgstr ""

#: xml/fdwhandler.xml:612(programlisting)
#, no-wrap
msgid "HeapTuple RefetchForeignRow (EState *estate,\n      ExecRowMark *erm, Datum rowid, bool\n      *updated);"
msgstr ""

#: xml/fdwhandler.xml:611(para)
msgid "<placeholder-1/>Re-fetch one tuple from the foreign table, after locking it if required. <literal>estate</literal>is global execution state for the query. <literal>erm</literal>is the <structname>ExecRowMark</structname>struct describing the target foreign table and the row lock type (if any) to acquire. <literal>rowid</literal>identifies the tuple to be fetched. <literal>updated</literal>is an output parameter."
msgstr ""

#: xml/fdwhandler.xml:624(para)
msgid "This function should return a palloc'ed copy of the fetched tuple, or <literal>NULL</literal>if the row lock couldn't be obtained. The row lock type to acquire is defined by <literal>erm-markType</literal>, which is the value previously returned by <function>GetForeignRowMarkType</function>. ( <literal>ROW_MARK_REFERENCE</literal>means to just re-fetch the tuple without acquiring any lock, and <literal>ROW_MARK_COPY</literal>will never be seen by this routine.)"
msgstr ""

#: xml/fdwhandler.xml:635(para)
msgid "In addition, <literal>*updated</literal>should be set to <literal>true</literal>if what was fetched was an updated version of the tuple rather than the same version previously obtained. (If the FDW cannot be sure about this, always returning <literal>true</literal>is recommended.)"
msgstr ""

#: xml/fdwhandler.xml:642(para)
msgid "Note that by default, failure to acquire a row lock should result in raising an error; a <literal>NULL</literal>return is only appropriate if the <literal>SKIP LOCKED</literal>option is specified by <literal>erm-waitPolicy</literal>."
msgstr ""

#: xml/fdwhandler.xml:647(para)
msgid "The <literal>rowid</literal>is the <structfield>ctid</structfield>value previously read for the row to be re-fetched. Although the <literal>rowid</literal>value is passed as a <type>Datum</type>, it can currently only be a <type>tid</type>. The function API is chosen in hopes that it may be possible to allow other data types for row IDs in future."
msgstr ""

#: xml/fdwhandler.xml:656(para)
msgid "If the <function>RefetchForeignRow</function>pointer is set to <literal>NULL</literal>, attempts to re-fetch rows will fail with an error message."
msgstr ""

#: xml/fdwhandler.xml:664(programlisting)
#, no-wrap
msgid "bool RecheckForeignScan (ForeignScanState\n      *node, TupleTableSlot *slot);"
msgstr ""

#: xml/fdwhandler.xml:663(para)
msgid "<placeholder-1/>Recheck that a previously-returned tuple still matches the relevant scan and join qualifiers, and possibly provide a modified version of the tuple. For foreign data wrappers which do not perform join pushdown, it will typically be more convenient to set this to <literal>NULL</literal>and instead set <structfield>fdw_recheck_quals</structfield>appropriately. When outer joins are pushed down, however, it isn't sufficient to reapply the checks relevant to all the base tables to the result tuple, even if all needed attributes are present, because failure to match some qualifier might result in some attributes going to NULL, rather than in no tuple being returned. <literal>RecheckForeignScan</literal>can recheck qualifiers and return true if they are still satisfied and false otherwise, but it can also store a replacement tuple into the supplied slot."
msgstr ""

#: xml/fdwhandler.xml:683(para)
msgid "To implement join pushdown, a foreign data wrapper will typically construct an alternative local join plan which is used only for rechecks; this will become the outer subplan of the <literal>ForeignScan</literal>. When a recheck is required, this subplan can be executed and the resulting tuple can be stored in the slot. This plan need not be efficient since no base table will return more than one row; for example, it may implement all joins as nested loops."
msgstr ""

#: xml/fdwhandler.xml:694(title)
msgid "FDW Routines for <command>EXPLAIN</command>"
msgstr ""

#: xml/fdwhandler.xml:697(programlisting)
#, no-wrap
msgid "void ExplainForeignScan (ForeignScanState\n      *node, ExplainState *es);"
msgstr ""

#: xml/fdwhandler.xml:696(para)
msgid "<placeholder-1/>Print additional <command>EXPLAIN</command>output for a foreign table scan. This function can call <function>ExplainPropertyText</function>and related functions to add fields to the <command>EXPLAIN</command>output. The flag fields in <literal>es</literal>can be used to determine what to print, and the state of the <structname>ForeignScanState</structname>node can be inspected to provide run-time statistics in the <command>EXPLAIN ANALYZE</command>case."
msgstr ""

#: xml/fdwhandler.xml:709(para)
msgid "If the <function>ExplainForeignScan</function>pointer is set to <literal>NULL</literal>, no additional information is printed during <command>EXPLAIN</command>."
msgstr ""

#: xml/fdwhandler.xml:715(programlisting)
#, no-wrap
msgid "void ExplainForeignModify (ModifyTableState\n      *mtstate, ResultRelInfo *rinfo, List *fdw_private, int\n      subplan_index, struct ExplainState\n      *es);"
msgstr ""

#: xml/fdwhandler.xml:714(para)
msgid "<placeholder-1/>Print additional <command>EXPLAIN</command>output for a foreign table update. This function can call <function>ExplainPropertyText</function>and related functions to add fields to the <command>EXPLAIN</command>output. The flag fields in <literal>es</literal>can be used to determine what to print, and the state of the <structname>ModifyTableState</structname>node can be inspected to provide run-time statistics in the <command>EXPLAIN ANALYZE</command>case. The first four arguments are the same as for <function>BeginForeignModify</function>."
msgstr ""

#: xml/fdwhandler.xml:731(para)
msgid "If the <function>ExplainForeignModify</function>pointer is set to <literal>NULL</literal>, no additional information is printed during <command>EXPLAIN</command>."
msgstr ""

#: xml/fdwhandler.xml:738(title)
msgid "FDW Routines for <command>ANALYZE</command>"
msgstr ""

#: xml/fdwhandler.xml:741(programlisting)
#, no-wrap
msgid "bool AnalyzeForeignTable (Relation relation,\n      AcquireSampleRowsFunc *func, BlockNumber\n      *totalpages);"
msgstr ""

#: xml/fdwhandler.xml:740(para)
msgid "<placeholder-1/>This function is called when <xref linkend=\"sql-analyze\">is executed on a foreign table. If the FDW can collect statistics for this foreign table, it should return <literal>true</literal>, and provide a pointer to a function that will collect sample rows from the table in <parameter>func</parameter>, plus the estimated size of the table in pages in <parameter>totalpages</parameter>. Otherwise, return <literal>false</literal>.</xref>"
msgstr ""

#: xml/fdwhandler.xml:753(para)
msgid "If the FDW does not support collecting statistics for any tables, the <function>AnalyzeForeignTable</function>pointer can be set to <literal>NULL</literal>."
msgstr ""

#: xml/fdwhandler.xml:760(programlisting)
#, no-wrap
msgid "int AcquireSampleRowsFunc (Relation relation,\n      int elevel, HeapTuple *rows, int targrows, double *totalrows,\n      double *totaldeadrows);"
msgstr ""

#: xml/fdwhandler.xml:758(para)
msgid "If provided, the sample collection function must have the signature <placeholder-1/>A random sample of up to <parameter>targrows</parameter>rows should be collected from the table and stored into the caller-provided <parameter>rows</parameter>array. The actual number of rows collected must be returned. In addition, store estimates of the total numbers of live and dead rows in the table into the output parameters <parameter>totalrows</parameter>and <parameter>totaldeadrows</parameter>. (Set <parameter>totaldeadrows</parameter>to zero if the FDW does not have any concept of dead rows.)"
msgstr ""

#: xml/fdwhandler.xml:776(title)
msgid "FDW Routines For <command>IMPORT FOREIGN SCHEMA</command>"
msgstr ""

#: xml/fdwhandler.xml:779(programlisting)
#, no-wrap
msgid "List * ImportForeignSchema\n      (ImportForeignSchemaStmt *stmt, Oid\n      serverOid);"
msgstr ""

#: xml/fdwhandler.xml:778(para)
msgid "<placeholder-1/>Obtain a list of foreign table creation commands. This function is called when executing <xref linkend=\"sql-importforeignschema\">, and is passed the parse tree for that statement, as well as the OID of the foreign server to use. It should return a list of C strings, each of which must contain a <xref linkend=\"sql-createforeigntable\">command. These strings will be parsed and executed by the core server.</xref></xref>"
msgstr ""

#: xml/fdwhandler.xml:790(para)
msgid "Within the <structname>ImportForeignSchemaStmt</structname>struct, <structfield>remote_schema</structfield>is the name of the remote schema from which tables are to be imported. <structfield>list_type</structfield>identifies how to filter table names: <literal>FDW_IMPORT_SCHEMA_ALL</literal>means that all tables in the remote schema should be imported (in this case <structfield>table_list</structfield>is empty), <literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal>means to include only tables listed in <structfield>table_list</structfield>, and <literal>FDW_IMPORT_SCHEMA_EXCEPT</literal>means to exclude the tables listed in <structfield>table_list</structfield>. <structfield>options</structfield>is a list of options used for the import process. The meanings of the options are up to the FDW. For example, an FDW could use an option to define whether the <literal>NOT NULL</literal>attributes of columns should be imported. These options need not have anything to do with those supported by the FDW as database object options."
msgstr ""

#: xml/fdwhandler.xml:812(para)
msgid "The FDW may ignore the <structfield>local_schema</structfield>field of the <structname>ImportForeignSchemaStmt</structname>, because the core server will automatically insert that name into the parsed <command>CREATE FOREIGN TABLE</command>commands."
msgstr ""

#: xml/fdwhandler.xml:818(para)
msgid "The FDW does not have to concern itself with implementing the filtering specified by <structfield>list_type</structfield>and <structfield>table_list</structfield>, either, as the core server will automatically skip any returned commands for tables excluded according to those options. However, it's often useful to avoid the work of creating commands for excluded tables in the first place. The function <function>IsImportableForeignTable()</function>may be useful to test whether a given foreign-table name will pass the filter."
msgstr ""

#: xml/fdwhandler.xml:829(para)
msgid "If the FDW does not support importing table definitions, the <function>ImportForeignSchema</function>pointer can be set to <literal>NULL</literal>."
msgstr ""

#: xml/fdwhandler.xml:837(title)
msgid "Foreign Data Wrapper Helper Functions"
msgstr ""

#: xml/fdwhandler.xml:838(para)
msgid "Several helper functions are exported from the core server so that authors of foreign data wrappers can get easy access to attributes of FDW-related objects, such as FDW options. To use any of these functions, you need to include the header file <filename>foreign/foreign.h</filename>in your source file. That header also defines the struct types that are returned by these functions."
msgstr ""

#: xml/fdwhandler.xml:847(programlisting)
#, no-wrap
msgid "ForeignDataWrapper * GetForeignDataWrapper(Oid\n    fdwid);"
msgstr ""

#: xml/fdwhandler.xml:846(para)
msgid "<placeholder-1/>This function returns a <structname>ForeignDataWrapper</structname>object for the foreign-data wrapper with the given OID. A <structname>ForeignDataWrapper</structname>object contains properties of the FDW (see <filename>foreign/foreign.h</filename>for details)."
msgstr ""

#: xml/fdwhandler.xml:855(programlisting)
#, no-wrap
msgid "ForeignServer * GetForeignServer(Oid\n    serverid);"
msgstr ""

#: xml/fdwhandler.xml:854(para)
msgid "<placeholder-1/>This function returns a <structname>ForeignServer</structname>object for the foreign server with the given OID. A <structname>ForeignServer</structname>object contains properties of the server (see <filename>foreign/foreign.h</filename>for details)."
msgstr ""

#: xml/fdwhandler.xml:863(programlisting)
#, no-wrap
msgid "UserMapping * GetUserMapping(Oid userid, Oid\n    serverid);"
msgstr ""

#: xml/fdwhandler.xml:862(para)
msgid "<placeholder-1/>This function returns a <structname>UserMapping</structname>object for the user mapping of the given role on the given server. (If there is no mapping for the specific user, it will return the mapping for <literal>PUBLIC</literal>, or throw error if there is none.) A <structname>UserMapping</structname>object contains properties of the user mapping (see <filename>foreign/foreign.h</filename>for details)."
msgstr ""

#: xml/fdwhandler.xml:873(programlisting)
#, no-wrap
msgid "ForeignTable * GetForeignTable(Oid\n    relid);"
msgstr ""

#: xml/fdwhandler.xml:872(para)
msgid "<placeholder-1/>This function returns a <structname>ForeignTable</structname>object for the foreign table with the given OID. A <structname>ForeignTable</structname>object contains properties of the foreign table (see <filename>foreign/foreign.h</filename>for details)."
msgstr ""

#: xml/fdwhandler.xml:881(programlisting)
#, no-wrap
msgid "List * GetForeignColumnOptions(Oid relid,\n    AttrNumber attnum);"
msgstr ""

#: xml/fdwhandler.xml:880(para)
msgid "<placeholder-1/>This function returns the per-column FDW options for the column with the given foreign table OID and attribute number, in the form of a list of <structname>DefElem</structname>. NIL is returned if the column has no options."
msgstr ""

#: xml/fdwhandler.xml:887(para)
msgid "Some object types have name-based lookup functions in addition to the OID-based ones:"
msgstr ""

#: xml/fdwhandler.xml:890(programlisting)
#, no-wrap
msgid "ForeignDataWrapper *\n    GetForeignDataWrapperByName(const char *name, bool\n    missing_ok);"
msgstr ""

#: xml/fdwhandler.xml:889(para)
msgid "<placeholder-1/>This function returns a <structname>ForeignDataWrapper</structname>object for the foreign-data wrapper with the given name. If the wrapper is not found, return NULL if missing_ok is true, otherwise raise an error."
msgstr ""

#: xml/fdwhandler.xml:898(programlisting)
#, no-wrap
msgid "ForeignServer * GetForeignServerByName(const\n    char *name, bool missing_ok);"
msgstr ""

#: xml/fdwhandler.xml:897(para)
msgid "<placeholder-1/>This function returns a <structname>ForeignServer</structname>object for the foreign server with the given name. If the server is not found, return NULL if missing_ok is true, otherwise raise an error."
msgstr ""

#: xml/fdwhandler.xml:906(title)
msgid "Foreign Data Wrapper Query Planning"
msgstr ""

#: xml/fdwhandler.xml:907(para)
msgid "The FDW callback functions <function>GetForeignRelSize</function>, <function>GetForeignPaths</function>, <function>GetForeignPlan</function>, <function>PlanForeignModify</function>, and <function>GetForeignJoinPaths</function>must fit into the workings of the <productname>PostgreSQL</productname>planner. Here are some notes about what they must do."
msgstr ""

#: xml/fdwhandler.xml:916(para)
msgid "The information in <literal>root</literal>and <literal>baserel</literal>can be used to reduce the amount of information that has to be fetched from the foreign table (and therefore reduce the cost). <literal>baserel-baserestrictinfo</literal>is particularly interesting, as it contains restriction quals ( <literal>WHERE</literal>clauses) that should be used to filter the rows to be fetched. (The FDW itself is not required to enforce these quals, as the core executor can check them instead.) <literal>baserel-reltargetlist</literal>can be used to determine which columns need to be fetched; but note that it only lists columns that have to be emitted by the <structname>ForeignScan</structname>plan node, not columns that are used in qual evaluation but not output by the query."
msgstr ""

#: xml/fdwhandler.xml:932(para)
msgid "Various private fields are available for the FDW planning functions to keep information in. Generally, whatever you store in FDW private fields should be palloc'd, so that it will be reclaimed at the end of planning."
msgstr ""

#: xml/fdwhandler.xml:936(para)
msgid "<literal>baserel-fdw_private</literal>is a <type>void</type>pointer that is available for FDW planning functions to store information relevant to the particular foreign table. The core planner does not touch it except to initialize it to NULL when the <literal>RelOptInfo</literal>node is created. It is useful for passing information forward from <function>GetForeignRelSize</function>to <function>GetForeignPaths</function>and/or <function>GetForeignPaths</function>to <function>GetForeignPlan</function>, thereby avoiding recalculation."
msgstr ""

#: xml/fdwhandler.xml:949(para)
msgid "<function>GetForeignPaths</function>can identify the meaning of different access paths by storing private information in the <structfield>fdw_private</structfield>field of <structname>ForeignPath</structname>nodes. <structfield>fdw_private</structfield>is declared as a <type>List</type>pointer, but could actually contain anything since the core planner does not touch it. However, best practice is to use a representation that's dumpable by <function>nodeToString</function>, for use with debugging support available in the backend."
msgstr ""

#: xml/fdwhandler.xml:960(para)
msgid "<function>GetForeignPlan</function>can examine the <structfield>fdw_private</structfield>field of the selected <structname>ForeignPath</structname>node, and can generate <structfield>fdw_exprs</structfield>and <structfield>fdw_private</structfield>lists to be placed in the <structname>ForeignScan</structname>plan node, where they will be available at execution time. Both of these lists must be represented in a form that <function>copyObject</function>knows how to copy. The <structfield>fdw_private</structfield>list has no other restrictions and is not interpreted by the core backend in any way. The <structfield>fdw_exprs</structfield>list, if not NIL, is expected to contain expression trees that are intended to be executed at run time. These trees will undergo post-processing by the planner to make them fully executable."
msgstr ""

#: xml/fdwhandler.xml:978(para)
msgid "In <function>GetForeignPlan</function>, generally the passed-in target list can be copied into the plan node as-is. The passed <literal>scan_clauses</literal>list contains the same clauses as <literal>baserel-baserestrictinfo</literal>, but may be re-ordered for better execution efficiency. In simple cases the FDW can just strip <structname>RestrictInfo</structname>nodes from the <literal>scan_clauses</literal>list (using <function>extract_actual_clauses</function>) and put all the clauses into the plan node's qual list, which means that all the clauses will be checked by the executor at run time. More complex FDWs may be able to check some of the clauses internally, in which case those clauses can be removed from the plan node's qual list so that the executor doesn't waste time rechecking them."
msgstr ""

#: xml/fdwhandler.xml:995(para)
msgid "As an example, the FDW might identify some restriction clauses of the form <replaceable>foreign_variable</replaceable><literal>=</literal><replaceable>sub_expression</replaceable>, which it determines can be executed on the remote server given the locally-evaluated value of the <replaceable>sub_expression</replaceable>. The actual identification of such a clause should happen during <function>GetForeignPaths</function>, since it would affect the cost estimate for the path. The path's <structfield>fdw_private</structfield>field would probably include a pointer to the identified clause's <structname>RestrictInfo</structname>node. Then <function>GetForeignPlan</function>would remove that clause from <literal>scan_clauses</literal>, but add the <replaceable>sub_expression</replaceable>to <structfield>fdw_exprs</structfield>to ensure that it gets massaged into executable form. It would probably also put control information into the plan node's <structfield>fdw_private</structfield>field to tell the execution functions what to do at run time. The query transmitted to the remote server would involve something like <literal>WHERE <replaceable>foreign_variable</replaceable>= $1</literal>, with the parameter value obtained at run time from evaluation of the <structfield>fdw_exprs</structfield>expression tree."
msgstr ""

#: xml/fdwhandler.xml:1024(para)
msgid "Any clauses removed from the plan node's qual list must instead be added to <literal>fdw_recheck_quals</literal>or rechecked by <literal>RecheckForeignScan</literal>in order to ensure correct behavior at the <literal>READ COMMITTED</literal>isolation level. When a concurrent update occurs for some other table involved in the query, the executor may need to verify that all of the original quals are still satisfied for the tuple, possibly against a different set of parameter values. Using <literal>fdw_recheck_quals</literal>is typically easier than implementing checks inside <literal>RecheckForeignScan</literal>, but this method will be insufficient when outer joins have been pushed down, since the join tuples in that case might have some fields go to NULL without rejecting the tuple entirely."
msgstr ""

#: xml/fdwhandler.xml:1040(para)
msgid "Another <structname>ForeignScan</structname>field that can be filled by FDWs is <structfield>fdw_scan_tlist</structfield>, which describes the tuples returned by the FDW for this plan node. For simple foreign table scans this can be set to <literal>NIL</literal>, implying that the returned tuples have the row type declared for the foreign table. A non- <symbol>NIL</symbol>value must be a target list (list of <structname>TargetEntry</structname>s) containing Vars and/or expressions representing the returned columns. This might be used, for example, to show that the FDW has omitted some columns that it noticed won't be needed for the query. Also, if the FDW can compute expressions used by the query more cheaply than can be done locally, it could add those expressions to <structfield>fdw_scan_tlist</structfield>. Note that join plans (created from paths made by <function>GetForeignJoinPaths</function>) must always supply <structfield>fdw_scan_tlist</structfield>to describe the set of columns they will return."
msgstr ""

#: xml/fdwhandler.xml:1060(para)
msgid "The FDW should always construct at least one path that depends only on the table's restriction clauses. In join queries, it might also choose to construct path(s) that depend on join clauses, for example <replaceable>foreign_variable</replaceable><literal>=</literal><replaceable>local_variable</replaceable>. Such clauses will not be found in <literal>baserel-baserestrictinfo</literal>but must be sought in the relation's join lists. A path using such a clause is called a <quote>parameterized path</quote>. It must identify the other relations used in the selected join clause(s) with a suitable value of <literal>param_info</literal>; use <function>get_baserel_parampathinfo</function>to compute that value. In <function>GetForeignPlan</function>, the <replaceable>local_variable</replaceable>portion of the join clause would be added to <structfield>fdw_exprs</structfield>, and then at run time the case works the same as for an ordinary restriction clause."
msgstr ""

#: xml/fdwhandler.xml:1083(para)
msgid "If an FDW supports remote joins, <function>GetForeignJoinPaths</function>should produce <structname>ForeignPath</structname>s for potential remote joins in much the same way as <function>GetForeignPaths</function>works for base tables. Information about the intended join can be passed forward to <function>GetForeignPlan</function>in the same ways described above. However, <structfield>baserestrictinfo</structfield>is not relevant for join relations; instead, the relevant join clauses for a particular join are passed to <function>GetForeignJoinPaths</function>as a separate parameter ( <literal>extra-restrictlist</literal>)."
msgstr ""

#: xml/fdwhandler.xml:1097(para)
msgid "When planning an <command>UPDATE</command>or <command>DELETE</command>, <function>PlanForeignModify</function>can look up the <structname>RelOptInfo</structname>struct for the foreign table and make use of the <literal>baserel-fdw_private</literal>data previously created by the scan-planning functions. However, in <command>INSERT</command>the target table is not scanned so there is no <structname>RelOptInfo</structname>for it. The <structname>List</structname>returned by <function>PlanForeignModify</function>has the same restrictions as the <structfield>fdw_private</structfield>list of a <structname>ForeignScan</structname>plan node, that is it must contain only structures that <function>copyObject</function>knows how to copy."
msgstr ""

#: xml/fdwhandler.xml:1115(para)
msgid "<command>INSERT</command>with an <literal>ON CONFLICT</literal>clause does not support specifying the conflict target, as unique constraints or exclusion constraints on remote tables are not locally known. This in turn implies that <literal>ON CONFLICT DO UPDATE</literal>is not supported, since the specification is mandatory there."
msgstr ""

#: xml/fdwhandler.xml:1125(title)
msgid "Row Locking in Foreign Data Wrappers"
msgstr ""

#: xml/fdwhandler.xml:1126(para)
msgid "If an FDW's underlying storage mechanism has a concept of locking individual rows to prevent concurrent updates of those rows, it is usually worthwhile for the FDW to perform row-level locking with as close an approximation as practical to the semantics used in ordinary <productname>PostgreSQL</productname>tables. There are multiple considerations involved in this."
msgstr ""

#: xml/fdwhandler.xml:1133(para)
msgid "One key decision to be made is whether to perform <firstterm>early locking</firstterm>or <firstterm>late locking</firstterm>. In early locking, a row is locked when it is first retrieved from the underlying store, while in late locking, the row is locked only when it is known that it needs to be locked. (The difference arises because some rows may be discarded by locally-checked restriction or join conditions.) Early locking is much simpler and avoids extra round trips to a remote store, but it can cause locking of rows that need not have been locked, resulting in reduced concurrency or even unexpected deadlocks. Also, late locking is only possible if the row to be locked can be uniquely re-identified later. Preferably the row identifier should identify a specific version of the row, as <productname>PostgreSQL</productname>TIDs do."
msgstr ""

#: xml/fdwhandler.xml:1148(para)
msgid "By default, <productname>PostgreSQL</productname>ignores locking considerations when interfacing to FDWs, but an FDW can perform early locking without any explicit support from the core code. The API functions described in <xref linkend=\"fdw-callbacks-row-locking\">, which were added in <productname>PostgreSQL</productname>9.5, allow an FDW to use late locking if it wishes.</xref>"
msgstr ""

#: xml/fdwhandler.xml:1157(para)
msgid "An additional consideration is that in <literal>READ COMMITTED</literal>isolation mode, <productname>PostgreSQL</productname>may need to re-check restriction and join conditions against an updated version of some target tuple. Rechecking join conditions requires re-obtaining copies of the non-target rows that were previously joined to the target tuple. When working with standard <productname>PostgreSQL</productname>tables, this is done by including the TIDs of the non-target tables in the column list projected through the join, and then re-fetching non-target rows when required. This approach keeps the join data set compact, but it requires inexpensive re-fetch capability, as well as a TID that can uniquely identify the row version to be re-fetched. By default, therefore, the approach used with foreign tables is to include a copy of the entire row fetched from a foreign table in the column list projected through the join. This puts no special demands on the FDW but can result in reduced performance of merge and hash joins. An FDW that is capable of meeting the re-fetch requirements can choose to do it the first way."
msgstr ""

#: xml/fdwhandler.xml:1177(para)
msgid "For an <command>UPDATE</command>or <command>DELETE</command>on a foreign table, it is recommended that the <literal>ForeignScan</literal>operation on the target table perform early locking on the rows that it fetches, perhaps via the equivalent of <command>SELECT FOR UPDATE</command>. An FDW can detect whether a table is an <command>UPDATE</command>/ <command>DELETE</command>target at plan time by comparing its relid to <literal>root-parse-resultRelation</literal>, or at execution time by using <function>ExecRelationIsTargetRelation()</function>. An alternative possibility is to perform late locking within the <function>ExecForeignUpdate</function>or <function>ExecForeignDelete</function>callback, but no special support is provided for this."
msgstr ""

#: xml/fdwhandler.xml:1196(para)
msgid "For foreign tables that are specified to be locked by a <command>SELECT FOR UPDATE/SHARE</command>command, the <literal>ForeignScan</literal>operation can again perform early locking by fetching tuples with the equivalent of <command>SELECT FOR UPDATE/SHARE</command>. To perform late locking instead, provide the callback functions defined in <xref linkend=\"fdw-callbacks-row-locking\">. In <function>GetForeignRowMarkType</function>, select rowmark option <literal>ROW_MARK_EXCLUSIVE</literal>, <literal>ROW_MARK_NOKEYEXCLUSIVE</literal>, <literal>ROW_MARK_SHARE</literal>, or <literal>ROW_MARK_KEYSHARE</literal>depending on the requested lock strength. (The core code will act the same regardless of which of these four options you choose.) Elsewhere, you can detect whether a foreign table was specified to be locked by this type of command by using <function>get_plan_rowmark</function>at plan time, or <function>ExecFindRowMark</function>at execution time; you must check not only whether a non-null rowmark struct is returned, but that its <structfield>strength</structfield>field is not <literal>LCS_NONE</literal>.</xref>"
msgstr ""

#: xml/fdwhandler.xml:1219(para)
msgid "Lastly, for foreign tables that are used in an <command>UPDATE</command>, <command>DELETE</command>or <command>SELECT FOR UPDATE/SHARE</command>command but are not specified to be row-locked, you can override the default choice to copy entire rows by having <function>GetForeignRowMarkType</function>select option <literal>ROW_MARK_REFERENCE</literal>when it sees lock strength <literal>LCS_NONE</literal>. This will cause <function>RefetchForeignRow</function>to be called with that value for <structfield>markType</structfield>; it should then re-fetch the row without acquiring any new lock. (If you have a <function>GetForeignRowMarkType</function>function but don't wish to re-fetch unlocked rows, select option <literal>ROW_MARK_COPY</literal>for <literal>LCS_NONE</literal>.)"
msgstr ""

#: xml/fdwhandler.xml:1237(para)
msgid "See <filename>src/include/nodes/lockoptions.h</filename>, the comments for <type>RowMarkType</type>and <type>PlanRowMark</type>in <filename>src/include/nodes/plannodes.h</filename>, and the comments for <type>ExecRowMark</type>in <filename>src/include/nodes/execnodes.h</filename>for additional information."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/fdwhandler.xml:0(None)
msgid "translator-credits"
msgstr ""

