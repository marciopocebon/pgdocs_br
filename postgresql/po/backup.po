msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/backup.xml:3(title)
msgid "Backup and Restore"
msgstr ""

#: xml/backup.xml:5(primary)
msgid "backup"
msgstr ""

#: xml/backup.xml:7(para)
msgid "As with everything that contains valuable data, <productname>PostgreSQL</productname>databases should be backed up regularly. While the procedure is essentially simple, it is important to have a clear understanding of the underlying techniques and assumptions."
msgstr ""

#: xml/backup.xml:17(para)
msgid "<acronym>SQL</acronym>dump"
msgstr ""

#: xml/backup.xml:21(para)
msgid "File system level backup"
msgstr ""

#: xml/backup.xml:24(para)
msgid "Continuous archiving"
msgstr ""

#: xml/backup.xml:12(para)
msgid "There are three fundamentally different approaches to backing up <productname>PostgreSQL</productname>data: <placeholder-1/>Each has its own strengths and weaknesses; each is discussed in turn in the following sections."
msgstr ""

#: xml/backup.xml:29(title)
msgid "<acronym>SQL</acronym>Dump"
msgstr ""

#: xml/backup.xml:31(para)
msgid "The idea behind this dump method is to generate a file with SQL commands that, when fed back to the server, will recreate the database in the same state as it was at the time of the dump. <productname>PostgreSQL</productname>provides the utility program <xref linkend=\"app-pgdump\">for this purpose. The basic usage of this command is: <synopsis>pg_dump \n    <replaceable class=\"parameter\">dbname</replaceable>\n    <replaceable class=\"parameter\">\n    outfile</replaceable></synopsis>As you see, <application>pg_dump</application>writes its result to the standard output. We will see below how this can be useful. While the above command creates a text file, <application>pg_dump</application>can create files in other formats that allow for parallelism and more fine-grained control of object restoration.</xref>"
msgstr ""

#: xml/backup.xml:49(para)
msgid "<application>pg_dump</application>is a regular <productname>PostgreSQL</productname>client application (albeit a particularly clever one). This means that you can perform this backup procedure from any remote host that has access to the database. But remember that <application>pg_dump</application>does not operate with special permissions. In particular, it must have read access to all tables that you want to back up, so in order to back up the entire database you almost always have to run it as a database superuser. (If you do not have sufficient privileges to back up the entire database, you can still back up portions of the database to which you do have access using options such as <option>-n <replaceable>schema</replaceable></option>or <option>-t <replaceable>table</replaceable></option>.)"
msgstr ""

#: xml/backup.xml:66(para)
msgid "To specify which database server <application>pg_dump</application>should contact, use the command line options <option>-h <replaceable>host</replaceable></option>and <option>-p <replaceable>port</replaceable></option>. The default host is the local host or whatever your <envar>PGHOST</envar>environment variable specifies. Similarly, the default port is indicated by the <envar>PGPORT</envar>environment variable or, failing that, by the compiled-in default. (Conveniently, the server will normally have the same compiled-in default.)"
msgstr ""

#: xml/backup.xml:79(para)
msgid "Like any other <productname>PostgreSQL</productname>client application, <application>pg_dump</application>will by default connect with the database user name that is equal to the current operating system user name. To override this, either specify the <option>-U</option>option or set the environment variable <envar>PGUSER</envar>. Remember that <application>pg_dump</application>connections are subject to the normal client authentication mechanisms (which are described in <xref linkend=\"client-authentication\">).</xref>"
msgstr ""

#: xml/backup.xml:90(para)
msgid "An important advantage of <application>pg_dump</application>over the other backup methods described later is that <application>pg_dump</application>'s output can generally be re-loaded into newer versions of <productname>PostgreSQL</productname>, whereas file-level backups and continuous archiving are both extremely server-version-specific. <application>pg_dump</application>is also the only method that will work when transferring a database to a different machine architecture, such as going from a 32-bit to a 64-bit server."
msgstr ""

#: xml/backup.xml:102(para)
msgid "Dumps created by <application>pg_dump</application>are internally consistent, meaning, the dump represents a snapshot of the database at the time <application>pg_dump</application>began running. <application>pg_dump</application>does not block other operations on the database while it is working. (Exceptions are those operations that need to operate with an exclusive lock, such as most forms of <command>ALTER TABLE</command>.)"
msgstr ""

#: xml/backup.xml:113(title)
msgid "Restoring the Dump"
msgstr ""

#: xml/backup.xml:114(para)
msgid "Text files created by <application>pg_dump</application>are intended to be read in by the <application>psql</application>program. The general command form to restore a dump is <synopsis>psql \n      <replaceable class=\"parameter\">dbname</replaceable>\n      <replaceable class=\"parameter\">\n      infile</replaceable></synopsis>where <replaceable class=\"parameter\">infile</replaceable>is the file output by the <application>pg_dump</application>command. The database <replaceable class=\"parameter\">dbname</replaceable>will not be created by this command, so you must create it yourself from <literal>template0</literal>before executing <application>psql</application>(e.g., with <literal>createdb -T template0 <replaceable class=\"parameter\"> dbname</replaceable></literal>). <application>psql</application>supports options similar to <application>pg_dump</application>for specifying the database server to connect to and the user name to use. See the <xref linkend=\"app-psql\">reference page for more information. Non-text file dumps are restored using the <xref linkend=\"app-pgrestore\">utility.</xref></xref>"
msgstr ""

#: xml/backup.xml:140(para)
msgid "Before restoring an SQL dump, all the users who own objects or were granted permissions on objects in the dumped database must already exist. If they do not, the restore will fail to recreate the objects with the original ownership and/or permissions. (Sometimes this is what you want, but usually it is not.)"
msgstr ""

#: xml/backup.xml:155(programlisting)
#, no-wrap
msgid "psql --set ON_ERROR_STOP=on dbname\n      infile"
msgstr ""

#: xml/backup.xml:146(para)
msgid "By default, the <application>psql</application>script will continue to execute after an SQL error is encountered. You might wish to run <application>psql</application>with the <literal>ON_ERROR_STOP</literal>variable set to alter that behavior and have <application>psql</application>exit with an exit status of 3 if an SQL error occurs: <placeholder-1/>Either way, you will only have a partially restored database. Alternatively, you can specify that the whole dump should be restored as a single transaction, so the restore is either fully completed or fully rolled back. This mode can be specified by passing the <option>-1</option>or <option>--single-transaction</option>command-line options to <application>psql</application>. When using this mode, be aware that even a minor error can rollback a restore that has already run for many hours. However, that might still be preferable to manually cleaning up a complex database after a partially restored dump."
msgstr ""

#: xml/backup.xml:173(programlisting)
#, no-wrap
msgid "pg_dump -h \n      <replaceable>host1</replaceable>\n      <replaceable>dbname</replaceable>| psql -h \n      <replaceable>host2</replaceable>\n      <replaceable>dbname</replaceable>"
msgstr ""

#: xml/backup.xml:168(para)
msgid "The ability of <application>pg_dump</application>and <application>psql</application>to write to or read from pipes makes it possible to dump a database directly from one server to another, for example: <placeholder-1/>"
msgstr ""

#: xml/backup.xml:179(para)
msgid "The dumps produced by <application>pg_dump</application>are relative to <literal>template0</literal>. This means that any languages, procedures, etc. added via <literal>template1</literal>will also be dumped by <application>pg_dump</application>. As a result, when restoring, if you are using a customized <literal>template1</literal>, you must create the empty database from <literal>template0</literal>, as in the example above."
msgstr ""

#: xml/backup.xml:191(para)
msgid "After restoring a backup, it is wise to run <xref linkend=\"sql-analyze\">on each database so the query optimizer has useful statistics; see <xref linkend=\"vacuum-for-statistics\">and <xref linkend=\"autovacuum\">for more information. For more advice on how to load large amounts of data into <productname>PostgreSQL</productname>efficiently, refer to <xref linkend=\"populate\">.</xref></xref></xref></xref>"
msgstr ""

#: xml/backup.xml:201(title)
msgid "Using <application>pg_dumpall</application>"
msgstr ""

#: xml/backup.xml:203(para)
msgid "<application>pg_dump</application>dumps only a single database at a time, and it does not dump information about roles or tablespaces (because those are cluster-wide rather than per-database). To support convenient dumping of the entire contents of a database cluster, the <xref linkend=\"app-pg-dumpall\">program is provided. <application>pg_dumpall</application>backs up each database in a given cluster, and also preserves cluster-wide data such as role and tablespace definitions. The basic usage of this command is: <synopsis>pg_dumpall \n      <replaceable>outfile</replaceable></synopsis>The resulting dump can be restored with <application>psql</application>: <synopsis>psql -f \n      <replaceable class=\"parameter\">\n      infile</replaceable>postgres</synopsis>(Actually, you can specify any existing database name to start from, but if you are loading into an empty cluster then <literal>postgres</literal>should usually be used.) It is always necessary to have database superuser access when restoring a <application>pg_dumpall</application>dump, as that is required to restore the role and tablespace information. If you use tablespaces, make sure that the tablespace paths in the dump are appropriate for the new installation.</xref>"
msgstr ""

#: xml/backup.xml:231(para)
msgid "<application>pg_dumpall</application>works by emitting commands to re-create roles, tablespaces, and empty databases, then invoking <application>pg_dump</application>for each database. This means that while each database will be internally consistent, the snapshots of different databases are not synchronized."
msgstr ""

#: xml/backup.xml:239(para)
msgid "Cluster-wide data can be dumped alone using the <application>pg_dumpall</application><option>--globals-only</option>option. This is necessary to fully backup the cluster if running the <application>pg_dump</application>command on individual databases."
msgstr ""

#: xml/backup.xml:247(title)
msgid "Handling Large Databases"
msgstr ""

#: xml/backup.xml:248(para)
msgid "Some operating systems have maximum file size limits that cause problems when creating large <application>pg_dump</application>output files. Fortunately, <application>pg_dump</application>can write to the standard output, so you can use standard Unix tools to work around this potential problem. There are several possible methods:"
msgstr ""

#: xml/backup.xml:256(title)
msgid "Use compressed dumps."
msgstr ""

#: xml/backup.xml:260(programlisting)
#, no-wrap
msgid "pg_dump \n        <replaceable class=\"parameter\">dbname</replaceable>| gzip \n        <replaceable class=\"parameter\">\n        filename</replaceable>.gz"
msgstr ""

#: xml/backup.xml:264(programlisting)
#, no-wrap
msgid "gunzip -c \n        <replaceable class=\"parameter\">filename</replaceable>.gz |\n        psql \n        <replaceable class=\"parameter\">\n        dbname</replaceable>"
msgstr ""

#: xml/backup.xml:269(programlisting)
#, no-wrap
msgid "cat \n        <replaceable class=\"parameter\">filename</replaceable>.gz |\n        gunzip | psql \n        <replaceable class=\"parameter\">\n        dbname</replaceable>"
msgstr ""

#: xml/backup.xml:257(para)
msgid "You can use your favorite compression program, for example <application>gzip</application>: <placeholder-1/>Reload with: <placeholder-2/>or: <placeholder-3/>"
msgstr ""

#: xml/backup.xml:276(title)
msgid "Use <command>split</command>."
msgstr ""

#: xml/backup.xml:283(programlisting)
#, no-wrap
msgid "pg_dump \n        <replaceable class=\"parameter\">dbname</replaceable>| split\n        -b 1m - \n        <replaceable class=\"parameter\">\n        filename</replaceable>"
msgstr ""

#: xml/backup.xml:288(programlisting)
#, no-wrap
msgid "cat \n        <replaceable class=\"parameter\">filename</replaceable>* |\n        psql \n        <replaceable class=\"parameter\">\n        dbname</replaceable>"
msgstr ""

#: xml/backup.xml:278(para)
msgid "The <command>split</command>command allows you to split the output into smaller files that are acceptable in size to the underlying file system. For example, to make chunks of 1 megabyte: <placeholder-1/>Reload with: <placeholder-2/>"
msgstr ""

#: xml/backup.xml:295(title)
msgid "Use <application>pg_dump</application>'s custom dump format."
msgstr ""

#: xml/backup.xml:308(programlisting)
#, no-wrap
msgid "pg_dump -Fc \n        <replaceable class=\"parameter\">dbname</replaceable>\n        <replaceable class=\"parameter\">\n        filename</replaceable>"
msgstr ""

#: xml/backup.xml:316(programlisting)
#, no-wrap
msgid "pg_restore -d \n        <replaceable class=\"parameter\">dbname</replaceable>\n        <replaceable class=\"parameter\">\n        filename</replaceable>"
msgstr ""

#: xml/backup.xml:298(para)
msgid "If <productname>PostgreSQL</productname>was built on a system with the <application>zlib</application>compression library installed, the custom dump format will compress data as it writes it to the output file. This will produce dump file sizes similar to using <command>gzip</command>, but it has the added advantage that tables can be restored selectively. The following command dumps a database using the custom dump format: <placeholder-1/>A custom-format dump is not a script for <application>psql</application>, but instead must be restored with <application>pg_restore</application>, for example: <placeholder-2/>See the <xref linkend=\"app-pgdump\">and <xref linkend=\"app-pgrestore\">reference pages for details.</xref></xref>"
msgstr ""

#: xml/backup.xml:324(para)
msgid "For very large databases, you might need to combine <command>split</command>with one of the other two approaches."
msgstr ""

#: xml/backup.xml:328(title)
msgid "Use <application>pg_dump</application>'s parallel dump feature."
msgstr ""

#: xml/backup.xml:338(programlisting)
#, no-wrap
msgid "pg_dump -j \n        <replaceable class=\"parameter\">num</replaceable>-F d -f \n        <replaceable class=\"parameter\">out.dir</replaceable>\n        <replaceable class=\"parameter\">\n        dbname</replaceable>"
msgstr ""

#: xml/backup.xml:331(para)
msgid "To speed up the dump of a large database, you can use <application>pg_dump</application>'s parallel mode. This will dump multiple tables at the same time. You can control the degree of parallelism with the <command>-j</command>parameter. Parallel dumps are only supported for the \"directory\" archive format. <placeholder-1/>You can use <command>pg_restore -j</command>to restore a dump in parallel. This will work for any archive of either the \"custom\" or the \"directory\" archive mode, whether or not it has been created with <command>pg_dump -j</command>."
msgstr ""

#: xml/backup.xml:352(title)
msgid "File System Level Backup"
msgstr ""

#: xml/backup.xml:360(programlisting)
#, no-wrap
msgid "tar -cf backup.tar\n    /usr/local/pgsql/data"
msgstr ""

#: xml/backup.xml:353(para)
msgid "An alternative backup strategy is to directly copy the files that <productname>PostgreSQL</productname>uses to store the data in the database; <xref linkend=\"creating-cluster\">explains where these files are located. You can use whatever method you prefer for doing file system backups; for example: <placeholder-1/></xref>"
msgstr ""

#: xml/backup.xml:367(para)
msgid "The database server <emphasis>must</emphasis>be shut down in order to get a usable backup. Half-way measures such as disallowing all connections will <emphasis>not</emphasis>work (in part because <command>tar</command>and similar tools do not take an atomic snapshot of the state of the file system, but also because of internal buffering within the server). Information about stopping the server can be found in <xref linkend=\"server-shutdown\">. Needless to say, you also need to shut down the server before restoring the data.</xref>"
msgstr ""

#: xml/backup.xml:381(para)
msgid "If you have dug into the details of the file system layout of the database, you might be tempted to try to back up or restore only certain individual tables or databases from their respective files or directories. This will <emphasis>not</emphasis>work because the information contained in these files is not usable without the commit log files, <filename>pg_clog/*</filename>, which contain the commit status of all transactions. A table file is only usable with this information. Of course it is also impossible to restore only a table and the associated <filename>pg_clog</filename>data because that would render all other tables in the database cluster useless. So file system backups only work for complete backup and restoration of an entire database cluster."
msgstr ""

#: xml/backup.xml:362(para)
msgid "There are two restrictions, however, which make this method impractical, or at least inferior to the <application>pg_dump</application>method: <placeholder-1/>"
msgstr ""

#: xml/backup.xml:398(para)
msgid "An alternative file-system backup approach is to make a <quote>consistent snapshot</quote>of the data directory, if the file system supports that functionality (and you are willing to trust that it is implemented correctly). The typical procedure is to make a <quote>frozen snapshot</quote>of the volume containing the database, then copy the whole data directory (not just parts, see above) from the snapshot to a backup device, then release the frozen snapshot. This will work even while the database server is running. However, a backup created in this way saves the database files in a state as if the database server was not properly shut down; therefore, when you start the database server on the backed-up data, it will think the previous server instance crashed and will replay the WAL log. This is not a problem; just be aware of it (and be sure to include the WAL files in your backup). You can perform a <command>CHECKPOINT</command>before taking the snapshot to reduce recovery time."
msgstr ""

#: xml/backup.xml:416(para)
msgid "If your database is spread across multiple file systems, there might not be any way to obtain exactly-simultaneous frozen snapshots of all the volumes. For example, if your data files and WAL log are on different disks, or if tablespaces are on different file systems, it might not be possible to use snapshot backup because the snapshots <emphasis>must</emphasis>be simultaneous. Read your file system documentation very carefully before trusting the consistent-snapshot technique in such situations."
msgstr ""

#: xml/backup.xml:425(para)
msgid "If simultaneous snapshots are not possible, one option is to shut down the database server long enough to establish all the frozen snapshots. Another option is to perform a continuous archiving base backup ( <xref linkend=\"backup-base-backup\">) because such backups are immune to file system changes during the backup. This requires enabling continuous archiving just during the backup process; restore is done using continuous archive recovery ( <xref linkend=\"backup-pitr-recovery\">).</xref></xref>"
msgstr ""

#: xml/backup.xml:434(para)
msgid "Another option is to use <application>rsync</application>to perform a file system backup. This is done by first running <application>rsync</application>while the database server is running, then shutting down the database server long enough to do an <command>rsync --checksum</command>. ( <option>--checksum</option>is necessary because <command>rsync</command>only has file modification-time granularity of one second.) The second <application>rsync</application>will be quicker than the first, because it has relatively little data to transfer, and the end result will be consistent because the server was down. This method allows a file system backup to be performed with minimal downtime."
msgstr ""

#: xml/backup.xml:449(para)
msgid "Note that a file system backup will typically be larger than an SQL dump. ( <application>pg_dump</application>does not need to dump the contents of indexes for example, just the commands to recreate them.) However, taking a file system backup might be faster."
msgstr ""

#: xml/backup.xml:457(title)
msgid "Continuous Archiving and Point-in-Time Recovery (PITR)"
msgstr ""

#: xml/backup.xml:460(primary)
msgid "continuous archiving"
msgstr ""

#: xml/backup.xml:463(primary)
msgid "point-in-time recovery"
msgstr ""

#: xml/backup.xml:466(primary)
msgid "PITR"
msgstr ""

#: xml/backup.xml:487(para)
msgid "We do not need a perfectly consistent file system backup as the starting point. Any internal inconsistency in the backup will be corrected by log replay (this is not significantly different from what happens during crash recovery). So we do not need a file system snapshot capability, just <application>tar</application>or a similar archiving tool."
msgstr ""

#: xml/backup.xml:497(para)
msgid "Since we can combine an indefinitely long sequence of WAL files for replay, continuous backup can be achieved simply by continuing to archive the WAL files. This is particularly valuable for large databases, where it might not be convenient to take a full backup frequently."
msgstr ""

#: xml/backup.xml:504(para)
msgid "It is not necessary to replay the WAL entries all the way to the end. We could stop the replay at any point and have a consistent snapshot of the database as it was at that time. Thus, this technique supports <firstterm>point-in-time recovery</firstterm>: it is possible to restore the database to its state at any time since your base backup was taken."
msgstr ""

#: xml/backup.xml:513(para)
msgid "If we continuously feed the series of WAL files to another machine that has been loaded with the same base backup file, we have a <firstterm>warm standby</firstterm>system: at any point we can bring up the second machine and it will have a nearly-current copy of the database."
msgstr ""

#: xml/backup.xml:468(para)
msgid "At all times, <productname>PostgreSQL</productname>maintains a <firstterm>write ahead log</firstterm>(WAL) in the <filename>pg_xlog/</filename>subdirectory of the cluster's data directory. The log records every change made to the database's data files. This log exists primarily for crash-safety purposes: if the system crashes, the database can be restored to consistency by <quote>replaying</quote>the log entries made since the last checkpoint. However, the existence of the log makes it possible to use a third strategy for backing up databases: we can combine a file-system-level backup with backup of the WAL files. If recovery is needed, we restore the file system backup and then replay from the backed-up WAL files to bring the system to a current state. This approach is more complex to administer than either of the previous approaches, but it has some significant benefits: <placeholder-1/>"
msgstr ""

#: xml/backup.xml:522(para)
msgid "<application>pg_dump</application>and <application>pg_dumpall</application>do not produce file-system-level backups and cannot be used as part of a continuous-archiving solution. Such dumps are <emphasis>logical</emphasis>and do not contain enough information to be used by WAL replay."
msgstr ""

#: xml/backup.xml:530(para)
msgid "As with the plain file-system-backup technique, this method can only support restoration of an entire database cluster, not a subset. Also, it requires a lot of archival storage: the base backup might be bulky, and a busy system will generate many megabytes of WAL traffic that have to be archived. Still, it is the preferred backup technique in many situations where high reliability is needed."
msgstr ""

#: xml/backup.xml:537(para)
msgid "To recover successfully using continuous archiving (also called <quote>online backup</quote>by many database vendors), you need a continuous sequence of archived WAL files that extends back at least as far as the start time of your backup. So to get started, you should set up and test your procedure for archiving WAL files <emphasis>before</emphasis>you take your first base backup. Accordingly, we first discuss the mechanics of archiving WAL files."
msgstr ""

#: xml/backup.xml:548(title)
msgid "Setting Up WAL Archiving"
msgstr ""

#: xml/backup.xml:549(para)
msgid "In an abstract sense, a running <productname>PostgreSQL</productname>system produces an indefinitely long sequence of WAL records. The system physically divides this sequence into WAL <firstterm>segment files</firstterm>, which are normally 16MB apiece (although the segment size can be altered when building <productname>PostgreSQL</productname>). The segment files are given numeric names that reflect their position in the abstract WAL sequence. When not using WAL archiving, the system normally creates just a few segment files and then <quote>recycles</quote>them by renaming no-longer-needed segment files to higher segment numbers. It's assumed that segment files whose contents precede the checkpoint-before-last are no longer of interest and can be recycled."
msgstr ""

#: xml/backup.xml:565(para)
msgid "When archiving WAL data, we need to capture the contents of each segment file once it is filled, and save that data somewhere before the segment file is recycled for reuse. Depending on the application and the available hardware, there could be many different ways of <quote>saving the data somewhere</quote>: we could copy the segment files to an NFS-mounted directory on another machine, write them onto a tape drive (ensuring that you have a way of identifying the original name of each file), or batch them together and burn them onto CDs, or something else entirely. To provide the database administrator with flexibility, <productname>PostgreSQL</productname>tries not to make any assumptions about how the archiving will be done. Instead, <productname>PostgreSQL</productname>lets the administrator specify a shell command to be executed to copy a completed segment file to wherever it needs to go. The command could be as simple as a <literal>cp</literal>, or it could invoke a complex shell script it's all up to you."
msgstr ""

#: xml/backup.xml:602(programlisting)
#, no-wrap
msgid "archive_command = 'test ! -f\n      /mnt/server/archivedir/%f cp %p /mnt/server/archivedir/%f' #\n      Unix archive_command = 'copy \"%p\"\n      \"C:\\\\server\\\\archivedir\\\\%f\"' # Windows"
msgstr ""

#: xml/backup.xml:613(programlisting)
#, no-wrap
msgid "test ! -f\n      /mnt/server/archivedir/00000001000000A900000065 cp\n      pg_xlog/00000001000000A900000065\n      /mnt/server/archivedir/00000001000000A900000065"
msgstr ""

#: xml/backup.xml:584(para)
msgid "To enable WAL archiving, set the <xref linkend=\"guc-wal-level\">configuration parameter to <literal>archive</literal>or higher, <xref linkend=\"guc-archive-mode\">to <literal>on</literal>, and specify the shell command to use in the <xref linkend=\"guc-archive-command\">configuration parameter. In practice these settings will always be placed in the <filename>postgresql.conf</filename>file. In <varname>archive_command</varname>, <literal>%p</literal>is replaced by the path name of the file to archive, while <literal>%f</literal>is replaced by only the file name. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Use <literal>%%</literal>if you need to embed an actual <literal>%</literal>character in the command. The simplest useful command is something like: <placeholder-1/>which will copy archivable WAL segments to the directory <filename>/mnt/server/archivedir</filename>. (This is an example, not a recommendation, and might not work on all platforms.) After the <literal>%p</literal>and <literal>%f</literal>parameters have been replaced, the actual command executed might look like this: <placeholder-2/>A similar command will be generated for each new file to be archived.</xref></xref></xref>"
msgstr ""

#: xml/backup.xml:619(para)
msgid "The archive command will be executed under the ownership of the same user that the <productname>PostgreSQL</productname>server is running as. Since the series of WAL files being archived contains effectively everything in your database, you will want to be sure that the archived data is protected from prying eyes; for example, archive into a directory that does not have group or world read access."
msgstr ""

#: xml/backup.xml:627(para)
msgid "It is important that the archive command return zero exit status if and only if it succeeds. Upon getting a zero result, <productname>PostgreSQL</productname>will assume that the file has been successfully archived, and will remove or recycle it. However, a nonzero status tells <productname>PostgreSQL</productname>that the file was not archived; it will try again periodically until it succeeds."
msgstr ""

#: xml/backup.xml:636(para)
msgid "The archive command should generally be designed to refuse to overwrite any pre-existing archive file. This is an important safety feature to preserve the integrity of your archive in case of administrator error (such as sending the output of two different servers to the same archive directory)."
msgstr ""

#: xml/backup.xml:642(para)
msgid "It is advisable to test your proposed archive command to ensure that it indeed does not overwrite an existing file, <emphasis>and that it returns nonzero status in this case</emphasis>. The example command above for Unix ensures this by including a separate <command>test</command>step. On some Unix platforms, <command>cp</command>has switches such as <option>-i</option>that can be used to do the same thing less verbosely, but you should not rely on these without verifying that the right exit status is returned. (In particular, GNU <command>cp</command>will return status zero when <option>-i</option>is used and the target file already exists, which is <emphasis>not</emphasis>the desired behavior.)"
msgstr ""

#: xml/backup.xml:657(para)
msgid "While designing your archiving setup, consider what will happen if the archive command fails repeatedly because some aspect requires operator intervention or the archive runs out of space. For example, this could occur if you write to tape without an autochanger; when the tape fills, nothing further can be archived until the tape is swapped. You should ensure that any error condition or request to a human operator is reported appropriately so that the situation can be resolved reasonably quickly. The <filename>pg_xlog/</filename>directory will continue to fill with WAL segment files until the situation is resolved. (If the file system containing <filename>pg_xlog/</filename>fills up, <productname>PostgreSQL</productname>will do a PANIC shutdown. No committed transactions will be lost, but the database will remain offline until you free some space.)"
msgstr ""

#: xml/backup.xml:674(para)
msgid "The speed of the archiving command is unimportant as long as it can keep up with the average rate at which your server generates WAL data. Normal operation continues even if the archiving process falls a little behind. If archiving falls significantly behind, this will increase the amount of data that would be lost in the event of a disaster. It will also mean that the <filename>pg_xlog/</filename>directory will contain large numbers of not-yet-archived segment files, which could eventually exceed available disk space. You are advised to monitor the archiving process to ensure that it is working as you intend."
msgstr ""

#: xml/backup.xml:686(para)
msgid "In writing your archive command, you should assume that the file names to be archived can be up to 64 characters long and can contain any combination of ASCII letters, digits, and dots. It is not necessary to preserve the original relative path ( <literal>%p</literal>) but it is necessary to preserve the file name ( <literal>%f</literal>)."
msgstr ""

#: xml/backup.xml:694(para)
msgid "Note that although WAL archiving will allow you to restore any modifications made to the data in your <productname>PostgreSQL</productname>database, it will not restore changes made to configuration files (that is, <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename>and <filename>pg_ident.conf</filename>), since those are edited manually rather than through SQL operations. You might wish to keep the configuration files in a location that will be backed up by your regular file system backup procedures. See <xref linkend=\"runtime-config-file-locations\">for how to relocate the configuration files.</xref>"
msgstr ""

#: xml/backup.xml:706(para)
msgid "The archive command is only invoked on completed WAL segments. Hence, if your server generates only little WAL traffic (or has slack periods where it does so), there could be a long delay between the completion of a transaction and its safe recording in archive storage. To put a limit on how old unarchived data can be, you can set <xref linkend=\"guc-archive-timeout\">to force the server to switch to a new WAL segment file at least that often. Note that archived files that are archived early due to a forced switch are still the same length as completely full files. It is therefore unwise to set a very short <varname>archive_timeout</varname>it will bloat your archive storage. <varname>archive_timeout</varname>settings of a minute or so are usually reasonable.</xref>"
msgstr ""

#: xml/backup.xml:721(para)
msgid "Also, you can force a segment switch manually with <function>pg_switch_xlog</function>if you want to ensure that a just-finished transaction is archived as soon as possible. Other utility functions related to WAL management are listed in <xref linkend=\"functions-admin-backup-table\">.</xref>"
msgstr ""

#: xml/backup.xml:727(para)
msgid "When <varname>wal_level</varname>is <literal>minimal</literal>some SQL commands are optimized to avoid WAL logging, as described in <xref linkend=\"populate-pitr\">. If archiving or streaming replication were turned on during execution of one of these statements, WAL would not contain enough information for archive recovery. (Crash recovery is unaffected.) For this reason, <varname>wal_level</varname>can only be changed at server start. However, <varname>archive_command</varname>can be changed with a configuration file reload. If you wish to temporarily stop archiving, one way to do it is to set <varname>archive_command</varname>to the empty string ( <literal>''</literal>). This will cause WAL files to accumulate in <filename>pg_xlog/</filename>until a working <varname>archive_command</varname>is re-established.</xref>"
msgstr ""

#: xml/backup.xml:749(title)
msgid "Making a Base Backup"
msgstr ""

#: xml/backup.xml:750(para)
msgid "The easiest way to perform a base backup is to use the <xref linkend=\"app-pgbasebackup\">tool. It can create a base backup either as regular files or as a tar archive. If more flexibility than <xref linkend=\"app-pgbasebackup\">can provide is required, you can also make a base backup using the low level API (see <xref linkend=\"backup-lowlevel-base-backup\"> ).</xref></xref></xref>"
msgstr ""

#: xml/backup.xml:758(para)
msgid "It is not necessary to be concerned about the amount of time it takes to make a base backup. However, if you normally run the server with <varname>full_page_writes</varname>disabled, you might notice a drop in performance while the backup runs since <varname>full_page_writes</varname>is effectively forced on during backup mode."
msgstr ""

#: xml/backup.xml:765(para)
msgid "To make use of the backup, you will need to keep all the WAL segment files generated during and after the file system backup. To aid you in doing this, the base backup process creates a <firstterm>backup history file</firstterm>that is immediately stored into the WAL archive area. This file is named after the first WAL segment file that you need for the file system backup. For example, if the starting WAL file is <literal>0000000100001234000055CD</literal>the backup history file will be named something like <literal>0000000100001234000055CD.007C9330.backup</literal>. (The second part of the file name stands for an exact position within the WAL file, and can ordinarily be ignored.) Once you have safely archived the file system backup and the WAL segment files used during the backup (as specified in the backup history file), all archived WAL segments with names numerically less are no longer needed to recover the file system backup and can be deleted. However, you should consider keeping several backup sets to be absolutely certain that you can recover your data."
msgstr ""

#: xml/backup.xml:785(para)
msgid "The backup history file is just a small text file. It contains the label string you gave to <xref linkend=\"app-pgbasebackup\">, as well as the starting and ending times and WAL segments of the backup. If you used the label to identify the associated dump file, then the archived history file is enough to tell you which dump file to restore.</xref>"
msgstr ""

#: xml/backup.xml:792(para)
msgid "Since you have to keep around all the archived WAL files back to your last base backup, the interval between base backups should usually be chosen based on how much storage you want to expend on archived WAL files. You should also consider how long you are prepared to spend recovering, if recovery should be necessary the system will have to replay all those WAL segments, and that could take awhile if it has been a long time since the last base backup."
msgstr ""

#: xml/backup.xml:802(title)
msgid "Making a Base Backup Using the Low Level API"
msgstr ""

#: xml/backup.xml:811(para)
msgid "Ensure that WAL archiving is enabled and working."
msgstr ""

#: xml/backup.xml:817(programlisting)
#, no-wrap
msgid "SELECT\n          pg_start_backup('label');"
msgstr ""

#: xml/backup.xml:815(para)
msgid "Connect to the database as a superuser and issue the command: <placeholder-1/>where <literal>label</literal>is any string you want to use to uniquely identify this backup operation. (One good practice is to use the full path where you intend to put the backup dump file.) <function>pg_start_backup</function>creates a <firstterm>backup label</firstterm>file, called <filename>backup_label</filename>, in the cluster directory with information about your backup, including the start time and label string. The function also creates a <firstterm>tablespace map</firstterm>file, called <filename>tablespace_map</filename>, in the cluster directory with information about tablespace symbolic links in <filename>pg_tblspc/</filename>if one or more such link is present. Both files are critical to the integrity of the backup, should you need to restore from it."
msgstr ""

#: xml/backup.xml:836(para)
msgid "It does not matter which database within the cluster you connect to to issue this command. You can ignore the result returned by the function; but if it reports an error, deal with that before proceeding."
msgstr ""

#: xml/backup.xml:852(programlisting)
#, no-wrap
msgid "SELECT pg_start_backup('label',\n          true);"
msgstr ""

#: xml/backup.xml:841(para)
msgid "By default, <function>pg_start_backup</function>can take a long time to finish. This is because it performs a checkpoint, and the I/O required for the checkpoint will be spread out over a significant period of time, by default half your inter-checkpoint interval (see the configuration parameter <xref linkend=\"guc-checkpoint-completion-target\">). This is usually what you want, because it minimizes the impact on query processing. If you want to start the backup as soon as possible, use: <placeholder-1/>This forces the checkpoint to be done as quickly as possible.</xref>"
msgstr ""

#: xml/backup.xml:857(para)
msgid "Perform the backup, using any convenient file-system-backup tool such as <application>tar</application>or <application>cpio</application>(not <application>pg_dump</application>or <application>pg_dumpall</application>). It is neither necessary nor desirable to stop normal operation of the database while you do this."
msgstr ""

#: xml/backup.xml:869(programlisting)
#, no-wrap
msgid "SELECT\n          pg_stop_backup();"
msgstr ""

#: xml/backup.xml:867(para)
msgid "Again connect to the database as a superuser, and issue the command: <placeholder-1/>This terminates the backup mode and performs an automatic switch to the next WAL segment. The reason for the switch is to arrange for the last WAL segment file written during the backup interval to be ready to archive."
msgstr ""

#: xml/backup.xml:877(para)
msgid "Once the WAL segment files active during the backup are archived, you are done. The file identified by <function>pg_stop_backup</function>'s result is the last segment that is required to form a complete set of backup files. If <varname>archive_mode</varname>is enabled, <function>pg_stop_backup</function>does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured <varname>archive_command</varname>. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of <function>pg_stop_backup</function>, set an appropriate <varname>statement_timeout</varname>value."
msgstr ""

#: xml/backup.xml:803(para)
msgid "The procedure for making a base backup using the low level APIs contains a few more steps than the <xref linkend=\"app-pgbasebackup\">method, but is relatively simple. It is very important that these steps are executed in sequence, and that the success of a step is verified before proceeding to the next step. <placeholder-1/></xref>"
msgstr ""

#: xml/backup.xml:898(para)
msgid "Some file system backup tools emit warnings or errors if the files they are trying to copy change while the copy proceeds. When taking a base backup of an active database, this situation is normal and not an error. However, you need to ensure that you can distinguish complaints of this sort from real errors. For example, some versions of <application>rsync</application>return a separate exit code for <quote>vanished source files</quote>, and you can write a driver script to accept this exit code as a non-error case. Also, some versions of GNU <application>tar</application>return an error code indistinguishable from a fatal error if a file was truncated while <application>tar</application>was copying it. Fortunately, GNU <application>tar</application>versions 1.16 and later exit with 1 if a file was changed during the backup, and 2 for other errors. With GNU <application>tar</application>version 1.23 and later, you can use the warning options <literal>--warning=no-file-changed --warning=no-file-removed</literal>to hide the related warning messages."
msgstr ""

#: xml/backup.xml:922(para)
msgid "Be certain that your backup dump includes all of the files under the database cluster directory (e.g., <filename>/usr/local/pgsql/data</filename>). If you are using tablespaces that do not reside underneath this directory, be careful to include them as well (and be sure that your backup dump archives symbolic links as links, otherwise the restore will corrupt your tablespaces)."
msgstr ""

#: xml/backup.xml:929(para)
msgid "You can, however, omit from the backup dump the files within the cluster's <filename>pg_xlog/</filename>subdirectory. This slight adjustment is worthwhile because it reduces the risk of mistakes when restoring. This is easy to arrange if <filename>pg_xlog/</filename>is a symbolic link pointing to someplace outside the cluster directory, which is a common setup anyway for performance reasons. You might also want to exclude <filename>postmaster.pid</filename>and <filename>postmaster.opts</filename>, which record information about the running <application>postmaster</application>, not about the <application>postmaster</application>which will eventually use this backup. (These files can confuse <application>pg_ctl</application>.)"
msgstr ""

#: xml/backup.xml:945(para)
msgid "It is often a good idea to also omit from the backup dump the files within the cluster's <filename>pg_replslot/</filename>directory, so that replication slots that exist on the master do not become part of the backup. Otherwise, the subsequent use of the backup to create a standby may result in indefinite retention of WAL files on the standby, and possibly bloat on the master if hot standby feedback is enabled, because the clients that are using those replication slots will still be connecting to and updating the slots on the master, not the standby. Even if the backup is only intended for use in creating a new master, copying the replication slots isn't expected to be particularly useful, since the contents of those slots will likely be badly out of date by the time the new master comes on line."
msgstr ""

#: xml/backup.xml:960(para)
msgid "It's also worth noting that the <function>pg_start_backup</function>function makes files named <filename>backup_label</filename>and <filename>tablespace_map</filename>in the database cluster directory, which are removed by <function>pg_stop_backup</function>. These files will of course be archived as a part of your backup dump file. The backup label file includes the label string you gave to <function>pg_start_backup</function>, as well as the time at which <function>pg_start_backup</function>was run, and the name of the starting WAL file. In case of confusion it is therefore possible to look inside a backup dump file and determine exactly which backup session the dump file came from. The tablespace map file includes the symbolic link names as they exist in the directory <filename>pg_tblspc/</filename>and the full path of each symbolic link. These files are not merely for your information; their presence and contents are critical to the proper operation of the system's recovery process."
msgstr ""

#: xml/backup.xml:981(para)
msgid "It is also possible to make a backup dump while the server is stopped. In this case, you obviously cannot use <function>pg_start_backup</function>or <function>pg_stop_backup</function>, and you will therefore be left to your own devices to keep track of which backup dump is which and how far back the associated WAL files go. It is generally better to follow the continuous archiving procedure above."
msgstr ""

#: xml/backup.xml:991(title)
msgid "Recovering Using a Continuous Archive Backup"
msgstr ""

#: xml/backup.xml:996(para)
msgid "Stop the server, if it's running."
msgstr ""

#: xml/backup.xml:999(para)
msgid "If you have the space to do so, copy the whole cluster data directory and any tablespaces to a temporary location in case you need them later. Note that this precaution will require that you have enough free space on your system to hold two copies of your existing database. If you do not have enough space, you should at least save the contents of the cluster's <filename>pg_xlog</filename>subdirectory, as it might contain logs which were not archived before the system went down."
msgstr ""

#: xml/backup.xml:1011(para)
msgid "Remove all existing files and subdirectories under the cluster data directory and under the root directories of any tablespaces you are using."
msgstr ""

#: xml/backup.xml:1016(para)
msgid "Restore the database files from your file system backup. Be sure that they are restored with the right ownership (the database system user, not <literal>root</literal>!) and with the right permissions. If you are using tablespaces, you should verify that the symbolic links in <filename>pg_tblspc/</filename>were correctly restored."
msgstr ""

#: xml/backup.xml:1026(para)
msgid "Remove any files present in <filename>pg_xlog/</filename>; these came from the file system backup and are therefore probably obsolete rather than current. If you didn't archive <filename>pg_xlog/</filename>at all, then recreate it with proper permissions, being careful to ensure that you re-establish it as a symbolic link if you had it set up that way before."
msgstr ""

#: xml/backup.xml:1036(para)
msgid "If you have unarchived WAL segment files that you saved in step 2, copy them into <filename>pg_xlog/</filename>. (It is best to copy them, not move them, so you still have the unmodified files if a problem occurs and you have to start over.)"
msgstr ""

#: xml/backup.xml:1043(para)
msgid "Create a recovery command file <filename>recovery.conf</filename>in the cluster data directory (see <xref linkend=\"recovery-config\">). You might also want to temporarily modify <filename>pg_hba.conf</filename>to prevent ordinary users from connecting until you are sure the recovery was successful.</xref>"
msgstr ""

#: xml/backup.xml:1053(para)
msgid "Start the server. The server will go into recovery mode and proceed to read through the archived WAL files it needs. Should the recovery be terminated because of an external error, the server can simply be restarted and it will continue recovery. Upon completion of the recovery process, the server will rename <filename>recovery.conf</filename>to <filename>recovery.done</filename>(to prevent accidentally re-entering recovery mode later) and then commence normal database operations."
msgstr ""

#: xml/backup.xml:1065(para)
msgid "Inspect the contents of the database to ensure you have recovered to the desired state. If not, return to step 1. If all is well, allow your users to connect by restoring <filename>pg_hba.conf</filename>to normal."
msgstr ""

#: xml/backup.xml:992(para)
msgid "Okay, the worst has happened and you need to recover from your backup. Here is the procedure: <placeholder-1/>"
msgstr ""

#: xml/backup.xml:1094(programlisting)
#, no-wrap
msgid "restore_command = 'cp\n      /mnt/server/archivedir/%f %p'"
msgstr ""

#: xml/backup.xml:1072(para)
msgid "The key part of all this is to set up a recovery configuration file that describes how you want to recover and how far the recovery should run. You can use <filename>recovery.conf.sample</filename>(normally located in the installation's <filename>share/</filename>directory) as a prototype. The one thing that you absolutely must specify in <filename>recovery.conf</filename>is the <varname>restore_command</varname>, which tells <productname>PostgreSQL</productname>how to retrieve archived WAL file segments. Like the <varname>archive_command</varname>, this is a shell command string. It can contain <literal>%f</literal>, which is replaced by the name of the desired log file, and <literal>%p</literal>, which is replaced by the path name to copy the log file to. (The path name is relative to the current working directory, i.e., the cluster's data directory.) Write <literal>%%</literal>if you need to embed an actual <literal>%</literal>character in the command. The simplest useful command is something like: <placeholder-1/>which will copy previously archived WAL segments from the directory <filename>/mnt/server/archivedir</filename>. Of course, you can use something much more complicated, perhaps even a shell script that requests the operator to mount an appropriate tape."
msgstr ""

#: xml/backup.xml:1101(para)
msgid "It is important that the command return nonzero exit status on failure. The command <emphasis>will</emphasis>be called requesting files that are not present in the archive; it must return nonzero when so asked. This is not an error condition. An exception is that if the command was terminated by a signal (other than <systemitem>SIGTERM</systemitem>, which is used as part of a database server shutdown) or an error by the shell (such as command not found), then recovery will abort and the server will not start up."
msgstr ""

#: xml/backup.xml:1111(para)
msgid "Not all of the requested files will be WAL segment files; you should also expect requests for files with a suffix of <literal>.backup</literal>or <literal>.history</literal>. Also be aware that the base name of the <literal>%p</literal>path will be different from <literal>%f</literal>; do not expect them to be interchangeable."
msgstr ""

#: xml/backup.xml:1120(para)
msgid "WAL segments that cannot be found in the archive will be sought in <filename>pg_xlog/</filename>; this allows use of recent un-archived segments. However, segments that are available from the archive will be used in preference to files in <filename>pg_xlog/</filename>."
msgstr ""

#: xml/backup.xml:1126(para)
msgid "Normally, recovery will proceed through all available WAL segments, thereby restoring the database to the current point in time (or as close as possible given the available WAL segments). Therefore, a normal recovery will end with a <quote>file not found</quote>message, the exact text of the error message depending upon your choice of <varname>restore_command</varname>. You may also see an error message at the start of recovery for a file named something like <filename>00000001.history</filename>. This is also normal and does not indicate a problem in simple recovery situations; see <xref linkend=\"backup-timelines\">for discussion.</xref>"
msgstr ""

#: xml/backup.xml:1140(para)
msgid "If you want to recover to some previous point in time (say, right before the junior DBA dropped your main transaction table), just specify the required <link linkend=\"recovery-target-settings\">stopping point</link>in <filename>recovery.conf</filename>. You can specify the stop point, known as the <quote>recovery target</quote>, either by date/time, named restore point or by completion of a specific transaction ID. As of this writing only the date/time and named restore point options are very usable, since there are no tools to help you identify with any accuracy which transaction ID to use."
msgstr ""

#: xml/backup.xml:1154(para)
msgid "The stop point must be after the ending time of the base backup, i.e., the end time of <function>pg_stop_backup</function>. You cannot use a base backup to recover to a time when that backup was in progress. (To recover to such a time, you must go back to your previous base backup and roll forward from there.)"
msgstr ""

#: xml/backup.xml:1162(para)
msgid "If recovery finds corrupted WAL data, recovery will halt at that point and the server will not start. In such a case the recovery process could be re-run from the beginning, specifying a <quote>recovery target</quote>before the point of corruption so that recovery can complete normally. If recovery fails for an external reason, such as a system crash or if the WAL archive has become inaccessible, then the recovery can simply be restarted and it will restart almost from where it failed. Recovery restart works much like checkpointing in normal operation: the server periodically forces all its state to disk, and then updates the <filename>pg_control</filename>file to indicate that the already-processed WAL data need not be scanned again."
msgstr ""

#: xml/backup.xml:1178(title)
msgid "Timelines"
msgstr ""

#: xml/backup.xml:1180(primary)
msgid "timelines"
msgstr ""

#: xml/backup.xml:1182(para)
msgid "The ability to restore the database to a previous point in time creates some complexities that are akin to science-fiction stories about time travel and parallel universes. For example, in the original history of the database, suppose you dropped a critical table at 5:15PM on Tuesday evening, but didn't realize your mistake until Wednesday noon. Unfazed, you get out your backup, restore to the point-in-time 5:14PM Tuesday evening, and are up and running. In <emphasis>this</emphasis>history of the database universe, you never dropped the table. But suppose you later realize this wasn't such a great idea, and would like to return to sometime Wednesday morning in the original history. You won't be able to if, while your database was up-and-running, it overwrote some of the WAL segment files that led up to the time you now wish you could get back to. Thus, to avoid this, you need to distinguish the series of WAL records generated after you've done a point-in-time recovery from those that were generated in the original database history."
msgstr ""

#: xml/backup.xml:1201(para)
msgid "To deal with this problem, <productname>PostgreSQL</productname>has a notion of <firstterm>timelines</firstterm>. Whenever an archive recovery completes, a new timeline is created to identify the series of WAL records generated after that recovery. The timeline ID number is part of WAL segment file names so a new timeline does not overwrite the WAL data generated by previous timelines. It is in fact possible to archive many different timelines. While that might seem like a useless feature, it's often a lifesaver. Consider the situation where you aren't quite sure what point-in-time to recover to, and so have to do several point-in-time recoveries by trial and error until you find the best place to branch off from the old history. Without timelines this process would soon generate an unmanageable mess. With timelines, you can recover to <emphasis>any</emphasis>prior state, including states in timeline branches that you abandoned earlier."
msgstr ""

#: xml/backup.xml:1219(para)
msgid "Every time a new timeline is created, <productname>PostgreSQL</productname>creates a <quote>timeline history</quote>file that shows which timeline it branched off from and when. These history files are necessary to allow the system to pick the right WAL segment files when recovering from an archive that contains multiple timelines. Therefore, they are archived into the WAL archive area just like WAL segment files. The history files are just small text files, so it's cheap and appropriate to keep them around indefinitely (unlike the segment files which are large). You can, if you like, add comments to a history file to record your own notes about how and why this particular timeline was created. Such comments will be especially valuable when you have a thicket of different timelines as a result of experimentation."
msgstr ""

#: xml/backup.xml:1234(para)
msgid "The default behavior of recovery is to recover along the same timeline that was current when the base backup was taken. If you wish to recover into some child timeline (that is, you want to return to some state that was itself generated after a recovery attempt), you need to specify the target timeline ID in <filename>recovery.conf</filename>. You cannot recover into timelines that branched off earlier than the base backup."
msgstr ""

#: xml/backup.xml:1245(title)
msgid "Tips and Examples"
msgstr ""

#: xml/backup.xml:1246(para)
msgid "Some tips for configuring continuous archiving are given here."
msgstr ""

#: xml/backup.xml:1249(title)
msgid "Standalone Hot Backups"
msgstr ""

#: xml/backup.xml:1250(para)
msgid "It is possible to use <productname>PostgreSQL</productname>'s backup facilities to produce standalone hot backups. These are backups that cannot be used for point-in-time recovery, yet are typically much faster to backup and restore than <application>pg_dump</application>dumps. (They are also much larger than <application>pg_dump</application>dumps, so in some cases the speed advantage might be negated.)"
msgstr ""

#: xml/backup.xml:1259(para)
msgid "As with base backups, the easiest way to produce a standalone hot backup is to use the <xref linkend=\"app-pgbasebackup\">tool. If you include the <literal>-X</literal>parameter when calling it, all the transaction log required to use the backup will be included in the backup automatically, and no special action is required to restore the backup.</xref>"
msgstr ""

#: xml/backup.xml:1277(programlisting)
#, no-wrap
msgid "archive_command = 'test ! -f\n        /var/lib/pgsql/backup_in_progress || (test ! -f\n        /var/lib/pgsql/archive/%f cp %p\n        /var/lib/pgsql/archive/%f)'"
msgstr ""

#: xml/backup.xml:1266(para)
msgid "If more flexibility in copying the backup files is needed, a lower level process can be used for standalone hot backups as well. To prepare for low level standalone hot backups, set <varname>wal_level</varname>to <literal>archive</literal>or higher, <varname>archive_mode</varname>to <literal>on</literal>, and set up an <varname>archive_command</varname>that performs archiving only when a <emphasis>switch file</emphasis>exists. For example: <placeholder-1/>This command will perform archiving when <filename> /var/lib/pgsql/backup_in_progress</filename>exists, and otherwise silently return zero exit status (allowing <productname>PostgreSQL</productname>to recycle the unwanted WAL file)."
msgstr ""

#: xml/backup.xml:1289(programlisting)
#, no-wrap
msgid "touch /var/lib/pgsql/backup_in_progress\n        psql -c \"select pg_start_backup('hot_backup');\" tar -cf\n        /var/lib/pgsql/backup.tar /var/lib/pgsql/data/ psql -c\n        \"select pg_stop_backup();\" rm\n        /var/lib/pgsql/backup_in_progress tar -rf\n        /var/lib/pgsql/backup.tar\n        /var/lib/pgsql/archive/"
msgstr ""

#: xml/backup.xml:1287(para)
msgid "With this preparation, a backup can be taken using a script like the following: <placeholder-1/>The switch file <filename>/var/lib/pgsql/backup_in_progress</filename>is created first, enabling archiving of completed WAL files to occur. After the backup the switch file is removed. Archived WAL files are then added to the backup so that both base backup and all required WAL files are part of the same <application>tar</application>file. Please remember to add error handling to your backup scripts."
msgstr ""

#: xml/backup.xml:1306(title)
msgid "Compressed Archive Logs"
msgstr ""

#: xml/backup.xml:1310(programlisting)
#, no-wrap
msgid "archive_command = 'gzip %p\n        /var/lib/pgsql/archive/%f'"
msgstr ""

#: xml/backup.xml:1314(programlisting)
#, no-wrap
msgid "restore_command = 'gunzip\n        /mnt/server/archivedir/%f %p'"
msgstr ""

#: xml/backup.xml:1307(para)
msgid "If archive storage size is a concern, you can use <application>gzip</application>to compress the archive files: <placeholder-1/>You will then need to use <application>gunzip</application>during recovery: <placeholder-2/>"
msgstr ""

#: xml/backup.xml:1318(title)
msgid "<varname>archive_command</varname>Scripts"
msgstr ""

#: xml/backup.xml:1324(programlisting)
#, no-wrap
msgid "archive_command = 'local_backup_script.sh\n        \"%p\" \"%f\"'"
msgstr ""

#: xml/backup.xml:1320(para)
msgid "Many people choose to use scripts to define their <varname>archive_command</varname>, so that their <filename>postgresql.conf</filename>entry looks very simple: <placeholder-1/>Using a separate script file is advisable any time you want to use more than a single command in the archiving process. This allows all complexity to be managed within the script, which can be written in a popular scripting language such as <application>bash</application>or <application>perl</application>."
msgstr ""

#: xml/backup.xml:1336(para)
msgid "Copying data to secure off-site data storage"
msgstr ""

#: xml/backup.xml:1340(para)
msgid "Batching WAL files so that they are transferred every three hours, rather than one at a time"
msgstr ""

#: xml/backup.xml:1344(para)
msgid "Interfacing with other backup and recovery software"
msgstr ""

#: xml/backup.xml:1348(para)
msgid "Interfacing with monitoring software to report errors"
msgstr ""

#: xml/backup.xml:1332(para)
msgid "Examples of requirements that might be solved within a script include: <placeholder-1/>"
msgstr ""

#: xml/backup.xml:1353(para)
msgid "When using an <varname>archive_command</varname>script, it's desirable to enable <xref linkend=\"guc-logging-collector\">. Any messages written to <systemitem>stderr</systemitem>from the script will then appear in the database server log, allowing complex configurations to be diagnosed easily if they fail.</xref>"
msgstr ""

#: xml/backup.xml:1366(title)
msgid "Caveats"
msgstr ""

#: xml/backup.xml:1372(para)
msgid "Operations on hash indexes are not presently WAL-logged, so replay will not update these indexes. This will mean that any new inserts will be ignored by the index, updated rows will apparently disappear and deleted rows will still retain pointers. In other words, if you modify a table with a hash index on it then you will get incorrect query results on a standby server. When recovery completes it is recommended that you manually <xref linkend=\"sql-reindex\">each such index after completing a recovery operation.</xref>"
msgstr ""

#: xml/backup.xml:1384(para)
msgid "If a <xref linkend=\"sql-createdatabase\">command is executed while a base backup is being taken, and then the template database that the <command>CREATE DATABASE</command>copied is modified while the base backup is still in progress, it is possible that recovery will cause those modifications to be propagated into the created database as well. This is of course undesirable. To avoid this risk, it is best not to modify any template databases while taking a base backup.</xref>"
msgstr ""

#: xml/backup.xml:1398(xref)
msgid "commands are WAL-logged with the literal absolute path, and will therefore be replayed as tablespace creations with the same absolute path. This might be undesirable if the log is being replayed on a different machine. It can be dangerous even if the log is being replayed on the same machine, but into a new data directory: the replay will still overwrite the contents of the original tablespace. To avoid potential gotchas of this sort, the best practice is to take a new base backup after creating or dropping tablespaces."
msgstr ""

#: xml/backup.xml:1367(para)
msgid "At this writing, there are several limitations of the continuous archiving technique. These will probably be fixed in future releases: <placeholder-1/>"
msgstr ""

#: xml/backup.xml:1412(para)
msgid "It should also be noted that the default <acronym>WAL</acronym>format is fairly bulky since it includes many disk page snapshots. These page snapshots are designed to support crash recovery, since we might need to fix partially-written disk pages. Depending on your system hardware and software, the risk of partial writes might be small enough to ignore, in which case you can significantly reduce the total volume of archived logs by turning off page snapshots using the <xref linkend=\"guc-full-page-writes\">parameter. (Read the notes and warnings in <xref linkend=\"wal\">before you do so.) Turning off page snapshots does not prevent use of the logs for PITR operations. An area for future development is to compress archived WAL data by removing unnecessary page copies even when <varname>full_page_writes</varname>is on. In the meantime, administrators might wish to reduce the number of page snapshots included in WAL by increasing the checkpoint interval parameters as much as feasible.</xref></xref>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/backup.xml:0(None)
msgid "translator-credits"
msgstr ""

