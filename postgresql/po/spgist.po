msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/spgist.xml:3(title)
msgid "SP-GiST Indexes"
msgstr ""

#: xml/spgist.xml:5(primary)
msgid "index"
msgstr ""

#: xml/spgist.xml:6(secondary)
msgid "SP-GiST"
msgstr ""

#: xml/spgist.xml:9(title)
msgid "Introduction"
msgstr ""

#: xml/spgist.xml:10(para)
msgid "<acronym>SP-GiST</acronym>is an abbreviation for space-partitioned <acronym>GiST</acronym>. <acronym>SP-GiST</acronym>supports partitioned search trees, which facilitate development of a wide range of different non-balanced data structures, such as quad-trees, k-d trees, and radix trees (tries). The common feature of these structures is that they repeatedly divide the search space into partitions that need not be of equal size. Searches that are well matched to the partitioning rule can be very fast."
msgstr ""

#: xml/spgist.xml:21(para)
msgid "These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by <acronym>SP-GiST</acronym>is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes."
msgstr ""

#: xml/spgist.xml:32(para)
msgid "Like <acronym>GiST</acronym>, <acronym>SP-GiST</acronym>is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert."
msgstr ""

#: xml/spgist.xml:38(para)
msgid "Some of the information here is derived from Purdue University's SP-GiST Indexing Project <ulink url=\"http://www.cs.purdue.edu/spgist/\">web site</ulink>. The <acronym>SP-GiST</acronym>implementation in <productname>PostgreSQL</productname>is primarily maintained by Teodor Sigaev and Oleg Bartunov, and there is more information on their <ulink url=\"http://www.sai.msu.su/~megera/wiki/spgist_dev\">web site</ulink>."
msgstr ""

#: xml/spgist.xml:50(title)
msgid "Built-in Operator Classes"
msgstr ""

#: xml/spgist.xml:51(para)
msgid "The core <productname>PostgreSQL</productname>distribution includes the <acronym>SP-GiST</acronym>operator classes shown in <xref linkend=\"spgist-builtin-opclasses-table\">.</xref>"
msgstr ""

#: xml/spgist.xml:56(title)
msgid "Built-in <acronym>SP-GiST</acronym>Operator Classes"
msgstr ""

#: xml/spgist.xml:61(entry)
msgid "Name"
msgstr ""

#: xml/spgist.xml:62(entry)
msgid "Indexed Data Type"
msgstr ""

#: xml/spgist.xml:63(entry)
msgid "Indexable Operators"
msgstr ""

#: xml/spgist.xml:69(literal)
msgid "kd_point_ops"
msgstr ""

#: xml/spgist.xml:72(type) xml/spgist.xml:88(type)
msgid "point"
msgstr ""

#: xml/spgist.xml:76(literal) xml/spgist.xml:92(literal) xml/spgist.xml:110(literal) xml/spgist.xml:113(literal)
msgid "@"
msgstr ""

#: xml/spgist.xml:77(literal) xml/spgist.xml:79(literal) xml/spgist.xml:93(literal) xml/spgist.xml:95(literal)
msgid "^"
msgstr ""

#: xml/spgist.xml:80(literal) xml/spgist.xml:96(literal)
msgid "~="
msgstr ""

#: xml/spgist.xml:85(literal)
msgid "quad_point_ops"
msgstr ""

#: xml/spgist.xml:101(literal)
msgid "range_ops"
msgstr ""

#: xml/spgist.xml:103(entry)
msgid "any range type"
msgstr ""

#: xml/spgist.xml:108(literal)
msgid "-|-"
msgstr ""

#: xml/spgist.xml:111(literal) xml/spgist.xml:125(literal) xml/spgist.xml:126(literal) xml/spgist.xml:128(literal)
msgid "="
msgstr ""

#: xml/spgist.xml:118(literal)
msgid "text_ops"
msgstr ""

#: xml/spgist.xml:121(type)
msgid "text"
msgstr ""

#: xml/spgist.xml:129(literal) xml/spgist.xml:131(literal)
msgid "~=~"
msgstr ""

#: xml/spgist.xml:130(literal) xml/spgist.xml:132(literal)
msgid "~~"
msgstr ""

#: xml/spgist.xml:138(para)
msgid "Of the two operator classes for type <type>point</type>, <literal>quad_point_ops</literal>is the default. <literal>kd_point_ops</literal>supports the same operators but uses a different index data structure which may offer better performance in some applications."
msgstr ""

#: xml/spgist.xml:146(title)
msgid "Extensibility"
msgstr ""

#: xml/spgist.xml:147(para)
msgid "<acronym>SP-GiST</acronym>offers an interface with a high level of abstraction, requiring the access method developer to implement only methods specific to a given data type. The <acronym>SP-GiST</acronym>core is responsible for efficient disk mapping and searching the tree structure. It also takes care of concurrency and logging considerations."
msgstr ""

#: xml/spgist.xml:154(para)
msgid "Leaf tuples of an <acronym>SP-GiST</acronym>tree contain values of the same data type as the indexed column. Leaf tuples at the root level will always contain the original indexed data value, but leaf tuples at lower levels might contain only a compressed representation, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level."
msgstr ""

#: xml/spgist.xml:163(para)
msgid "Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more <firstterm>nodes</firstterm>, which represent groups of similar leaf values. A node contains a downlink that leads to either another, lower-level inner tuple, or a short list of leaf tuples that all lie on the same index page. Each node has a <firstterm>label</firstterm>that describes it; for example, in a radix tree the node label could be the next character of the string value. Optionally, an inner tuple can have a <firstterm>prefix</firstterm>value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point."
msgstr ""

#: xml/spgist.xml:181(para)
msgid "Some tree algorithms require knowledge of level (or depth) of the current tuple, so the <acronym>SP-GiST</acronym>core provides the possibility for operator classes to manage level counting while descending the tree. There is also support for incrementally reconstructing the represented value when that is needed."
msgstr ""

#: xml/spgist.xml:188(para)
msgid "The <acronym>SP-GiST</acronym>core code takes care of null entries. Although <acronym>SP-GiST</acronym>indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that <acronym>SP-GiST</acronym>operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here."
msgstr ""

#: xml/spgist.xml:200(para)
msgid "There are five user-defined methods that an index operator class for <acronym>SP-GiST</acronym>must provide. All five follow the convention of accepting two <type>internal</type>arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the methods just return <type>void</type>, since all their results appear in the output struct; but <function>leaf_consistent</function>additionally returns a <type>boolean</type>result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method."
msgstr ""

#: xml/spgist.xml:215(para)
msgid "The five user-defined methods are:"
msgstr ""

#: xml/spgist.xml:219(function)
msgid "config"
msgstr ""

#: xml/spgist.xml:222(para)
msgid "Returns static information about the index implementation, including the data type OIDs of the prefix and node label data types."
msgstr ""

#: xml/spgist.xml:228(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_config(internal,\n          internal) RETURNS void ..."
msgstr ""

#: xml/spgist.xml:236(programlisting)
#, no-wrap
msgid "typedef struct spgConfigIn { Oid attType;\n          /* Data type to be indexed */ } spgConfigIn; typedef\n          struct spgConfigOut { Oid prefixType; /* Data type of\n          inner-tuple prefixes */ Oid labelType; /* Data type of\n          inner-tuple node labels */ bool canReturnData; /* Opclass\n          can reconstruct original data */ bool longValuesOK; /*\n          Opclass can cope with values 1 page */ }\n          spgConfigOut;"
msgstr ""

#: xml/spgist.xml:225(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>The first argument is a pointer to a <structname>spgConfigIn</structname>C struct, containing input data for the function. The second argument is a pointer to a <structname>spgConfigOut</structname>C struct, which the function must fill with result data. <placeholder-2/><structfield>attType</structfield>is passed in order to support polymorphic index operator classes; for ordinary fixed-data-type operator classes, it will always have the same value and so can be ignored."
msgstr ""

#: xml/spgist.xml:248(para)
msgid "For operator classes that do not use prefixes, <structfield>prefixType</structfield>can be set to <literal>VOIDOID</literal>. Likewise, for operator classes that do not use node labels, <structfield>labelType</structfield>can be set to <literal>VOIDOID</literal>. <structfield>canReturnData</structfield>should be set true if the operator class is capable of reconstructing the originally-supplied index value. <structfield>longValuesOK</structfield>should be set true only when the <structfield>attType</structfield>is of variable length and the operator class is capable of segmenting long values by repeated suffixing (see <xref linkend=\"spgist-limits\">).</xref>"
msgstr ""

#: xml/spgist.xml:267(function)
msgid "choose"
msgstr ""

#: xml/spgist.xml:270(para)
msgid "Chooses a method for inserting a new value into an inner tuple."
msgstr ""

#: xml/spgist.xml:275(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_choose(internal,\n          internal) RETURNS void ..."
msgstr ""

#: xml/spgist.xml:283(programlisting)
#, no-wrap
msgid "typedef struct spgChooseIn { Datum datum;\n          /* original datum to be indexed */ Datum leafDatum; /*\n          current datum to be stored at leaf */ int level; /*\n          current level (counting from zero) */ /* Data from\n          current inner tuple */ bool allTheSame; /* tuple is\n          marked all-the-same? */ bool hasPrefix; /* tuple has a\n          prefix? */ Datum prefixDatum; /* if so, the prefix value\n          */ int nNodes; /* number of nodes in the inner tuple */\n          Datum *nodeLabels; /* node label values (NULL if none) */\n          } spgChooseIn; typedef enum spgChooseResultType {\n          spgMatchNode = 1, /* descend into existing node */\n          spgAddNode, /* add a node to the inner tuple */\n          spgSplitTuple /* split inner tuple (change its prefix) */\n          } spgChooseResultType; typedef struct spgChooseOut {\n          spgChooseResultType resultType; /* action code, see above\n          */ union { struct /* results for spgMatchNode */ { int\n          nodeN; /* descend to this node (index from 0) */ int\n          levelAdd; /* increment level by this much */ Datum\n          restDatum; /* new leaf datum */ } matchNode; struct /*\n          results for spgAddNode */ { Datum nodeLabel; /* new\n          node's label */ int nodeN; /* where to insert it (index\n          from 0) */ } addNode; struct /* results for spgSplitTuple\n          */ { /* Info to form new inner tuple with one node */\n          bool prefixHasPrefix; /* tuple should have a prefix? */\n          Datum prefixPrefixDatum; /* if so, its value */ Datum\n          nodeLabel; /* node's label */ /* Info to form new\n          lower-level inner tuple with all old nodes */ bool\n          postfixHasPrefix; /* tuple should have a prefix? */ Datum\n          postfixPrefixDatum; /* if so, its value */ } splitTuple;\n          } result; } spgChooseOut;"
msgstr ""

#: xml/spgist.xml:272(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>The first argument is a pointer to a <structname>spgChooseIn</structname>C struct, containing input data for the function. The second argument is a pointer to a <structname>spgChooseOut</structname>C struct, which the function must fill with result data. <placeholder-2/><structfield>datum</structfield>is the original datum that was to be inserted into the index. <structfield>leafDatum</structfield>is initially the same as <structfield>datum</structfield>, but can change at lower levels of the tree if the <function>choose</function>or <function>picksplit</function>methods change it. When the insertion search reaches a leaf page, the current value of <structfield>leafDatum</structfield>is what will be stored in the newly created leaf tuple. <structfield>level</structfield>is the current inner tuple's level, starting at zero for the root level. <structfield>allTheSame</structfield>is true if the current inner tuple is marked as containing multiple equivalent nodes (see <xref linkend=\"spgist-all-the-same\">). <structfield>hasPrefix</structfield>is true if the current inner tuple contains a prefix; if so, <structfield>prefixDatum</structfield>is its value. <structfield>nNodes</structfield>is the number of child nodes contained in the inner tuple, and <structfield>nodeLabels</structfield>is an array of their label values, or NULL if there are no labels.</xref>"
msgstr ""

#: xml/spgist.xml:339(para)
msgid "The <function>choose</function>function can determine either that the new value matches one of the existing child nodes, or that a new child node must be added, or that the new value is inconsistent with the tuple prefix and so the inner tuple must be split to create a less restrictive prefix."
msgstr ""

#: xml/spgist.xml:346(para)
msgid "If the new value matches one of the existing child nodes, set <structfield>resultType</structfield>to <literal>spgMatchNode</literal>. Set <structfield>nodeN</structfield>to the index (from zero) of that node in the node array. Set <structfield>levelAdd</structfield>to the increment in <structfield>level</structfield>caused by descending through that node, or leave it as zero if the operator class does not use levels. Set <structfield>restDatum</structfield>to equal <structfield>datum</structfield>if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as <structfield>leafDatum</structfield>at the next level."
msgstr ""

#: xml/spgist.xml:362(para)
msgid "If a new child node must be added, set <structfield>resultType</structfield>to <literal>spgAddNode</literal>. Set <structfield>nodeLabel</structfield>to the label to be used for the new node, and set <structfield>nodeN</structfield>to the index (from zero) at which to insert the node in the node array. After the node has been added, the <function>choose</function>function will be called again with the modified inner tuple; that call should result in an <literal>spgMatchNode</literal>result."
msgstr ""

#: xml/spgist.xml:374(para)
msgid "If the new value is inconsistent with the tuple prefix, set <structfield>resultType</structfield>to <literal>spgSplitTuple</literal>. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single node that links to the new lower-level inner tuple. Set <structfield>prefixHasPrefix</structfield>to indicate whether the new upper tuple should have a prefix, and if so set <structfield>prefixPrefixDatum</structfield>to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed, and it should be no longer than the original prefix. Set <structfield>nodeLabel</structfield>to the label to be used for the node that will point to the new lower-level inner tuple. Set <structfield>postfixHasPrefix</structfield>to indicate whether the new lower-level inner tuple should have a prefix, and if so set <structfield>postfixPrefixDatum</structfield>to the prefix value. The combination of these two prefixes and the additional label must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the <function>choose</function>function will be called again with the replacement inner tuple. That call will usually result in an <literal>spgAddNode</literal>result, since presumably the node label added in the split step will not match the new value; so after that, there will be a third call that finally returns <literal>spgMatchNode</literal>and allows the insertion to descend to the leaf level."
msgstr ""

#: xml/spgist.xml:416(function)
msgid "picksplit"
msgstr ""

#: xml/spgist.xml:419(para)
msgid "Decides how to create a new inner tuple over a set of leaf tuples."
msgstr ""

#: xml/spgist.xml:424(programlisting)
#, no-wrap
msgid "CREATE FUNCTION my_picksplit(internal,\n          internal) RETURNS void ..."
msgstr ""

#: xml/spgist.xml:432(programlisting)
#, no-wrap
msgid "typedef struct spgPickSplitIn { int\n          nTuples; /* number of leaf tuples */ Datum *datums; /*\n          their datums (array of length nTuples) */ int level; /*\n          current level (counting from zero) */ } spgPickSplitIn;\n          typedef struct spgPickSplitOut { bool hasPrefix; /* new\n          inner tuple should have a prefix? */ Datum prefixDatum;\n          /* if so, its value */ int nNodes; /* number of nodes for\n          new inner tuple */ Datum *nodeLabels; /* their labels (or\n          NULL for no labels) */ int *mapTuplesToNodes; /* node\n          index for each leaf tuple */ Datum *leafTupleDatums; /*\n          datum to store in each new leaf tuple */ }\n          spgPickSplitOut;"
msgstr ""

#: xml/spgist.xml:421(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>The first argument is a pointer to a <structname>spgPickSplitIn</structname>C struct, containing input data for the function. The second argument is a pointer to a <structname>spgPickSplitOut</structname>C struct, which the function must fill with result data. <placeholder-2/><structfield>nTuples</structfield>is the number of leaf tuples provided. <structfield>datums</structfield>is an array of their datum values. <structfield>level</structfield>is the current level that all the leaf tuples share, which will become the level of the new inner tuple."
msgstr ""

#: xml/spgist.xml:451(para)
msgid "Set <structfield>hasPrefix</structfield>to indicate whether the new inner tuple should have a prefix, and if so set <structfield>prefixDatum</structfield>to the prefix value. Set <structfield>nNodes</structfield>to indicate the number of nodes that the new inner tuple will contain, and set <structfield>nodeLabels</structfield>to an array of their label values. (If the nodes do not require labels, set <structfield>nodeLabels</structfield>to NULL; see <xref linkend=\"spgist-null-labels\">for details.) Set <structfield>mapTuplesToNodes</structfield>to an array that gives the index (from zero) of the node that each leaf tuple should be assigned to. Set <structfield>leafTupleDatums</structfield>to an array of the values to be stored in the new leaf tuples (these will be the same as the input <structfield>datums</structfield>if the operator class does not modify datums from one level to the next). Note that the <function>picksplit</function>function is responsible for palloc'ing the <structfield>nodeLabels</structfield>, <structfield>mapTuplesToNodes</structfield>and <structfield> leafTupleDatums</structfield>arrays.</xref>"
msgstr ""

#: xml/spgist.xml:477(para)
msgid "If more than one leaf tuple is supplied, it is expected that the <function>picksplit</function>function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the <function>picksplit</function>function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked <literal>allTheSame</literal>to signify that this has happened. The <function>choose</function>and <function>inner_consistent</function>functions must take suitable care with such inner tuples. See <xref linkend=\"spgist-all-the-same\">for more information.</xref>"
msgstr ""

#: xml/spgist.xml:496(para)
msgid "<function>picksplit</function>can be applied to a single leaf tuple only in the case that the <function>config</function>function set <structfield>longValuesOK</structfield>to true and a larger-than-a-page input value has been supplied. In this case the point of the operation is to strip off a prefix and produce a new, shorter leaf datum value. The call will be repeated until a leaf datum short enough to fit on a page has been produced. See <xref linkend=\"spgist-limits\">for more information.</xref>"
msgstr ""

#: xml/spgist.xml:512(function)
msgid "inner_consistent"
msgstr ""

#: xml/spgist.xml:515(para)
msgid "Returns set of nodes (branches) to follow during tree search."
msgstr ""

#: xml/spgist.xml:520(programlisting)
#, no-wrap
msgid "CREATE FUNCTION\n          my_inner_consistent(internal, internal) RETURNS void\n          ..."
msgstr ""

#: xml/spgist.xml:528(programlisting)
#, no-wrap
msgid "typedef struct spgInnerConsistentIn {\n          ScanKey scankeys; /* array of operators and comparison\n          values */ int nkeys; /* length of array */ Datum\n          reconstructedValue; /* value reconstructed at parent */\n          int level; /* current level (counting from zero) */ bool\n          returnData; /* original data must be returned? */ /* Data\n          from current inner tuple */ bool allTheSame; /* tuple is\n          marked all-the-same? */ bool hasPrefix; /* tuple has a\n          prefix? */ Datum prefixDatum; /* if so, the prefix value\n          */ int nNodes; /* number of nodes in the inner tuple */\n          Datum *nodeLabels; /* node label values (NULL if none) */\n          } spgInnerConsistentIn; typedef struct\n          spgInnerConsistentOut { int nNodes; /* number of child\n          nodes to be visited */ int *nodeNumbers; /* their indexes\n          in the node array */ int *levelAdds; /* increment level\n          by this much for each */ Datum *reconstructedValues; /*\n          associated reconstructed values */ }\n          spgInnerConsistentOut;"
msgstr ""

#: xml/spgist.xml:517(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>The first argument is a pointer to a <structname>spgInnerConsistentIn</structname>C struct, containing input data for the function. The second argument is a pointer to a <structname>spgInnerConsistentOut</structname>C struct, which the function must fill with result data. <placeholder-2/>The array <structfield>scankeys</structfield>, of length <structfield>nkeys</structfield>, describes the index search condition(s). These conditions are combined with AND only index entries that satisfy all of them are interesting. (Note that <structfield>nkeys</structfield>= 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the <structfield>sk_strategy</structfield>and <structfield>sk_argument</structfield>fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check <structfield>sk_flags</structfield>to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. <structfield>reconstructedValue</structfield>is the value reconstructed for the parent tuple; it is <literal>(Datum) 0</literal>at the root level or if the <function>inner_consistent</function>function did not provide a value at the parent level. <structfield>level</structfield>is the current inner tuple's level, starting at zero for the root level. <structfield>returnData</structfield>is <literal>true</literal>if reconstructed data is required for this query; this will only be so if the <function>config</function>function asserted <structfield>canReturnData</structfield>. <structfield>allTheSame</structfield>is true if the current inner tuple is marked <quote>all-the-same</quote>; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see <xref linkend=\"spgist-all-the-same\">). <structfield>hasPrefix</structfield>is true if the current inner tuple contains a prefix; if so, <structfield>prefixDatum</structfield>is its value. <structfield>nNodes</structfield>is the number of child nodes contained in the inner tuple, and <structfield>nodeLabels</structfield>is an array of their label values, or NULL if the nodes do not have labels.</xref>"
msgstr ""

#: xml/spgist.xml:588(para)
msgid "<structfield>nNodes</structfield>must be set to the number of child nodes that need to be visited by the search, and <structfield>nodeNumbers</structfield>must be set to an array of their indexes. If the operator class keeps track of levels, set <structfield>levelAdds</structfield>to an array of the level increments required when descending to each node to be visited. (Often these increments will be the same for all the nodes, but that's not necessarily so, so an array is used.) If value reconstruction is needed, set <structfield>reconstructedValues</structfield>to an array of the values reconstructed for each child node to be visited; otherwise, leave <structfield>reconstructedValues</structfield>as NULL. Note that the <function>inner_consistent</function>function is responsible for palloc'ing the <structfield>nodeNumbers</structfield>, <structfield>levelAdds</structfield>and <structfield> reconstructedValues</structfield>arrays."
msgstr ""

#: xml/spgist.xml:615(function)
msgid "leaf_consistent"
msgstr ""

#: xml/spgist.xml:618(para)
msgid "Returns true if a leaf tuple satisfies a query."
msgstr ""

#: xml/spgist.xml:623(programlisting)
#, no-wrap
msgid "CREATE FUNCTION\n          my_leaf_consistent(internal, internal) RETURNS bool\n          ..."
msgstr ""

#: xml/spgist.xml:631(programlisting)
#, no-wrap
msgid "typedef struct spgLeafConsistentIn {\n          ScanKey scankeys; /* array of operators and comparison\n          values */ int nkeys; /* length of array */ Datum\n          reconstructedValue; /* value reconstructed at parent */\n          int level; /* current level (counting from zero) */ bool\n          returnData; /* original data must be returned? */ Datum\n          leafDatum; /* datum in leaf tuple */ }\n          spgLeafConsistentIn; typedef struct spgLeafConsistentOut\n          { Datum leafValue; /* reconstructed original data, if any\n          */ bool recheck; /* set true if operator must be\n          rechecked */ } spgLeafConsistentOut;"
msgstr ""

#: xml/spgist.xml:620(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>The first argument is a pointer to a <structname>spgLeafConsistentIn</structname>C struct, containing input data for the function. The second argument is a pointer to a <structname>spgLeafConsistentOut</structname>C struct, which the function must fill with result data. <placeholder-2/>The array <structfield>scankeys</structfield>, of length <structfield>nkeys</structfield>, describes the index search condition(s). These conditions are combined with AND only index entries that satisfy all of them satisfy the query. (Note that <structfield>nkeys</structfield>= 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the <structfield>sk_strategy</structfield>and <structfield>sk_argument</structfield>fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check <structfield>sk_flags</structfield>to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. <structfield>reconstructedValue</structfield>is the value reconstructed for the parent tuple; it is <literal>(Datum) 0</literal>at the root level or if the <function>inner_consistent</function>function did not provide a value at the parent level. <structfield>level</structfield>is the current leaf tuple's level, starting at zero for the root level. <structfield>returnData</structfield>is <literal>true</literal>if reconstructed data is required for this query; this will only be so if the <function>config</function>function asserted <structfield>canReturnData</structfield>. <structfield>leafDatum</structfield>is the key value stored in the current leaf tuple."
msgstr ""

#: xml/spgist.xml:673(para)
msgid "The function must return <literal>true</literal>if the leaf tuple matches the query, or <literal>false</literal>if not. In the <literal>true</literal>case, if <structfield>returnData</structfield>is <literal>true</literal>then <structfield>leafValue</structfield>must be set to the value originally supplied to be indexed for this leaf tuple. Also, <structfield>recheck</structfield>may be set to <literal>true</literal>if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match."
msgstr ""

#: xml/spgist.xml:690(para)
msgid "All the SP-GiST support methods are normally called in a short-lived memory context; that is, <varname>CurrentMemoryContext</varname>will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The <function>config</function>method is an exception: it should try to avoid leaking memory. But usually the <function>config</function>method need do nothing but assign constants into the passed parameter struct.)"
msgstr ""

#: xml/spgist.xml:699(para)
msgid "If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard <function>PG_GET_COLLATION()</function>mechanism."
msgstr ""

#: xml/spgist.xml:705(title)
msgid "Implementation"
msgstr ""

#: xml/spgist.xml:706(para)
msgid "This section covers implementation details and other tricks that are useful for implementers of <acronym>SP-GiST</acronym>operator classes to know."
msgstr ""

#: xml/spgist.xml:710(title)
msgid "SP-GiST Limits"
msgstr ""

#: xml/spgist.xml:711(para)
msgid "Individual leaf tuples and inner tuples must fit on a single index page (8KB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set <structfield>longValuesOK</structfield>to TRUE only if it is prepared to arrange for this to happen. Otherwise, the <acronym>SP-GiST</acronym>core will reject any request to index a value that is too large to fit on an index page."
msgstr ""

#: xml/spgist.xml:723(para)
msgid "Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value."
msgstr ""

#: xml/spgist.xml:728(para)
msgid "Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple <emphasis>must</emphasis>divide the set of leaf values into more than one node group. If the operator class's <function>picksplit</function>function fails to do that, the <acronym>SP-GiST</acronym>core resorts to extraordinary measures described in <xref linkend=\"spgist-all-the-same\">.</xref>"
msgstr ""

#: xml/spgist.xml:743(title)
msgid "SP-GiST Without Node Labels"
msgstr ""

#: xml/spgist.xml:744(para)
msgid "Some tree algorithms use a fixed set of nodes for each inner tuple; for example, in a quad-tree there are always exactly four nodes corresponding to the four quadrants around the inner tuple's centroid point. In such a case the code typically works with the nodes by number, and there is no need for explicit node labels. To suppress node labels (and thereby save some space), the <function>picksplit</function>function can return NULL for the <structfield>nodeLabels</structfield>array. This will in turn result in <structfield>nodeLabels</structfield>being NULL during subsequent calls to <function>choose</function>and <function>inner_consistent</function>. In principle, node labels could be used for some inner tuples and omitted for others in the same index."
msgstr ""

#: xml/spgist.xml:761(para)
msgid "When working with an inner tuple having unlabeled nodes, it is an error for <function>choose</function>to return <literal>spgAddNode</literal>, since the set of nodes is supposed to be fixed in such cases. Also, there is no provision for generating an unlabeled node in <literal>spgSplitTuple</literal>actions, since it is expected that an <literal>spgAddNode</literal>action will be needed as well."
msgstr ""

#: xml/spgist.xml:773(title)
msgid "<quote>All-the-same</quote>Inner Tuples"
msgstr ""

#: xml/spgist.xml:775(para)
msgid "The <acronym>SP-GiST</acronym>core can override the results of the operator class's <function>picksplit</function>function when <function>picksplit</function>fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that <function>picksplit</function>gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The <literal>allTheSame</literal>flag is set on the inner tuple to warn the <function>choose</function>and <function>inner_consistent</function>functions that the tuple does not have the node set that they might otherwise expect."
msgstr ""

#: xml/spgist.xml:792(para)
msgid "When dealing with an <literal>allTheSame</literal>tuple, a <function>choose</function>result of <literal>spgMatchNode</literal>is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied <structfield>nodeN</structfield>value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for <function>choose</function>to return <literal>spgAddNode</literal>, since that would make the nodes not all equivalent; the <literal>spgSplitTuple</literal>action must be used if the value to be inserted doesn't match the existing nodes."
msgstr ""

#: xml/spgist.xml:806(para)
msgid "When dealing with an <literal>allTheSame</literal>tuple, the <function>inner_consistent</function>function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the <function>inner_consistent</function>function normally assumes about the meaning of the nodes."
msgstr ""

#: xml/spgist.xml:817(title)
msgid "Examples"
msgstr ""

#: xml/spgist.xml:818(para)
msgid "The <productname>PostgreSQL</productname>source distribution includes several examples of index operator classes for <acronym>SP-GiST</acronym>. The core system currently provides radix trees over text columns and two types of trees over points: quad-tree and k-d tree. Look into <filename>src/backend/access/spgist/</filename>to see the code."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/spgist.xml:0(None)
msgid "translator-credits"
msgstr ""

