msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/sql.xml:3(title)
msgid "SQL"
msgstr ""

#: xml/sql.xml:5(para)
msgid "This chapter introduces the mathematical concepts behind relational databases. It is not required reading, so if you bog down or want to get straight to some simple examples feel free to jump ahead to the next chapter and come back when you have more time and patience. This stuff is supposed to be fun!"
msgstr ""

#: xml/sql.xml:11(para)
msgid "This material originally appeared as a part of Stefan Simkovics' Master's Thesis ( <xref linkend=\"SIM98\" endterm=\"SIM98\">).</xref>"
msgstr ""

#: xml/sql.xml:15(para)
msgid "<acronym>SQL</acronym>has become the most popular relational query language. The name <quote><acronym>SQL</acronym></quote>is an abbreviation for <firstterm>Structured Query Language</firstterm>. In 1974 Donald Chamberlin and others defined the language SEQUEL ( <firstterm>Structured English Query Language</firstterm>) at IBM Research. This language was first implemented in an IBM prototype called SEQUEL-XRM in 1974-75. In 1976-77 a revised version of SEQUEL called SEQUEL/2 was defined and the name was changed to <acronym>SQL</acronym>subsequently."
msgstr ""

#: xml/sql.xml:28(para)
msgid "A new prototype called System R was developed by IBM in 1977. System R implemented a large subset of SEQUEL/2 (now <acronym>SQL</acronym>) and a number of changes were made to <acronym>SQL</acronym>during the project. System R was installed in a number of user sites, both internal IBM sites and also some selected customer sites. Thanks to the success and acceptance of System R at those user sites IBM started to develop commercial products that implemented the <acronym>SQL</acronym>language based on the System R technology."
msgstr ""

#: xml/sql.xml:38(para)
msgid "Over the next years IBM and also a number of other vendors announced <acronym>SQL</acronym>products such as <productname>SQL/DS</productname>(IBM), <productname>DB2</productname>(IBM), <productname>ORACLE</productname>(Oracle Corp.), <productname>DG/SQL</productname>(Data General Corp.), and <productname>SYBASE</productname>(Sybase Inc.)."
msgstr ""

#: xml/sql.xml:46(para)
msgid "<acronym>SQL</acronym>is also an official standard now. In 1982 the American National Standards Institute ( <acronym>ANSI</acronym>) chartered its Database Committee X3H2 to develop a proposal for a standard relational language. This proposal was ratified in 1986 and consisted essentially of the IBM dialect of <acronym>SQL</acronym>. In 1987 this <acronym>ANSI</acronym>standard was also accepted as an international standard by the International Organization for Standardization ( <acronym>ISO</acronym>). This original standard version of <acronym>SQL</acronym>is often referred to, informally, as <quote><abbrev>SQL/86</abbrev></quote>. In 1989 the original standard was extended and this new standard is often, again informally, referred to as <quote><abbrev>SQL/89</abbrev></quote>. Also in 1989, a related standard called <firstterm>Database Language Embedded <acronym>SQL</acronym></firstterm>( <acronym>ESQL</acronym>) was developed."
msgstr ""

#: xml/sql.xml:69(para)
msgid "The <acronym>ISO</acronym>and <acronym>ANSI</acronym>committees have been working for many years on the definition of a greatly expanded version of the original standard, referred to informally as <firstterm><acronym>SQL2</acronym></firstterm>or <firstterm><acronym>SQL/92</acronym></firstterm>. This version became a ratified standard - <quote>International Standard ISO/IEC 9075:1992, Database Language <acronym>SQL</acronym></quote>- in late 1992. <acronym>SQL/92</acronym>is the version normally meant when people refer to <quote>the <acronym>SQL</acronym>standard</quote>. A detailed description of <acronym>SQL/92</acronym>is given in <xref linkend=\"DATE97\" endterm=\"DATE97\">. At the time of writing this document a new standard informally referred to as <firstterm><acronym>SQL3</acronym></firstterm>is under development. It is planned to make <acronym>SQL</acronym>a Turing-complete language, i.e., all computable queries (e.g., recursive queries) will be possible. This has now been completed as SQL:2003.</xref>"
msgstr ""

#: xml/sql.xml:98(title)
msgid "The Relational Data Model"
msgstr ""

#: xml/sql.xml:99(para)
msgid "As mentioned before, <acronym>SQL</acronym>is a relational language. That means it is based on the <firstterm>relational data model</firstterm>first published by E.F. Codd in 1970. We will give a formal description of the relational model later (in <xref linkend=\"formal-notion\" endterm=\"formal-notion\">) but first we want to have a look at it from a more intuitive point of view.</xref>"
msgstr ""

#: xml/sql.xml:119(para)
msgid "SUPPLIER is a table storing the number (SNO), the name (SNAME) and the city (CITY) of a supplier."
msgstr ""

#: xml/sql.xml:123(para)
msgid "PART is a table storing the number (PNO) the name (PNAME) and the price (PRICE) of a part."
msgstr ""

#: xml/sql.xml:127(para)
msgid "SELLS stores information about which part (PNO) is sold by which supplier (SNO). It serves in a sense to connect the other two tables together."
msgstr ""

#: xml/sql.xml:133(title)
msgid "The Suppliers and Parts Database"
msgstr ""

#: xml/sql.xml:108(para)
msgid "A <firstterm>relational database</firstterm>is a database that is perceived by its users as a <firstterm>collection of tables</firstterm>(and nothing else but tables). A table consists of rows and columns where each row represents a record and each column represents an attribute of the records contained in the table. <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">shows an example of a database consisting of three tables: <placeholder-1/><example><placeholder-2/><screen>SUPPLIER: SELLS: SNO | SNAME | CITY SNO | PNO\n      ----+---------+-------- -----+----- 1 | Smith | London 1 | 1\n      2 | Jones | Paris 1 | 2 3 | Adams | Vienna 2 | 4 4 | Blake |\n      Rome 3 | 1 3 | 3 4 | 2 PART: 4 | 3 PNO | PNAME | PRICE 4 | 4\n      ----+---------+--------- 1 | Screw | 10 2 | Nut | 8 3 | Bolt\n      | 15 4 | Cam | 25</screen></example></xref>"
msgstr ""

#: xml/sql.xml:142(para)
msgid "The tables PART and SUPPLIER can be regarded as <firstterm>entities</firstterm>and SELLS can be regarded as a <firstterm>relationship</firstterm>between a particular part and a particular supplier."
msgstr ""

#: xml/sql.xml:146(para)
msgid "As we will see later, <acronym>SQL</acronym>operates on tables like the ones just defined but before that we will study the theory of the relational model."
msgstr ""

#: xml/sql.xml:152(title)
msgid "Relational Data Model Formalities"
msgstr ""

#: xml/sql.xml:154(para)
msgid "The mathematical concept underlying the relational model is the set-theoretic <firstterm>relation</firstterm>which is a subset of the Cartesian product of a list of domains. This set-theoretic relation gives the model its name (do not confuse it with the relationship from the <firstterm>Entity-Relationship model</firstterm>). Formally a domain is simply a set of values. For example the set of integers is a domain. Also the set of character strings of length 20 and the real numbers are examples of domains."
msgstr ""

#: xml/sql.xml:164(para)
msgid "The <firstterm>Cartesian product</firstterm>of domains <parameter>D <subscript>1</subscript></parameter>, <parameter>D <subscript>2</subscript></parameter>, ... <parameter>D <subscript>k</subscript></parameter>, written <parameter>D <subscript>1</subscript></parameter><parameter>D <subscript>2</subscript></parameter>... <parameter>D <subscript>k</subscript></parameter>is the set of all k-tuples <parameter>v <subscript>1</subscript></parameter>, <parameter>v <subscript>2</subscript></parameter>, ... <parameter>v <subscript>k</subscript></parameter>, such that <parameter>v <subscript>1</subscript></parameter><parameter>D <subscript>1</subscript></parameter>, <parameter>v <subscript>2</subscript></parameter><parameter>D <subscript>2</subscript></parameter>, ... <parameter>v <subscript>k</subscript></parameter><parameter>D <subscript>k</subscript></parameter>."
msgstr ""

#: xml/sql.xml:196(para)
msgid "For example, when we have <parameter>k</parameter>=2, <parameter>D <subscript>1</subscript></parameter>= <literal>{0,1}</literal>and <parameter>D <subscript>2</subscript></parameter>= <literal>{a,b,c}</literal>then <parameter>D <subscript>1</subscript></parameter><parameter>D <subscript>2</subscript></parameter>is <literal> {(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>."
msgstr ""

#: xml/sql.xml:210(para)
msgid "A Relation is any subset of the Cartesian product of one or more domains: <parameter>R</parameter><parameter>D <subscript>1</subscript></parameter><parameter>D <subscript>2</subscript></parameter>... <parameter>D <subscript>k</subscript></parameter>."
msgstr ""

#: xml/sql.xml:219(para)
msgid "For example <literal>{(0,a),(0,b),(1,a)}</literal>is a relation; it is in fact a subset of <parameter>D <subscript>1</subscript></parameter><parameter>D <subscript>2</subscript></parameter>mentioned above."
msgstr ""

#: xml/sql.xml:226(para)
msgid "The members of a relation are called tuples. Each relation of some Cartesian product <parameter>D <subscript>1</subscript></parameter><parameter>D <subscript>2</subscript></parameter>... <parameter>D <subscript>k</subscript></parameter>is said to have arity <literal>k</literal>and is therefore a set of <literal>k</literal>-tuples."
msgstr ""

#: xml/sql.xml:236(para)
msgid "A relation can be viewed as a table (as we already did, remember <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">where every tuple is represented by a row and every column corresponds to one component of a tuple. Giving names (called attributes) to the columns leads to the definition of a <firstterm>relation scheme</firstterm>.</xref>"
msgstr ""

#: xml/sql.xml:267(para)
msgid "A <firstterm>relation scheme</firstterm>is just a kind of template whereas a <firstterm>relation</firstterm>is an instance of a <firstterm>relation scheme</firstterm>. The relation consists of tuples (and can therefore be viewed as a table); not so the relation scheme."
msgstr ""

#: xml/sql.xml:243(para)
msgid "A <firstterm>relation scheme</firstterm><literal>R</literal>is a finite set of attributes <parameter>A <subscript>1</subscript></parameter>, <parameter>A <subscript>2</subscript></parameter>, ... <parameter>A <subscript>k</subscript></parameter>. There is a domain <parameter>D <subscript>i</subscript></parameter>, for each attribute <parameter>A <subscript>i</subscript></parameter>, 1 = <literal>i</literal>= <literal>k</literal>, where the values of the attributes are taken from. We often write a relation scheme as <literal>R( <parameter>A <subscript>1</subscript></parameter>, <parameter>A <subscript>2</subscript></parameter>, ... <parameter>A <subscript>k</subscript></parameter>)</literal>. <placeholder-1/>"
msgstr ""

#: xml/sql.xml:276(title)
msgid "Domains vs. Data Types"
msgstr ""

#: xml/sql.xml:277(para)
msgid "We often talked about <firstterm>domains</firstterm>in the last section. Recall that a domain is, formally, just a set of values (e.g., the set of integers or the real numbers). In terms of database systems we often talk of <firstterm>data types</firstterm>instead of domains. When we define a table we have to make a decision about which attributes to include. Additionally we have to decide which kind of data is going to be stored as attribute values. For example the values of <classname>SNAME</classname>from the table <classname>SUPPLIER</classname>will be character strings, whereas <classname>SNO</classname>will store integers. We define this by assigning a data type to each attribute. The type of <classname>SNAME</classname>will be <type>VARCHAR(20)</type>(this is the <acronym>SQL</acronym>type for character strings of length = 20), the type of <classname>SNO</classname>will be <type>INTEGER</type>. With the assignment of a data type we also have selected a domain for an attribute. The domain of <classname>SNAME</classname>is the set of all character strings of length = 20, the domain of <classname>SNO</classname>is the set of all integer numbers."
msgstr ""

#: xml/sql.xml:306(title)
msgid "Operations in the Relational Data Model"
msgstr ""

#: xml/sql.xml:319(para)
msgid "The <firstterm>Relational Algebra</firstterm>which is an algebraic notation, where queries are expressed by applying specialized operators to the relations."
msgstr ""

#: xml/sql.xml:325(para)
msgid "The <firstterm>Relational Calculus</firstterm>which is a logical notation, where queries are expressed by formulating some logical restrictions that the tuples in the answer must satisfy."
msgstr ""

#: xml/sql.xml:308(para)
msgid "In the previous section ( <xref linkend=\"formal-notion\" endterm=\"formal-notion\">) we defined the mathematical notion of the relational model. Now we know how the data can be stored using a relational data model but we do not know what to do with all these tables to retrieve something from the database yet. For example somebody could ask for the names of all suppliers that sell the part 'Screw'. Therefore two rather different kinds of notations for expressing operations on relations have been defined: <placeholder-1/></xref>"
msgstr ""

#: xml/sql.xml:333(title)
msgid "Relational Algebra"
msgstr ""

#: xml/sql.xml:340(para)
msgid "SELECT (): extracts <firstterm>tuples</firstterm>from a relation that satisfy a given restriction. Let <parameter>R</parameter>be a table that contains an attribute <parameter>A</parameter>. <subscript>A=a</subscript>(R) = {t R t(A) = a} where <literal>t</literal>denotes a tuple of <parameter>R</parameter>and <literal>t(A)</literal>denotes the value of attribute <parameter>A</parameter>of tuple <literal>t</literal>."
msgstr ""

#: xml/sql.xml:354(para)
msgid "PROJECT (): extracts specified <firstterm>attributes</firstterm>(columns) from a relation. Let <classname>R</classname>be a relation that contains an attribute <classname>X</classname>. <subscript>X</subscript>( <classname>R</classname>) = {t(X) t <classname>R</classname>}, where <literal>t</literal>( <classname>X</classname>) denotes the value of attribute <classname>X</classname>of tuple <literal>t</literal>."
msgstr ""

#: xml/sql.xml:369(para)
msgid "PRODUCT (): builds the Cartesian product of two relations. Let <classname>R</classname>be a table with arity <literal>k</literal><subscript>1</subscript>and let <classname>S</classname>be a table with arity <literal>k</literal><subscript>2</subscript>. <classname>R</classname><classname>S</classname>is the set of all <literal>k</literal><subscript>1</subscript>+ <literal>k</literal><subscript>2</subscript>-tuples whose first <literal>k</literal><subscript>1</subscript>components form a tuple in <classname>R</classname>and whose last <literal>k</literal><subscript>2</subscript>components form a tuple in <classname>S</classname>."
msgstr ""

#: xml/sql.xml:391(para)
msgid "UNION (): builds the set-theoretic union of two tables. Given the tables <classname>R</classname>and <classname>S</classname>(both must have the same arity), the union <classname>R</classname><classname>S</classname>is the set of tuples that are in <classname>R</classname>or <classname>S</classname>or both."
msgstr ""

#: xml/sql.xml:402(para)
msgid "INTERSECT (): builds the set-theoretic intersection of two tables. Given the tables <classname>R</classname>and <classname>S</classname>, <classname>R</classname><classname>S</classname>is the set of tuples that are in <classname>R</classname>and in <classname>S</classname>. We again require that <classname>R</classname>and <classname>S</classname>have the same arity."
msgstr ""

#: xml/sql.xml:414(para)
msgid "DIFFERENCE ( or ): builds the set difference of two tables. Let <classname>R</classname>and <classname>S</classname>again be two tables with the same arity. <classname>R</classname>- <classname>S</classname>is the set of tuples in <classname>R</classname>but not in <classname>S</classname>."
msgstr ""

#: xml/sql.xml:425(para)
msgid "JOIN (): connects two tables by their common attributes. Let <classname>R</classname>be a table with the attributes <classname>A</classname>, <classname>B</classname>and <classname>C</classname>and let <classname>S</classname>be a table with the attributes <classname>C</classname>, <classname>D</classname>and <classname>E</classname>. There is one attribute common to both relations, the attribute <classname>C</classname>. R S = <subscript>R.A,R.B,R.C,S.D,S.E</subscript>( <subscript>R.C=S.C</subscript>(R S)). What are we doing here? We first calculate the Cartesian product <classname>R</classname><classname>S</classname>. Then we select those tuples whose values for the common attribute <classname>C</classname>are equal ( <subscript>R.C = S.C</subscript>). Now we have a table that contains the attribute <classname>C</classname>two times and we correct this by projecting out the duplicate column."
msgstr ""

#: xml/sql.xml:449(title)
msgid "An Inner Join"
msgstr ""

#: xml/sql.xml:450(para)
msgid "Let's have a look at the tables that are produced by evaluating the steps necessary for a join. Let the following two tables be given: <screen>R: S: A | B | C C | D | E ---+---+---\n            ---+---+--- 1 | 2 | 3 3 | a | b 4 | 5 | 6 6 | c | d 7 |\n            8 | 9</screen>"
msgstr ""

#: xml/sql.xml:457(para)
msgid "First we calculate the Cartesian product <classname>R</classname><classname>S</classname>and get: <screen>R x S: A | B | R.C | S.C | D | E\n          ---+---+-----+-----+---+--- 1 | 2 | 3 | 3 | a | b 1 | 2 |\n          3 | 6 | c | d 4 | 5 | 6 | 3 | a | b 4 | 5 | 6 | 6 | c | d\n          7 | 8 | 9 | 3 | a | b 7 | 8 | 9 | 6 | c |\n          d</screen>"
msgstr ""

#: xml/sql.xml:465(para)
msgid "After the selection <subscript>R.C=S.C</subscript>(R S) we get: <screen>A | B | R.C | S.C | D | E\n          ---+---+-----+-----+---+--- 1 | 2 | 3 | 3 | a | b 4 | 5 |\n          6 | 6 | c | d</screen>"
msgstr ""

#: xml/sql.xml:470(para)
msgid "To remove the duplicate column <classname>S</classname>. <classname>C</classname>we project it out by the following operation: <subscript>R.A,R.B,R.C,S.D,S.E</subscript>( <subscript>R.C=S.C</subscript>(R S)) and get: <screen>A | B | C | D | E ---+---+---+---+--- 1 | 2 | 3 |\n          a | b 4 | 5 | 6 | c | d</screen>"
msgstr ""

#: xml/sql.xml:485(programlisting)
#, no-wrap
msgid "R S = {t t \n          <subscript>s</subscript>S t \n          <subscript>r</subscript>R"
msgstr ""

#: xml/sql.xml:480(para)
msgid "DIVIDE (): Let <classname>R</classname>be a table with the attributes A, B, C, and D and let <classname>S</classname>be a table with the attributes C and D. Then we define the division as: <placeholder-1/>such that t <subscript>r</subscript>(A,B)=tt <subscript>r</subscript>(C,D)=t <subscript>s</subscript>} where t <subscript>r</subscript>(x,y) denotes a tuple of table <classname>R</classname>that consists only of the components <literal>x</literal>and <literal>y</literal>. Note that the tuple <literal>t</literal>only consists of the components <classname>A</classname>and <classname>B</classname>of relation <classname>R</classname>."
msgstr ""

#: xml/sql.xml:500(para)
msgid "Given the following tables <screen>R: S: A | B | C | D C | D ---+---+---+--- ---+---\n          a | b | c | d c | d a | b | e | f e | f b | c | e | f e |\n          d | c | d e | d | e | f a | b | d | e</screen>R S is derived as <screen>A | B ---+--- a | b e | d</screen>"
msgstr ""

#: xml/sql.xml:334(para)
msgid "The <firstterm>Relational Algebra</firstterm>was introduced by E. F. Codd in 1972. It consists of a set of operations on relations: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:508(para)
msgid "For a more detailed description and definition of the relational algebra refer to [ <xref linkend=\"ULL88\" endterm=\"ULL88\">] or [ <xref linkend=\"DATE04\" endterm=\"DATE04\"> ].</xref></xref>"
msgstr ""

#: xml/sql.xml:514(title)
msgid "A Query Using Relational Algebra"
msgstr ""

#: xml/sql.xml:524(programlisting)
#, no-wrap
msgid "\n        <subscript>SUPPLIER.SNAME</subscript>( \n        <subscript>PART.PNAME='Screw'</subscript>(SUPPLIER SELLS\n        PART))"
msgstr ""

#: xml/sql.xml:516(para)
msgid "Recall that we formulated all those relational operators to be able to retrieve data from the database. Let's return to our example from the previous section ( <xref linkend=\"operations\" endterm=\"operations\">) where someone wanted to know the names of all suppliers that sell the part <literal>Screw</literal>. This question can be answered using relational algebra by the following operation: <placeholder-1/></xref>"
msgstr ""

#: xml/sql.xml:528(para)
msgid "We call such an operation a query. If we evaluate the above query against the our example tables ( <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">) we will obtain the following result: <screen>SNAME ------- Smith Adams</screen></xref>"
msgstr ""

#: xml/sql.xml:536(title)
msgid "Relational Calculus"
msgstr ""

#: xml/sql.xml:542(para)
msgid "The <firstterm>Domain Relational Calculus</firstterm>( <acronym>DRC</acronym>), where variables stand for components (attributes) of the tuples."
msgstr ""

#: xml/sql.xml:548(para)
msgid "The <firstterm>Tuple Relational Calculus</firstterm>( <acronym>TRC</acronym>), where variables stand for tuples."
msgstr ""

#: xml/sql.xml:537(para)
msgid "The relational calculus is based on the <firstterm>first order logic</firstterm>. There are two variants of the relational calculus: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:554(para)
msgid "We want to discuss the tuple relational calculus only because it is the one underlying the most relational languages. For a detailed discussion on <acronym>DRC</acronym>(and also <acronym>TRC</acronym>) see <xref linkend=\"DATE04\" endterm=\"DATE04\">or <xref linkend=\"ULL88\" endterm=\"ULL88\">.</xref></xref>"
msgstr ""

#: xml/sql.xml:563(title)
msgid "Tuple Relational Calculus"
msgstr ""

#: xml/sql.xml:566(programlisting)
#, no-wrap
msgid "x(A) F(x)"
msgstr ""

#: xml/sql.xml:564(para)
msgid "The queries used in <acronym>TRC</acronym>are of the following form: <placeholder-1/>where <literal>x</literal>is a tuple variable <classname>A</classname>is a set of attributes and <literal>F</literal>is a formula. The resulting relation consists of all tuples <literal>t(A)</literal>that satisfy <literal>F(t)</literal>."
msgstr ""

#: xml/sql.xml:576(programlisting)
#, no-wrap
msgid "{x(SNAME) x SUPPLIER y SELLS z PART\n      (y(SNO)=x(SNO) z(PNO)=y(PNO)\n      z(PNAME)='Screw')}"
msgstr ""

#: xml/sql.xml:573(para)
msgid "If we want to answer the question from example <xref linkend=\"suppl-rel-alg\" endterm=\"suppl-rel-alg\">using <acronym>TRC</acronym>we formulate the following query: <placeholder-1/></xref>"
msgstr ""

#: xml/sql.xml:579(para)
msgid "Evaluating the query against the tables from <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">again leads to the same result as in <xref linkend=\"suppl-rel-alg\" endterm=\"suppl-rel-alg\"> .</xref></xref>"
msgstr ""

#: xml/sql.xml:586(title)
msgid "Relational Algebra vs. Relational Calculus"
msgstr ""

#: xml/sql.xml:587(para)
msgid "The relational algebra and the relational calculus have the same <firstterm>expressive power</firstterm>; i.e., all queries that can be formulated using relational algebra can also be formulated using the relational calculus and vice versa. This was first proved by E. F. Codd in 1972. This proof is based on an algorithm ( <quote>Codd's reduction algorithm</quote>) by which an arbitrary expression of the relational calculus can be reduced to a semantically equivalent expression of relational algebra. For a more detailed discussion on that refer to <xref linkend=\"DATE04\" endterm=\"DATE04\">and <xref linkend=\"ULL88\" endterm=\"ULL88\">.</xref></xref>"
msgstr ""

#: xml/sql.xml:600(para)
msgid "It is sometimes said that languages based on the relational calculus are <quote>higher level</quote>or <quote>more declarative</quote>than languages based on relational algebra because the algebra (partially) specifies the order of operations while the calculus leaves it to a compiler or interpreter to determine the most efficient order of evaluation."
msgstr ""

#: xml/sql.xml:611(title)
msgid "The <acronym>SQL</acronym>Language"
msgstr ""

#: xml/sql.xml:625(para)
msgid "Commands for insertion, deletion or modification of data."
msgstr ""

#: xml/sql.xml:632(programlisting)
#, no-wrap
msgid "A B + 3."
msgstr ""

#: xml/sql.xml:629(para)
msgid "Arithmetic capability: In <acronym>SQL</acronym>it is possible to involve arithmetic operations as well as comparisons, e.g.: <placeholder-1/>Note that + or other arithmetic operators appear neither in relational algebra nor in relational calculus."
msgstr ""

#: xml/sql.xml:637(para)
msgid "Assignment and Print Commands: It is possible to print a relation constructed by a query and to assign a computed relation to a relation name."
msgstr ""

#: xml/sql.xml:642(para)
msgid "Aggregate Functions: Operations such as <firstterm>average</firstterm>, <firstterm>sum</firstterm>, <firstterm>max</firstterm>, etc. can be applied to columns of a relation to obtain a single quantity."
msgstr ""

#: xml/sql.xml:613(para)
msgid "As is the case with most modern relational languages, <acronym>SQL</acronym>is based on the tuple relational calculus. As a result every query that can be formulated using the tuple relational calculus (or equivalently, relational algebra) can also be formulated using <acronym>SQL</acronym>. There are, however, capabilities beyond the scope of relational algebra or calculus. Here is a list of some additional features provided by <acronym>SQL</acronym>that are not part of relational algebra or calculus: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:650(title)
msgid "Select"
msgstr ""

#: xml/sql.xml:651(para)
msgid "The most often used command in <acronym>SQL</acronym>is the <command>SELECT</command>statement, used to retrieve data. The syntax is: <synopsis>SELECT [ ALL | DISTINCT [ ON ( \n      <replaceable class=\"PARAMETER\">expression</replaceable>[,\n      ...] ) ] ] * | \n      <replaceable class=\"PARAMETER\">expression</replaceable>[ [ AS\n      ] \n      <replaceable class=\"PARAMETER\">output_name</replaceable>] [,\n      ...] [ INTO [ TEMPORARY | TEMP ] [ TABLE ] \n      <replaceable class=\"PARAMETER\">new_table</replaceable>] [\n      FROM \n      <replaceable class=\"PARAMETER\">from_item</replaceable>[, ...]\n      ] [ WHERE \n      <replaceable class=\"PARAMETER\">condition</replaceable>] [\n      GROUP BY \n      <replaceable class=\"PARAMETER\">expression</replaceable>[,\n      ...] ] [ HAVING \n      <replaceable class=\"PARAMETER\">condition</replaceable>[, ...]\n      ] [ { UNION | INTERSECT | EXCEPT } [ ALL ] \n      <replaceable class=\"PARAMETER\">select</replaceable>] [ ORDER\n      BY \n      <replaceable class=\"parameter\">expression</replaceable>[ ASC\n      | DESC | USING \n      <replaceable class=\"parameter\">operator</replaceable>] [\n      NULLS { FIRST | LAST } ] [, ...] ] [ LIMIT { \n      <replaceable class=\"PARAMETER\">count</replaceable>| ALL } ] [\n      OFFSET \n      <replaceable class=\"PARAMETER\">start</replaceable>] [ FOR {\n      UPDATE | SHARE } [ OF \n      <replaceable class=\"parameter\">table_name</replaceable>[,\n      ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]</synopsis>"
msgstr ""

#: xml/sql.xml:684(para)
msgid "Now we will illustrate the complex syntax of the <command>SELECT</command>statement with various examples. The tables used for the examples are defined in <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\"> .</xref>"
msgstr ""

#: xml/sql.xml:690(title)
msgid "Simple Selects"
msgstr ""

#: xml/sql.xml:694(title)
msgid "Simple Query with Qualification"
msgstr ""

#: xml/sql.xml:699(programlisting)
#, no-wrap
msgid "SELECT * FROM PART WHERE PRICE\n          10;"
msgstr ""

#: xml/sql.xml:696(para)
msgid "To retrieve all tuples from table PART where the attribute PRICE is greater than 10 we formulate the following query: <placeholder-1/>and get the table: <screen>PNO | PNAME | PRICE -----+---------+-------- 3 |\n          Bolt | 15 4 | Cam | 25</screen>"
msgstr ""

#: xml/sql.xml:709(programlisting)
#, no-wrap
msgid "SELECT PNAME, PRICE FROM PART WHERE PRICE\n          10;"
msgstr ""

#: xml/sql.xml:703(para)
msgid "Using <quote>*</quote>in the <command>SELECT</command>statement will deliver all attributes from the table. If we want to retrieve only the attributes PNAME and PRICE from table PART we use the statement: <placeholder-1/>In this case the result is: <screen>PNAME | PRICE --------+-------- Bolt | 15 Cam |\n          25</screen>Note that the <acronym>SQL</acronym><command>SELECT</command>corresponds to the <quote>projection</quote>in relational algebra not to the <quote>selection</quote>(see <xref linkend=\"rel-alg\" endterm=\"rel-alg\">for more details).</xref>"
msgstr ""

#: xml/sql.xml:722(programlisting)
#, no-wrap
msgid "SELECT PNAME, PRICE FROM PART WHERE PNAME\n          = 'Bolt' AND (PRICE = 0 OR PRICE =\n          15);"
msgstr ""

#: xml/sql.xml:720(para)
msgid "The qualifications in the WHERE clause can also be logically connected using the keywords OR, AND, and NOT: <placeholder-1/>will lead to the result: <screen>PNAME | PRICE --------+-------- Bolt |\n          15</screen>"
msgstr ""

#: xml/sql.xml:731(programlisting)
#, no-wrap
msgid "SELECT PNAME, PRICE * 2 AS DOUBLE FROM\n          PART WHERE PRICE * 2 50;"
msgstr ""

#: xml/sql.xml:727(para)
msgid "Arithmetic operations can be used in the target list and in the WHERE clause. For example if we want to know how much it would cost if we take two pieces of a part we could use the following query: <placeholder-1/>and we get: <screen>PNAME | DOUBLE --------+--------- Screw | 20 Nut\n          | 16 Bolt | 30</screen>Note that the word DOUBLE after the keyword AS is the new title of the second column. This technique can be used for every element of the target list to assign a new title to the resulting column. This new title is often referred to as alias. The alias cannot be used throughout the rest of the query."
msgstr ""

#: xml/sql.xml:691(para)
msgid "Here are some simple examples using a <command>SELECT</command>statement: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:744(title)
msgid "Joins"
msgstr ""

#: xml/sql.xml:745(para)
msgid "The following example shows how <firstterm>joins</firstterm>are realized in <acronym>SQL</acronym>."
msgstr ""

#: xml/sql.xml:751(programlisting)
#, no-wrap
msgid "SELECT S.SNAME, P.PNAME FROM SUPPLIER S,\n        PART P, SELLS SE WHERE S.SNO = SE.SNO AND P.PNO =\n        SE.PNO;"
msgstr ""

#: xml/sql.xml:748(para)
msgid "To join the three tables SUPPLIER, PART and SELLS over their common attributes we formulate the following statement: <placeholder-1/>and get the following table as a result: <screen>SNAME | PNAME -------+------- Smith | Screw Smith |\n        Nut Jones | Cam Adams | Screw Adams | Bolt Blake | Nut\n        Blake | Bolt Blake | Cam</screen>"
msgstr ""

#: xml/sql.xml:758(para)
msgid "In the FROM clause we introduced an alias name for every relation because there are common named attributes (SNO and PNO) among the relations. Now we can distinguish between the common named attributes by simply prefixing the attribute name with the alias name followed by a dot. The join is calculated in the same way as shown in <xref linkend=\"join-example\" endterm=\"join-example\">. First the Cartesian product SUPPLIER PART SELLS is derived. Now only those tuples satisfying the conditions given in the WHERE clause are selected (i.e., the common named attributes have to be equal). Finally we project out all columns but S.SNAME and P.PNAME.</xref>"
msgstr ""

#: xml/sql.xml:772(programlisting)
#, no-wrap
msgid "SELECT sname, pname from supplier JOIN\n        sells USING (sno) JOIN part USING\n        (pno);"
msgstr ""

#: xml/sql.xml:770(para)
msgid "Another way to perform joins is to use the SQL JOIN syntax as follows: <placeholder-1/>giving again: <screen>sname | pname -------+------- Smith | Screw Adams |\n        Screw Smith | Nut Blake | Nut Adams | Bolt Blake | Bolt\n        Jones | Cam Blake | Cam (8 rows)</screen>"
msgstr ""

#: xml/sql.xml:778(para)
msgid "A joined table, created using JOIN syntax, is a table reference list item that occurs in a FROM clause and before any WHERE, GROUP BY, or HAVING clause. Other table references, including table names or other JOIN clauses, can be included in the FROM clause if separated by commas. JOINed tables are logically like any other table listed in the FROM clause."
msgstr ""

#: xml/sql.xml:785(para)
msgid "SQL JOINs come in two main types, CROSS JOINs (unqualified joins) and <firstterm>qualified JOINs</firstterm>. Qualified joins can be further subdivided based on the way in which the <firstterm>join condition</firstterm>is specified (ON, USING, or NATURAL) and the way in which it is applied (INNER or OUTER join)."
msgstr ""

#: xml/sql.xml:793(title)
msgid "Join Types"
msgstr ""

#: xml/sql.xml:795(term) xml/sql.xml:801(command)
msgid "CROSS JOIN"
msgstr ""

#: xml/sql.xml:799(replaceable) xml/sql.xml:820(replaceable)
msgid "T1"
msgstr ""

#: xml/sql.xml:803(replaceable) xml/sql.xml:836(replaceable)
msgid "T2"
msgstr ""

#: xml/sql.xml:806(para)
msgid "A cross join takes two tables T1 and T2 having N and M rows respectively, and returns a joined table containing all N*M possible joined rows. For each row R1 of T1, each row R2 of T2 is joined with R1 to yield a joined table row JR consisting of all fields in R1 and R2. A CROSS JOIN is equivalent to an INNER JOIN ON TRUE."
msgstr ""

#: xml/sql.xml:816(term)
msgid "Qualified JOINs"
msgstr ""

#: xml/sql.xml:822(arg)
msgid "NATURAL"
msgstr ""

#: xml/sql.xml:824(arg) xml/sql.xml:864(arg)
msgid "INNER"
msgstr ""

#: xml/sql.xml:827(arg) xml/sql.xml:882(arg)
msgid "LEFT"
msgstr ""

#: xml/sql.xml:828(arg) xml/sql.xml:902(arg)
msgid "RIGHT"
msgstr ""

#: xml/sql.xml:829(arg) xml/sql.xml:922(arg)
msgid "FULL"
msgstr ""

#: xml/sql.xml:831(arg) xml/sql.xml:883(arg) xml/sql.xml:903(arg) xml/sql.xml:923(arg)
msgid "OUTER"
msgstr ""

#: xml/sql.xml:834(command) xml/sql.xml:865(command) xml/sql.xml:884(command) xml/sql.xml:904(command) xml/sql.xml:924(command)
msgid "JOIN"
msgstr ""

#: xml/sql.xml:840(replaceable)
msgid "search condition"
msgstr ""

#: xml/sql.xml:839(arg)
msgid "ON <placeholder-1/>"
msgstr ""

#: xml/sql.xml:842(replaceable)
msgid "join column list"
msgstr ""

#: xml/sql.xml:841(arg)
msgid "USING ( <placeholder-1/>)"
msgstr ""

#: xml/sql.xml:846(para)
msgid "A qualified JOIN must specify its join condition by providing one (and only one) of NATURAL, ON, or USING. The ON clause takes a <replaceable>search condition</replaceable>, which is the same as in a WHERE clause. The USING clause takes a comma-separated list of column names, which the joined tables must have in common, and joins the tables on equality of those columns. NATURAL is shorthand for a USING clause that lists all the common column names of the two tables. A side-effect of both USING and NATURAL is that only one copy of each joined column is emitted into the result table (compare the relational-algebra definition of JOIN, shown earlier)."
msgstr ""

#: xml/sql.xml:869(para)
msgid "For each row R1 of T1, the joined table has a row for each row in T2 that satisfies the join condition with R1."
msgstr ""

#: xml/sql.xml:873(para)
msgid "The words INNER and OUTER are optional for all JOINs. INNER is the default. LEFT, RIGHT, and FULL imply an OUTER JOIN."
msgstr ""

#: xml/sql.xml:888(para)
msgid "First, an INNER JOIN is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, an additional joined row is returned with null fields in the columns from T2."
msgstr ""

#: xml/sql.xml:894(para)
msgid "The joined table unconditionally has a row for each row in T1."
msgstr ""

#: xml/sql.xml:908(para)
msgid "First, an INNER JOIN is performed. Then, for each row in T2 that does not satisfy the join condition with any row in T1, an additional joined row is returned with null fields in the columns from T1."
msgstr ""

#: xml/sql.xml:914(para)
msgid "The joined table unconditionally has a row for each row in T2."
msgstr ""

#: xml/sql.xml:928(para)
msgid "First, an INNER JOIN is performed. Then, for each row in T1 that does not satisfy the join condition with any row in T2, an additional joined row is returned with null fields in the columns from T2. Also, for each row in T2 that does not satisfy the join condition with any row in T1, an additional joined row is returned with null fields in the columns from T1."
msgstr ""

#: xml/sql.xml:938(para)
msgid "The joined table unconditionally has a row for every row of T1 and a row for every row of T2."
msgstr ""

#: xml/sql.xml:948(para)
msgid "JOINs of all types can be chained together or nested where either or both of <replaceable class=\"parameter\">T1</replaceable>and <replaceable class=\"parameter\">T2</replaceable>can be JOINed tables. Parenthesis can be used around JOIN clauses to control the order of JOINs which are otherwise processed left to right."
msgstr ""

#: xml/sql.xml:957(title)
msgid "Aggregate Functions"
msgstr ""

#: xml/sql.xml:970(title) xml/sql.xml:1006(title)
msgid "Aggregates"
msgstr ""

#: xml/sql.xml:973(programlisting)
#, no-wrap
msgid "SELECT AVG(PRICE) AS AVG_PRICE FROM\n          PART;"
msgstr ""

#: xml/sql.xml:971(para)
msgid "If we want to know the average cost of all parts in table PART we use the following query: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:975(para)
msgid "The result is: <screen>AVG_PRICE ----------- 14.5</screen>"
msgstr ""

#: xml/sql.xml:979(programlisting)
#, no-wrap
msgid "SELECT COUNT(PNO) FROM\n          PART;"
msgstr ""

#: xml/sql.xml:977(para)
msgid "If we want to know how many parts are defined in table PART we use the statement: <placeholder-1/>and get: <screen>COUNT ------- 4</screen>"
msgstr ""

#: xml/sql.xml:958(para)
msgid "<acronym>SQL</acronym>provides aggregate functions such as AVG, COUNT, SUM, MIN, and MAX. The argument(s) of an aggregate function are evaluated at each row that satisfies the WHERE clause, and the aggregate function is calculated over this set of input values. Normally, an aggregate delivers a single result for a whole <command>SELECT</command>statement. But if grouping is specified in the query, then a separate calculation is done over the rows of each group, and an aggregate result is delivered per group (see next section). <placeholder-1/>"
msgstr ""

#: xml/sql.xml:985(title)
msgid "Aggregation by Groups"
msgstr ""

#: xml/sql.xml:986(para)
msgid "<acronym>SQL</acronym>allows one to partition the tuples of a table into groups. Then the aggregate functions described above can be applied to the groups i.e., the value of the aggregate function is no longer calculated over all the values of the specified column but over all values of a group. Thus the aggregate function is evaluated separately for every group."
msgstr ""

#: xml/sql.xml:1009(programlisting)
#, no-wrap
msgid "SELECT S.SNO, S.SNAME, COUNT(SE.PNO) FROM\n          SUPPLIER S, SELLS SE WHERE S.SNO = SE.SNO GROUP BY S.SNO,\n          S.SNAME;"
msgstr ""

#: xml/sql.xml:1007(para)
msgid "If we want to know how many parts are sold by every supplier we formulate the query: <placeholder-1/>and get: <screen>SNO | SNAME | COUNT -----+-------+------- 1 |\n          Smith | 2 2 | Jones | 1 3 | Adams | 2 4 | Blake |\n          3</screen>"
msgstr ""

#: xml/sql.xml:1015(para)
msgid "Now let's have a look of what is happening here. First the join of the tables SUPPLIER and SELLS is derived: <screen>S.SNO | S.SNAME | SE.PNO\n          -------+---------+-------- 1 | Smith | 1 1 | Smith | 2 2\n          | Jones | 4 3 | Adams | 1 3 | Adams | 3 4 | Blake | 2 4 |\n          Blake | 3 4 | Blake | 4</screen>"
msgstr ""

#: xml/sql.xml:1022(para)
msgid "Next we partition the tuples into groups by putting all tuples together that agree on both attributes S.SNO and S.SNAME: <screen>S.SNO | S.SNAME | SE.PNO\n          -------+---------+-------- 1 | Smith | 1 | 2\n          -------------------------- 2 | Jones | 4\n          -------------------------- 3 | Adams | 1 | 3\n          -------------------------- 4 | Blake | 2 | 3 |\n          4</screen>"
msgstr ""

#: xml/sql.xml:1031(para)
msgid "In our example we got four groups and now we can apply the aggregate function COUNT to every group leading to the final result of the query given above."
msgstr ""

#: xml/sql.xml:994(para)
msgid "The partitioning of the tuples into groups is done by using the keywords <command>GROUP BY</command>followed by a list of attributes that define the groups. If we have <command>GROUP BY A <subscript>1</subscript>, , A <subscript>k</subscript></command>we partition the relation into groups, such that two tuples are in the same group if and only if they agree on all the attributes A <subscript>1</subscript>, , A <subscript>k</subscript>. <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1035(para)
msgid "Note that for a query using GROUP BY and aggregate functions to make sense, the target list can only refer directly to the attributes being grouped by. Other attributes can only be used inside the arguments of aggregate functions. Otherwise there would not be a unique value to associate with the other attributes."
msgstr ""

#: xml/sql.xml:1041(para)
msgid "Also observe that it makes no sense to ask for an aggregate of an aggregate, e.g., AVG(MAX(sno)), because a <command>SELECT</command>only does one pass of grouping and aggregation. You can get a result of this kind by using a temporary table or a sub-SELECT in the FROM clause to do the first level of aggregation."
msgstr ""

#: xml/sql.xml:1049(title) xml/sql.xml:1063(title)
msgid "Having"
msgstr ""

#: xml/sql.xml:1066(programlisting)
#, no-wrap
msgid "SELECT S.SNO, S.SNAME, COUNT(SE.PNO) FROM\n          SUPPLIER S, SELLS SE WHERE S.SNO = SE.SNO GROUP BY S.SNO,\n          S.SNAME HAVING COUNT(SE.PNO) 1;"
msgstr ""

#: xml/sql.xml:1064(para)
msgid "If we want only those suppliers selling more than one part we use the query: <placeholder-1/>and get: <screen>SNO | SNAME | COUNT -----+-------+------- 1 |\n          Smith | 2 3 | Adams | 2 4 | Blake | 3</screen>"
msgstr ""

#: xml/sql.xml:1050(para)
msgid "The HAVING clause works much like the WHERE clause and is used to consider only those groups satisfying the qualification given in the HAVING clause. Essentially, WHERE filters out unwanted input rows before grouping and aggregation are done, whereas HAVING filters out unwanted group rows post-GROUP. Therefore, WHERE cannot refer to the results of aggregate functions. On the other hand, there's no point in writing a HAVING condition that doesn't involve an aggregate function! If your condition doesn't involve aggregates, you might as well write it in WHERE, and thereby avoid the computation of aggregates for groups that you're just going to throw away anyway. <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1074(title)
msgid "Subqueries"
msgstr ""

#: xml/sql.xml:1082(title)
msgid "Subselect"
msgstr ""

#: xml/sql.xml:1085(programlisting)
#, no-wrap
msgid "SELECT * FROM PART WHERE PRICE (SELECT\n          PRICE FROM PART WHERE\n          PNAME='Screw');"
msgstr ""

#: xml/sql.xml:1083(para)
msgid "If we want to know all parts having a greater price than the part named 'Screw' we use the query: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1088(para)
msgid "The result is: <screen>PNO | PNAME | PRICE -----+---------+-------- 3 |\n          Bolt | 15 4 | Cam | 25</screen>"
msgstr ""

#: xml/sql.xml:1091(para)
msgid "When we look at the above query we can see the keyword <command>SELECT</command>two times. The first one at the beginning of the query - we will refer to it as outer <command>SELECT</command>- and the one in the WHERE clause which begins a nested query - we will refer to it as inner <command>SELECT</command>. For every tuple of the outer <command>SELECT</command>the inner <command>SELECT</command>has to be evaluated. After every evaluation we know the price of the tuple named 'Screw' and we can check if the price of the actual tuple is greater. (Actually, in this example the inner query need only be evaluated once, since it does not depend on the state of the outer query.)"
msgstr ""

#: xml/sql.xml:1109(programlisting)
#, no-wrap
msgid "SELECT * FROM SUPPLIER S WHERE NOT EXISTS\n          (SELECT * FROM SELLS SE WHERE SE.SNO =\n          S.SNO);"
msgstr ""

#: xml/sql.xml:1106(para)
msgid "If we want to know all suppliers that do not sell any part (e.g., to be able to remove these suppliers from the database) we use: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1112(para)
msgid "In our example the result will be empty because every supplier sells at least one part. Note that we use S.SNO from the outer <command>SELECT</command>within the WHERE clause of the inner <command>SELECT</command>. Here the subquery must be evaluated afresh for each tuple from the outer query, i.e., the value for S.SNO is always taken from the current tuple of the outer <command>SELECT</command>."
msgstr ""

#: xml/sql.xml:1075(para)
msgid "In the WHERE and HAVING clauses the use of subqueries (subselects) is allowed in every place where a value is expected. In this case the value must be derived by evaluating the subquery first. The usage of subqueries extends the expressive power of <acronym>SQL</acronym>. <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1125(title)
msgid "Subqueries in FROM"
msgstr ""

#: xml/sql.xml:1134(title)
msgid "Subselect in FROM"
msgstr ""

#: xml/sql.xml:1139(programlisting)
#, no-wrap
msgid "SELECT MAX(subtable.avgprice) FROM\n          (SELECT AVG(P.PRICE) AS avgprice FROM SUPPLIER S, PART P,\n          SELLS SE WHERE S.SNO = SE.SNO AND P.PNO = SE.PNO GROUP BY\n          S.SNO) subtable;"
msgstr ""

#: xml/sql.xml:1136(para)
msgid "If we want to know the highest average part price among all our suppliers, we cannot write MAX(AVG(PRICE)), but we can write: <placeholder-1/>The subquery returns one row per supplier (because of its GROUP BY) and then we aggregate over those rows in the outer query."
msgstr ""

#: xml/sql.xml:1126(para)
msgid "A somewhat different way of using subqueries is to put them in the FROM clause. This is a useful feature because a subquery of this kind can output multiple columns and rows, whereas a subquery used in an expression must deliver just a single result. It also lets us get more than one round of grouping/aggregation without resorting to a temporary table. <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1148(title) xml/sql.xml:1153(title)
msgid "Union, Intersect, Except"
msgstr ""

#: xml/sql.xml:1156(programlisting)
#, no-wrap
msgid "SELECT S.SNO, S.SNAME, S.CITY FROM\n          SUPPLIER S WHERE S.SNAME = 'Jones' UNION SELECT S.SNO,\n          S.SNAME, S.CITY FROM SUPPLIER S WHERE S.SNAME =\n          'Adams';"
msgstr ""

#: xml/sql.xml:1155(para)
msgid "The following query is an example for UNION: <placeholder-1/>gives the result: <screen>SNO | SNAME | CITY -----+-------+-------- 2 |\n          Jones | Paris 3 | Adams | Vienna</screen>"
msgstr ""

#: xml/sql.xml:1163(programlisting)
#, no-wrap
msgid "SELECT S.SNO, S.SNAME, S.CITY FROM\n          SUPPLIER S WHERE S.SNO 1 INTERSECT SELECT S.SNO, S.SNAME,\n          S.CITY FROM SUPPLIER S WHERE S.SNO\n          3;"
msgstr ""

#: xml/sql.xml:1162(para)
msgid "Here is an example for INTERSECT: <placeholder-1/>gives the result: <screen>SNO | SNAME | CITY -----+-------+-------- 2 |\n          Jones | Paris</screen>The only tuple returned by both parts of the query is the one having SNO=2."
msgstr ""

#: xml/sql.xml:1171(programlisting)
#, no-wrap
msgid "SELECT S.SNO, S.SNAME, S.CITY FROM\n          SUPPLIER S WHERE S.SNO 1 EXCEPT SELECT S.SNO, S.SNAME,\n          S.CITY FROM SUPPLIER S WHERE S.SNO\n          3;"
msgstr ""

#: xml/sql.xml:1170(para)
msgid "Finally an example for EXCEPT: <placeholder-1/>gives the result: <screen>SNO | SNAME | CITY -----+-------+-------- 2 |\n          Jones | Paris 3 | Adams | Vienna</screen>"
msgstr ""

#: xml/sql.xml:1149(para)
msgid "These operations calculate the union, intersection and set theoretic difference of the tuples derived by two subqueries. <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1181(title)
msgid "Data Definition"
msgstr ""

#: xml/sql.xml:1182(para)
msgid "There is a set of commands used for data definition included in the <acronym>SQL</acronym>language."
msgstr ""

#: xml/sql.xml:1186(title)
msgid "Create Table"
msgstr ""

#: xml/sql.xml:1200(title)
msgid "Table Creation"
msgstr ""

#: xml/sql.xml:1205(programlisting)
#, no-wrap
msgid "CREATE TABLE SUPPLIER (SNO INTEGER, SNAME\n          VARCHAR(20), CITY VARCHAR(20));"
msgstr ""

#: xml/sql.xml:1207(programlisting)
#, no-wrap
msgid "CREATE TABLE PART (PNO INTEGER, PNAME\n          VARCHAR(20), PRICE DECIMAL(4 , 2));"
msgstr ""

#: xml/sql.xml:1209(programlisting)
#, no-wrap
msgid "CREATE TABLE SELLS (SNO INTEGER, PNO\n          INTEGER);"
msgstr ""

#: xml/sql.xml:1201(para)
msgid "To create the tables defined in <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">the following <acronym>SQL</acronym>statements are used: <placeholder-1/><placeholder-2/><placeholder-3/></xref>"
msgstr ""

#: xml/sql.xml:1187(para)
msgid "The most fundamental command for data definition is the one that creates a new relation (a new table). The syntax of the <command>CREATE TABLE</command>command is: <synopsis>CREATE TABLE \n        <replaceable class=\"parameter\">table_name</replaceable>( \n        <replaceable class=\"parameter\">name_of_attr_1</replaceable>\n        <replaceable class=\"parameter\">\n        type_of_attr_1</replaceable>[, \n        <replaceable class=\"parameter\">name_of_attr_2</replaceable>\n        <replaceable class=\"parameter\">\n        type_of_attr_2</replaceable>[, ...]]);</synopsis><placeholder-1/>"
msgstr ""

#: xml/sql.xml:1214(title)
msgid "Data Types in <acronym>SQL</acronym>"
msgstr ""

#: xml/sql.xml:1221(para)
msgid "INTEGER: signed fullword binary integer (31 bits precision)."
msgstr ""

#: xml/sql.xml:1225(para)
msgid "SMALLINT: signed halfword binary integer (15 bits precision)."
msgstr ""

#: xml/sql.xml:1229(para)
msgid "DECIMAL ( <replaceable class=\"parameter\">p</replaceable>[, <replaceable class=\"parameter\">q</replaceable>]): signed packed decimal number of up to <replaceable class=\"parameter\">p</replaceable>digits, with <replaceable class=\"parameter\">q</replaceable>digits to the right of the decimal point. If <replaceable class=\"parameter\">q</replaceable>is omitted it is assumed to be 0."
msgstr ""

#: xml/sql.xml:1241(para)
msgid "FLOAT: signed doubleword floating point number."
msgstr ""

#: xml/sql.xml:1245(para)
msgid "VARCHAR( <replaceable class=\"parameter\">n</replaceable>): varying length character string of maximum length <replaceable class=\"parameter\">n</replaceable>."
msgstr ""

#: xml/sql.xml:1251(para)
msgid "CHAR( <replaceable class=\"parameter\">n</replaceable>): fixed length character string of length <replaceable class=\"parameter\">n</replaceable>."
msgstr ""

#: xml/sql.xml:1216(para)
msgid "The following is a list of some data types that are supported by <acronym>SQL</acronym>: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1259(title) xml/sql.xml:1283(title)
msgid "Create Index"
msgstr ""

#: xml/sql.xml:1260(para)
msgid "Indexes are used to speed up access to a relation. If a relation <classname>R</classname>has an index on attribute <classname>A</classname>then we can retrieve all tuples <replaceable>t</replaceable>having <replaceable>t</replaceable>( <classname>A</classname>) = <replaceable>a</replaceable>in time roughly proportional to the number of such tuples <replaceable>t</replaceable>rather than in time proportional to the size of <classname>R</classname>."
msgstr ""

#: xml/sql.xml:1276(programlisting)
#, no-wrap
msgid "CREATE INDEX \n        <replaceable class=\"parameter\">index_name</replaceable>ON \n        <replaceable class=\"parameter\">table_name</replaceable>( \n        <replaceable class=\"parameter\">\n        name_of_attribute</replaceable>);"
msgstr ""

#: xml/sql.xml:1272(para)
msgid "To create an index in <acronym>SQL</acronym>the <command>CREATE INDEX</command>command is used. The syntax is: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1286(programlisting)
#, no-wrap
msgid "CREATE INDEX I ON SUPPLIER\n            (SNAME);"
msgstr ""

#: xml/sql.xml:1284(para)
msgid "To create an index named I on attribute SNAME of relation SUPPLIER we use the following statement: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1288(para)
msgid "The created index is maintained automatically, i.e., whenever a new tuple is inserted into the relation SUPPLIER the index I is adapted. Note that the only changes a user can perceive when an index is present are increased speed for <command>SELECT</command>and decreases in speed of updates."
msgstr ""

#: xml/sql.xml:1299(title)
msgid "Create View"
msgstr ""

#: xml/sql.xml:1300(para)
msgid "A view can be regarded as a <firstterm>virtual table</firstterm>, i.e., a table that does not <emphasis>physically</emphasis>exist in the database but looks to the user as if it does. By contrast, when we talk of a <firstterm>base table</firstterm>there is really a physically stored counterpart of each row of the table somewhere in the physical storage."
msgstr ""

#: xml/sql.xml:1309(para)
msgid "Views do not have their own, physically separate, distinguishable stored data. Instead, the system stores the definition of the view (i.e., the rules about how to access physically stored base tables in order to materialize the view) somewhere in the system catalogs (see <xref linkend=\"tutorial-catalogs-title\" endterm=\"tutorial-catalogs-title\">). For a discussion on different techniques to implement views refer to <citetitle>SIM98</citetitle>.</xref>"
msgstr ""

#: xml/sql.xml:1322(programlisting)
#, no-wrap
msgid "CREATE VIEW \n        <replaceable class=\"parameter\">view_name</replaceable>AS \n        <replaceable class=\"parameter\">\n        select_stmt</replaceable>"
msgstr ""

#: xml/sql.xml:1318(para)
msgid "In <acronym>SQL</acronym>the <command>CREATE VIEW</command>command is used to define a view. The syntax is: <placeholder-1/>where <replaceable class=\"parameter\">select_stmt</replaceable>is a valid select statement as defined in <xref linkend=\"select-title\" endterm=\"select-title\">. Note that <replaceable class=\"parameter\">select_stmt</replaceable>is not executed when the view is created. It is just stored in the <firstterm>system catalogs</firstterm>and is executed whenever a query against the view is made.</xref>"
msgstr ""

#: xml/sql.xml:1339(programlisting)
#, no-wrap
msgid "CREATE VIEW London_Suppliers AS SELECT\n        S.SNAME, P.PNAME FROM SUPPLIER S, PART P, SELLS SE WHERE\n        S.SNO = SE.SNO AND P.PNO = SE.PNO AND S.CITY =\n        'London';"
msgstr ""

#: xml/sql.xml:1335(para)
msgid "Let the following view definition be given (we use the tables from <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">again): <placeholder-1/></xref>"
msgstr ""

#: xml/sql.xml:1347(programlisting)
#, no-wrap
msgid "SELECT * FROM London_Suppliers WHERE PNAME\n        = 'Screw';"
msgstr ""

#: xml/sql.xml:1343(para)
msgid "Now we can use this <firstterm>virtual relation</firstterm><classname>London_Suppliers</classname>as if it were another base table: <placeholder-1/>which will return the following table: <screen>SNAME | PNAME -------+------- Smith |\n        Screw</screen>"
msgstr ""

#: xml/sql.xml:1352(para)
msgid "To calculate this result the database system has to do a <emphasis>hidden</emphasis>access to the base tables SUPPLIER, SELLS and PART first. It does so by executing the query given in the view definition against those base tables. After that the additional qualifications (given in the query against the view) can be applied to obtain the resulting table."
msgstr ""

#: xml/sql.xml:1362(title)
msgid "Drop Table, Drop Index, Drop View"
msgstr ""

#: xml/sql.xml:1366(programlisting)
#, no-wrap
msgid "DROP TABLE \n        <replaceable class=\"parameter\">\n        table_name</replaceable>;"
msgstr ""

#: xml/sql.xml:1363(para)
msgid "To destroy a table (including all tuples stored in that table) the <command>DROP TABLE</command>command is used: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1371(programlisting)
#, no-wrap
msgid "DROP TABLE\n        SUPPLIER;"
msgstr ""

#: xml/sql.xml:1369(para)
msgid "To destroy the SUPPLIER table use the following statement: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1376(programlisting)
#, no-wrap
msgid "DROP INDEX \n        <replaceable class=\"parameter\">\n        index_name</replaceable>;"
msgstr ""

#: xml/sql.xml:1373(para)
msgid "The <command>DROP INDEX</command>command is used to destroy an index: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1381(programlisting)
#, no-wrap
msgid "DROP VIEW \n        <replaceable class=\"parameter\">\n        view_name</replaceable>;"
msgstr ""

#: xml/sql.xml:1379(para)
msgid "Finally to destroy a given view use the command <command>DROP VIEW</command>: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1387(title)
msgid "Data Manipulation"
msgstr ""

#: xml/sql.xml:1389(title)
msgid "Insert Into"
msgstr ""

#: xml/sql.xml:1394(programlisting)
#, no-wrap
msgid "INSERT INTO \n        <replaceable class=\"parameter\">table_name</replaceable>( \n        <replaceable class=\"parameter\">\n        name_of_attr_1</replaceable>[, \n        <replaceable class=\"parameter\">\n        name_of_attr_2</replaceable>[, ...]]) VALUES ( \n        <replaceable class=\"parameter\">val_attr_1</replaceable>[, \n        <replaceable class=\"parameter\">val_attr_2</replaceable>[,\n        ...]]);"
msgstr ""

#: xml/sql.xml:1390(para)
msgid "Once a table is created (see <xref linkend=\"create-title\" endterm=\"create-title\">), it can be filled with tuples using the command <command>INSERT INTO</command>. The syntax is: <placeholder-1/></xref>"
msgstr ""

#: xml/sql.xml:1407(programlisting)
#, no-wrap
msgid "INSERT INTO SUPPLIER (SNO, SNAME, CITY)\n        VALUES (1, 'Smith',\n        'London');"
msgstr ""

#: xml/sql.xml:1403(para)
msgid "To insert the first tuple into the relation SUPPLIER (from <xref linkend=\"supplier-fig\" endterm=\"supplier-fig\">) we use the following statement: <placeholder-1/></xref>"
msgstr ""

#: xml/sql.xml:1412(programlisting)
#, no-wrap
msgid "INSERT INTO SELLS (SNO, PNO) VALUES (1,\n        1);"
msgstr ""

#: xml/sql.xml:1410(para)
msgid "To insert the first tuple into the relation SELLS we use: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1416(title)
msgid "Update"
msgstr ""

#: xml/sql.xml:1420(programlisting)
#, no-wrap
msgid "UPDATE \n        <replaceable class=\"parameter\">table_name</replaceable>SET \n        <replaceable class=\"parameter\">\n        name_of_attr_1</replaceable>= \n        <replaceable class=\"parameter\">value_1</replaceable>[, ...\n        [, \n        <replaceable class=\"parameter\">\n        name_of_attr_k</replaceable>= \n        <replaceable class=\"parameter\">value_k</replaceable>]]\n        WHERE \n        <replaceable class=\"parameter\">\n        condition</replaceable>;"
msgstr ""

#: xml/sql.xml:1417(para)
msgid "To change one or more attribute values of tuples in a relation the <command>UPDATE</command>command is used. The syntax is: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1434(programlisting)
#, no-wrap
msgid "UPDATE PART SET PRICE = 15 WHERE PNAME =\n        'Screw';"
msgstr ""

#: xml/sql.xml:1432(para)
msgid "To change the value of attribute PRICE of the part 'Screw' in the relation PART we use: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1436(para)
msgid "The new value of attribute PRICE of the tuple whose name is 'Screw' is now 15."
msgstr ""

#: xml/sql.xml:1440(title)
msgid "Delete"
msgstr ""

#: xml/sql.xml:1443(programlisting)
#, no-wrap
msgid "DELETE FROM \n        <replaceable class=\"parameter\">\n        table_name</replaceable>WHERE \n        <replaceable class=\"parameter\">\n        condition</replaceable>;"
msgstr ""

#: xml/sql.xml:1441(para)
msgid "To delete a tuple from a particular table use the command DELETE FROM. The syntax is: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1450(programlisting)
#, no-wrap
msgid "DELETE FROM SUPPLIER WHERE SNAME =\n        'Smith';"
msgstr ""

#: xml/sql.xml:1448(para)
msgid "To delete the supplier called 'Smith' of the table SUPPLIER the following statement is used: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1455(title)
msgid "System Catalogs"
msgstr ""

#: xml/sql.xml:1456(para)
msgid "In every <acronym>SQL</acronym>database system <firstterm>system catalogs</firstterm>are used to keep track of which tables, views indexes etc. are defined in the database. These system catalogs can be queried as if they were normal relations. For example there is one catalog used for the definition of views. This catalog stores the query from the view definition. Whenever a query against a view is made, the system first gets the <firstterm>view definition query</firstterm>out of the catalog and materializes the view before proceeding with the user query (see <xref linkend=\"SIM98\" endterm=\"SIM98\">for a more detailed description). For more information about system catalogs refer to <xref linkend=\"DATE04\" endterm=\"DATE04\"> .</xref></xref>"
msgstr ""

#: xml/sql.xml:1475(title)
msgid "Embedded <acronym>SQL</acronym>"
msgstr ""

#: xml/sql.xml:1485(para)
msgid "There are queries that cannot be formulated using pure <acronym>SQL</acronym>(i.e., recursive queries). To be able to perform such queries we need a host language with a greater expressive power than <acronym>SQL</acronym>."
msgstr ""

#: xml/sql.xml:1493(para)
msgid "We simply want to access a database from some application that is written in the host language (e.g., a ticket reservation system with a graphical user interface is written in C and the information about which tickets are still left is stored in a database that can be accessed using embedded <acronym>SQL</acronym>)."
msgstr ""

#: xml/sql.xml:1477(para)
msgid "In this section we will sketch how <acronym>SQL</acronym>can be embedded into a host language (e.g., <literal>C</literal>). There are two main reasons why we want to use <acronym>SQL</acronym>from a host language: <placeholder-1/>"
msgstr ""

#: xml/sql.xml:1502(para)
msgid "A program using embedded <acronym>SQL</acronym>in a host language consists of statements of the host language and of <firstterm>embedded <acronym>SQL</acronym></firstterm>( <acronym>ESQL</acronym>) statements. Every <acronym>ESQL</acronym>statement begins with the keywords <command>EXEC SQL</command>. The <acronym>ESQL</acronym>statements are transformed to statements of the host language by a <firstterm>precompiler</firstterm>(which usually inserts calls to library routines that perform the various <acronym>SQL</acronym>commands)."
msgstr ""

#: xml/sql.xml:1515(para)
msgid "When we look at the examples throughout <xref linkend=\"select-title\" endterm=\"select-title\">we realize that the result of the queries is very often a set of tuples. Most host languages are not designed to operate on sets so we need a mechanism to access every single tuple of the set of tuples returned by a SELECT statement. This mechanism can be provided by declaring a <firstterm>cursor</firstterm>. After that we can use the <command>FETCH</command>command to retrieve a tuple and set the cursor to the next tuple.</xref>"
msgstr ""

#: xml/sql.xml:1525(para)
msgid "For a detailed discussion on embedded <acronym>SQL</acronym>refer to <xref linkend=\"DATE97\" endterm=\"DATE97\">, <xref linkend=\"DATE04\" endterm=\"DATE04\">, or <xref linkend=\"ULL88\" endterm=\"ULL88\"> .</xref></xref></xref>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/sql.xml:0(None)
msgid "translator-credits"
msgstr ""

