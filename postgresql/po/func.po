msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/func.xml:3(title)
msgid "Functions and Operators"
msgstr ""

#: xml/func.xml:5(primary)
msgid "function"
msgstr ""

#: xml/func.xml:8(primary) xml/func.xml:34(primary)
msgid "operator"
msgstr ""

#: xml/func.xml:10(para)
msgid "<productname>PostgreSQL</productname>provides a large number of functions and operators for the built-in data types. Users can also define their own functions and operators, as described in <xref linkend=\"server-programming\">. The <application>psql</application>commands <command>\\df</command>and <command>\\do</command>can be used to list all available functions and operators, respectively.</xref>"
msgstr ""

#: xml/func.xml:19(para)
msgid "If you are concerned about portability then note that most of the functions and operators described in this chapter, with the exception of the most trivial arithmetic and comparison operators and some explicitly marked functions, are not specified by the <acronym>SQL</acronym>standard. Some of this extended functionality is present in other <acronym>SQL</acronym>database management systems, and in many cases this functionality is compatible and consistent between the various implementations. This chapter is also not exhaustive; additional functions appear in relevant sections of the manual."
msgstr ""

#: xml/func.xml:32(title)
msgid "Logical Operators"
msgstr ""

#: xml/func.xml:35(secondary)
msgid "logical"
msgstr ""

#: xml/func.xml:38(primary)
msgid "Boolean"
msgstr ""

#: xml/func.xml:39(secondary) xml/func.xml:173(secondary)
msgid "operators"
msgstr ""

#: xml/func.xml:40(see)
msgid "operators, logical"
msgstr ""

#: xml/func.xml:63(literal)
msgid "AND"
msgstr ""

#: xml/func.xml:66(literal)
msgid "OR"
msgstr ""

#: xml/func.xml:69(literal)
msgid "NOT"
msgstr ""

#: xml/func.xml:42(para)
msgid "The usual logical operators are available: <indexterm><primary>AND (operator)</primary></indexterm><indexterm><primary>OR (operator)</primary></indexterm><indexterm><primary>NOT (operator)</primary></indexterm><indexterm><primary>conjunction</primary></indexterm><indexterm><primary>disjunction</primary></indexterm><indexterm><primary>negation</primary></indexterm><placeholder-1/><acronym>SQL</acronym>uses a three-valued logic system with true, false, and <literal>null</literal>, which represents <quote>unknown</quote>. Observe the following truth tables: <informaltable><tgroup cols=\"4\"><thead><row><entry><replaceable>a</replaceable></entry><entry><replaceable>b</replaceable></entry><entry><replaceable>a</replaceable>AND <replaceable>b</replaceable></entry><entry><replaceable>a</replaceable>OR <replaceable>b</replaceable></entry></row></thead><tbody><row><entry>TRUE</entry><entry>TRUE</entry><entry>TRUE</entry><entry>TRUE</entry></row><row><entry>TRUE</entry><entry>FALSE</entry><entry>FALSE</entry><entry>TRUE</entry></row><row><entry>TRUE</entry><entry>NULL</entry><entry>NULL</entry><entry>TRUE</entry></row><row><entry>FALSE</entry><entry>FALSE</entry><entry>FALSE</entry><entry>FALSE</entry></row><row><entry>FALSE</entry><entry>NULL</entry><entry>FALSE</entry><entry>NULL</entry></row><row><entry>NULL</entry><entry>NULL</entry><entry>NULL</entry><entry>NULL</entry></row></tbody></tgroup></informaltable><informaltable><tgroup cols=\"2\"><thead><row><entry><replaceable>a</replaceable></entry><entry>NOT <replaceable>a</replaceable></entry></row></thead><tbody><row><entry>TRUE</entry><entry>FALSE</entry></row><row><entry>FALSE</entry><entry>TRUE</entry></row><row><entry>NULL</entry><entry>NULL</entry></row></tbody></tgroup></informaltable>"
msgstr ""

#: xml/func.xml:161(para)
msgid "The operators <literal>AND</literal>and <literal>OR</literal>are commutative, that is, you can switch the left and right operand without affecting the result. But see <xref linkend=\"syntax-express-eval\">for more information about the order of evaluation of subexpressions.</xref>"
msgstr ""

#: xml/func.xml:170(title) xml/func.xml:178(title)
msgid "Comparison Operators"
msgstr ""

#: xml/func.xml:172(primary)
msgid "comparison"
msgstr ""

#: xml/func.xml:175(para)
msgid "The usual comparison operators are available, shown in <xref linkend=\"functions-comparison-table\">.</xref>"
msgstr ""

#: xml/func.xml:182(entry) xml/func.xml:427(entry) xml/func.xml:5129(entry) xml/func.xml:5585(entry) xml/func.xml:8667(entry) xml/func.xml:10629(entry)
msgid "Operator"
msgstr ""

#: xml/func.xml:183(entry) xml/func.xml:428(entry) xml/func.xml:670(entry) xml/func.xml:1264(entry) xml/func.xml:1329(entry) xml/func.xml:1482(entry) xml/func.xml:1840(entry) xml/func.xml:4675(entry) xml/func.xml:4845(entry) xml/func.xml:5130(entry) xml/func.xml:5586(entry) xml/func.xml:5919(entry) xml/func.xml:6181(entry) xml/func.xml:6414(entry) xml/func.xml:6596(entry) xml/func.xml:6668(entry) xml/func.xml:6731(entry) xml/func.xml:6818(entry) xml/func.xml:7289(entry) xml/func.xml:7474(entry) xml/func.xml:7835(entry) xml/func.xml:8102(entry) xml/func.xml:8280(entry) xml/func.xml:8901(entry) xml/func.xml:10219(entry) xml/func.xml:10492(entry) xml/func.xml:10630(entry)
msgid "Description"
msgstr ""

#: xml/func.xml:191(entry)
msgid "less than"
msgstr ""

#: xml/func.xml:197(entry)
msgid "greater than"
msgstr ""

#: xml/func.xml:201(literal) xml/func.xml:207(literal) xml/func.xml:213(literal)
msgid "="
msgstr ""

#: xml/func.xml:203(entry)
msgid "less than or equal to"
msgstr ""

#: xml/func.xml:209(entry)
msgid "greater than or equal to"
msgstr ""

#: xml/func.xml:215(entry)
msgid "equal"
msgstr ""

#: xml/func.xml:220(literal)
msgid "!="
msgstr ""

#: xml/func.xml:218(entry)
msgid "<literal/>or <placeholder-1/>"
msgstr ""

#: xml/func.xml:221(entry)
msgid "not equal"
msgstr ""

#: xml/func.xml:227(para)
msgid "The <literal>!=</literal>operator is converted to <literal/>in the parser stage. It is not possible to implement <literal>!=</literal>and <literal/>operators that do different things."
msgstr ""

#: xml/func.xml:234(para)
msgid "Comparison operators are available for all relevant data types. All comparison operators are binary operators that return values of type <type>boolean</type>; expressions like <literal>1 2 3</literal>are not valid (because there is no <literal/>operator to compare a Boolean value with <literal>3</literal>)."
msgstr ""

#: xml/func.xml:241(para)
msgid "<indexterm><primary>BETWEEN</primary></indexterm>In addition to the comparison operators, the special <token>BETWEEN</token>construct is available: <synopsis>\n    <replaceable>a</replaceable>BETWEEN \n    <replaceable>x</replaceable>AND \n    <replaceable>y</replaceable></synopsis>is equivalent to <synopsis>\n    <replaceable>a</replaceable>= \n    <replaceable>x</replaceable>AND \n    <replaceable>a</replaceable>= \n    <replaceable>y</replaceable></synopsis>Notice that <token>BETWEEN</token>treats the endpoint values as included in the range. <literal>NOT BETWEEN</literal>does the opposite comparison: <synopsis>\n    <replaceable>a</replaceable>NOT BETWEEN \n    <replaceable>x</replaceable>AND \n    <replaceable>y</replaceable></synopsis>is equivalent to <synopsis>\n    <replaceable>a</replaceable>\n    <replaceable>x</replaceable>OR \n    <replaceable>a</replaceable>\n    <replaceable>y</replaceable></synopsis><indexterm><primary>BETWEEN SYMMETRIC</primary></indexterm><literal>BETWEEN SYMMETRIC</literal>is the same as <literal>BETWEEN</literal>except there is no requirement that the argument to the left of <literal>AND</literal>be less than or equal to the argument on the right. If it is not, those two arguments are automatically swapped, so that a nonempty range is always implied."
msgstr ""

#: xml/func.xml:277(para)
msgid "<indexterm><primary>IS NULL</primary></indexterm><indexterm><primary>IS NOT NULL</primary></indexterm><indexterm><primary>ISNULL</primary></indexterm><indexterm><primary>NOTNULL</primary></indexterm>To check whether a value is or is not null, use the constructs: <synopsis>\n    <replaceable>expression</replaceable>IS NULL \n    <replaceable>expression</replaceable>IS NOT NULL</synopsis>or the equivalent, but nonstandard, constructs: <synopsis>\n    <replaceable>expression</replaceable>ISNULL \n    <replaceable>expression</replaceable>NOTNULL</synopsis><indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>"
msgstr ""

#: xml/func.xml:302(para)
msgid "Do <emphasis>not</emphasis>write <literal><replaceable>expression</replaceable>= NULL</literal>because <literal>NULL</literal>is not <quote>equal to</quote><literal>NULL</literal>. (The null value represents an unknown value, and it is not known whether two unknown values are equal.) This behavior conforms to the SQL standard."
msgstr ""

#: xml/func.xml:312(para)
msgid "Some applications might expect that <literal><replaceable>expression</replaceable>= NULL</literal>returns true if <replaceable>expression</replaceable>evaluates to the null value. It is highly recommended that these applications be modified to comply with the SQL standard. However, if that cannot be done the <xref linkend=\"guc-transform-null-equals\">configuration variable is available. If it is enabled, <productname>PostgreSQL</productname>will convert <literal>x = NULL</literal>clauses to <literal>x IS NULL</literal>.</xref>"
msgstr ""

#: xml/func.xml:327(para)
msgid "If the <replaceable>expression</replaceable>is row-valued, then <literal>IS NULL</literal>is true when the row expression itself is null or when all the row's fields are null, while <literal>IS NOT NULL</literal>is true when the row expression itself is non-null and all the row's fields are non-null. Because of this behavior, <literal>IS NULL</literal>and <literal>IS NOT NULL</literal>do not always return inverse results for row-valued expressions, i.e., a row-valued expression that contains both NULL and non-null values will return false for both tests. This definition conforms to the SQL standard, and is a change from the inconsistent behavior exhibited by <productname>PostgreSQL</productname>versions prior to 8.2."
msgstr ""

#: xml/func.xml:344(para)
msgid "<indexterm><primary>IS DISTINCT FROM</primary></indexterm><indexterm><primary>IS NOT DISTINCT FROM</primary></indexterm>Ordinary comparison operators yield null (signifying <quote>unknown</quote>), not true or false, when either input is null. For example, <literal>7 = NULL</literal>yields null, as does <literal>7 NULL</literal>. When this behavior is not suitable, use the <literal>IS <optional>NOT</optional>DISTINCT FROM</literal>constructs: <synopsis>\n    <replaceable>expression</replaceable>IS DISTINCT FROM \n    <replaceable>expression</replaceable>\n    <replaceable>expression</replaceable>IS NOT DISTINCT FROM \n    <replaceable>expression</replaceable></synopsis>For non-null inputs, <literal>IS DISTINCT FROM</literal>is the same as the <literal/>operator. However, if both inputs are null it returns false, and if only one input is null it returns true. Similarly, <literal>IS NOT DISTINCT FROM</literal>is identical to <literal>=</literal>for non-null inputs, but it returns true when both inputs are null, and false when only one input is null. Thus, these constructs effectively act as though null were a normal data value, rather than <quote>unknown</quote>."
msgstr ""

#: xml/func.xml:375(para)
msgid "<indexterm><primary>IS TRUE</primary></indexterm><indexterm><primary>IS NOT TRUE</primary></indexterm><indexterm><primary>IS FALSE</primary></indexterm><indexterm><primary>IS NOT FALSE</primary></indexterm><indexterm><primary>IS UNKNOWN</primary></indexterm><indexterm><primary>IS NOT UNKNOWN</primary></indexterm>Boolean values can also be tested using the constructs <synopsis>\n    <replaceable>expression</replaceable>IS TRUE \n    <replaceable>expression</replaceable>IS NOT TRUE \n    <replaceable>expression</replaceable>IS FALSE \n    <replaceable>expression</replaceable>IS NOT FALSE \n    <replaceable>expression</replaceable>IS UNKNOWN \n    <replaceable>expression</replaceable>IS NOT\n    UNKNOWN</synopsis>These will always return true or false, never a null value, even when the operand is null. A null input is treated as the logical value <quote>unknown</quote>. Notice that <literal>IS UNKNOWN</literal>and <literal>IS NOT UNKNOWN</literal>are effectively the same as <literal>IS NULL</literal>and <literal>IS NOT NULL</literal>, respectively, except that the input expression must be of Boolean type."
msgstr ""

#: xml/func.xml:413(title)
msgid "Mathematical Functions and Operators"
msgstr ""

#: xml/func.xml:414(para)
msgid "Mathematical operators are provided for many <productname>PostgreSQL</productname>types. For types without standard mathematical conventions (e.g., date/time types) we describe the actual behavior in subsequent sections."
msgstr ""

#: xml/func.xml:419(xref)
msgid "shows the available mathematical operators."
msgstr ""

#: xml/func.xml:423(title)
msgid "Mathematical Operators"
msgstr ""

#: xml/func.xml:429(entry) xml/func.xml:671(entry) xml/func.xml:1483(entry) xml/func.xml:1841(entry) xml/func.xml:4676(entry) xml/func.xml:4846(entry) xml/func.xml:5131(entry) xml/func.xml:5587(entry) xml/func.xml:7290(entry) xml/func.xml:7836(entry) xml/func.xml:8281(entry) xml/func.xml:8668(entry) xml/func.xml:8902(entry) xml/func.xml:10493(entry) xml/func.xml:10631(entry)
msgid "Example"
msgstr ""

#: xml/func.xml:430(entry) xml/func.xml:672(entry) xml/func.xml:1484(entry) xml/func.xml:1842(entry) xml/func.xml:4677(entry) xml/func.xml:4847(entry) xml/func.xml:5132(entry) xml/func.xml:8325(entry) xml/func.xml:8669(entry) xml/func.xml:8903(entry)
msgid "Result"
msgstr ""

#: xml/func.xml:436(literal) xml/func.xml:6041(literal) xml/func.xml:6100(literal) xml/func.xml:8640(literal) xml/func.xml:8675(literal) xml/func.xml:8686(literal) xml/func.xml:8698(literal) xml/func.xml:8709(literal) xml/func.xml:8721(literal) xml/func.xml:8733(literal) xml/func.xml:10637(literal)
msgid "+"
msgstr ""

#: xml/func.xml:438(entry)
msgid "addition"
msgstr ""

#: xml/func.xml:440(literal)
msgid "2 + 3"
msgstr ""

#: xml/func.xml:443(literal) xml/func.xml:517(literal) xml/func.xml:565(literal) xml/func.xml:4723(literal) xml/func.xml:5013(literal) xml/func.xml:9791(computeroutput)
msgid "5"
msgstr ""

#: xml/func.xml:448(literal) xml/func.xml:8744(literal) xml/func.xml:8755(literal) xml/func.xml:8766(literal) xml/func.xml:8777(literal) xml/func.xml:8789(literal) xml/func.xml:8800(literal) xml/func.xml:8811(literal) xml/func.xml:8823(literal) xml/func.xml:8835(literal) xml/func.xml:10647(literal) xml/func.xml:10725(literal)
msgid "-"
msgstr ""

#: xml/func.xml:450(entry)
msgid "subtraction"
msgstr ""

#: xml/func.xml:452(literal)
msgid "2 - 3"
msgstr ""

#: xml/func.xml:455(literal) xml/func.xml:1080(literal)
msgid "-1"
msgstr ""

#: xml/func.xml:460(literal) xml/func.xml:6034(literal) xml/func.xml:6093(literal) xml/func.xml:8641(literal) xml/func.xml:8847(literal) xml/func.xml:8858(literal) xml/func.xml:8869(literal) xml/func.xml:10657(literal)
msgid "*"
msgstr ""

#: xml/func.xml:462(entry)
msgid "multiplication"
msgstr ""

#: xml/func.xml:464(literal)
msgid "2 * 3"
msgstr ""

#: xml/func.xml:467(literal)
msgid "6"
msgstr ""

#: xml/func.xml:472(literal) xml/func.xml:8881(literal) xml/func.xml:10667(literal)
msgid "/"
msgstr ""

#: xml/func.xml:474(entry)
msgid "division (integer division truncates the result)"
msgstr ""

#: xml/func.xml:477(literal)
msgid "4 / 2"
msgstr ""

#: xml/func.xml:480(literal) xml/func.xml:637(literal) xml/func.xml:802(literal) xml/func.xml:883(literal) xml/func.xml:1247(literal) xml/func.xml:2851(literal) xml/func.xml:9965(computeroutput)
msgid "2"
msgstr ""

#: xml/func.xml:485(literal)
msgid "%"
msgstr ""

#: xml/func.xml:487(entry)
msgid "modulo (remainder)"
msgstr ""

#: xml/func.xml:489(literal)
msgid "5 % 4"
msgstr ""

#: xml/func.xml:492(literal) xml/func.xml:927(literal) xml/func.xml:4960(literal) xml/func.xml:7731(literal) xml/func.xml:7739(literal) xml/func.xml:9971(computeroutput) xml/func.xml:9984(computeroutput)
msgid "1"
msgstr ""

#: xml/func.xml:497(literal) xml/func.xml:6187(literal) xml/func.xml:6680(literal) xml/func.xml:10826(literal) xml/func.xml:10836(literal)
msgid "^"
msgstr ""

#: xml/func.xml:499(entry)
msgid "exponentiation (associates left to right)"
msgstr ""

#: xml/func.xml:502(literal)
msgid "2.0 ^ 3.0"
msgstr ""

#: xml/func.xml:505(literal)
msgid "8"
msgstr ""

#: xml/func.xml:510(literal)
msgid "|/"
msgstr ""

#: xml/func.xml:512(entry) xml/func.xml:1095(entry)
msgid "square root"
msgstr ""

#: xml/func.xml:514(literal)
msgid "|/ 25.0"
msgstr ""

#: xml/func.xml:522(literal)
msgid "||/"
msgstr ""

#: xml/func.xml:524(entry) xml/func.xml:708(entry)
msgid "cube root"
msgstr ""

#: xml/func.xml:526(literal)
msgid "||/ 27.0"
msgstr ""

#: xml/func.xml:529(literal) xml/func.xml:713(literal) xml/func.xml:1181(literal) xml/func.xml:1217(literal) xml/func.xml:1677(literal) xml/func.xml:4772(literal) xml/func.xml:9071(literal) xml/func.xml:9163(literal) xml/func.xml:9921(computeroutput) xml/func.xml:9968(computeroutput)
msgid "3"
msgstr ""

#: xml/func.xml:534(literal)
msgid "!"
msgstr ""

#: xml/func.xml:536(entry)
msgid "factorial"
msgstr ""

#: xml/func.xml:538(literal)
msgid "5 !"
msgstr ""

#: xml/func.xml:541(literal) xml/func.xml:553(literal) xml/func.xml:1870(literal)
msgid "120"
msgstr ""

#: xml/func.xml:546(literal)
msgid "!!"
msgstr ""

#: xml/func.xml:548(entry)
msgid "factorial (prefix operator)"
msgstr ""

#: xml/func.xml:550(literal)
msgid "!! 5"
msgstr ""

#: xml/func.xml:558(literal)
msgid "@"
msgstr ""

#: xml/func.xml:560(entry) xml/func.xml:687(entry)
msgid "absolute value"
msgstr ""

#: xml/func.xml:562(literal)
msgid "@ -5.0"
msgstr ""

#: xml/func.xml:572(entry) xml/func.xml:5152(entry)
msgid "bitwise AND"
msgstr ""

#: xml/func.xml:574(literal)
msgid "91 15"
msgstr ""

#: xml/func.xml:577(literal)
msgid "11"
msgstr ""

#: xml/func.xml:582(literal) xml/func.xml:5162(literal) xml/func.xml:10786(literal) xml/func.xml:10796(literal) xml/func.xml:10806(literal) xml/func.xml:10816(literal)
msgid "|"
msgstr ""

#: xml/func.xml:584(entry) xml/func.xml:5164(entry)
msgid "bitwise OR"
msgstr ""

#: xml/func.xml:586(literal)
msgid "32 | 3"
msgstr ""

#: xml/func.xml:589(literal)
msgid "35"
msgstr ""

#: xml/func.xml:594(literal) xml/func.xml:5174(literal) xml/func.xml:10677(literal) xml/func.xml:10687(literal)
msgid "#"
msgstr ""

#: xml/func.xml:596(entry) xml/func.xml:5176(entry)
msgid "bitwise XOR"
msgstr ""

#: xml/func.xml:598(literal)
msgid "17 # 5"
msgstr ""

#: xml/func.xml:601(literal) xml/func.xml:9048(literal) xml/func.xml:9142(literal) xml/func.xml:9737(computeroutput) xml/func.xml:9849(computeroutput)
msgid "20"
msgstr ""

#: xml/func.xml:606(literal) xml/func.xml:5186(literal) xml/func.xml:5593(literal)
msgid "~"
msgstr ""

#: xml/func.xml:608(entry) xml/func.xml:5188(entry)
msgid "bitwise NOT"
msgstr ""

#: xml/func.xml:610(literal)
msgid "~1"
msgstr ""

#: xml/func.xml:613(literal)
msgid "-2"
msgstr ""

#: xml/func.xml:620(entry) xml/func.xml:5200(entry)
msgid "bitwise shift left"
msgstr ""

#: xml/func.xml:622(literal)
msgid "1 4"
msgstr ""

#: xml/func.xml:625(literal) xml/func.xml:9762(computeroutput) xml/func.xml:10108(computeroutput)
msgid "16"
msgstr ""

#: xml/func.xml:632(entry) xml/func.xml:5212(entry)
msgid "bitwise shift right"
msgstr ""

#: xml/func.xml:634(literal)
msgid "8 2"
msgstr ""

#: xml/func.xml:643(para)
msgid "The bitwise operators work only on integral data types, whereas the others are available for all numeric data types. The bitwise operators are also available for the bit string types <type>bit</type>and <type>bit varying</type>, as shown in <xref linkend=\"functions-bit-string-op-table\">.</xref>"
msgstr ""

#: xml/func.xml:653(literal) xml/func.xml:702(type) xml/func.xml:706(type) xml/func.xml:723(type) xml/func.xml:743(type) xml/func.xml:765(type) xml/func.xml:769(type) xml/func.xml:812(type) xml/func.xml:832(type) xml/func.xml:853(type) xml/func.xml:873(type) xml/func.xml:940(type) xml/func.xml:959(type) xml/func.xml:961(type) xml/func.xml:965(type) xml/func.xml:1007(type) xml/func.xml:1011(type) xml/func.xml:1028(type) xml/func.xml:1070(type) xml/func.xml:1090(type) xml/func.xml:1110(type) xml/func.xml:1153(type) xml/func.xml:1155(type) xml/func.xml:1157(type) xml/func.xml:1278(type) xml/func.xml:1289(type)
msgid "dp"
msgstr ""

#: xml/func.xml:654(type) xml/func.xml:658(type) xml/func.xml:7351(type) xml/func.xml:7441(type) xml/func.xml:9037(type) xml/func.xml:9060(type) xml/func.xml:9132(type) xml/func.xml:9153(type) xml/func.xml:9378(type) xml/func.xml:9406(type) xml/func.xml:9439(type) xml/func.xml:9473(type)
msgid "double precision"
msgstr ""

#: xml/func.xml:651(xref)
msgid "shows the available mathematical functions. In the table, <placeholder-1/>indicates <placeholder-2/>. Many of these functions are provided in multiple forms with different argument types. Except where noted, any given form of a function returns the same data type as its argument. The functions working with <placeholder-3/>data are mostly implemented on top of the host system's C library; accuracy and behavior in boundary cases can therefore vary depending on the host system."
msgstr ""

#: xml/func.xml:664(title)
msgid "Mathematical Functions"
msgstr ""

#: xml/func.xml:668(entry) xml/func.xml:1262(entry) xml/func.xml:1328(entry) xml/func.xml:1480(entry) xml/func.xml:1838(entry) xml/func.xml:4673(entry) xml/func.xml:4843(entry) xml/func.xml:7287(entry) xml/func.xml:8899(entry) xml/func.xml:10491(entry)
msgid "Function"
msgstr ""

#: xml/func.xml:669(entry) xml/func.xml:1263(entry) xml/func.xml:1481(entry) xml/func.xml:1839(entry) xml/func.xml:4674(entry) xml/func.xml:4844(entry) xml/func.xml:7288(entry) xml/func.xml:8900(entry) xml/func.xml:10218(entry)
msgid "Return Type"
msgstr ""

#: xml/func.xml:679(primary)
msgid "abs"
msgstr ""

#: xml/func.xml:683(replaceable) xml/func.xml:788(parameter) xml/func.xml:797(parameter) xml/func.xml:892(parameter) xml/func.xml:916(parameter) xml/func.xml:922(parameter) xml/func.xml:1340(replaceable) xml/func.xml:1352(replaceable) xml/func.xml:1364(replaceable) xml/func.xml:1377(replaceable) xml/func.xml:1383(replaceable) xml/func.xml:1392(replaceable) xml/func.xml:1404(replaceable) xml/func.xml:1416(replaceable) xml/func.xml:1428(replaceable) xml/func.xml:6002(replaceable) xml/func.xml:6005(replaceable) xml/func.xml:6904(literal)
msgid "x"
msgstr ""

#: xml/func.xml:682(function)
msgid "abs( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:686(entry) xml/func.xml:727(entry) xml/func.xml:747(entry) xml/func.xml:816(entry) xml/func.xml:836(entry) xml/func.xml:857(entry) xml/func.xml:877(entry) xml/func.xml:1032(entry) xml/func.xml:1074(entry) xml/func.xml:1094(entry) xml/func.xml:1114(entry)
msgid "(same as input)"
msgstr ""

#: xml/func.xml:689(literal)
msgid "abs(-17.4)"
msgstr ""

#: xml/func.xml:692(literal)
msgid "17.4"
msgstr ""

#: xml/func.xml:698(primary)
msgid "cbrt"
msgstr ""

#: xml/func.xml:701(function)
msgid "cbrt( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:710(literal)
msgid "cbrt(27.0)"
msgstr ""

#: xml/func.xml:719(primary) xml/func.xml:750(function)
msgid "ceil"
msgstr ""

#: xml/func.xml:724(type) xml/func.xml:744(type) xml/func.xml:787(type) xml/func.xml:789(type) xml/func.xml:793(type) xml/func.xml:813(type) xml/func.xml:833(type) xml/func.xml:854(type) xml/func.xml:874(type) xml/func.xml:891(type) xml/func.xml:893(type) xml/func.xml:897(type) xml/func.xml:982(type) xml/func.xml:984(type) xml/func.xml:988(type) xml/func.xml:1029(type) xml/func.xml:1046(type) xml/func.xml:1052(type) xml/func.xml:1071(type) xml/func.xml:1091(type) xml/func.xml:1111(type) xml/func.xml:1128(type) xml/func.xml:1134(type) xml/func.xml:1189(type) xml/func.xml:1191(type) xml/func.xml:1193(type) xml/func.xml:7366(type) xml/func.xml:7409(type)
msgid "numeric"
msgstr ""

#: xml/func.xml:722(function)
msgid "ceil( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:728(entry)
msgid "smallest integer not less than argument"
msgstr ""

#: xml/func.xml:730(literal)
msgid "ceil(-42.8)"
msgstr ""

#: xml/func.xml:733(literal)
msgid "-42"
msgstr ""

#: xml/func.xml:739(primary)
msgid "ceiling"
msgstr ""

#: xml/func.xml:742(function)
msgid "ceiling( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:748(entry)
msgid "smallest integer not less than argument (alias for <placeholder-1/>)"
msgstr ""

#: xml/func.xml:752(literal)
msgid "ceiling(-95.3)"
msgstr ""

#: xml/func.xml:755(literal)
msgid "-95"
msgstr ""

#: xml/func.xml:761(primary)
msgid "degrees"
msgstr ""

#: xml/func.xml:764(function)
msgid "degrees( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:771(entry)
msgid "radians to degrees"
msgstr ""

#: xml/func.xml:773(literal)
msgid "degrees(0.5)"
msgstr ""

#: xml/func.xml:776(literal)
msgid "28.6478897565412"
msgstr ""

#: xml/func.xml:782(primary)
msgid "div"
msgstr ""

#: xml/func.xml:786(parameter) xml/func.xml:796(parameter) xml/func.xml:915(parameter) xml/func.xml:921(parameter) xml/func.xml:1376(replaceable) xml/func.xml:1382(replaceable)
msgid "y"
msgstr ""

#: xml/func.xml:785(function)
msgid "div( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:795(entry)
msgid "integer quotient of <placeholder-1/>/ <placeholder-2/>"
msgstr ""

#: xml/func.xml:799(literal)
msgid "div(9,4)"
msgstr ""

#: xml/func.xml:808(primary)
msgid "exp"
msgstr ""

#: xml/func.xml:811(function)
msgid "exp( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:817(entry)
msgid "exponential"
msgstr ""

#: xml/func.xml:819(literal)
msgid "exp(1.0)"
msgstr ""

#: xml/func.xml:822(literal)
msgid "2.71828182845905"
msgstr ""

#: xml/func.xml:828(primary)
msgid "floor"
msgstr ""

#: xml/func.xml:831(function)
msgid "floor( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:837(entry)
msgid "largest integer not greater than argument"
msgstr ""

#: xml/func.xml:840(literal)
msgid "floor(-42.8)"
msgstr ""

#: xml/func.xml:843(literal)
msgid "-43"
msgstr ""

#: xml/func.xml:849(primary)
msgid "ln"
msgstr ""

#: xml/func.xml:852(function)
msgid "ln( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:858(entry)
msgid "natural logarithm"
msgstr ""

#: xml/func.xml:860(literal)
msgid "ln(2.0)"
msgstr ""

#: xml/func.xml:863(literal)
msgid "0.693147180559945"
msgstr ""

#: xml/func.xml:869(primary)
msgid "log"
msgstr ""

#: xml/func.xml:872(function)
msgid "log( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:878(entry)
msgid "base 10 logarithm"
msgstr ""

#: xml/func.xml:880(literal)
msgid "log(100.0)"
msgstr ""

#: xml/func.xml:890(parameter) xml/func.xml:900(parameter) xml/func.xml:960(parameter) xml/func.xml:969(parameter) xml/func.xml:983(parameter) xml/func.xml:992(parameter) xml/func.xml:6824(literal)
msgid "b"
msgstr ""

#: xml/func.xml:889(function)
msgid "log( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:899(entry)
msgid "logarithm to base <placeholder-1/>"
msgstr ""

#: xml/func.xml:902(literal)
msgid "log(2.0, 64.0)"
msgstr ""

#: xml/func.xml:905(literal)
msgid "6.0000000000"
msgstr ""

#: xml/func.xml:911(primary)
msgid "mod"
msgstr ""

#: xml/func.xml:914(function)
msgid "mod( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:919(entry)
msgid "(same as argument types)"
msgstr ""

#: xml/func.xml:920(entry)
msgid "remainder of <placeholder-1/>/ <placeholder-2/>"
msgstr ""

#: xml/func.xml:924(literal)
msgid "mod(9,4)"
msgstr ""

#: xml/func.xml:933(primary)
msgid "pi"
msgstr ""

#: xml/func.xml:936(function) xml/func.xml:945(literal)
msgid "pi()"
msgstr ""

#: xml/func.xml:942(entry)
msgid "<quote/>constant"
msgstr ""

#: xml/func.xml:948(literal)
msgid "3.14159265358979"
msgstr ""

#: xml/func.xml:954(primary)
msgid "power"
msgstr ""

#: xml/func.xml:958(parameter) xml/func.xml:968(parameter) xml/func.xml:981(parameter) xml/func.xml:991(parameter)
msgid "a"
msgstr ""

#: xml/func.xml:957(function) xml/func.xml:980(function)
msgid "power( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:967(entry) xml/func.xml:990(entry)
msgid "<placeholder-1/>raised to the power of <placeholder-2/>"
msgstr ""

#: xml/func.xml:971(literal) xml/func.xml:994(literal)
msgid "power(9.0, 3.0)"
msgstr ""

#: xml/func.xml:974(literal) xml/func.xml:997(literal)
msgid "729"
msgstr ""

#: xml/func.xml:1003(primary)
msgid "radians"
msgstr ""

#: xml/func.xml:1006(function)
msgid "radians( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1013(entry)
msgid "degrees to radians"
msgstr ""

#: xml/func.xml:1015(literal)
msgid "radians(45.0)"
msgstr ""

#: xml/func.xml:1018(literal)
msgid "0.785398163397448"
msgstr ""

#: xml/func.xml:1024(primary)
msgid "round"
msgstr ""

#: xml/func.xml:1027(function)
msgid "round( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1033(entry)
msgid "round to nearest integer"
msgstr ""

#: xml/func.xml:1035(literal)
msgid "round(42.4)"
msgstr ""

#: xml/func.xml:1038(literal) xml/func.xml:1120(literal)
msgid "42"
msgstr ""

#: xml/func.xml:1045(parameter) xml/func.xml:1127(parameter)
msgid "v"
msgstr ""

#: xml/func.xml:1047(parameter) xml/func.xml:1055(parameter) xml/func.xml:1129(parameter) xml/func.xml:1137(parameter) xml/func.xml:6882(literal)
msgid "s"
msgstr ""

#: xml/func.xml:1048(type) xml/func.xml:1130(type) xml/func.xml:1159(type) xml/func.xml:1163(type) xml/func.xml:1195(type) xml/func.xml:1199(type) xml/func.xml:1231(type) xml/func.xml:1546(type) xml/func.xml:1570(type) xml/func.xml:1622(type) xml/func.xml:1641(type) xml/func.xml:1643(type) xml/func.xml:1670(type) xml/func.xml:1689(type) xml/func.xml:1691(type) xml/func.xml:1857(type) xml/func.xml:1909(type) xml/func.xml:2195(type) xml/func.xml:2225(type) xml/func.xml:2247(type) xml/func.xml:2271(type) xml/func.xml:2638(type) xml/func.xml:2715(type) xml/func.xml:2744(type) xml/func.xml:2810(type) xml/func.xml:2840(type) xml/func.xml:2922(type) xml/func.xml:4716(type) xml/func.xml:4735(type) xml/func.xml:4737(type) xml/func.xml:4764(type) xml/func.xml:4784(type) xml/func.xml:4786(type) xml/func.xml:4953(type) xml/func.xml:4975(type) xml/func.xml:4996(type) xml/func.xml:7335(type) xml/func.xml:9339(type) xml/func.xml:9341(type) xml/func.xml:9343(type) xml/func.xml:9366(type) xml/func.xml:9368(type) xml/func.xml:9370(type) xml/func.xml:9372(type) xml/func.xml:9374(type) xml/func.xml:9376(type) xml/func.xml:9402(type) xml/func.xml:9404(type) xml/func.xml:9429(type) xml/func.xml:9431(type) xml/func.xml:9433(type) xml/func.xml:9435(type) xml/func.xml:9437(type) xml/func.xml:9463(type) xml/func.xml:9465(type) xml/func.xml:9467(type) xml/func.xml:9469(type) xml/func.xml:9471(type)
msgid "int"
msgstr ""

#: xml/func.xml:1044(function)
msgid "round( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:1054(entry)
msgid "round to <placeholder-1/>decimal places"
msgstr ""

#: xml/func.xml:1057(literal)
msgid "round(42.4382, 2)"
msgstr ""

#: xml/func.xml:1060(literal)
msgid "42.44"
msgstr ""

#: xml/func.xml:1066(primary)
msgid "sign"
msgstr ""

#: xml/func.xml:1069(function)
msgid "sign( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1075(entry)
msgid "sign of the argument (-1, 0, +1)"
msgstr ""

#: xml/func.xml:1077(literal)
msgid "sign(-8.4)"
msgstr ""

#: xml/func.xml:1086(primary)
msgid "sqrt"
msgstr ""

#: xml/func.xml:1089(function)
msgid "sqrt( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1097(literal)
msgid "sqrt(2.0)"
msgstr ""

#: xml/func.xml:1100(literal)
msgid "1.4142135623731"
msgstr ""

#: xml/func.xml:1106(primary)
msgid "trunc"
msgstr ""

#: xml/func.xml:1109(function)
msgid "trunc( <placeholder-1/>or <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1115(entry)
msgid "truncate toward zero"
msgstr ""

#: xml/func.xml:1117(literal)
msgid "trunc(42.8)"
msgstr ""

#: xml/func.xml:1126(function)
msgid "trunc( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:1136(entry)
msgid "truncate to <placeholder-1/>decimal places"
msgstr ""

#: xml/func.xml:1139(literal)
msgid "trunc(42.4382, 2)"
msgstr ""

#: xml/func.xml:1142(literal)
msgid "42.43"
msgstr ""

#: xml/func.xml:1148(primary)
msgid "width_bucket"
msgstr ""

#: xml/func.xml:1152(parameter) xml/func.xml:1166(parameter) xml/func.xml:1188(parameter) xml/func.xml:1202(parameter) xml/func.xml:1224(parameter) xml/func.xml:1234(parameter)
msgid "operand"
msgstr ""

#: xml/func.xml:1154(parameter) xml/func.xml:1170(parameter) xml/func.xml:1190(parameter) xml/func.xml:1206(parameter)
msgid "b1"
msgstr ""

#: xml/func.xml:1156(parameter) xml/func.xml:1171(parameter) xml/func.xml:1192(parameter) xml/func.xml:1207(parameter)
msgid "b2"
msgstr ""

#: xml/func.xml:1158(parameter) xml/func.xml:1168(parameter) xml/func.xml:1174(parameter) xml/func.xml:1194(parameter) xml/func.xml:1204(parameter) xml/func.xml:1210(parameter) xml/func.xml:2864(parameter) xml/func.xml:2874(parameter)
msgid "count"
msgstr ""

#: xml/func.xml:1151(function) xml/func.xml:1187(function)
msgid "width_bucket( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>, <placeholder-7/><placeholder-8/>)"
msgstr ""

#: xml/func.xml:1172(literal) xml/func.xml:1208(literal) xml/func.xml:1237(literal) xml/func.xml:6533(literal) xml/func.xml:6545(literal) xml/func.xml:6558(literal) xml/func.xml:8115(literal)
msgid "0"
msgstr ""

#: xml/func.xml:1173(literal) xml/func.xml:1209(literal)
msgid "<placeholder-1/>+1"
msgstr ""

#: xml/func.xml:1165(entry) xml/func.xml:1201(entry)
msgid "return the bucket number to which <placeholder-1/>would be assigned in a histogram having <placeholder-2/>equal-width buckets spanning the range <placeholder-3/>to <placeholder-4/>; returns <placeholder-5/>or <placeholder-6/>for an input outside the range"
msgstr ""

#: xml/func.xml:1177(literal) xml/func.xml:1213(literal)
msgid "width_bucket(5.35, 0.024, 10.06, 5)"
msgstr ""

#: xml/func.xml:1225(type) xml/func.xml:2434(type) xml/func.xml:2484(type)
msgid "anyelement"
msgstr ""

#: xml/func.xml:1226(parameter) xml/func.xml:1239(parameter)
msgid "thresholds"
msgstr ""

#: xml/func.xml:1227(type)
msgid "anyarray"
msgstr ""

#: xml/func.xml:1223(function)
msgid "width_bucket( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:1240(emphasis)
msgid "must be sorted"
msgstr ""

#: xml/func.xml:1233(entry)
msgid "return the bucket number to which <placeholder-1/>would be assigned given an array listing the lower bounds of the buckets; returns <placeholder-2/>for an input less than the first lower bound; the <placeholder-3/>array <placeholder-4/>, smallest first, or unexpected results will be obtained"
msgstr ""

#: xml/func.xml:1243(literal)
msgid "width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"
msgstr ""

#: xml/func.xml:1254(xref)
msgid "shows functions for generating random numbers."
msgstr ""

#: xml/func.xml:1258(title)
msgid "Random Functions"
msgstr ""

#: xml/func.xml:1271(primary)
msgid "random"
msgstr ""

#: xml/func.xml:1274(function) xml/func.xml:1296(literal)
msgid "random()"
msgstr ""

#: xml/func.xml:1280(entry)
msgid "random value in the range 0.0 = x 1.0"
msgstr ""

#: xml/func.xml:1285(primary)
msgid "setseed"
msgstr ""

#: xml/func.xml:1288(function)
msgid "setseed( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1293(type)
msgid "void"
msgstr ""

#: xml/func.xml:1295(entry)
msgid "set seed for subsequent <placeholder-1/>calls (value between -1.0 and 1.0, inclusive)"
msgstr ""

#: xml/func.xml:1302(para)
msgid "The characteristics of the values returned by <literal><function>random()</function></literal>depend on the system implementation. It is not suitable for cryptographic applications; see <xref linkend=\"pgcrypto\">module for an alternative.</xref>"
msgstr ""

#: xml/func.xml:1309(para)
msgid "Finally, <xref linkend=\"functions-math-trig-table\">shows the available trigonometric functions. All trigonometric functions take arguments and return values of type <type>double precision</type>. Trigonometric functions arguments are expressed in radians. Inverse functions return values are expressed in radians. See unit transformation functions <literal><function>radians()</function></literal>and <literal><function>degrees()</function></literal>above.</xref>"
msgstr ""

#: xml/func.xml:1324(title)
msgid "Trigonometric Functions"
msgstr ""

#: xml/func.xml:1336(primary)
msgid "acos"
msgstr ""

#: xml/func.xml:1339(function)
msgid "acos( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1343(entry)
msgid "inverse cosine"
msgstr ""

#: xml/func.xml:1348(primary)
msgid "asin"
msgstr ""

#: xml/func.xml:1351(function)
msgid "asin( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1355(entry)
msgid "inverse sine"
msgstr ""

#: xml/func.xml:1360(primary)
msgid "atan"
msgstr ""

#: xml/func.xml:1363(function)
msgid "atan( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1367(entry)
msgid "inverse tangent"
msgstr ""

#: xml/func.xml:1372(primary)
msgid "atan2"
msgstr ""

#: xml/func.xml:1375(function)
msgid "atan2( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1381(literal)
msgid "<placeholder-1/>/ <placeholder-2/>"
msgstr ""

#: xml/func.xml:1380(entry)
msgid "inverse tangent of <placeholder-1/>"
msgstr ""

#: xml/func.xml:1388(primary)
msgid "cos"
msgstr ""

#: xml/func.xml:1391(function)
msgid "cos( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1395(entry)
msgid "cosine"
msgstr ""

#: xml/func.xml:1400(primary)
msgid "cot"
msgstr ""

#: xml/func.xml:1403(function)
msgid "cot( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1407(entry)
msgid "cotangent"
msgstr ""

#: xml/func.xml:1412(primary)
msgid "sin"
msgstr ""

#: xml/func.xml:1415(function)
msgid "sin( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1419(entry)
msgid "sine"
msgstr ""

#: xml/func.xml:1424(primary)
msgid "tan"
msgstr ""

#: xml/func.xml:1427(function)
msgid "tan( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1431(entry)
msgid "tangent"
msgstr ""

#: xml/func.xml:1438(title)
msgid "String Functions and Operators"
msgstr ""

#: xml/func.xml:1439(para)
msgid "This section describes functions and operators for examining and manipulating string values. Strings in this context include values of the types <type>character</type>, <type>character varying</type>, and <type>text</type>. Unless otherwise noted, all of the functions listed below work on all of these types, but be wary of potential effects of automatic space-padding when using the <type>character</type>type. Some functions also exist natively for the bit-string types."
msgstr ""

#: xml/func.xml:1449(para)
msgid "<acronym>SQL</acronym>defines some string functions that use key words, rather than commas, to separate arguments. Details are in <xref linkend=\"functions-string-sql\">. <productname>PostgreSQL</productname>also provides versions of these functions that use the regular function invocation syntax (see <xref linkend=\"functions-string-other\">).</xref></xref>"
msgstr ""

#: xml/func.xml:1459(para)
msgid "Before <productname>PostgreSQL</productname>8.3, these functions would silently accept values of several non-string data types as well, due to the presence of implicit coercions from those data types to <type>text</type>. Those coercions have been removed because they frequently caused surprising behaviors. However, the string concatenation operator ( <literal>||</literal>) still accepts non-string input, so long as at least one input is of a string type, as shown in <xref linkend=\"functions-string-sql\">. For other cases, insert an explicit coercion to <type>text</type>if you need to duplicate the previous behavior.</xref>"
msgstr ""

#: xml/func.xml:1475(title)
msgid "<acronym>SQL</acronym>String Functions and Operators"
msgstr ""

#: xml/func.xml:1491(parameter) xml/func.xml:1493(parameter) xml/func.xml:1514(parameter) xml/func.xml:1521(parameter) xml/func.xml:1542(parameter) xml/func.xml:1563(parameter) xml/func.xml:1567(parameter) xml/func.xml:1597(parameter) xml/func.xml:1618(parameter) xml/func.xml:1639(parameter) xml/func.xml:1640(parameter) xml/func.xml:1666(parameter) xml/func.xml:1687(parameter) xml/func.xml:1709(parameter) xml/func.xml:1731(parameter) xml/func.xml:1762(parameter) xml/func.xml:1771(parameter) xml/func.xml:1785(parameter) xml/func.xml:1810(parameter) xml/func.xml:1853(parameter) xml/func.xml:1880(parameter) xml/func.xml:1894(parameter) xml/func.xml:1990(parameter) xml/func.xml:2005(parameter) xml/func.xml:2026(parameter) xml/func.xml:2038(parameter) xml/func.xml:2055(parameter) xml/func.xml:2080(parameter) xml/func.xml:2091(parameter) xml/func.xml:2168(parameter) xml/func.xml:2221(parameter) xml/func.xml:2228(parameter) xml/func.xml:2240(parameter) xml/func.xml:2250(parameter) xml/func.xml:2252(parameter) xml/func.xml:2268(parameter) xml/func.xml:2281(parameter) xml/func.xml:2286(parameter) xml/func.xml:2303(parameter) xml/func.xml:2317(parameter) xml/func.xml:2332(parameter) xml/func.xml:2339(parameter) xml/func.xml:2375(parameter) xml/func.xml:2404(parameter) xml/func.xml:2457(parameter) xml/func.xml:2508(parameter) xml/func.xml:2521(parameter) xml/func.xml:2539(parameter) xml/func.xml:2571(parameter) xml/func.xml:2583(parameter) xml/func.xml:2602(parameter) xml/func.xml:2614(parameter) xml/func.xml:2635(parameter) xml/func.xml:2645(parameter) xml/func.xml:2661(parameter) xml/func.xml:2673(parameter) xml/func.xml:2741(parameter) xml/func.xml:2754(parameter) xml/func.xml:2759(parameter) xml/func.xml:2776(parameter) xml/func.xml:2790(parameter) xml/func.xml:2805(parameter) xml/func.xml:2817(parameter) xml/func.xml:2835(parameter) xml/func.xml:2845(parameter) xml/func.xml:2861(parameter) xml/func.xml:2872(parameter) xml/func.xml:2889(parameter) xml/func.xml:2900(parameter) xml/func.xml:2946(parameter) xml/func.xml:2958(parameter) xml/func.xml:4684(parameter) xml/func.xml:4686(parameter) xml/func.xml:4712(parameter) xml/func.xml:4733(parameter) xml/func.xml:4734(parameter) xml/func.xml:4760(parameter) xml/func.xml:4782(parameter) xml/func.xml:4810(parameter) xml/func.xml:4819(parameter) xml/func.xml:4858(parameter) xml/func.xml:4870(parameter) xml/func.xml:4886(parameter) xml/func.xml:4897(parameter) xml/func.xml:4948(parameter) xml/func.xml:4970(parameter) xml/func.xml:4992(parameter) xml/func.xml:5023(parameter) xml/func.xml:5030(parameter) xml/func.xml:5046(parameter) xml/func.xml:5070(parameter) xml/func.xml:5322(replaceable) xml/func.xml:5326(replaceable) xml/func.xml:5416(replaceable) xml/func.xml:5420(replaceable)
msgid "string"
msgstr ""

#: xml/func.xml:1492(literal) xml/func.xml:1515(literal) xml/func.xml:1520(literal) xml/func.xml:4685(literal) xml/func.xml:5138(literal)
msgid "||"
msgstr ""

#: xml/func.xml:1497(type) xml/func.xml:1524(type) xml/func.xml:1601(type) xml/func.xml:1647(type) xml/func.xml:1695(type) xml/func.xml:1714(type) xml/func.xml:1737(type) xml/func.xml:1766(type) xml/func.xml:1792(type) xml/func.xml:1814(type) xml/func.xml:1881(type) xml/func.xml:1884(type) xml/func.xml:1888(type) xml/func.xml:1913(type) xml/func.xml:1943(type) xml/func.xml:1962(type) xml/func.xml:1970(type) xml/func.xml:2033(type) xml/func.xml:2056(type) xml/func.xml:2081(type) xml/func.xml:2083(type) xml/func.xml:2111(type) xml/func.xml:2115(type) xml/func.xml:2142(type) xml/func.xml:2147(type) xml/func.xml:2172(type) xml/func.xml:2193(type) xml/func.xml:2199(type) xml/func.xml:2269(type) xml/func.xml:2274(type) xml/func.xml:2278(type) xml/func.xml:2304(type) xml/func.xml:2307(type) xml/func.xml:2311(type) xml/func.xml:2336(type) xml/func.xml:2376(type) xml/func.xml:2380(type) xml/func.xml:2405(type) xml/func.xml:2409(type) xml/func.xml:2438(type) xml/func.xml:2458(type) xml/func.xml:2462(type) xml/func.xml:2488(type) xml/func.xml:2509(type) xml/func.xml:2511(type) xml/func.xml:2513(type) xml/func.xml:2540(type) xml/func.xml:2542(type) xml/func.xml:2544(type) xml/func.xml:2546(type) xml/func.xml:2550(type) xml/func.xml:2572(type) xml/func.xml:2574(type) xml/func.xml:2576(type) xml/func.xml:2603(type) xml/func.xml:2605(type) xml/func.xml:2607(type) xml/func.xml:2636(type) xml/func.xml:2642(type) xml/func.xml:2662(type) xml/func.xml:2664(type) xml/func.xml:2666(type) xml/func.xml:2670(type) xml/func.xml:2695(type) xml/func.xml:2713(type) xml/func.xml:2719(type) xml/func.xml:2742(type) xml/func.xml:2747(type) xml/func.xml:2751(type) xml/func.xml:2777(type) xml/func.xml:2780(type) xml/func.xml:2784(type) xml/func.xml:2806(type) xml/func.xml:2808(type) xml/func.xml:2814(type) xml/func.xml:2868(type) xml/func.xml:2890(type) xml/func.xml:2893(type) xml/func.xml:2897(type) xml/func.xml:2927(type) xml/func.xml:2947(type) xml/func.xml:2949(type) xml/func.xml:2951(type) xml/func.xml:2955(type) xml/func.xml:4887(type) xml/func.xml:4889(type) xml/func.xml:4917(type) xml/func.xml:4921(type) xml/func.xml:5027(type) xml/func.xml:7302(type) xml/func.xml:7306(type) xml/func.xml:7319(type) xml/func.xml:7323(type) xml/func.xml:7336(type) xml/func.xml:7340(type) xml/func.xml:7352(type) xml/func.xml:7355(type) xml/func.xml:7367(type) xml/func.xml:7371(type) xml/func.xml:7385(type) xml/func.xml:7386(type) xml/func.xml:7404(type) xml/func.xml:7405(type) xml/func.xml:7424(type) xml/func.xml:7425(type) xml/func.xml:9032(type) xml/func.xml:9055(type) xml/func.xml:9081(type) xml/func.xml:9103(type) xml/func.xml:9476(type) xml/func.xml:9543(type) xml/func.xml:9547(type)
msgid "text"
msgstr ""

#: xml/func.xml:1501(primary) xml/func.xml:1574(primary)
msgid "character string"
msgstr ""

#: xml/func.xml:1502(secondary) xml/func.xml:4695(secondary) xml/func.xml:5140(entry)
msgid "concatenation"
msgstr ""

#: xml/func.xml:1499(entry) xml/func.xml:4692(entry)
msgid "String concatenation <indexterm><placeholder-1/><placeholder-2/></indexterm>"
msgstr ""

#: xml/func.xml:1505(literal)
msgid "'Post' || 'greSQL'"
msgstr ""

#: xml/func.xml:1508(literal)
msgid "PostgreSQL"
msgstr ""

#: xml/func.xml:1516(parameter) xml/func.xml:1519(parameter)
msgid "non-string"
msgstr ""

#: xml/func.xml:1512(entry)
msgid "<literal><placeholder-1/><placeholder-2/><placeholder-3/></literal>or <literal><placeholder-4/><placeholder-5/><placeholder-6/></literal>"
msgstr ""

#: xml/func.xml:1526(entry)
msgid "String concatenation with one non-string input"
msgstr ""

#: xml/func.xml:1529(literal)
msgid "'Value: ' || 42"
msgstr ""

#: xml/func.xml:1532(literal)
msgid "Value: 42"
msgstr ""

#: xml/func.xml:1538(primary)
msgid "bit_length"
msgstr ""

#: xml/func.xml:1541(function)
msgid "bit_length( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1548(entry)
msgid "Number of bits in string"
msgstr ""

#: xml/func.xml:1550(literal)
msgid "bit_length('jose')"
msgstr ""

#: xml/func.xml:1553(literal)
msgid "32"
msgstr ""

#: xml/func.xml:1559(primary)
msgid "char_length"
msgstr ""

#: xml/func.xml:1562(function)
msgid "char_length( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1566(function)
msgid "character_length( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1557(entry)
msgid "<indexterm><placeholder-1/></indexterm><literal><placeholder-2/></literal>or <literal><placeholder-3/></literal>"
msgstr ""

#: xml/func.xml:1575(secondary) xml/func.xml:1578(primary) xml/func.xml:2217(primary) xml/func.xml:2270(parameter) xml/func.xml:2282(parameter) xml/func.xml:2287(parameter) xml/func.xml:2743(parameter) xml/func.xml:2755(parameter) xml/func.xml:2760(parameter) xml/func.xml:4988(primary) xml/func.xml:5001(secondary) xml/func.xml:5004(primary)
msgid "length"
msgstr ""

#: xml/func.xml:1579(secondary)
msgid "of a character string"
msgstr ""

#: xml/func.xml:1581(see)
msgid "character string, length"
msgstr ""

#: xml/func.xml:1572(entry)
msgid "Number of characters in string <indexterm><placeholder-1/><placeholder-2/></indexterm><indexterm><placeholder-3/><placeholder-4/><placeholder-5/></indexterm>"
msgstr ""

#: xml/func.xml:1584(literal)
msgid "char_length('jose')"
msgstr ""

#: xml/func.xml:1587(literal) xml/func.xml:1629(literal) xml/func.xml:2233(literal) xml/func.xml:2258(literal) xml/func.xml:10111(computeroutput)
msgid "4"
msgstr ""

#: xml/func.xml:1593(primary)
msgid "lower"
msgstr ""

#: xml/func.xml:1596(function)
msgid "lower( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1603(entry)
msgid "Convert string to lower case"
msgstr ""

#: xml/func.xml:1605(literal)
msgid "lower('TOM')"
msgstr ""

#: xml/func.xml:1608(literal)
msgid "tom"
msgstr ""

#: xml/func.xml:1614(primary) xml/func.xml:4708(primary)
msgid "octet_length"
msgstr ""

#: xml/func.xml:1617(function) xml/func.xml:4711(function)
msgid "octet_length( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1624(entry)
msgid "Number of bytes in string"
msgstr ""

#: xml/func.xml:1626(literal)
msgid "octet_length('jose')"
msgstr ""

#: xml/func.xml:1635(primary) xml/func.xml:4729(primary)
msgid "overlay"
msgstr ""

#: xml/func.xml:1642(optional) xml/func.xml:1690(optional) xml/func.xml:4736(optional) xml/func.xml:4785(optional)
msgid "for <placeholder-1/>"
msgstr ""

#: xml/func.xml:1638(function) xml/func.xml:4732(function)
msgid "overlay( <placeholder-1/>placing <placeholder-2/>from <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:1649(entry) xml/func.xml:4743(entry)
msgid "Replace substring"
msgstr ""

#: xml/func.xml:1651(literal)
msgid "overlay('Txxxxas' placing 'hom' from 2 for 4)"
msgstr ""

#: xml/func.xml:1655(literal)
msgid "Thomas"
msgstr ""

#: xml/func.xml:1661(primary) xml/func.xml:4755(primary)
msgid "position"
msgstr ""

#: xml/func.xml:1665(parameter) xml/func.xml:1683(primary) xml/func.xml:2836(parameter) xml/func.xml:2844(parameter) xml/func.xml:4759(parameter) xml/func.xml:4778(primary) xml/func.xml:5413(primary) xml/func.xml:5561(primary)
msgid "substring"
msgstr ""

#: xml/func.xml:1664(function) xml/func.xml:2843(literal) xml/func.xml:4758(function)
msgid "position( <placeholder-1/>in <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1672(entry) xml/func.xml:4766(entry)
msgid "Location of specified substring"
msgstr ""

#: xml/func.xml:1674(literal)
msgid "position('om' in 'Thomas')"
msgstr ""

#: xml/func.xml:1688(optional) xml/func.xml:4783(optional)
msgid "from <placeholder-1/>"
msgstr ""

#: xml/func.xml:1686(function) xml/func.xml:4781(function)
msgid "substring( <placeholder-1/><placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/func.xml:1697(entry) xml/func.xml:4792(entry)
msgid "Extract substring"
msgstr ""

#: xml/func.xml:1699(literal)
msgid "substring('Thomas' from 2 for 3)"
msgstr ""

#: xml/func.xml:1702(literal)
msgid "hom"
msgstr ""

#: xml/func.xml:1710(replaceable) xml/func.xml:1732(replaceable) xml/func.xml:2510(parameter) xml/func.xml:2541(parameter) xml/func.xml:2573(parameter) xml/func.xml:2604(parameter) xml/func.xml:5323(replaceable) xml/func.xml:5327(replaceable) xml/func.xml:5417(replaceable) xml/func.xml:5421(replaceable)
msgid "pattern"
msgstr ""

#: xml/func.xml:1708(function)
msgid "substring( <placeholder-1/>from <placeholder-2/>)"
msgstr ""

#: xml/func.xml:1718(xref) xml/func.xml:1741(xref)
msgid "for more information on pattern matching."
msgstr ""

#: xml/func.xml:1716(entry)
msgid "Extract substring matching POSIX regular expression. See <placeholder-1/>"
msgstr ""

#: xml/func.xml:1721(literal)
msgid "substring('Thomas' from '...$')"
msgstr ""

#: xml/func.xml:1724(literal)
msgid "mas"
msgstr ""

#: xml/func.xml:1733(replaceable) xml/func.xml:2121(literal) xml/func.xml:2122(literal) xml/func.xml:4927(literal) xml/func.xml:4928(literal) xml/func.xml:5985(firstterm)
msgid "escape"
msgstr ""

#: xml/func.xml:1730(function) xml/func.xml:2871(literal)
msgid "substring( <placeholder-1/>from <placeholder-2/>for <placeholder-3/>)"
msgstr ""

#: xml/func.xml:1740(acronym) xml/func.xml:2384(acronym) xml/func.xml:2413(acronym) xml/func.xml:2466(acronym)
msgid "SQL"
msgstr ""

#: xml/func.xml:1739(entry)
msgid "Extract substring matching <placeholder-1/>regular expression. See <placeholder-2/>"
msgstr ""

#: xml/func.xml:1744(literal)
msgid "substring('Thomas' from '%#\"o_a#\"_' for '#')"
msgstr ""

#: xml/func.xml:1748(literal)
msgid "oma"
msgstr ""

#: xml/func.xml:1754(primary) xml/func.xml:1899(literal) xml/func.xml:2322(literal) xml/func.xml:2795(literal) xml/func.xml:4804(primary) xml/func.xml:4876(literal)
msgid "trim"
msgstr ""

#: xml/func.xml:1758(optional) xml/func.xml:1783(optional)
msgid "leading | trailing | both"
msgstr ""

#: xml/func.xml:1760(parameter) xml/func.xml:1769(parameter) xml/func.xml:1883(parameter) xml/func.xml:1892(parameter) xml/func.xml:2306(parameter) xml/func.xml:2315(parameter) xml/func.xml:2779(parameter) xml/func.xml:2788(parameter)
msgid "characters"
msgstr ""

#: xml/func.xml:1757(function)
msgid "trim( <placeholder-1/><optional><placeholder-2/></optional>from <placeholder-3/>)"
msgstr ""

#: xml/func.xml:1768(entry)
msgid "Remove the longest string containing only the <placeholder-1/>(a space by default) from the start/end/both ends of the <placeholder-2/>"
msgstr ""

#: xml/func.xml:1773(literal)
msgid "trim(both 'x' from 'xTomxx')"
msgstr ""

#: xml/func.xml:1776(literal) xml/func.xml:1800(literal) xml/func.xml:4825(literal)
msgid "Tom"
msgstr ""

#: xml/func.xml:1784(optional) xml/func.xml:2663(parameter) xml/func.xml:2674(parameter) xml/func.xml:2862(parameter) xml/func.xml:2873(parameter) xml/func.xml:2948(parameter) xml/func.xml:2960(parameter) xml/func.xml:2963(parameter) xml/func.xml:2966(parameter)
msgid "from"
msgstr ""

#: xml/func.xml:1787(parameter)
msgid ", characters"
msgstr ""

#: xml/func.xml:1782(function)
msgid "trim( <placeholder-1/><placeholder-2/><placeholder-3/><optional><placeholder-4/></optional>)"
msgstr ""

#: xml/func.xml:1795(function)
msgid "trim()"
msgstr ""

#: xml/func.xml:1794(entry)
msgid "Non-standard version of <placeholder-1/>"
msgstr ""

#: xml/func.xml:1797(literal)
msgid "trim(both from 'xTomxx', 'x')"
msgstr ""

#: xml/func.xml:1806(primary)
msgid "upper"
msgstr ""

#: xml/func.xml:1809(function)
msgid "upper( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1816(entry)
msgid "Convert string to upper case"
msgstr ""

#: xml/func.xml:1818(literal)
msgid "upper('tom')"
msgstr ""

#: xml/func.xml:1821(literal)
msgid "TOM"
msgstr ""

#: xml/func.xml:1827(para)
msgid "Additional string manipulation functions are available and are listed in <xref linkend=\"functions-string-other\">. Some of them are used internally to implement the <acronym>SQL</acronym>-standard string functions listed in <xref linkend=\"functions-string-sql\">.</xref></xref>"
msgstr ""

#: xml/func.xml:1834(title)
msgid "Other String Functions"
msgstr ""

#: xml/func.xml:1849(primary)
msgid "ascii"
msgstr ""

#: xml/func.xml:1852(function)
msgid "ascii( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1860(acronym) xml/func.xml:1865(acronym) xml/func.xml:1919(acronym) xml/func.xml:2901(acronym)
msgid "ASCII"
msgstr ""

#: xml/func.xml:1862(acronym) xml/func.xml:1916(acronym) xml/func.xml:3035(literal) xml/func.xml:3068(literal) xml/func.xml:3090(literal) xml/func.xml:3123(literal) xml/func.xml:3145(literal) xml/func.xml:3178(literal) xml/func.xml:3189(literal) xml/func.xml:3200(literal) xml/func.xml:3211(literal) xml/func.xml:3222(literal) xml/func.xml:3233(literal) xml/func.xml:3244(literal) xml/func.xml:3255(literal) xml/func.xml:3277(literal) xml/func.xml:3299(literal) xml/func.xml:3332(literal) xml/func.xml:3354(literal) xml/func.xml:3387(literal) xml/func.xml:3420(literal) xml/func.xml:3431(literal) xml/func.xml:3442(literal) xml/func.xml:3453(literal) xml/func.xml:3464(literal) xml/func.xml:3497(literal) xml/func.xml:3530(literal) xml/func.xml:3739(literal) xml/func.xml:3750(literal) xml/func.xml:3761(literal) xml/func.xml:3769(literal) xml/func.xml:3780(literal) xml/func.xml:3791(literal) xml/func.xml:3802(literal) xml/func.xml:3813(literal) xml/func.xml:3824(literal) xml/func.xml:3835(literal) xml/func.xml:3846(literal) xml/func.xml:3857(literal) xml/func.xml:3868(literal) xml/func.xml:3879(literal) xml/func.xml:3890(literal) xml/func.xml:3901(literal) xml/func.xml:3912(literal) xml/func.xml:3923(literal) xml/func.xml:3934(literal) xml/func.xml:3945(literal) xml/func.xml:3956(literal) xml/func.xml:3967(literal) xml/func.xml:3978(literal) xml/func.xml:3989(literal) xml/func.xml:4000(literal) xml/func.xml:4011(literal) xml/func.xml:4022(literal) xml/func.xml:4033(literal) xml/func.xml:4044(literal) xml/func.xml:4055(literal) xml/func.xml:4066(literal) xml/func.xml:4077(literal) xml/func.xml:4088(literal) xml/func.xml:4099(literal) xml/func.xml:4110(literal) xml/func.xml:4121(literal) xml/func.xml:4132(literal) xml/func.xml:4143(literal) xml/func.xml:4154(literal) xml/func.xml:4165(literal) xml/func.xml:4176(literal) xml/func.xml:4212(literal) xml/func.xml:4256(literal) xml/func.xml:4278(literal) xml/func.xml:4289(literal) xml/func.xml:4333(literal) xml/func.xml:4355(literal) xml/func.xml:4366(literal) xml/func.xml:4374(literal) xml/func.xml:4388(literal) xml/func.xml:4396(literal)
msgid "UTF8"
msgstr ""

#: xml/func.xml:1859(entry)
msgid "<placeholder-1/>code of the first character of the argument. For <placeholder-2/>returns the Unicode code point of the character. For other multibyte encodings, the argument must be an <placeholder-3/>character."
msgstr ""

#: xml/func.xml:1867(literal)
msgid "ascii('x')"
msgstr ""

#: xml/func.xml:1876(primary) xml/func.xml:4854(primary)
msgid "btrim"
msgstr ""

#: xml/func.xml:1882(optional) xml/func.xml:2272(optional) xml/func.xml:2305(optional) xml/func.xml:2745(optional) xml/func.xml:2778(optional) xml/func.xml:2891(optional)
msgid ", <placeholder-1/><placeholder-2/>"
msgstr ""

#: xml/func.xml:1879(function)
msgid "btrim( <placeholder-1/><placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/func.xml:1890(entry)
msgid "Remove the longest string consisting only of characters in <placeholder-1/>(a space by default) from the start and end of <placeholder-2/>"
msgstr ""

#: xml/func.xml:1896(literal)
msgid "btrim('xyxtrimyyx', 'xy')"
msgstr ""

#: xml/func.xml:1905(primary)
msgid "chr"
msgstr ""

#: xml/func.xml:1908(function)
msgid "chr( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:1915(entry)
msgid "Character with the given code. For <placeholder-1/>the argument is treated as a Unicode code point. For other multibyte encodings the argument must designate an <placeholder-2/>character. The NULL (0) character is not allowed because text data types cannot store such bytes."
msgstr ""

#: xml/func.xml:1923(literal)
msgid "chr(65)"
msgstr ""

#: xml/func.xml:1926(literal)
msgid "A"
msgstr ""

#: xml/func.xml:1932(primary)
msgid "concat"
msgstr ""

#: xml/func.xml:1936(parameter) xml/func.xml:1938(parameter) xml/func.xml:1963(parameter) xml/func.xml:1965(parameter) xml/func.xml:2192(parameter) xml/func.xml:2691(parameter) xml/func.xml:2712(parameter)
msgid "str"
msgstr ""

#: xml/func.xml:1937(type) xml/func.xml:1939(type) xml/func.xml:1964(type) xml/func.xml:1966(type) xml/func.xml:2144(type)
msgid "\"any\""
msgstr ""

#: xml/func.xml:1935(function)
msgid "concat( <placeholder-1/><placeholder-2/>[, <placeholder-3/><placeholder-4/>[, ...] ])"
msgstr ""

#: xml/func.xml:1945(entry)
msgid "Concatenate the text representations of all the arguments. NULL arguments are ignored."
msgstr ""

#: xml/func.xml:1948(literal)
msgid "concat('abcde', 2, NULL, 22)"
msgstr ""

#: xml/func.xml:1951(literal)
msgid "abcde222"
msgstr ""

#: xml/func.xml:1957(primary)
msgid "concat_ws"
msgstr ""

#: xml/func.xml:1961(parameter)
msgid "sep"
msgstr ""

#: xml/func.xml:1960(function)
msgid "concat_ws( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>[, <placeholder-5/><placeholder-6/>[, ...] ])"
msgstr ""

#: xml/func.xml:1972(entry)
msgid "Concatenate all but the first argument with separators. The first argument is used as the separator string. NULL arguments are ignored."
msgstr ""

#: xml/func.xml:1976(literal)
msgid "concat_ws(',', 'abcde', 2, NULL, 22)"
msgstr ""

#: xml/func.xml:1980(literal)
msgid "abcde,2,22"
msgstr ""

#: xml/func.xml:1986(primary)
msgid "convert"
msgstr ""

#: xml/func.xml:1991(type) xml/func.xml:1999(type) xml/func.xml:2027(type) xml/func.xml:2062(type) xml/func.xml:2087(type) xml/func.xml:2109(type) xml/func.xml:2241(type) xml/func.xml:4690(type) xml/func.xml:4741(type) xml/func.xml:4790(type) xml/func.xml:4814(type) xml/func.xml:4859(type) xml/func.xml:4861(type) xml/func.xml:4865(type) xml/func.xml:4893(type) xml/func.xml:4915(type) xml/func.xml:5052(type) xml/func.xml:5076(type)
msgid "bytea"
msgstr ""

#: xml/func.xml:1992(parameter) xml/func.xml:2004(parameter) xml/func.xml:2028(parameter) xml/func.xml:2037(parameter)
msgid "src_encoding"
msgstr ""

#: xml/func.xml:1993(type) xml/func.xml:1995(type) xml/func.xml:2029(type) xml/func.xml:2058(type) xml/func.xml:2243(type) xml/func.xml:2358(type)
msgid "name"
msgstr ""

#: xml/func.xml:1994(parameter) xml/func.xml:2002(parameter) xml/func.xml:2057(parameter) xml/func.xml:2065(parameter)
msgid "dest_encoding"
msgstr ""

#: xml/func.xml:1989(function)
msgid "convert( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>)"
msgstr ""

#: xml/func.xml:2007(command)
msgid "CREATE CONVERSION"
msgstr ""

#: xml/func.xml:2009(xref)
msgid "for available conversions."
msgstr ""

#: xml/func.xml:2001(entry)
msgid "Convert string to <placeholder-1/>. The original encoding is specified by <placeholder-2/>. The <placeholder-3/>must be valid in this encoding. Conversions can be defined by <placeholder-4/>. Also there are some predefined conversions. See <placeholder-5/>"
msgstr ""

#: xml/func.xml:2012(literal)
msgid "convert('text_in_utf8', 'UTF8', 'LATIN1')"
msgstr ""

#: xml/func.xml:2016(literal) xml/func.xml:2045(literal)
msgid "text_in_utf8"
msgstr ""

#: xml/func.xml:2015(entry)
msgid "<placeholder-1/>represented in Latin-1 encoding (ISO 8859-1)"
msgstr ""

#: xml/func.xml:2022(primary)
msgid "convert_from"
msgstr ""

#: xml/func.xml:2025(function)
msgid "convert_from( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2035(entry)
msgid "Convert string to the database encoding. The original encoding is specified by <placeholder-1/>. The <placeholder-2/>must be valid in this encoding."
msgstr ""

#: xml/func.xml:2041(literal)
msgid "convert_from('text_in_utf8', 'UTF8')"
msgstr ""

#: xml/func.xml:2044(entry)
msgid "<placeholder-1/>represented in the current database encoding"
msgstr ""

#: xml/func.xml:2051(primary)
msgid "convert_to"
msgstr ""

#: xml/func.xml:2054(function)
msgid "convert_to( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2064(entry)
msgid "Convert string to <placeholder-1/>."
msgstr ""

#: xml/func.xml:2067(literal)
msgid "convert_to('some text', 'UTF8')"
msgstr ""

#: xml/func.xml:2070(literal)
msgid "some text"
msgstr ""

#: xml/func.xml:2069(entry)
msgid "<placeholder-1/>represented in the UTF8 encoding"
msgstr ""

#: xml/func.xml:2076(primary) xml/func.xml:4882(primary)
msgid "decode"
msgstr ""

#: xml/func.xml:2082(parameter) xml/func.xml:2092(parameter) xml/func.xml:2110(parameter) xml/func.xml:2137(primary) xml/func.xml:2140(function) xml/func.xml:4429(function) xml/func.xml:4432(primary) xml/func.xml:4888(parameter) xml/func.xml:4898(parameter) xml/func.xml:4916(parameter)
msgid "format"
msgstr ""

#: xml/func.xml:2079(function) xml/func.xml:4885(function)
msgid "decode( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2093(function) xml/func.xml:2104(primary) xml/func.xml:4899(function) xml/func.xml:4910(primary)
msgid "encode"
msgstr ""

#: xml/func.xml:2089(entry) xml/func.xml:4895(entry)
msgid "Decode binary data from textual representation in <placeholder-1/>. Options for <placeholder-2/>are same as in <placeholder-3/>."
msgstr ""

#: xml/func.xml:2095(literal)
msgid "decode('MTIzAAE=', 'base64')"
msgstr ""

#: xml/func.xml:2098(literal)
msgid "\\x3132330001"
msgstr ""

#: xml/func.xml:2108(parameter) xml/func.xml:4914(parameter)
msgid "data"
msgstr ""

#: xml/func.xml:2107(function) xml/func.xml:4913(function)
msgid "encode( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2119(literal) xml/func.xml:4925(literal)
msgid "base64"
msgstr ""

#: xml/func.xml:2120(literal) xml/func.xml:4926(literal)
msgid "hex"
msgstr ""

#: xml/func.xml:2124(literal) xml/func.xml:4930(literal) xml/func.xml:5967(literal) xml/func.xml:5979(literal) xml/func.xml:6435(literal) xml/func.xml:6537(literal) xml/func.xml:6550(literal) xml/func.xml:6737(literal) xml/func.xml:6748(literal)
msgid "\\"
msgstr ""

#: xml/func.xml:2125(replaceable) xml/func.xml:4931(replaceable)
msgid "nnn"
msgstr ""

#: xml/func.xml:2117(entry) xml/func.xml:4923(entry)
msgid "Encode binary data into a textual representation. Supported formats are: <placeholder-1/>, <placeholder-2/>, <placeholder-3/>. <placeholder-4/>converts zero bytes and high-bit-set bytes to octal sequences ( <placeholder-5/><placeholder-6/>) and doubles backslashes."
msgstr ""

#: xml/func.xml:2128(literal)
msgid "encode(E'123\\\\000\\\\001', 'base64')"
msgstr ""

#: xml/func.xml:2131(literal)
msgid "MTIzAAE="
msgstr ""

#: xml/func.xml:2141(parameter)
msgid "formatstr"
msgstr ""

#: xml/func.xml:2143(parameter)
msgid "formatarg"
msgstr ""

#: xml/func.xml:2139(literal)
msgid "<placeholder-1/>( <placeholder-2/><placeholder-3/>[, <placeholder-4/><placeholder-5/>[, ...] ])"
msgstr ""

#: xml/func.xml:2151(function)
msgid "sprintf"
msgstr ""

#: xml/func.xml:2152(xref) xml/func.xml:2388(xref) xml/func.xml:2420(xref) xml/func.xml:2470(xref) xml/func.xml:5948(literal) xml/func.xml:8121(literal) xml/func.xml:8645(xref)
msgid "."
msgstr ""

#: xml/func.xml:2149(entry)
msgid "Format arguments according to a format string. This function is similar to the C function <placeholder-1/>. See <placeholder-2/>"
msgstr ""

#: xml/func.xml:2155(literal)
msgid "format('Hello %s, %1$s', 'World')"
msgstr ""

#: xml/func.xml:2158(literal)
msgid "Hello World, World"
msgstr ""

#: xml/func.xml:2164(primary)
msgid "initcap"
msgstr ""

#: xml/func.xml:2167(function)
msgid "initcap( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:2174(entry)
msgid "Convert the first letter of each word to upper case and the rest to lower case. Words are sequences of alphanumeric characters separated by non-alphanumeric characters."
msgstr ""

#: xml/func.xml:2179(literal)
msgid "initcap('hi THOMAS')"
msgstr ""

#: xml/func.xml:2182(literal)
msgid "Hi Thomas"
msgstr ""

#: xml/func.xml:2188(primary)
msgid "left"
msgstr ""

#: xml/func.xml:2194(parameter) xml/func.xml:2202(replaceable) xml/func.xml:2204(replaceable) xml/func.xml:2206(replaceable) xml/func.xml:2714(parameter) xml/func.xml:2722(replaceable) xml/func.xml:2724(replaceable) xml/func.xml:2726(replaceable) xml/func.xml:6078(replaceable) xml/func.xml:6083(replaceable) xml/func.xml:6086(replaceable) xml/func.xml:6136(replaceable) xml/func.xml:6143(replaceable) xml/func.xml:6854(literal) xml/func.xml:6858(literal)
msgid "n"
msgstr ""

#: xml/func.xml:2191(function)
msgid "left( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2201(entry)
msgid "Return first <placeholder-1/>characters in the string. When <placeholder-2/>is negative, return all but last | <placeholder-3/>| characters."
msgstr ""

#: xml/func.xml:2208(literal)
msgid "left('abcde', 2)"
msgstr ""

#: xml/func.xml:2211(literal)
msgid "ab"
msgstr ""

#: xml/func.xml:2220(function) xml/func.xml:4991(function)
msgid "length( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:2227(entry)
msgid "Number of characters in <placeholder-1/>"
msgstr ""

#: xml/func.xml:2230(literal)
msgid "length('jose')"
msgstr ""

#: xml/func.xml:2242(parameter) xml/func.xml:2251(parameter) xml/func.xml:2892(parameter)
msgid "encoding"
msgstr ""

#: xml/func.xml:2239(function)
msgid "length( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2249(entry)
msgid "Number of characters in <placeholder-1/>in the given <placeholder-2/>. The <placeholder-3/>must be valid in this encoding."
msgstr ""

#: xml/func.xml:2255(literal)
msgid "length('jose', 'UTF8')"
msgstr ""

#: xml/func.xml:2264(primary)
msgid "lpad"
msgstr ""

#: xml/func.xml:2273(parameter) xml/func.xml:2284(parameter) xml/func.xml:2746(parameter) xml/func.xml:2757(parameter)
msgid "fill"
msgstr ""

#: xml/func.xml:2267(function)
msgid "lpad( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/><placeholder-5/>)"
msgstr ""

#: xml/func.xml:2280(entry)
msgid "Fill up the <placeholder-1/>to length <placeholder-2/>by prepending the characters <placeholder-3/>(a space by default). If the <placeholder-4/>is already longer than <placeholder-5/>then it is truncated (on the right)."
msgstr ""

#: xml/func.xml:2290(literal)
msgid "lpad('hi', 5, 'xy')"
msgstr ""

#: xml/func.xml:2293(literal)
msgid "xyxhi"
msgstr ""

#: xml/func.xml:2299(primary)
msgid "ltrim"
msgstr ""

#: xml/func.xml:2302(function)
msgid "ltrim( <placeholder-1/><placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/func.xml:2313(entry)
msgid "Remove the longest string containing only characters from <placeholder-1/>(a space by default) from the start of <placeholder-2/>"
msgstr ""

#: xml/func.xml:2319(literal)
msgid "ltrim('zzzytrim', 'xyz')"
msgstr ""

#: xml/func.xml:2328(primary) xml/func.xml:5019(primary)
msgid "md5"
msgstr ""

#: xml/func.xml:2331(function) xml/func.xml:5022(function)
msgid "md5( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:2338(entry) xml/func.xml:5029(entry)
msgid "Calculates the MD5 hash of <placeholder-1/>, returning the result in hexadecimal"
msgstr ""

#: xml/func.xml:2342(literal)
msgid "md5('abc')"
msgstr ""

#: xml/func.xml:2345(literal)
msgid "900150983cd24fb0 d6963f7d28e17f72"
msgstr ""

#: xml/func.xml:2351(primary)
msgid "pg_client_encoding"
msgstr ""

#: xml/func.xml:2354(function) xml/func.xml:2362(literal)
msgid "pg_client_encoding()"
msgstr ""

#: xml/func.xml:2360(entry)
msgid "Current client encoding name"
msgstr ""

#: xml/func.xml:2365(literal) xml/func.xml:3021(literal) xml/func.xml:3032(literal) xml/func.xml:3541(literal) xml/func.xml:3772(literal)
msgid "SQL_ASCII"
msgstr ""

#: xml/func.xml:2371(primary)
msgid "quote_ident"
msgstr ""

#: xml/func.xml:2374(function)
msgid "quote_ident( <placeholder-1/><placeholder-2/>)"
msgstr ""

#: xml/func.xml:2382(entry)
msgid "Return the given string suitably quoted to be used as an identifier in an <placeholder-1/>statement string. Quotes are added only if necessary (i.e., if the string contains non-identifier characters or would be case-folded). Embedded quotes are properly doubled. See also <placeholder-2/>"
msgstr ""

#: xml/func.xml:2391(literal)
msgid "quote_ident('Foo bar')"
msgstr ""

#: xml/func.xml:2394(literal)
msgid "\"Foo bar\""
msgstr ""

#: xml/func.xml:2400(primary) xml/func.xml:2416(function)
msgid "quote_literal"
msgstr ""

#: xml/func.xml:2403(function) xml/func.xml:2432(function)
msgid "quote_literal( <placeholder-1/><placeholder-2/>)"
msgstr ""

#: xml/func.xml:2418(function) xml/func.xml:2453(primary)
msgid "quote_nullable"
msgstr ""

#: xml/func.xml:2411(entry)
msgid "Return the given string suitably quoted to be used as a string literal in an <placeholder-1/>statement string. Embedded single-quotes and backslashes are properly doubled. Note that <placeholder-2/>returns null on null input; if the argument might be null, <placeholder-3/>is often more suitable. See also <placeholder-4/>"
msgstr ""

#: xml/func.xml:2423(literal)
msgid "quote_literal(E'O\\'Reilly')"
msgstr ""

#: xml/func.xml:2426(literal)
msgid "'O''Reilly'"
msgstr ""

#: xml/func.xml:2433(parameter) xml/func.xml:2483(parameter)
msgid "value"
msgstr ""

#: xml/func.xml:2440(entry)
msgid "Coerce the given value to text and then quote it as a literal. Embedded single-quotes and backslashes are properly doubled."
msgstr ""

#: xml/func.xml:2444(literal)
msgid "quote_literal(42.5)"
msgstr ""

#: xml/func.xml:2447(literal) xml/func.xml:2498(literal)
msgid "'42.5'"
msgstr ""

#: xml/func.xml:2456(function) xml/func.xml:2482(function)
msgid "quote_nullable( <placeholder-1/><placeholder-2/>)"
msgstr ""

#: xml/func.xml:2468(literal) xml/func.xml:2476(literal) xml/func.xml:2492(literal)
msgid "NULL"
msgstr ""

#: xml/func.xml:2464(entry)
msgid "Return the given string suitably quoted to be used as a string literal in an <placeholder-1/>statement string; or, if the argument is null, return <placeholder-2/>. Embedded single-quotes and backslashes are properly doubled. See also <placeholder-3/>"
msgstr ""

#: xml/func.xml:2473(literal)
msgid "quote_nullable(NULL)"
msgstr ""

#: xml/func.xml:2490(entry)
msgid "Coerce the given value to text and then quote it as a literal; or, if the argument is null, return <placeholder-1/>. Embedded single-quotes and backslashes are properly doubled."
msgstr ""

#: xml/func.xml:2495(literal)
msgid "quote_nullable(42.5)"
msgstr ""

#: xml/func.xml:2504(primary) xml/func.xml:5567(primary)
msgid "regexp_matches"
msgstr ""

#: xml/func.xml:2512(parameter) xml/func.xml:2545(parameter) xml/func.xml:2575(parameter) xml/func.xml:2606(parameter)
msgid "flags"
msgstr ""

#: xml/func.xml:2507(function)
msgid "regexp_matches( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>[, <placeholder-5/><placeholder-6/>])"
msgstr ""

#: xml/func.xml:2517(type)
msgid "setof text[]"
msgstr ""

#: xml/func.xml:2522(xref) xml/func.xml:2554(xref) xml/func.xml:2585(xref) xml/func.xml:2616(xref)
msgid "for more information."
msgstr ""

#: xml/func.xml:2519(entry)
msgid "Return all captured substrings resulting from matching a POSIX regular expression against the <placeholder-1/>. See <placeholder-2/>"
msgstr ""

#: xml/func.xml:2525(literal)
msgid "regexp_matches('foobarbequebaz', '(bar)(beque)')"
msgstr ""

#: xml/func.xml:2529(literal)
msgid "{bar,beque}"
msgstr ""

#: xml/func.xml:2535(primary) xml/func.xml:5564(primary)
msgid "regexp_replace"
msgstr ""

#: xml/func.xml:2543(parameter)
msgid "replacement"
msgstr ""

#: xml/func.xml:2538(function)
msgid "regexp_replace( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>[, <placeholder-7/><placeholder-8/>])"
msgstr ""

#: xml/func.xml:2552(entry)
msgid "Replace substring(s) matching a POSIX regular expression. See <placeholder-1/>"
msgstr ""

#: xml/func.xml:2557(literal)
msgid "regexp_replace('Thomas', '.[mN]a.', 'M')"
msgstr ""

#: xml/func.xml:2561(literal)
msgid "ThM"
msgstr ""

#: xml/func.xml:2567(primary) xml/func.xml:5573(primary)
msgid "regexp_split_to_array"
msgstr ""

#: xml/func.xml:2570(function)
msgid "regexp_split_to_array( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>[, <placeholder-5/><placeholder-6/>])"
msgstr ""

#: xml/func.xml:2580(type)
msgid "text[]"
msgstr ""

#: xml/func.xml:2582(entry) xml/func.xml:2613(entry)
msgid "Split <placeholder-1/>using a POSIX regular expression as the delimiter. See <placeholder-2/>"
msgstr ""

#: xml/func.xml:2588(literal)
msgid "regexp_split_to_array('hello world', E'\\\\s+')"
msgstr ""

#: xml/func.xml:2592(literal)
msgid "{hello,world}"
msgstr ""

#: xml/func.xml:2598(primary) xml/func.xml:5570(primary)
msgid "regexp_split_to_table"
msgstr ""

#: xml/func.xml:2601(function)
msgid "regexp_split_to_table( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>[, <placeholder-5/><placeholder-6/>])"
msgstr ""

#: xml/func.xml:2611(type)
msgid "setof text"
msgstr ""

#: xml/func.xml:2619(literal)
msgid "regexp_split_to_table('hello world', E'\\\\s+')"
msgstr ""

#: xml/func.xml:2623(literal)
msgid "hello"
msgstr ""

#: xml/func.xml:2625(literal)
msgid "world"
msgstr ""

#: xml/func.xml:2622(entry)
msgid "<placeholder-1/><placeholder-2/>(2 rows)"
msgstr ""

#: xml/func.xml:2631(primary)
msgid "repeat"
msgstr ""

#: xml/func.xml:2637(parameter) xml/func.xml:2646(parameter) xml/func.xml:2921(parameter) xml/func.xml:2930(parameter)
msgid "number"
msgstr ""

#: xml/func.xml:2634(function)
msgid "repeat( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2644(entry)
msgid "Repeat <placeholder-1/>the specified <placeholder-2/>of times"
msgstr ""

#: xml/func.xml:2648(literal)
msgid "repeat('Pg', 4)"
msgstr ""

#: xml/func.xml:2651(literal)
msgid "PgPgPgPg"
msgstr ""

#: xml/func.xml:2657(primary)
msgid "replace"
msgstr ""

#: xml/func.xml:2665(parameter) xml/func.xml:2675(parameter) xml/func.xml:2950(parameter) xml/func.xml:2962(parameter) xml/func.xml:2964(parameter)
msgid "to"
msgstr ""

#: xml/func.xml:2660(function)
msgid "replace( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>)"
msgstr ""

#: xml/func.xml:2672(entry)
msgid "Replace all occurrences in <placeholder-1/>of substring <placeholder-2/>with substring <placeholder-3/>"
msgstr ""

#: xml/func.xml:2677(literal)
msgid "replace('abcdefabcdef', 'cd', 'XX')"
msgstr ""

#: xml/func.xml:2681(literal)
msgid "abXXefabXXef"
msgstr ""

#: xml/func.xml:2687(primary)
msgid "reverse"
msgstr ""

#: xml/func.xml:2690(function)
msgid "reverse( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:2697(entry)
msgid "Return reversed string."
msgstr ""

#: xml/func.xml:2699(literal)
msgid "reverse('abcde')"
msgstr ""

#: xml/func.xml:2702(literal)
msgid "edcba"
msgstr ""

#: xml/func.xml:2708(primary)
msgid "right"
msgstr ""

#: xml/func.xml:2711(function)
msgid "right( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:2721(entry)
msgid "Return last <placeholder-1/>characters in the string. When <placeholder-2/>is negative, return all but first | <placeholder-3/>| characters."
msgstr ""

#: xml/func.xml:2728(literal)
msgid "right('abcde', 2)"
msgstr ""

#: xml/func.xml:2731(literal)
msgid "de"
msgstr ""

#: xml/func.xml:2737(primary)
msgid "rpad"
msgstr ""

#: xml/func.xml:2740(function)
msgid "rpad( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/><placeholder-5/>)"
msgstr ""

#: xml/func.xml:2753(entry)
msgid "Fill up the <placeholder-1/>to length <placeholder-2/>by appending the characters <placeholder-3/>(a space by default). If the <placeholder-4/>is already longer than <placeholder-5/>then it is truncated."
msgstr ""

#: xml/func.xml:2763(literal)
msgid "rpad('hi', 5, 'xy')"
msgstr ""

#: xml/func.xml:2766(literal)
msgid "hixyx"
msgstr ""

#: xml/func.xml:2772(primary)
msgid "rtrim"
msgstr ""

#: xml/func.xml:2775(function)
msgid "rtrim( <placeholder-1/><placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/func.xml:2786(entry)
msgid "Remove the longest string containing only characters from <placeholder-1/>(a space by default) from the end of <placeholder-2/>"
msgstr ""

#: xml/func.xml:2792(literal)
msgid "rtrim('trimxxxx', 'x')"
msgstr ""

#: xml/func.xml:2801(primary)
msgid "split_part"
msgstr ""

#: xml/func.xml:2807(parameter) xml/func.xml:2818(parameter)
msgid "delimiter"
msgstr ""

#: xml/func.xml:2809(parameter) xml/func.xml:9128(parameter) xml/func.xml:9149(parameter) xml/func.xml:9709(replaceable)
msgid "field"
msgstr ""

#: xml/func.xml:2804(function)
msgid "split_part( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>)"
msgstr ""

#: xml/func.xml:2816(entry)
msgid "Split <placeholder-1/>on <placeholder-2/>and return the given field (counting from one)"
msgstr ""

#: xml/func.xml:2821(literal)
msgid "split_part('abc~@~def~@~ghi', '~@~', 2)"
msgstr ""

#: xml/func.xml:2825(literal)
msgid "def"
msgstr ""

#: xml/func.xml:2831(primary)
msgid "strpos"
msgstr ""

#: xml/func.xml:2834(function)
msgid "strpos( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:2842(entry)
msgid "Location of specified substring (same as <placeholder-1/>, but note the reversed argument order)"
msgstr ""

#: xml/func.xml:2848(literal)
msgid "strpos('high', 'ig')"
msgstr ""

#: xml/func.xml:2857(primary)
msgid "substr"
msgstr ""

#: xml/func.xml:2863(optional)
msgid ", <placeholder-1/>"
msgstr ""

#: xml/func.xml:2860(function)
msgid "substr( <placeholder-1/>, <placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/func.xml:2870(entry)
msgid "Extract substring (same as <placeholder-1/>)"
msgstr ""

#: xml/func.xml:2876(literal)
msgid "substr('alphabet', 3, 2)"
msgstr ""

#: xml/func.xml:2879(literal)
msgid "ph"
msgstr ""

#: xml/func.xml:2885(primary)
msgid "to_ascii"
msgstr ""

#: xml/func.xml:2888(function)
msgid "to_ascii( <placeholder-1/><placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/func.xml:2903(literal) xml/func.xml:3263(literal) xml/func.xml:3274(literal) xml/func.xml:3607(literal) xml/func.xml:3860(literal)
msgid "LATIN1"
msgstr ""

#: xml/func.xml:2904(literal) xml/func.xml:3285(literal) xml/func.xml:3296(literal) xml/func.xml:3307(literal) xml/func.xml:3618(literal) xml/func.xml:3926(literal) xml/func.xml:4190(literal)
msgid "LATIN2"
msgstr ""

#: xml/func.xml:2905(literal) xml/func.xml:3241(literal) xml/func.xml:3904(literal)
msgid "LATIN9"
msgstr ""

#: xml/func.xml:2906(literal) xml/func.xml:3310(literal) xml/func.xml:3684(literal) xml/func.xml:4080(literal) xml/func.xml:4187(literal) xml/func.xml:4198(literal) xml/func.xml:4209(literal)
msgid "WIN1250"
msgstr ""

#: xml/func.xml:2899(entry)
msgid "Convert <placeholder-1/>to <placeholder-2/>from another encoding (only supports conversion from <placeholder-3/>, <placeholder-4/>, <placeholder-5/>, and <placeholder-6/>encodings)"
msgstr ""

#: xml/func.xml:2908(literal)
msgid "to_ascii('Karel')"
msgstr ""

#: xml/func.xml:2911(literal)
msgid "Karel"
msgstr ""

#: xml/func.xml:2917(primary)
msgid "to_hex"
msgstr ""

#: xml/func.xml:2923(type)
msgid "bigint"
msgstr ""

#: xml/func.xml:2920(function)
msgid "to_hex( <placeholder-1/><placeholder-2/>or <placeholder-3/>)"
msgstr ""

#: xml/func.xml:2929(entry)
msgid "Convert <placeholder-1/>to its equivalent hexadecimal representation"
msgstr ""

#: xml/func.xml:2933(literal)
msgid "to_hex(2147483647)"
msgstr ""

#: xml/func.xml:2936(literal)
msgid "7fffffff"
msgstr ""

#: xml/func.xml:2942(primary)
msgid "translate"
msgstr ""

#: xml/func.xml:2945(function)
msgid "translate( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>)"
msgstr ""

#: xml/func.xml:2957(entry)
msgid "Any character in <placeholder-1/>that matches a character in the <placeholder-2/>set is replaced by the corresponding character in the <placeholder-3/>set. If <placeholder-4/>is longer than <placeholder-5/>, occurrences of the extra characters in <placeholder-6/>are removed."
msgstr ""

#: xml/func.xml:2968(literal)
msgid "translate('12345', '143', 'ax')"
msgstr ""

#: xml/func.xml:2971(literal)
msgid "a2x5"
msgstr ""

#: xml/func.xml:2977(para)
msgid "The <function>concat</function>, <function>concat_ws</function>and <function>format</function>functions are variadic, so it is possible to pass the values to be concatenated or formatted as an array marked with the <literal>VARIADIC</literal>keyword (see <xref linkend=\"xfunc-sql-variadic-functions\">). The array's elements are treated as if they were separate ordinary arguments to the function. If the variadic array argument is NULL, <function>concat</function>and <function>concat_ws</function>return NULL, but <function>format</function>treats a NULL as a zero-element array.</xref>"
msgstr ""

#: xml/func.xml:2992(para)
msgid "See also the aggregate function <function>string_agg</function>in <xref linkend=\"functions-aggregate\">.</xref>"
msgstr ""

#: xml/func.xml:2996(title)
msgid "Built-in Conversions"
msgstr ""

#: xml/func.xml:3002(para)
msgid "The conversion names follow a standard naming scheme: The official name of the source encoding with all non-alphanumeric characters replaced by underscores, followed by <literal>_to_</literal>, followed by the similarly processed destination encoding name. Therefore, the names might deviate from the customary encoding names."
msgstr ""

#: xml/func.xml:3000(entry)
msgid "Conversion Name <placeholder-1/>"
msgstr ""

#: xml/func.xml:3011(entry)
msgid "Source Encoding"
msgstr ""

#: xml/func.xml:3012(entry)
msgid "Destination Encoding"
msgstr ""

#: xml/func.xml:3018(literal)
msgid "ascii_to_mic"
msgstr ""

#: xml/func.xml:3024(literal) xml/func.xml:3057(literal) xml/func.xml:3079(literal) xml/func.xml:3101(literal) xml/func.xml:3134(literal) xml/func.xml:3167(literal) xml/func.xml:3266(literal) xml/func.xml:3288(literal) xml/func.xml:3321(literal) xml/func.xml:3343(literal) xml/func.xml:3376(literal) xml/func.xml:3486(literal) xml/func.xml:3538(literal) xml/func.xml:3549(literal) xml/func.xml:3560(literal) xml/func.xml:3571(literal) xml/func.xml:3582(literal) xml/func.xml:3593(literal) xml/func.xml:3604(literal) xml/func.xml:3615(literal) xml/func.xml:3626(literal) xml/func.xml:3637(literal) xml/func.xml:3648(literal) xml/func.xml:3659(literal) xml/func.xml:3670(literal) xml/func.xml:3681(literal) xml/func.xml:3692(literal) xml/func.xml:3703(literal) xml/func.xml:3728(literal) xml/func.xml:4201(literal) xml/func.xml:4245(literal) xml/func.xml:4322(literal)
msgid "MULE_INTERNAL"
msgstr ""

#: xml/func.xml:3029(literal)
msgid "ascii_to_utf8"
msgstr ""

#: xml/func.xml:3040(literal)
msgid "big5_to_euc_tw"
msgstr ""

#: xml/func.xml:3043(literal) xml/func.xml:3054(literal) xml/func.xml:3065(literal) xml/func.xml:3156(literal) xml/func.xml:3552(literal) xml/func.xml:3783(literal)
msgid "BIG5"
msgstr ""

#: xml/func.xml:3046(literal) xml/func.xml:3153(literal) xml/func.xml:3164(literal) xml/func.xml:3175(literal) xml/func.xml:3596(literal) xml/func.xml:3827(literal)
msgid "EUC_TW"
msgstr ""

#: xml/func.xml:3051(literal)
msgid "big5_to_mic"
msgstr ""

#: xml/func.xml:3062(literal)
msgid "big5_to_utf8"
msgstr ""

#: xml/func.xml:3073(literal)
msgid "euc_cn_to_mic"
msgstr ""

#: xml/func.xml:3076(literal) xml/func.xml:3087(literal) xml/func.xml:3563(literal) xml/func.xml:3794(literal)
msgid "EUC_CN"
msgstr ""

#: xml/func.xml:3084(literal)
msgid "euc_cn_to_utf8"
msgstr ""

#: xml/func.xml:3095(literal)
msgid "euc_jp_to_mic"
msgstr ""

#: xml/func.xml:3098(literal) xml/func.xml:3109(literal) xml/func.xml:3120(literal) xml/func.xml:3574(literal) xml/func.xml:3717(literal) xml/func.xml:3805(literal)
msgid "EUC_JP"
msgstr ""

#: xml/func.xml:3106(literal)
msgid "euc_jp_to_sjis"
msgstr ""

#: xml/func.xml:3112(literal) xml/func.xml:3673(literal) xml/func.xml:3714(literal) xml/func.xml:3725(literal) xml/func.xml:3736(literal) xml/func.xml:4047(literal)
msgid "SJIS"
msgstr ""

#: xml/func.xml:3117(literal)
msgid "euc_jp_to_utf8"
msgstr ""

#: xml/func.xml:3128(literal)
msgid "euc_kr_to_mic"
msgstr ""

#: xml/func.xml:3131(literal) xml/func.xml:3142(literal) xml/func.xml:3585(literal) xml/func.xml:3816(literal)
msgid "EUC_KR"
msgstr ""

#: xml/func.xml:3139(literal)
msgid "euc_kr_to_utf8"
msgstr ""

#: xml/func.xml:3150(literal)
msgid "euc_tw_to_big5"
msgstr ""

#: xml/func.xml:3161(literal)
msgid "euc_tw_to_mic"
msgstr ""

#: xml/func.xml:3172(literal)
msgid "euc_tw_to_utf8"
msgstr ""

#: xml/func.xml:3183(literal)
msgid "gb18030_to_utf8"
msgstr ""

#: xml/func.xml:3186(literal) xml/func.xml:3838(literal)
msgid "GB18030"
msgstr ""

#: xml/func.xml:3194(literal)
msgid "gbk_to_utf8"
msgstr ""

#: xml/func.xml:3197(literal) xml/func.xml:3849(literal)
msgid "GBK"
msgstr ""

#: xml/func.xml:3205(literal)
msgid "iso_8859_10_to_utf8"
msgstr ""

#: xml/func.xml:3208(literal) xml/func.xml:3871(literal)
msgid "LATIN6"
msgstr ""

#: xml/func.xml:3216(literal)
msgid "iso_8859_13_to_utf8"
msgstr ""

#: xml/func.xml:3219(literal) xml/func.xml:3882(literal)
msgid "LATIN7"
msgstr ""

#: xml/func.xml:3227(literal)
msgid "iso_8859_14_to_utf8"
msgstr ""

#: xml/func.xml:3230(literal) xml/func.xml:3893(literal)
msgid "LATIN8"
msgstr ""

#: xml/func.xml:3238(literal)
msgid "iso_8859_15_to_utf8"
msgstr ""

#: xml/func.xml:3249(literal)
msgid "iso_8859_16_to_utf8"
msgstr ""

#: xml/func.xml:3252(literal) xml/func.xml:3915(literal)
msgid "LATIN10"
msgstr ""

#: xml/func.xml:3260(literal)
msgid "iso_8859_1_to_mic"
msgstr ""

#: xml/func.xml:3271(literal)
msgid "iso_8859_1_to_utf8"
msgstr ""

#: xml/func.xml:3282(literal)
msgid "iso_8859_2_to_mic"
msgstr ""

#: xml/func.xml:3293(literal)
msgid "iso_8859_2_to_utf8"
msgstr ""

#: xml/func.xml:3304(literal)
msgid "iso_8859_2_to_windows_1250"
msgstr ""

#: xml/func.xml:3315(literal)
msgid "iso_8859_3_to_mic"
msgstr ""

#: xml/func.xml:3318(literal) xml/func.xml:3329(literal) xml/func.xml:3629(literal) xml/func.xml:3937(literal)
msgid "LATIN3"
msgstr ""

#: xml/func.xml:3326(literal)
msgid "iso_8859_3_to_utf8"
msgstr ""

#: xml/func.xml:3337(literal)
msgid "iso_8859_4_to_mic"
msgstr ""

#: xml/func.xml:3340(literal) xml/func.xml:3351(literal) xml/func.xml:3640(literal) xml/func.xml:3948(literal)
msgid "LATIN4"
msgstr ""

#: xml/func.xml:3348(literal)
msgid "iso_8859_4_to_utf8"
msgstr ""

#: xml/func.xml:3359(literal)
msgid "iso_8859_5_to_koi8_r"
msgstr ""

#: xml/func.xml:3362(literal) xml/func.xml:3373(literal) xml/func.xml:3384(literal) xml/func.xml:3395(literal) xml/func.xml:3406(literal) xml/func.xml:3475(literal) xml/func.xml:3651(literal) xml/func.xml:3959(literal) xml/func.xml:4223(literal) xml/func.xml:4300(literal)
msgid "ISO_8859_5"
msgstr ""

#: xml/func.xml:3365(literal) xml/func.xml:3472(literal) xml/func.xml:3483(literal) xml/func.xml:3494(literal) xml/func.xml:3505(literal) xml/func.xml:3516(literal) xml/func.xml:3662(literal) xml/func.xml:4025(literal) xml/func.xml:4234(literal) xml/func.xml:4311(literal)
msgid "KOI8R"
msgstr ""

#: xml/func.xml:3370(literal)
msgid "iso_8859_5_to_mic"
msgstr ""

#: xml/func.xml:3381(literal)
msgid "iso_8859_5_to_utf8"
msgstr ""

#: xml/func.xml:3392(literal)
msgid "iso_8859_5_to_windows_1251"
msgstr ""

#: xml/func.xml:3398(literal) xml/func.xml:3508(literal) xml/func.xml:3695(literal) xml/func.xml:4091(literal) xml/func.xml:4220(literal) xml/func.xml:4231(literal) xml/func.xml:4242(literal) xml/func.xml:4253(literal) xml/func.xml:4264(literal)
msgid "WIN1251"
msgstr ""

#: xml/func.xml:3403(literal)
msgid "iso_8859_5_to_windows_866"
msgstr ""

#: xml/func.xml:3409(literal) xml/func.xml:3519(literal) xml/func.xml:3706(literal) xml/func.xml:4168(literal) xml/func.xml:4267(literal) xml/func.xml:4297(literal) xml/func.xml:4308(literal) xml/func.xml:4319(literal) xml/func.xml:4330(literal) xml/func.xml:4341(literal)
msgid "WIN866"
msgstr ""

#: xml/func.xml:3414(literal)
msgid "iso_8859_6_to_utf8"
msgstr ""

#: xml/func.xml:3417(literal) xml/func.xml:3970(literal)
msgid "ISO_8859_6"
msgstr ""

#: xml/func.xml:3425(literal)
msgid "iso_8859_7_to_utf8"
msgstr ""

#: xml/func.xml:3428(literal) xml/func.xml:3981(literal)
msgid "ISO_8859_7"
msgstr ""

#: xml/func.xml:3436(literal)
msgid "iso_8859_8_to_utf8"
msgstr ""

#: xml/func.xml:3439(literal) xml/func.xml:3992(literal)
msgid "ISO_8859_8"
msgstr ""

#: xml/func.xml:3447(literal)
msgid "iso_8859_9_to_utf8"
msgstr ""

#: xml/func.xml:3450(literal) xml/func.xml:4003(literal)
msgid "LATIN5"
msgstr ""

#: xml/func.xml:3458(literal)
msgid "johab_to_utf8"
msgstr ""

#: xml/func.xml:3461(literal) xml/func.xml:4014(literal)
msgid "JOHAB"
msgstr ""

#: xml/func.xml:3469(literal)
msgid "koi8_r_to_iso_8859_5"
msgstr ""

#: xml/func.xml:3480(literal)
msgid "koi8_r_to_mic"
msgstr ""

#: xml/func.xml:3491(literal)
msgid "koi8_r_to_utf8"
msgstr ""

#: xml/func.xml:3502(literal)
msgid "koi8_r_to_windows_1251"
msgstr ""

#: xml/func.xml:3513(literal)
msgid "koi8_r_to_windows_866"
msgstr ""

#: xml/func.xml:3524(literal)
msgid "koi8_u_to_utf8"
msgstr ""

#: xml/func.xml:3527(literal) xml/func.xml:4036(literal)
msgid "KOI8U"
msgstr ""

#: xml/func.xml:3535(literal)
msgid "mic_to_ascii"
msgstr ""

#: xml/func.xml:3546(literal)
msgid "mic_to_big5"
msgstr ""

#: xml/func.xml:3557(literal)
msgid "mic_to_euc_cn"
msgstr ""

#: xml/func.xml:3568(literal)
msgid "mic_to_euc_jp"
msgstr ""

#: xml/func.xml:3579(literal)
msgid "mic_to_euc_kr"
msgstr ""

#: xml/func.xml:3590(literal)
msgid "mic_to_euc_tw"
msgstr ""

#: xml/func.xml:3601(literal)
msgid "mic_to_iso_8859_1"
msgstr ""

#: xml/func.xml:3612(literal)
msgid "mic_to_iso_8859_2"
msgstr ""

#: xml/func.xml:3623(literal)
msgid "mic_to_iso_8859_3"
msgstr ""

#: xml/func.xml:3634(literal)
msgid "mic_to_iso_8859_4"
msgstr ""

#: xml/func.xml:3645(literal)
msgid "mic_to_iso_8859_5"
msgstr ""

#: xml/func.xml:3656(literal)
msgid "mic_to_koi8_r"
msgstr ""

#: xml/func.xml:3667(literal)
msgid "mic_to_sjis"
msgstr ""

#: xml/func.xml:3678(literal)
msgid "mic_to_windows_1250"
msgstr ""

#: xml/func.xml:3689(literal)
msgid "mic_to_windows_1251"
msgstr ""

#: xml/func.xml:3700(literal)
msgid "mic_to_windows_866"
msgstr ""

#: xml/func.xml:3711(literal)
msgid "sjis_to_euc_jp"
msgstr ""

#: xml/func.xml:3722(literal)
msgid "sjis_to_mic"
msgstr ""

#: xml/func.xml:3733(literal)
msgid "sjis_to_utf8"
msgstr ""

#: xml/func.xml:3744(literal)
msgid "tcvn_to_utf8"
msgstr ""

#: xml/func.xml:3747(literal) xml/func.xml:4058(literal)
msgid "WIN1258"
msgstr ""

#: xml/func.xml:3755(literal)
msgid "uhc_to_utf8"
msgstr ""

#: xml/func.xml:3758(literal) xml/func.xml:4069(literal)
msgid "UHC"
msgstr ""

#: xml/func.xml:3766(literal)
msgid "utf8_to_ascii"
msgstr ""

#: xml/func.xml:3777(literal)
msgid "utf8_to_big5"
msgstr ""

#: xml/func.xml:3788(literal)
msgid "utf8_to_euc_cn"
msgstr ""

#: xml/func.xml:3799(literal)
msgid "utf8_to_euc_jp"
msgstr ""

#: xml/func.xml:3810(literal)
msgid "utf8_to_euc_kr"
msgstr ""

#: xml/func.xml:3821(literal)
msgid "utf8_to_euc_tw"
msgstr ""

#: xml/func.xml:3832(literal)
msgid "utf8_to_gb18030"
msgstr ""

#: xml/func.xml:3843(literal)
msgid "utf8_to_gbk"
msgstr ""

#: xml/func.xml:3854(literal)
msgid "utf8_to_iso_8859_1"
msgstr ""

#: xml/func.xml:3865(literal)
msgid "utf8_to_iso_8859_10"
msgstr ""

#: xml/func.xml:3876(literal)
msgid "utf8_to_iso_8859_13"
msgstr ""

#: xml/func.xml:3887(literal)
msgid "utf8_to_iso_8859_14"
msgstr ""

#: xml/func.xml:3898(literal)
msgid "utf8_to_iso_8859_15"
msgstr ""

#: xml/func.xml:3909(literal)
msgid "utf8_to_iso_8859_16"
msgstr ""

#: xml/func.xml:3920(literal)
msgid "utf8_to_iso_8859_2"
msgstr ""

#: xml/func.xml:3931(literal)
msgid "utf8_to_iso_8859_3"
msgstr ""

#: xml/func.xml:3942(literal)
msgid "utf8_to_iso_8859_4"
msgstr ""

#: xml/func.xml:3953(literal)
msgid "utf8_to_iso_8859_5"
msgstr ""

#: xml/func.xml:3964(literal)
msgid "utf8_to_iso_8859_6"
msgstr ""

#: xml/func.xml:3975(literal)
msgid "utf8_to_iso_8859_7"
msgstr ""

#: xml/func.xml:3986(literal)
msgid "utf8_to_iso_8859_8"
msgstr ""

#: xml/func.xml:3997(literal)
msgid "utf8_to_iso_8859_9"
msgstr ""

#: xml/func.xml:4008(literal)
msgid "utf8_to_johab"
msgstr ""

#: xml/func.xml:4019(literal)
msgid "utf8_to_koi8_r"
msgstr ""

#: xml/func.xml:4030(literal)
msgid "utf8_to_koi8_u"
msgstr ""

#: xml/func.xml:4041(literal)
msgid "utf8_to_sjis"
msgstr ""

#: xml/func.xml:4052(literal)
msgid "utf8_to_tcvn"
msgstr ""

#: xml/func.xml:4063(literal)
msgid "utf8_to_uhc"
msgstr ""

#: xml/func.xml:4074(literal)
msgid "utf8_to_windows_1250"
msgstr ""

#: xml/func.xml:4085(literal)
msgid "utf8_to_windows_1251"
msgstr ""

#: xml/func.xml:4096(literal)
msgid "utf8_to_windows_1252"
msgstr ""

#: xml/func.xml:4102(literal) xml/func.xml:4275(literal)
msgid "WIN1252"
msgstr ""

#: xml/func.xml:4107(literal)
msgid "utf8_to_windows_1253"
msgstr ""

#: xml/func.xml:4113(literal)
msgid "WIN1253"
msgstr ""

#: xml/func.xml:4118(literal)
msgid "utf8_to_windows_1254"
msgstr ""

#: xml/func.xml:4124(literal)
msgid "WIN1254"
msgstr ""

#: xml/func.xml:4129(literal)
msgid "utf8_to_windows_1255"
msgstr ""

#: xml/func.xml:4135(literal)
msgid "WIN1255"
msgstr ""

#: xml/func.xml:4140(literal)
msgid "utf8_to_windows_1256"
msgstr ""

#: xml/func.xml:4146(literal) xml/func.xml:4286(literal)
msgid "WIN1256"
msgstr ""

#: xml/func.xml:4151(literal)
msgid "utf8_to_windows_1257"
msgstr ""

#: xml/func.xml:4157(literal)
msgid "WIN1257"
msgstr ""

#: xml/func.xml:4162(literal)
msgid "utf8_to_windows_866"
msgstr ""

#: xml/func.xml:4173(literal)
msgid "utf8_to_windows_874"
msgstr ""

#: xml/func.xml:4179(literal) xml/func.xml:4352(literal)
msgid "WIN874"
msgstr ""

#: xml/func.xml:4184(literal)
msgid "windows_1250_to_iso_8859_2"
msgstr ""

#: xml/func.xml:4195(literal)
msgid "windows_1250_to_mic"
msgstr ""

#: xml/func.xml:4206(literal)
msgid "windows_1250_to_utf8"
msgstr ""

#: xml/func.xml:4217(literal)
msgid "windows_1251_to_iso_8859_5"
msgstr ""

#: xml/func.xml:4228(literal)
msgid "windows_1251_to_koi8_r"
msgstr ""

#: xml/func.xml:4239(literal)
msgid "windows_1251_to_mic"
msgstr ""

#: xml/func.xml:4250(literal)
msgid "windows_1251_to_utf8"
msgstr ""

#: xml/func.xml:4261(literal)
msgid "windows_1251_to_windows_866"
msgstr ""

#: xml/func.xml:4272(literal)
msgid "windows_1252_to_utf8"
msgstr ""

#: xml/func.xml:4283(literal)
msgid "windows_1256_to_utf8"
msgstr ""

#: xml/func.xml:4294(literal)
msgid "windows_866_to_iso_8859_5"
msgstr ""

#: xml/func.xml:4305(literal)
msgid "windows_866_to_koi8_r"
msgstr ""

#: xml/func.xml:4316(literal)
msgid "windows_866_to_mic"
msgstr ""

#: xml/func.xml:4327(literal)
msgid "windows_866_to_utf8"
msgstr ""

#: xml/func.xml:4338(literal)
msgid "windows_866_to_windows_1251"
msgstr ""

#: xml/func.xml:4344(literal)
msgid "WIN"
msgstr ""

#: xml/func.xml:4349(literal)
msgid "windows_874_to_utf8"
msgstr ""

#: xml/func.xml:4360(literal)
msgid "euc_jis_2004_to_utf8"
msgstr ""

#: xml/func.xml:4363(literal) xml/func.xml:4377(literal) xml/func.xml:4407(literal) xml/func.xml:4421(literal)
msgid "EUC_JIS_2004"
msgstr ""

#: xml/func.xml:4371(literal)
msgid "utf8_to_euc_jis_2004"
msgstr ""

#: xml/func.xml:4382(literal)
msgid "shift_jis_2004_to_utf8"
msgstr ""

#: xml/func.xml:4385(literal) xml/func.xml:4399(literal) xml/func.xml:4410(literal) xml/func.xml:4418(literal)
msgid "SHIFT_JIS_2004"
msgstr ""

#: xml/func.xml:4393(literal)
msgid "utf8_to_shift_jis_2004"
msgstr ""

#: xml/func.xml:4404(literal)
msgid "euc_jis_2004_to_shift_jis_2004"
msgstr ""

#: xml/func.xml:4415(literal)
msgid "shift_jis_2004_to_euc_jis_2004"
msgstr ""

#: xml/func.xml:4434(para)
msgid "The function <function>format</function>produces output formatted according to a format string, in a style similar to the C function <function>sprintf</function>."
msgstr ""

#: xml/func.xml:4439(para)
msgid "<synopsis>\n      <function>format</function>( \n      <parameter>formatstr</parameter>\n      <type>text</type>[, \n      <parameter>formatarg</parameter>\n      <type>\"any\"</type>[, ...] ])</synopsis><replaceable>formatstr</replaceable>is a format string that specifies how the result should be formatted. Text in the format string is copied directly to the result, except where <firstterm>format specifiers</firstterm>are used. Format specifiers act as placeholders in the string, defining how subsequent function arguments should be formatted and inserted into the result. Each <replaceable>formatarg</replaceable>argument is converted to text according to the usual output rules for its data type, and then formatted and inserted into the result string according to the format specifier(s)."
msgstr ""

#: xml/func.xml:4467(term)
msgid "<replaceable>position</replaceable>(optional)"
msgstr ""

#: xml/func.xml:4470(para)
msgid "A string of the form <literal><replaceable>n</replaceable>$</literal>where <replaceable>n</replaceable>is the index of the argument to print. Index 1 means the first argument after <replaceable>formatstr</replaceable>. If the <replaceable>position</replaceable>is omitted, the default is to use the next argument in sequence."
msgstr ""

#: xml/func.xml:4482(term)
msgid "<replaceable>flags</replaceable>(optional)"
msgstr ""

#: xml/func.xml:4485(para)
msgid "Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign ( <literal>-</literal>) which will cause the format specifier's output to be left-justified. This has no effect unless the <replaceable>width</replaceable>field is also specified."
msgstr ""

#: xml/func.xml:4496(term)
msgid "<replaceable>width</replaceable>(optional)"
msgstr ""

#: xml/func.xml:4499(para)
msgid "Specifies the <emphasis>minimum</emphasis>number of characters to use to display the format specifier's output. The output is padded on the left or right (depending on the <literal>-</literal>flag) with spaces as needed to fill the width. A too-small width does not cause truncation of the output, but is simply ignored. The width may be specified using any of the following: a positive integer; an asterisk ( <literal>*</literal>) to use the next function argument as the width; or a string of the form <literal>* <replaceable>n</replaceable>$</literal>to use the <replaceable>n</replaceable>th function argument as the width."
msgstr ""

#: xml/func.xml:4514(para)
msgid "If the width comes from a function argument, that argument is consumed before the argument that is used for the format specifier's value. If the width argument is negative, the result is left aligned (as if the <literal>-</literal>flag had been specified) within a field of length <function>abs</function>( <replaceable>width</replaceable>)."
msgstr ""

#: xml/func.xml:4525(term)
msgid "<replaceable>type</replaceable>(required)"
msgstr ""

#: xml/func.xml:4533(para)
msgid "<literal>s</literal>formats the argument value as a simple string. A null value is treated as an empty string."
msgstr ""

#: xml/func.xml:4539(para)
msgid "<literal>I</literal>treats the argument value as an SQL identifier, double-quoting it if necessary. It is an error for the value to be null (equivalent to <function>quote_ident</function>)."
msgstr ""

#: xml/func.xml:4547(para)
msgid "<literal>L</literal>quotes the argument value as an SQL literal. A null value is displayed as the string <literal>NULL</literal>, without quotes (equivalent to <function>quote_nullable</function>)."
msgstr ""

#: xml/func.xml:4528(para)
msgid "The type of format conversion to use to produce the format specifier's output. The following types are supported: <placeholder-1/>"
msgstr ""

#: xml/func.xml:4457(para)
msgid "Format specifiers are introduced by a <literal>%</literal>character and have the form <synopsis>%[ \n      <replaceable>position</replaceable>][ \n      <replaceable>flags</replaceable>][ \n      <replaceable>width</replaceable>] \n      <replaceable>type</replaceable></synopsis>where the component fields are: <placeholder-1/>"
msgstr ""

#: xml/func.xml:4559(para)
msgid "In addition to the format specifiers described above, the special sequence <literal>%%</literal>may be used to output a literal <literal>%</literal>character."
msgstr ""

#: xml/func.xml:4563(para)
msgid "Here are some examples of the basic format conversions: <screen>SELECT format('Hello %s', 'World'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>Hello World</computeroutput>SELECT\n      format('Testing %s, %s, %s, %%', 'one', 'two', 'three'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>Testing one, two, three,\n      %</computeroutput>SELECT format('INSERT INTO %I VALUES(%L)',\n      'Foo bar', E'O\\'Reilly'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>INSERT INTO \"Foo bar\"\n      VALUES('O''Reilly')</computeroutput>SELECT format('INSERT\n      INTO %I VALUES(%L)', 'locations', E'C:\\\\Program Files'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>INSERT INTO locations VALUES(E'C:\\\\Program\n      Files')</computeroutput></screen>"
msgstr ""

#: xml/func.xml:4580(para)
msgid "Here are examples using <replaceable>width</replaceable>fields and the <literal>-</literal>flag: <screen>SELECT format('|%10s|', 'foo'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>| foo|</computeroutput>SELECT\n      format('|%-10s|', 'foo'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>|foo |</computeroutput>SELECT format('|%*s|',\n      10, 'foo'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>| foo|</computeroutput>SELECT format('|%*s|',\n      -10, 'foo'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>|foo |</computeroutput>SELECT\n      format('|%-*s|', 10, 'foo'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>|foo |</computeroutput>SELECT\n      format('|%-*s|', -10, 'foo'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>|foo |</computeroutput></screen>"
msgstr ""

#: xml/func.xml:4601(para)
msgid "These examples show use of <replaceable>position</replaceable>fields: <screen>SELECT format('Testing %3$s, %2$s, %1$s', 'one',\n      'two', 'three'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>Testing three, two,\n      one</computeroutput>SELECT format('|%*2$s|', 'foo', 10,\n      'bar'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>| bar|</computeroutput>SELECT\n      format('|%1$*2$s|', 'foo', 10, 'bar'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>| foo|</computeroutput></screen>"
msgstr ""

#: xml/func.xml:4614(para)
msgid "Unlike the standard C function <function>sprintf</function>, <productname>PostgreSQL</productname>'s <function>format</function>function allows format specifiers with and without <replaceable>position</replaceable>fields to be mixed in the same format string. A format specifier without a <replaceable>position</replaceable>field always uses the next argument after the last argument consumed. In addition, the <function>format</function>function does not require all function arguments to be used in the format string. For example: <screen>SELECT format('Testing %3$s, %2$s, %s', 'one', 'two',\n      'three'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>Testing three, two,\n      three</computeroutput></screen>"
msgstr ""

#: xml/func.xml:4631(para)
msgid "The <literal>%I</literal>and <literal>%L</literal>format specifiers are particularly useful for safely constructing dynamic SQL statements. See <xref linkend=\"plpgsql-quote-literal-example\">.</xref>"
msgstr ""

#: xml/func.xml:4639(title)
msgid "Binary String Functions and Operators"
msgstr ""

#: xml/func.xml:4641(primary)
msgid "binary data"
msgstr ""

#: xml/func.xml:4642(secondary) xml/func.xml:5109(secondary)
msgid "functions"
msgstr ""

#: xml/func.xml:4644(para)
msgid "This section describes functions and operators for examining and manipulating values of type <type>bytea</type>."
msgstr ""

#: xml/func.xml:4647(para)
msgid "<acronym>SQL</acronym>defines some string functions that use key words, rather than commas, to separate arguments. Details are in <xref linkend=\"functions-binarystring-sql\">. <productname>PostgreSQL</productname>also provides versions of these functions that use the regular function invocation syntax (see <xref linkend=\"functions-binarystring-other\"> ).</xref></xref>"
msgstr ""

#: xml/func.xml:4658(para)
msgid "The sample results shown on this page assume that the server parameter <link linkend=\"guc-bytea-output\"><varname>bytea_output</varname></link>is set to <literal>escape</literal>(the traditional PostgreSQL format)."
msgstr ""

#: xml/func.xml:4667(title)
msgid "<acronym>SQL</acronym>Binary String Functions and Operators"
msgstr ""

#: xml/func.xml:4694(primary) xml/func.xml:5000(primary)
msgid "binary string"
msgstr ""

#: xml/func.xml:4698(literal)
msgid "E'\\\\\\\\Post'::bytea || E'\\\\047gres\\\\000'::bytea"
msgstr ""

#: xml/func.xml:4702(literal)
msgid "\\\\Post'gres\\000"
msgstr ""

#: xml/func.xml:4718(entry)
msgid "Number of bytes in binary string"
msgstr ""

#: xml/func.xml:4720(literal)
msgid "octet_length(E'jo\\\\000se'::bytea)"
msgstr ""

#: xml/func.xml:4745(literal)
msgid "overlay(E'Th\\\\000omas'::bytea placing E'\\\\002\\\\003'::bytea from 2 for 3)"
msgstr ""

#: xml/func.xml:4749(literal)
msgid "T\\\\002\\\\003mas"
msgstr ""

#: xml/func.xml:4768(literal)
msgid "position(E'\\\\000om'::bytea in E'Th\\\\000omas'::bytea)"
msgstr ""

#: xml/func.xml:4794(literal)
msgid "substring(E'Th\\\\000omas'::bytea from 2 for 3)"
msgstr ""

#: xml/func.xml:4798(literal)
msgid "h\\000o"
msgstr ""

#: xml/func.xml:4808(optional)
msgid "both"
msgstr ""

#: xml/func.xml:4809(parameter) xml/func.xml:4818(parameter) xml/func.xml:4860(parameter) xml/func.xml:4869(parameter)
msgid "bytes"
msgstr ""

#: xml/func.xml:4807(function)
msgid "trim( <placeholder-1/><placeholder-2/>from <placeholder-3/>)"
msgstr ""

#: xml/func.xml:4816(entry)
msgid "Remove the longest string containing only the bytes in <placeholder-1/>from the start and end of <placeholder-2/>"
msgstr ""

#: xml/func.xml:4821(literal)
msgid "trim(E'\\\\000'::bytea from E'\\\\000Tom\\\\000'::bytea)"
msgstr ""

#: xml/func.xml:4831(para)
msgid "Additional binary string manipulation functions are available and are listed in <xref linkend=\"functions-binarystring-other\">. Some of them are used internally to implement the <acronym>SQL</acronym>-standard string functions listed in <xref linkend=\"functions-binarystring-sql\"> .</xref></xref>"
msgstr ""

#: xml/func.xml:4839(title)
msgid "Other Binary String Functions"
msgstr ""

#: xml/func.xml:4857(function)
msgid "btrim( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>)"
msgstr ""

#: xml/func.xml:4867(entry)
msgid "Remove the longest string consisting only of bytes in <placeholder-1/>from the start and end of <placeholder-2/>"
msgstr ""

#: xml/func.xml:4872(literal)
msgid "btrim(E'\\\\000trim\\\\000'::bytea, E'\\\\000'::bytea)"
msgstr ""

#: xml/func.xml:4901(literal)
msgid "decode(E'123\\\\000456', 'escape')"
msgstr ""

#: xml/func.xml:4904(literal) xml/func.xml:4938(literal)
msgid "123\\000456"
msgstr ""

#: xml/func.xml:4934(literal)
msgid "encode(E'123\\\\000456'::bytea, 'escape')"
msgstr ""

#: xml/func.xml:4944(primary)
msgid "get_bit"
msgstr ""

#: xml/func.xml:4949(parameter) xml/func.xml:4971(parameter) xml/func.xml:5047(parameter) xml/func.xml:5071(parameter)
msgid "offset"
msgstr ""

#: xml/func.xml:4947(function)
msgid "get_bit( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:4955(entry)
msgid "Extract bit from string"
msgstr ""

#: xml/func.xml:4957(literal)
msgid "get_bit(E'Th\\\\000omas'::bytea, 45)"
msgstr ""

#: xml/func.xml:4966(primary)
msgid "get_byte"
msgstr ""

#: xml/func.xml:4969(function)
msgid "get_byte( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:4977(entry)
msgid "Extract byte from string"
msgstr ""

#: xml/func.xml:4979(literal)
msgid "get_byte(E'Th\\\\000omas'::bytea, 4)"
msgstr ""

#: xml/func.xml:4982(literal)
msgid "109"
msgstr ""

#: xml/func.xml:5005(secondary)
msgid "of a binary string"
msgstr ""

#: xml/func.xml:5007(see)
msgid "binary strings, length"
msgstr ""

#: xml/func.xml:4998(entry)
msgid "Length of binary string <indexterm><placeholder-1/><placeholder-2/></indexterm><indexterm><placeholder-3/><placeholder-4/><placeholder-5/></indexterm>"
msgstr ""

#: xml/func.xml:5010(literal)
msgid "length(E'jo\\\\000se'::bytea)"
msgstr ""

#: xml/func.xml:5033(literal)
msgid "md5(E'Th\\\\000omas'::bytea)"
msgstr ""

#: xml/func.xml:5036(literal)
msgid "8ab2d3c9689aaf18 b4958c334c82d8b1"
msgstr ""

#: xml/func.xml:5042(primary)
msgid "set_bit"
msgstr ""

#: xml/func.xml:5048(parameter) xml/func.xml:5072(parameter)
msgid "newvalue"
msgstr ""

#: xml/func.xml:5045(function)
msgid "set_bit( <placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""

#: xml/func.xml:5054(entry)
msgid "Set bit in string"
msgstr ""

#: xml/func.xml:5056(literal)
msgid "set_bit(E'Th\\\\000omas'::bytea, 45, 0)"
msgstr ""

#: xml/func.xml:5060(literal)
msgid "Th\\000omAs"
msgstr ""

#: xml/func.xml:5066(primary)
msgid "set_byte"
msgstr ""

#: xml/func.xml:5069(function)
msgid "set_byte( <placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""

#: xml/func.xml:5078(entry)
msgid "Set byte in string"
msgstr ""

#: xml/func.xml:5080(literal)
msgid "set_byte(E'Th\\\\000omas'::bytea, 4, 64)"
msgstr ""

#: xml/func.xml:5084(literal)
msgid "Th\\000o@as"
msgstr ""

#: xml/func.xml:5090(para)
msgid "<function>get_byte</function>and <function>set_byte</function>number the first byte of a binary string as byte 0. <function>get_bit</function>and <function>set_bit</function>number bits from the right within each byte; for example bit 0 is the least significant bit of the first byte, and bit 15 is the most significant bit of the second byte."
msgstr ""

#: xml/func.xml:5099(para)
msgid "See also the aggregate function <function>string_agg</function>in <xref linkend=\"functions-aggregate\">and the large object functions in <xref linkend=\"lo-funcs\">.</xref></xref>"
msgstr ""

#: xml/func.xml:5106(title)
msgid "Bit String Functions and Operators"
msgstr ""

#: xml/func.xml:5108(primary)
msgid "bit strings"
msgstr ""

#: xml/func.xml:5111(para)
msgid "This section describes functions and operators for examining and manipulating bit strings, that is values of the types <type>bit</type>and <type>bit varying</type>. Aside from the usual comparison operators, the operators shown in <xref linkend=\"functions-bit-string-op-table\">can be used. Bit string operands of <literal/>, <literal>|</literal>, and <literal>#</literal>must be of equal length. When bit shifting, the original length of the string is preserved, as shown in the examples.</xref>"
msgstr ""

#: xml/func.xml:5125(title)
msgid "Bit String Operators"
msgstr ""

#: xml/func.xml:5142(literal)
msgid "B'10001' || B'011'"
msgstr ""

#: xml/func.xml:5145(literal)
msgid "10001011"
msgstr ""

#: xml/func.xml:5154(literal)
msgid "B'10001' B'01101'"
msgstr ""

#: xml/func.xml:5157(literal)
msgid "00001"
msgstr ""

#: xml/func.xml:5166(literal)
msgid "B'10001' | B'01101'"
msgstr ""

#: xml/func.xml:5169(literal)
msgid "11101"
msgstr ""

#: xml/func.xml:5178(literal)
msgid "B'10001' # B'01101'"
msgstr ""

#: xml/func.xml:5181(literal)
msgid "11100"
msgstr ""

#: xml/func.xml:5190(literal)
msgid "~ B'10001'"
msgstr ""

#: xml/func.xml:5193(literal)
msgid "01110"
msgstr ""

#: xml/func.xml:5202(literal)
msgid "B'10001' 3"
msgstr ""

#: xml/func.xml:5205(literal)
msgid "01000"
msgstr ""

#: xml/func.xml:5214(literal)
msgid "B'10001' 2"
msgstr ""

#: xml/func.xml:5217(literal)
msgid "00100"
msgstr ""

#: xml/func.xml:5223(para)
msgid "The following <acronym>SQL</acronym>-standard functions work on bit strings as well as character strings: <literal><function>length</function></literal>, <literal><function>bit_length</function></literal>, <literal><function>octet_length</function></literal>, <literal><function>position</function></literal>, <literal><function>substring</function></literal>, <literal><function>overlay</function></literal>."
msgstr ""

#: xml/func.xml:5244(para)
msgid "The following functions work on bit strings as well as binary strings: <literal><function>get_bit</function></literal>, <literal><function>set_bit</function></literal>. When working with a bit string, these functions number the first (leftmost) bit of the string as bit 0."
msgstr ""

#: xml/func.xml:5256(programlisting)
#, no-wrap
msgid "44::bit(10) \n    <lineannotation>0000101100</lineannotation>44::bit(3) \n    <lineannotation>100</lineannotation>cast(-44 as bit(12)) \n    <lineannotation>\n    111111010100</lineannotation>'1110'::bit(4)::integer \n    <lineannotation>14</lineannotation>"
msgstr ""

#: xml/func.xml:5253(para)
msgid "In addition, it is possible to cast integral values to and from type <type>bit</type>. Some examples: <placeholder-1/>Note that casting to just <quote>bit</quote>means casting to <literal>bit(1)</literal>, and so will deliver only the least significant bit of the integer."
msgstr ""

#: xml/func.xml:5267(para)
msgid "Casting an integer to <type>bit(n)</type>copies the rightmost <literal>n</literal>bits. Casting an integer to a bit string width wider than the integer itself will sign-extend on the left."
msgstr ""

#: xml/func.xml:5275(title)
msgid "Pattern Matching"
msgstr ""

#: xml/func.xml:5277(primary) xml/func.xml:5558(seealso)
msgid "pattern matching"
msgstr ""

#: xml/func.xml:5279(para)
msgid "There are three separate approaches to pattern matching provided by <productname>PostgreSQL</productname>: the traditional <acronym>SQL</acronym><function>LIKE</function>operator, the more recent <function>SIMILAR TO</function>operator (added in SQL:1999), and <acronym>POSIX</acronym>-style regular expressions. Aside from the basic <quote>does this string match this pattern?</quote>operators, functions are available to extract or replace matching substrings and to split a string at matching locations."
msgstr ""

#: xml/func.xml:5292(para)
msgid "If you have pattern matching needs that go beyond this, consider writing a user-defined function in Perl or Tcl."
msgstr ""

#: xml/func.xml:5297(para)
msgid "While most regular-expression searches can be executed very quickly, regular expressions can be contrived that take arbitrary amounts of time and memory to process. Be wary of accepting regular-expression search patterns from hostile sources. If you must do so, it is advisable to impose a statement timeout."
msgstr ""

#: xml/func.xml:5303(para)
msgid "Searches using <function>SIMILAR TO</function>patterns have the same security hazards, since <function>SIMILAR TO</function>provides many of the same capabilities as <acronym>POSIX</acronym>-style regular expressions."
msgstr ""

#: xml/func.xml:5309(para)
msgid "<function>LIKE</function>searches, being much simpler than the other two options, are safer to use with possibly-hostile pattern sources."
msgstr ""

#: xml/func.xml:5316(function) xml/func.xml:5319(primary)
msgid "LIKE"
msgstr ""

#: xml/func.xml:5325(replaceable) xml/func.xml:5329(replaceable) xml/func.xml:5419(replaceable) xml/func.xml:5423(replaceable)
msgid "escape-character"
msgstr ""

#: xml/func.xml:5324(optional) xml/func.xml:5328(optional) xml/func.xml:5418(optional) xml/func.xml:5422(optional)
msgid "ESCAPE <placeholder-1/>"
msgstr ""

#: xml/func.xml:5321(synopsis)
#, no-wrap
msgid "\n      <placeholder-1/>LIKE \n      <placeholder-2/>\n      <placeholder-3/>\n      <placeholder-4/>NOT LIKE \n      <placeholder-5/>\n      <placeholder-6/>"
msgstr ""

#: xml/func.xml:5331(para)
msgid "The <function>LIKE</function>expression returns true if the <replaceable>string</replaceable>matches the supplied <replaceable>pattern</replaceable>. (As expected, the <function>NOT LIKE</function>expression returns false if <function>LIKE</function>returns true, and vice versa. An equivalent expression is <literal>NOT ( <replaceable>string</replaceable>LIKE <replaceable>pattern</replaceable>)</literal>.)"
msgstr ""

#: xml/func.xml:5341(para)
msgid "If <replaceable>pattern</replaceable>does not contain percent signs or underscores, then the pattern only represents the string itself; in that case <function>LIKE</function>acts like the equals operator. An underscore ( <literal>_</literal>) in <replaceable>pattern</replaceable>stands for (matches) any single character; a percent sign ( <literal>%</literal>) matches any sequence of zero or more characters."
msgstr ""

#: xml/func.xml:5353(programlisting)
#, no-wrap
msgid "'abc' LIKE 'abc' \n      <lineannotation>true</lineannotation>'abc' LIKE 'a%' \n      <lineannotation>true</lineannotation>'abc' LIKE '_b_' \n      <lineannotation>true</lineannotation>'abc' LIKE 'c' \n      <lineannotation>\n      false</lineannotation>"
msgstr ""

#: xml/func.xml:5352(para) xml/func.xml:5520(para) xml/func.xml:5658(para) xml/func.xml:5684(para) xml/func.xml:5726(para) xml/func.xml:5768(para) xml/func.xml:5820(para)
msgid "Some examples: <placeholder-1/>"
msgstr ""

#: xml/func.xml:5359(para)
msgid "<function>LIKE</function>pattern matching always covers the entire string. Therefore, if it's desired to match a sequence anywhere within a string, the pattern must start and end with a percent sign."
msgstr ""

#: xml/func.xml:5364(para)
msgid "To match a literal underscore or percent sign without matching other characters, the respective character in <replaceable>pattern</replaceable>must be preceded by the escape character. The default escape character is the backslash but a different one can be selected by using the <literal>ESCAPE</literal>clause. To match the escape character itself, write two escape characters."
msgstr ""

#: xml/func.xml:5372(para) xml/func.xml:6015(para)
msgid "If you have <xref linkend=\"guc-standard-conforming-strings\">turned off, any backslashes you write in literal string constants will need to be doubled. See <xref linkend=\"sql-syntax-strings\">for more information.</xref></xref>"
msgstr ""

#: xml/func.xml:5379(para)
msgid "It's also possible to select no escape character by writing <literal>ESCAPE ''</literal>. This effectively disables the escape mechanism, which makes it impossible to turn off the special meaning of underscore and percent signs in the pattern."
msgstr ""

#: xml/func.xml:5385(para)
msgid "The key word <token>ILIKE</token>can be used instead of <token>LIKE</token>to make the match case-insensitive according to the active locale. This is not in the <acronym>SQL</acronym>standard but is a <productname>PostgreSQL</productname>extension."
msgstr ""

#: xml/func.xml:5391(para)
msgid "The operator <literal>~~</literal>is equivalent to <function>LIKE</function>, and <literal>~~*</literal>corresponds to <function>ILIKE</function>. There are also <literal>!~~</literal>and <literal>!~~*</literal>operators that represent <function>NOT LIKE</function>and <function>NOT ILIKE</function>, respectively. All of these operators are <productname>PostgreSQL</productname>-specific."
msgstr ""

#: xml/func.xml:5404(title)
msgid "<function>SIMILAR TO</function>Regular Expressions"
msgstr ""

#: xml/func.xml:5407(primary) xml/func.xml:5557(primary)
msgid "regular expression"
msgstr ""

#: xml/func.xml:5410(primary)
msgid "SIMILAR TO"
msgstr ""

#: xml/func.xml:5415(synopsis)
#, no-wrap
msgid "\n      <placeholder-1/>SIMILAR TO \n      <placeholder-2/>\n      <placeholder-3/>\n      <placeholder-4/>NOT SIMILAR TO \n      <placeholder-5/>\n      <placeholder-6/>"
msgstr ""

#: xml/func.xml:5425(para)
msgid "The <function>SIMILAR TO</function>operator returns true or false depending on whether its pattern matches the given string. It is similar to <function>LIKE</function>, except that it interprets the pattern using the SQL standard's definition of a regular expression. SQL regular expressions are a curious cross between <function>LIKE</function>notation and common regular expression notation."
msgstr ""

#: xml/func.xml:5435(para)
msgid "Like <function>LIKE</function>, the <function>SIMILAR TO</function>operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string. Also like <function>LIKE</function>, <function>SIMILAR TO</function>uses <literal>_</literal>and <literal>%</literal>as wildcard characters denoting any single character and any string, respectively (these are comparable to <literal>.</literal>and <literal>.*</literal>in POSIX regular expressions)."
msgstr ""

#: xml/func.xml:5456(para)
msgid "<literal>|</literal>denotes alternation (either of two alternatives)."
msgstr ""

#: xml/func.xml:5461(para)
msgid "<literal>*</literal>denotes repetition of the previous item zero or more times."
msgstr ""

#: xml/func.xml:5466(para)
msgid "<literal>+</literal>denotes repetition of the previous item one or more times."
msgstr ""

#: xml/func.xml:5471(para)
msgid "<literal>?</literal>denotes repetition of the previous item zero or one time."
msgstr ""

#: xml/func.xml:5476(para)
msgid "<literal>{</literal><replaceable>m</replaceable><literal>}</literal>denotes repetition of the previous item exactly <replaceable>m</replaceable>times."
msgstr ""

#: xml/func.xml:5484(para)
msgid "<literal>{</literal><replaceable>m</replaceable><literal>,}</literal>denotes repetition of the previous item <replaceable>m</replaceable>or more times."
msgstr ""

#: xml/func.xml:5492(para)
msgid "<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>denotes repetition of the previous item at least <replaceable>m</replaceable>and not more than <replaceable>n</replaceable>times."
msgstr ""

#: xml/func.xml:5503(para)
msgid "Parentheses <literal>()</literal>can be used to group items into a single logical item."
msgstr ""

#: xml/func.xml:5508(para)
msgid "A bracket expression <literal>[...]</literal>specifies a character class, just as in POSIX regular expressions."
msgstr ""

#: xml/func.xml:5449(para)
msgid "In addition to these facilities borrowed from <function>LIKE</function>, <function>SIMILAR TO</function>supports these pattern-matching metacharacters borrowed from POSIX regular expressions: <placeholder-1/>Notice that the period ( <literal>.</literal>) is not a metacharacter for <function>SIMILAR TO</function>."
msgstr ""

#: xml/func.xml:5515(para)
msgid "As with <function>LIKE</function>, a backslash disables the special meaning of any of these metacharacters; or a different escape character can be specified with <literal>ESCAPE</literal>."
msgstr ""

#: xml/func.xml:5521(programlisting)
#, no-wrap
msgid "'abc' SIMILAR TO 'abc' \n      <lineannotation>true</lineannotation>'abc' SIMILAR TO 'a' \n      <lineannotation>false</lineannotation>'abc' SIMILAR TO\n      '%(b|d)%' \n      <lineannotation>true</lineannotation>'abc' SIMILAR TO\n      '(b|c)%' \n      <lineannotation>\n      false</lineannotation>"
msgstr ""

#: xml/func.xml:5529(para)
msgid "The <function>substring</function>function with three parameters, <function>substring( <replaceable>string</replaceable>from <replaceable>pattern</replaceable>for <replaceable>escape-character</replaceable>)</function>, provides extraction of a substring that matches an SQL regular expression pattern. As with <literal>SIMILAR TO</literal>, the specified pattern must match the entire data string, or else the function fails and returns null. To indicate the part of the pattern that should be returned on success, the pattern must contain two occurrences of the escape character followed by a double quote ( <literal>\"</literal>). The text matching the portion of the pattern between these markers is returned."
msgstr ""

#: xml/func.xml:5548(programlisting)
#, no-wrap
msgid "substring('foobar' from '%#\"o_b#\"%' for '#') \n      <lineannotation>oob</lineannotation>substring('foobar' from\n      '#\"o_b#\"%' for '#') \n      <lineannotation>NULL</lineannotation>"
msgstr ""

#: xml/func.xml:5546(para)
msgid "Some examples, with <literal>#</literal>delimiting the return string: <placeholder-1/>"
msgstr ""

#: xml/func.xml:5554(title)
msgid "<acronym>POSIX</acronym>Regular Expressions"
msgstr ""

#: xml/func.xml:5576(xref)
msgid "lists the available operators for pattern matching using POSIX regular expressions."
msgstr ""

#: xml/func.xml:5581(title)
msgid "Regular Expression Match Operators"
msgstr ""

#: xml/func.xml:5595(entry)
msgid "Matches regular expression, case sensitive"
msgstr ""

#: xml/func.xml:5598(literal)
msgid "'thomas' ~ '.*thomas.*'"
msgstr ""

#: xml/func.xml:5603(literal)
msgid "~*"
msgstr ""

#: xml/func.xml:5605(entry)
msgid "Matches regular expression, case insensitive"
msgstr ""

#: xml/func.xml:5608(literal)
msgid "'thomas' ~* '.*Thomas.*'"
msgstr ""

#: xml/func.xml:5613(literal)
msgid "!~"
msgstr ""

#: xml/func.xml:5615(entry)
msgid "Does not match regular expression, case sensitive"
msgstr ""

#: xml/func.xml:5618(literal)
msgid "'thomas' !~ '.*Thomas.*'"
msgstr ""

#: xml/func.xml:5623(literal)
msgid "!~*"
msgstr ""

#: xml/func.xml:5625(entry)
msgid "Does not match regular expression, case insensitive"
msgstr ""

#: xml/func.xml:5628(literal)
msgid "'thomas' !~* '.*vadim.*'"
msgstr ""

#: xml/func.xml:5634(para)
msgid "<acronym>POSIX</acronym>regular expressions provide a more powerful means for pattern matching than the <function>LIKE</function>and <function>SIMILAR TO</function>operators. Many Unix tools such as <command>egrep</command>, <command>sed</command>, or <command>awk</command>use a pattern matching language that is similar to the one described here."
msgstr ""

#: xml/func.xml:5644(para)
msgid "A regular expression is a character sequence that is an abbreviated definition of a set of strings (a <firstterm>regular set</firstterm>). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with <function>LIKE</function>, pattern characters match string characters exactly unless they are special characters in the regular expression language but regular expressions use different special characters than <function>LIKE</function>does. Unlike <function>LIKE</function>patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string."
msgstr ""

#: xml/func.xml:5659(programlisting)
#, no-wrap
msgid "'abc' ~ 'abc' \n      <lineannotation>true</lineannotation>'abc' ~ '^a' \n      <lineannotation>true</lineannotation>'abc' ~ '(b|d)' \n      <lineannotation>true</lineannotation>'abc' ~ '^(b|c)' \n      <lineannotation>\n      false</lineannotation>"
msgstr ""

#: xml/func.xml:5665(para)
msgid "The <acronym>POSIX</acronym>pattern language is described in much greater detail below."
msgstr ""

#: xml/func.xml:5668(para)
msgid "The <function>substring</function>function with two parameters, <function>substring( <replaceable>string</replaceable>from <replaceable>pattern</replaceable>)</function>, provides extraction of a substring that matches a POSIX regular expression pattern. It returns null if there is no match, otherwise the portion of the text that matched the pattern. But if the pattern contains any parentheses, the portion of the text that matched the first parenthesized subexpression (the one whose left parenthesis comes first) is returned. You can put parentheses around the whole expression if you want to use parentheses within it without triggering this exception. If you need parentheses in the pattern before the subexpression you want to extract, see the non-capturing parentheses described below."
msgstr ""

#: xml/func.xml:5685(programlisting)
#, no-wrap
msgid "substring('foobar' from 'o.b') \n      <lineannotation>oob</lineannotation>substring('foobar' from\n      'o(.)b') \n      <lineannotation>o</lineannotation>"
msgstr ""

#: xml/func.xml:5689(para)
msgid "The <function>regexp_replace</function>function provides substitution of new text for substrings that match POSIX regular expression patterns. It has the syntax <function>regexp_replace</function>( <replaceable>source</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable><optional>, <replaceable>flags</replaceable></optional>). The <replaceable>source</replaceable>string is returned unchanged if there is no match to the <replaceable>pattern</replaceable>. If there is a match, the <replaceable>source</replaceable>string is returned with the <replaceable>replacement</replaceable>string substituted for the matching substring. The <replaceable>replacement</replaceable>string can contain <literal>\\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable>is 1 through 9, to indicate that the source substring matching the <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be inserted, and it can contain <literal>\\</literal>to indicate that the substring matching the entire pattern should be inserted. Write <literal>\\\\</literal>if you need to put a literal backslash in the replacement text. The <replaceable>flags</replaceable>parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag <literal>i</literal>specifies case-insensitive matching, while flag <literal>g</literal>specifies replacement of each matching substring rather than only the first one. Supported flags (though not <literal>g</literal>) are described in <xref linkend=\"posix-embedded-options-table\">.</xref>"
msgstr ""

#: xml/func.xml:5727(programlisting)
#, no-wrap
msgid "regexp_replace('foobarbaz', 'b..', 'X') \n      <lineannotation>\n      fooXbaz</lineannotation>regexp_replace('foobarbaz', 'b..',\n      'X', 'g') \n      <lineannotation>\n      fooXX</lineannotation>regexp_replace('foobarbaz', 'b(..)',\n      E'X\\\\1Y', 'g') \n      <lineannotation>\n      fooXarYXazY</lineannotation>"
msgstr ""

#: xml/func.xml:5736(para)
msgid "The <function>regexp_matches</function>function returns a text array of all of the captured substrings resulting from matching a POSIX regular expression pattern. It has the syntax <function>regexp_matches</function>( <replaceable>string</replaceable>, <replaceable>pattern</replaceable><optional>, <replaceable>flags</replaceable></optional>). The function can return no rows, one row, or multiple rows (see the <literal>g</literal>flag below). If the <replaceable>pattern</replaceable>does not match, the function returns no rows. If the pattern contains no parenthesized subexpressions, then each row returned is a single-element text array containing the substring matching the whole pattern. If the pattern contains parenthesized subexpressions, the function returns a text array whose <replaceable>n</replaceable>'th element is the substring matching the <replaceable>n</replaceable>'th parenthesized subexpression of the pattern (not counting <quote>non-capturing</quote>parentheses; see below for details). The <replaceable>flags</replaceable>parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. Flag <literal>g</literal>causes the function to find each match in the string, not only the first one, and return a row for each such match. Supported flags (though not <literal>g</literal>) are described in <xref linkend=\"posix-embedded-options-table\">.</xref>"
msgstr ""

#: xml/func.xml:5769(programlisting)
#, no-wrap
msgid "SELECT regexp_matches('foobarbequebaz',\n      '(bar)(beque)'); regexp_matches ---------------- {bar,beque}\n      (1 row) SELECT regexp_matches('foobarbequebazilbarfbonk',\n      '(b[^b]+)(b[^b]+)', 'g'); regexp_matches ----------------\n      {bar,beque} {bazil,barf} (2 rows) SELECT\n      regexp_matches('foobarbequebaz', 'barbeque'); regexp_matches\n      ---------------- {barbeque} (1 row)"
msgstr ""

#: xml/func.xml:5781(programlisting)
#, no-wrap
msgid "SELECT col1, (SELECT regexp_matches(col2,\n      '(bar)(beque)')) FROM tab;"
msgstr ""

#: xml/func.xml:5776(para)
msgid "It is possible to force <function>regexp_matches()</function>to always return one row by using a sub-select; this is particularly useful in a <literal>SELECT</literal>target list when you want all rows returned, even non-matching ones: <placeholder-1/>"
msgstr ""

#: xml/func.xml:5783(para)
msgid "The <function>regexp_split_to_table</function>function splits a string using a POSIX regular expression pattern as a delimiter. It has the syntax <function>regexp_split_to_table</function>( <replaceable>string</replaceable>, <replaceable>pattern</replaceable><optional>, <replaceable>flags</replaceable></optional>). If there is no match to the <replaceable>pattern</replaceable>, the function returns the <replaceable>string</replaceable>. If there is at least one match, for each match it returns the text from the end of the last match (or the beginning of the string) to the beginning of the match. When there are no more matches, it returns the text from the end of the last match to the end of the string. The <replaceable>flags</replaceable>parameter is an optional text string containing zero or more single-letter flags that change the function's behavior. <function>regexp_split_to_table</function>supports the flags described in <xref linkend=\"posix-embedded-options-table\">.</xref>"
msgstr ""

#: xml/func.xml:5806(para)
msgid "The <function>regexp_split_to_array</function>function behaves the same as <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>returns its result as an array of <type>text</type>. It has the syntax <function>regexp_split_to_array</function>( <replaceable>string</replaceable>, <replaceable>pattern</replaceable><optional>, <replaceable>flags</replaceable></optional>). The parameters are the same as for <function>regexp_split_to_table</function>."
msgstr ""

#: xml/func.xml:5821(programlisting)
#, no-wrap
msgid "SELECT foo FROM regexp_split_to_table('the\n      quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n      foo ------- the quick brown fox jumps over the lazy dog (9\n      rows) SELECT regexp_split_to_array('the quick brown fox jumps\n      over the lazy dog', E'\\\\s+'); regexp_split_to_array\n      -----------------------------------------------\n      {the,quick,brown,fox,jumps,over,the,lazy,dog} (1 row) SELECT\n      foo FROM regexp_split_to_table('the quick brown fox',\n      E'\\\\s*') AS foo; foo ----- t h e q u i c k b r o w n f o x\n      (16 rows)"
msgstr ""

#: xml/func.xml:5831(para)
msgid "As the last example demonstrates, the regexp split functions ignore zero-length matches that occur at the start or end of the string or immediately after a previous match. This is contrary to the strict definition of regexp matching that is implemented by <function>regexp_matches</function>, but is usually the most convenient behavior in practice. Other software systems such as Perl use similar definitions."
msgstr ""

#: xml/func.xml:5840(title)
msgid "Regular Expression Details"
msgstr ""

#: xml/func.xml:5841(para)
msgid "<productname>PostgreSQL</productname>'s regular expressions are implemented using a software package written by Henry Spencer. Much of the description of regular expressions below is copied verbatim from his manual."
msgstr ""

#: xml/func.xml:5846(para)
msgid "Regular expressions ( <acronym>RE</acronym>s), as defined in <acronym>POSIX</acronym>1003.2, come in two forms: <firstterm>extended</firstterm><acronym>RE</acronym>s or <acronym>ERE</acronym>s (roughly those of <command>egrep</command>), and <firstterm>basic</firstterm><acronym>RE</acronym>s or <acronym>BRE</acronym>s (roughly those of <command>ed</command>). <productname>PostgreSQL</productname>supports both forms, and also implements some extensions that are not in the POSIX standard, but have become widely used due to their availability in programming languages such as Perl and Tcl. <acronym>RE</acronym>s using these non-POSIX extensions are called <firstterm>advanced</firstterm><acronym>RE</acronym>s or <acronym>ARE</acronym>s in this documentation. AREs are almost an exact superset of EREs, but BREs have several notational incompatibilities (as well as being much more limited). We first describe the ARE and ERE forms, noting features that apply only to AREs, and then describe how BREs differ."
msgstr ""

#: xml/func.xml:5873(para)
msgid "<productname>PostgreSQL</productname>always initially presumes that a regular expression follows the ARE rules. However, the more limited ERE or BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>to the RE pattern, as described in <xref linkend=\"posix-metasyntax\">. This can be useful for compatibility with applications that expect exactly the <acronym>POSIX</acronym>1003.2 rules.</xref>"
msgstr ""

#: xml/func.xml:5884(para)
msgid "A regular expression is defined as one or more <firstterm>branches</firstterm>, separated by <literal>|</literal>. It matches anything that matches one of the branches."
msgstr ""

#: xml/func.xml:5888(para)
msgid "A branch is zero or more <firstterm>quantified atoms</firstterm>or <firstterm>constraints</firstterm>, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string."
msgstr ""

#: xml/func.xml:5894(para)
msgid "A quantified atom is an <firstterm>atom</firstterm>possibly followed by a single <firstterm>quantifier</firstterm>. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An <firstterm>atom</firstterm>can be any of the possibilities shown in <xref linkend=\"posix-atoms-table\">. The possible quantifiers and their meanings are shown in <xref linkend=\"posix-quantifiers-table\"> .</xref></xref>"
msgstr ""

#: xml/func.xml:5905(para)
msgid "A <firstterm>constraint</firstterm>matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in <xref linkend=\"posix-constraints-table\">; some more constraints are described later.</xref>"
msgstr ""

#: xml/func.xml:5914(title)
msgid "Regular Expression Atoms"
msgstr ""

#: xml/func.xml:5918(entry)
msgid "Atom"
msgstr ""

#: xml/func.xml:5925(literal)
msgid "("
msgstr ""

#: xml/func.xml:5926(replaceable) xml/func.xml:5930(replaceable) xml/func.xml:5932(replaceable) xml/func.xml:5938(replaceable) xml/func.xml:6201(replaceable) xml/func.xml:6207(replaceable) xml/func.xml:6213(replaceable) xml/func.xml:6219(replaceable)
msgid "re"
msgstr ""

#: xml/func.xml:5927(literal) xml/func.xml:5939(literal) xml/func.xml:6202(literal) xml/func.xml:6214(literal) xml/func.xml:6861(xref) xml/func.xml:6869(xref) xml/func.xml:6899(xref) xml/func.xml:7879(xref)
msgid ")"
msgstr ""

#: xml/func.xml:5929(entry)
msgid "(where <placeholder-1/>is any regular expression) matches a match for <placeholder-2/>, with the match noted for possible reporting"
msgstr ""

#: xml/func.xml:5937(literal)
msgid "(?:"
msgstr ""

#: xml/func.xml:5943(quote)
msgid "non-capturing"
msgstr ""

#: xml/func.xml:5941(entry)
msgid "as above, but the match is not noted for reporting (a <placeholder-1/>set of parentheses) (AREs only)"
msgstr ""

#: xml/func.xml:5950(entry)
msgid "matches any single character"
msgstr ""

#: xml/func.xml:5954(literal)
msgid "["
msgstr ""

#: xml/func.xml:5955(replaceable) xml/func.xml:5961(replaceable)
msgid "chars"
msgstr ""

#: xml/func.xml:5956(literal)
msgid "]"
msgstr ""

#: xml/func.xml:5959(firstterm)
msgid "bracket expression"
msgstr ""

#: xml/func.xml:5962(xref)
msgid "for more detail)"
msgstr ""

#: xml/func.xml:5958(entry)
msgid "a <placeholder-1/>, matching any one of the <placeholder-2/>(see <placeholder-3/>"
msgstr ""

#: xml/func.xml:5968(replaceable) xml/func.xml:5971(replaceable)
msgid "k"
msgstr ""

#: xml/func.xml:5974(literal)
msgid "\\\\"
msgstr ""

#: xml/func.xml:5970(entry)
msgid "(where <placeholder-1/>is a non-alphanumeric character) matches that character taken as an ordinary character, e.g., <placeholder-2/>matches a backslash character"
msgstr ""

#: xml/func.xml:5980(replaceable) xml/func.xml:5983(replaceable) xml/func.xml:5988(replaceable) xml/func.xml:6830(literal)
msgid "c"
msgstr ""

#: xml/func.xml:5986(xref)
msgid "(AREs only; in EREs and BREs, this matches <placeholder-1/>)"
msgstr ""

#: xml/func.xml:5982(entry)
msgid "where <placeholder-1/>is alphanumeric (possibly followed by other characters) is an <placeholder-2/>, see <placeholder-3/>"
msgstr ""

#: xml/func.xml:5992(literal) xml/func.xml:5996(literal) xml/func.xml:6055(literal) xml/func.xml:6065(literal) xml/func.xml:6075(literal) xml/func.xml:6111(literal) xml/func.xml:6116(literal) xml/func.xml:6122(literal) xml/func.xml:6127(literal) xml/func.xml:6133(literal) xml/func.xml:6140(literal)
msgid "{"
msgstr ""

#: xml/func.xml:5998(replaceable)
msgid "bound"
msgstr ""

#: xml/func.xml:5994(entry)
msgid "when followed by a character other than a digit, matches the left-brace character <placeholder-1/>; when followed by a digit, it is the beginning of a <placeholder-2/>(see below)"
msgstr ""

#: xml/func.xml:6004(entry)
msgid "where <placeholder-1/>is a single character with no other significance, matches that character"
msgstr ""

#: xml/func.xml:6012(para)
msgid "An RE cannot end with a backslash ( <literal>\\</literal>)."
msgstr ""

#: xml/func.xml:6023(title)
msgid "Regular Expression Quantifiers"
msgstr ""

#: xml/func.xml:6027(entry)
msgid "Quantifier"
msgstr ""

#: xml/func.xml:6028(entry)
msgid "Matches"
msgstr ""

#: xml/func.xml:6036(entry)
msgid "a sequence of 0 or more matches of the atom"
msgstr ""

#: xml/func.xml:6043(entry)
msgid "a sequence of 1 or more matches of the atom"
msgstr ""

#: xml/func.xml:6048(literal) xml/func.xml:6107(literal)
msgid "?"
msgstr ""

#: xml/func.xml:6050(entry)
msgid "a sequence of 0 or 1 matches of the atom"
msgstr ""

#: xml/func.xml:6056(replaceable) xml/func.xml:6060(replaceable) xml/func.xml:6066(replaceable) xml/func.xml:6070(replaceable) xml/func.xml:6076(replaceable) xml/func.xml:6082(replaceable) xml/func.xml:6085(replaceable) xml/func.xml:6112(replaceable) xml/func.xml:6117(replaceable) xml/func.xml:6123(replaceable) xml/func.xml:6128(replaceable) xml/func.xml:6134(replaceable) xml/func.xml:6141(replaceable) xml/func.xml:6738(replaceable) xml/func.xml:6741(replaceable) xml/func.xml:6743(replaceable) xml/func.xml:6752(replaceable) xml/func.xml:6851(literal)
msgid "m"
msgstr ""

#: xml/func.xml:6057(literal) xml/func.xml:6079(literal) xml/func.xml:6118(literal) xml/func.xml:6144(literal)
msgid "}"
msgstr ""

#: xml/func.xml:6059(entry)
msgid "a sequence of exactly <placeholder-1/>matches of the atom"
msgstr ""

#: xml/func.xml:6067(literal) xml/func.xml:6129(literal)
msgid ",}"
msgstr ""

#: xml/func.xml:6069(entry)
msgid "a sequence of <placeholder-1/>or more matches of the atom"
msgstr ""

#: xml/func.xml:6077(literal) xml/func.xml:6135(literal) xml/func.xml:6142(literal) xml/func.xml:8126(literal)
msgid ","
msgstr ""

#: xml/func.xml:6081(entry)
msgid "a sequence of <placeholder-1/>through <placeholder-2/>(inclusive) matches of the atom; <placeholder-3/>cannot exceed <placeholder-4/>"
msgstr ""

#: xml/func.xml:6090(literal)
msgid "*?"
msgstr ""

#: xml/func.xml:6092(entry) xml/func.xml:6099(entry) xml/func.xml:6106(entry)
msgid "non-greedy version of <placeholder-1/>"
msgstr ""

#: xml/func.xml:6097(literal)
msgid "+?"
msgstr ""

#: xml/func.xml:6104(literal)
msgid "??"
msgstr ""

#: xml/func.xml:6113(literal) xml/func.xml:6137(literal)
msgid "}?"
msgstr ""

#: xml/func.xml:6115(entry) xml/func.xml:6126(entry)
msgid "non-greedy version of <placeholder-1/><placeholder-2/><placeholder-3/>"
msgstr ""

#: xml/func.xml:6124(literal)
msgid ",}?"
msgstr ""

#: xml/func.xml:6139(entry)
msgid "non-greedy version of <placeholder-1/><placeholder-2/><placeholder-3/><placeholder-4/><placeholder-5/>"
msgstr ""

#: xml/func.xml:6149(para)
msgid "The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>are known as <firstterm>bounds</firstterm>. The numbers <replaceable>m</replaceable>and <replaceable>n</replaceable>within a bound are unsigned decimal integers with permissible values from 0 to 255 inclusive."
msgstr ""

#: xml/func.xml:6158(para)
msgid "<firstterm>Non-greedy</firstterm>quantifiers (available in AREs only) match the same possibilities as their corresponding normal ( <firstterm>greedy</firstterm>) counterparts, but prefer the smallest number rather than the largest number of matches. See <xref linkend=\"posix-matching-rules\">for more detail.</xref>"
msgstr ""

#: xml/func.xml:6168(para)
msgid "A quantifier cannot immediately follow another quantifier, e.g., <literal>**</literal>is invalid. A quantifier cannot begin an expression or subexpression or follow <literal>^</literal>or <literal>|</literal>."
msgstr ""

#: xml/func.xml:6176(title)
msgid "Regular Expression Constraints"
msgstr ""

#: xml/func.xml:6180(entry)
msgid "Constraint"
msgstr ""

#: xml/func.xml:6189(entry)
msgid "matches at the beginning of the string"
msgstr ""

#: xml/func.xml:6194(literal) xml/func.xml:6716(literal)
msgid "$"
msgstr ""

#: xml/func.xml:6196(entry)
msgid "matches at the end of the string"
msgstr ""

#: xml/func.xml:6200(literal)
msgid "(?="
msgstr ""

#: xml/func.xml:6205(firstterm)
msgid "positive lookahead"
msgstr ""

#: xml/func.xml:6204(entry)
msgid "<placeholder-1/>matches at any point where a substring matching <placeholder-2/>begins (AREs only)"
msgstr ""

#: xml/func.xml:6212(literal)
msgid "(?!"
msgstr ""

#: xml/func.xml:6217(firstterm)
msgid "negative lookahead"
msgstr ""

#: xml/func.xml:6216(entry)
msgid "<placeholder-1/>matches at any point where no substring matching <placeholder-2/>begins (AREs only)"
msgstr ""

#: xml/func.xml:6225(para)
msgid "Lookahead constraints cannot contain <firstterm>back references</firstterm>(see <xref linkend=\"posix-escape-sequences\">), and all parentheses within them are considered non-capturing.</xref>"
msgstr ""

#: xml/func.xml:6232(title)
msgid "Bracket Expressions"
msgstr ""

#: xml/func.xml:6233(para)
msgid "A <firstterm>bracket expression</firstterm>is a list of characters enclosed in <literal>[]</literal>. It normally matches any single character from the list (but see below). If the list begins with <literal>^</literal>, it matches any single character <emphasis>not</emphasis>from the rest of the list. If two characters in the list are separated by <literal>-</literal>, this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g., <literal>[0-9]</literal>in <acronym>ASCII</acronym>matches any decimal digit. It is illegal for two ranges to share an endpoint, e.g., <literal>a-c-e</literal>. Ranges are very collating-sequence-dependent, so portable programs should avoid relying on them."
msgstr ""

#: xml/func.xml:6251(para)
msgid "To include a literal <literal>]</literal>in the list, make it the first character (after <literal>^</literal>, if that is used). To include a literal <literal>-</literal>, make it the first or last character, or the second endpoint of a range. To use a literal <literal>-</literal>as the first endpoint of a range, enclose it in <literal>[.</literal>and <literal>.]</literal>to make it a collating element (see below). With the exception of these characters, some combinations using <literal>[</literal>(see next paragraphs), and escapes (AREs only), all other special characters lose their special significance within a bracket expression. In particular, <literal>\\</literal>is not special when following ERE or BRE rules, though it is special (as introducing an escape) in AREs."
msgstr ""

#: xml/func.xml:6271(para)
msgid "Within a bracket expression, a collating element (a character, a multiple-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in <literal>[.</literal>and <literal>.]</literal>stands for the sequence of characters of that collating element. The sequence is treated as a single element of the bracket expression's list. This allows a bracket expression containing a multiple-character collating element to match more than one character, e.g., if the collating sequence includes a <literal>ch</literal>collating element, then the RE <literal>[[.ch.]]*c</literal>matches the first five characters of <literal>chchcc</literal>."
msgstr ""

#: xml/func.xml:6287(para)
msgid "<productname>PostgreSQL</productname>currently does not support multi-character collating elements. This information describes possible future behavior."
msgstr ""

#: xml/func.xml:6292(para)
msgid "Within a bracket expression, a collating element enclosed in <literal>[=</literal>and <literal>=]</literal>is an <firstterm>equivalence class</firstterm>, standing for the sequences of characters of all collating elements equivalent to that one, including itself. (If there are no other equivalent collating elements, the treatment is as if the enclosing delimiters were <literal>[.</literal>and <literal>.]</literal>.) For example, if <literal>o</literal>and <literal>^</literal>are the members of an equivalence class, then <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and <literal>[o^]</literal>are all synonymous. An equivalence class cannot be an endpoint of a range."
msgstr ""

#: xml/func.xml:6310(para)
msgid "Within a bracket expression, the name of a character class enclosed in <literal>[:</literal>and <literal>:]</literal>stands for the list of all characters belonging to that class. Standard character class names are: <literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</literal>, <literal>cntrl</literal>, <literal>digit</literal>, <literal>graph</literal>, <literal>lower</literal>, <literal>print</literal>, <literal>punct</literal>, <literal>space</literal>, <literal>upper</literal>, <literal>xdigit</literal>. These stand for the character classes defined in <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>. A locale can provide others. A character class cannot be used as an endpoint of a range."
msgstr ""

#: xml/func.xml:6334(para)
msgid "There are two special cases of bracket expressions: the bracket expressions <literal>[[::]]</literal>and <literal>[[::]]</literal>are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an <literal>alnum</literal>character (as defined by <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>) or an underscore. This is an extension, compatible with but not specified by <acronym>POSIX</acronym>1003.2, and should be used with caution in software intended to be portable to other systems. The constraint escapes described below are usually preferable; they are no more standard, but are easier to type."
msgstr ""

#: xml/func.xml:6355(title)
msgid "Regular Expression Escapes"
msgstr ""

#: xml/func.xml:6356(para)
msgid "<firstterm>Escapes</firstterm>are special sequences beginning with <literal>\\</literal>followed by an alphanumeric character. Escapes come in several varieties: character entry, class shorthands, constraint escapes, and back references. A <literal>\\</literal>followed by an alphanumeric character but not constituting a valid escape is illegal in AREs. In EREs, there are no escapes: outside a bracket expression, a <literal>\\</literal>followed by an alphanumeric character merely stands for that character as an ordinary character, and inside a bracket expression, <literal>\\</literal>is an ordinary character. (The latter is the one actual incompatibility between EREs and AREs.)"
msgstr ""

#: xml/func.xml:6372(para)
msgid "<firstterm>Character-entry escapes</firstterm>exist to make it easier to specify non-printing and other inconvenient characters in REs. They are shown in <xref linkend=\"posix-character-entry-escapes-table\"> .</xref>"
msgstr ""

#: xml/func.xml:6378(para)
msgid "<firstterm>Class-shorthand escapes</firstterm>provide shorthands for certain commonly-used character classes. They are shown in <xref linkend=\"posix-class-shorthand-escapes-table\"> .</xref>"
msgstr ""

#: xml/func.xml:6384(para)
msgid "A <firstterm>constraint escape</firstterm>is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in <xref linkend=\"posix-constraint-escapes-table\"> .</xref>"
msgstr ""

#: xml/func.xml:6390(para)
msgid "A <firstterm>back reference</firstterm>( <literal>\\</literal><replaceable>n</replaceable>) matches the same string matched by the previous parenthesized subexpression specified by the number <replaceable>n</replaceable>(see <xref linkend=\"posix-constraint-backref-table\">). For example, <literal>([bc])\\1</literal>matches <literal>bb</literal>or <literal>cc</literal>but not <literal>bc</literal>or <literal>cb</literal>. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</xref>"
msgstr ""

#: xml/func.xml:6409(title)
msgid "Regular Expression Character-entry Escapes"
msgstr ""

#: xml/func.xml:6413(entry) xml/func.xml:6595(entry) xml/func.xml:6667(entry) xml/func.xml:6730(entry)
msgid "Escape"
msgstr ""

#: xml/func.xml:6420(literal)
msgid "\\a"
msgstr ""

#: xml/func.xml:6422(entry)
msgid "alert (bell) character, as in C"
msgstr ""

#: xml/func.xml:6426(literal)
msgid "\\b"
msgstr ""

#: xml/func.xml:6428(entry)
msgid "backspace, as in C"
msgstr ""

#: xml/func.xml:6432(literal)
msgid "\\B"
msgstr ""

#: xml/func.xml:6434(entry)
msgid "synonym for backslash ( <placeholder-1/>) to help reduce the need for backslash doubling"
msgstr ""

#: xml/func.xml:6440(literal)
msgid "\\c"
msgstr ""

#: xml/func.xml:6441(replaceable) xml/func.xml:6444(replaceable) xml/func.xml:6447(replaceable)
msgid "X"
msgstr ""

#: xml/func.xml:6443(entry)
msgid "(where <placeholder-1/>is any character) the character whose low-order 5 bits are the same as those of <placeholder-2/>, and whose other bits are all zero"
msgstr ""

#: xml/func.xml:6452(literal)
msgid "\\e"
msgstr ""

#: xml/func.xml:6456(literal)
msgid "ESC"
msgstr ""

#: xml/func.xml:6458(literal)
msgid "033"
msgstr ""

#: xml/func.xml:6454(entry)
msgid "the character whose collating-sequence name is <placeholder-1/>, or failing that, the character with octal value <placeholder-2/>"
msgstr ""

#: xml/func.xml:6462(literal)
msgid "\\f"
msgstr ""

#: xml/func.xml:6464(entry)
msgid "form feed, as in C"
msgstr ""

#: xml/func.xml:6468(literal)
msgid "\\n"
msgstr ""

#: xml/func.xml:6470(entry)
msgid "newline, as in C"
msgstr ""

#: xml/func.xml:6474(literal)
msgid "\\r"
msgstr ""

#: xml/func.xml:6476(entry)
msgid "carriage return, as in C"
msgstr ""

#: xml/func.xml:6480(literal)
msgid "\\t"
msgstr ""

#: xml/func.xml:6482(entry)
msgid "horizontal tab, as in C"
msgstr ""

#: xml/func.xml:6486(literal)
msgid "\\u"
msgstr ""

#: xml/func.xml:6487(replaceable) xml/func.xml:6490(replaceable) xml/func.xml:6494(replaceable)
msgid "wxyz"
msgstr ""

#: xml/func.xml:6493(literal) xml/func.xml:6505(literal) xml/func.xml:6523(literal)
msgid "0x"
msgstr ""

#: xml/func.xml:6489(entry)
msgid "(where <placeholder-1/>is exactly four hexadecimal digits) the character whose hexadecimal value is <placeholder-2/><placeholder-3/>"
msgstr ""

#: xml/func.xml:6498(literal)
msgid "\\U"
msgstr ""

#: xml/func.xml:6499(replaceable) xml/func.xml:6502(replaceable) xml/func.xml:6506(replaceable)
msgid "stuvwxyz"
msgstr ""

#: xml/func.xml:6501(entry)
msgid "(where <placeholder-1/>is exactly eight hexadecimal digits) the character whose hexadecimal value is <placeholder-2/><placeholder-3/>"
msgstr ""

#: xml/func.xml:6510(literal)
msgid "\\v"
msgstr ""

#: xml/func.xml:6512(entry)
msgid "vertical tab, as in C"
msgstr ""

#: xml/func.xml:6516(literal)
msgid "\\x"
msgstr ""

#: xml/func.xml:6517(replaceable) xml/func.xml:6520(replaceable) xml/func.xml:6524(replaceable)
msgid "hhh"
msgstr ""

#: xml/func.xml:6519(entry)
msgid "(where <placeholder-1/>is any sequence of hexadecimal digits) the character whose hexadecimal value is <placeholder-2/><placeholder-3/>(a single character no matter how many hexadecimal digits are used)"
msgstr ""

#: xml/func.xml:6530(literal)
msgid "\\0"
msgstr ""

#: xml/func.xml:6532(entry)
msgid "the character whose value is <placeholder-1/>(the null byte)"
msgstr ""

#: xml/func.xml:6538(replaceable) xml/func.xml:6541(replaceable) xml/func.xml:6546(replaceable)
msgid "xy"
msgstr ""

#: xml/func.xml:6543(firstterm) xml/func.xml:6556(firstterm)
msgid "back reference"
msgstr ""

#: xml/func.xml:6540(entry)
msgid "(where <placeholder-1/>is exactly two octal digits, and is not a <placeholder-2/>) the character whose octal value is <placeholder-3/><placeholder-4/>"
msgstr ""

#: xml/func.xml:6551(replaceable) xml/func.xml:6554(replaceable) xml/func.xml:6559(replaceable)
msgid "xyz"
msgstr ""

#: xml/func.xml:6553(entry)
msgid "(where <placeholder-1/>is exactly three octal digits, and is not a <placeholder-2/>) the character whose octal value is <placeholder-3/><placeholder-4/>"
msgstr ""

#: xml/func.xml:6564(para)
msgid "Hexadecimal digits are <literal>0</literal>- <literal>9</literal>, <literal>a</literal>- <literal>f</literal>, and <literal>A</literal>- <literal>F</literal>. Octal digits are <literal>0</literal>- <literal>7</literal>."
msgstr ""

#: xml/func.xml:6573(para)
msgid "Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example <literal>\\u1234</literal>means the character <literal>U+1234</literal>. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data."
msgstr ""

#: xml/func.xml:6584(para)
msgid "The character-entry escapes are always taken as ordinary characters. For example, <literal>\\135</literal>is <literal>]</literal>in ASCII, but <literal>\\135</literal>does not terminate a bracket expression."
msgstr ""

#: xml/func.xml:6591(title)
msgid "Regular Expression Class-shorthand Escapes"
msgstr ""

#: xml/func.xml:6602(literal)
msgid "\\d"
msgstr ""

#: xml/func.xml:6605(literal)
msgid "[[:digit:]]"
msgstr ""

#: xml/func.xml:6610(literal)
msgid "\\s"
msgstr ""

#: xml/func.xml:6613(literal)
msgid "[[:space:]]"
msgstr ""

#: xml/func.xml:6618(literal)
msgid "\\w"
msgstr ""

#: xml/func.xml:6621(literal)
msgid "[[:alnum:]_]"
msgstr ""

#: xml/func.xml:6620(entry) xml/func.xml:6644(entry)
msgid "<placeholder-1/>(note underscore is included)"
msgstr ""

#: xml/func.xml:6626(literal)
msgid "\\D"
msgstr ""

#: xml/func.xml:6629(literal)
msgid "[^[:digit:]]"
msgstr ""

#: xml/func.xml:6634(literal)
msgid "\\S"
msgstr ""

#: xml/func.xml:6637(literal)
msgid "[^[:space:]]"
msgstr ""

#: xml/func.xml:6642(literal)
msgid "\\W"
msgstr ""

#: xml/func.xml:6645(literal)
msgid "[^[:alnum:]_]"
msgstr ""

#: xml/func.xml:6651(para)
msgid "Within bracket expressions, <literal>\\d</literal>, <literal>\\s</literal>, and <literal>\\w</literal>lose their outer brackets, and <literal>\\D</literal>, <literal>\\S</literal>, and <literal>\\W</literal>are illegal. (So, for example, <literal>[a-c\\d]</literal>is equivalent to <literal>[a-c[:digit:]]</literal>. Also, <literal>[a-c\\D]</literal>, which is equivalent to <literal>[a-c^[:digit:]]</literal>, is illegal.)"
msgstr ""

#: xml/func.xml:6663(title)
msgid "Regular Expression Constraint Escapes"
msgstr ""

#: xml/func.xml:6674(literal)
msgid "\\A"
msgstr ""

#: xml/func.xml:6678(xref) xml/func.xml:6714(xref)
msgid "for how this differs from <placeholder-1/>)"
msgstr ""

#: xml/func.xml:6676(entry)
msgid "matches only at the beginning of the string (see <placeholder-1/>"
msgstr ""

#: xml/func.xml:6684(literal)
msgid "\\m"
msgstr ""

#: xml/func.xml:6686(entry)
msgid "matches only at the beginning of a word"
msgstr ""

#: xml/func.xml:6691(literal)
msgid "\\M"
msgstr ""

#: xml/func.xml:6693(entry)
msgid "matches only at the end of a word"
msgstr ""

#: xml/func.xml:6697(literal)
msgid "\\y"
msgstr ""

#: xml/func.xml:6699(entry)
msgid "matches only at the beginning or end of a word"
msgstr ""

#: xml/func.xml:6704(literal)
msgid "\\Y"
msgstr ""

#: xml/func.xml:6706(entry)
msgid "matches only at a point that is not the beginning or end of a word"
msgstr ""

#: xml/func.xml:6711(literal)
msgid "\\Z"
msgstr ""

#: xml/func.xml:6713(entry)
msgid "matches only at the end of the string (see <placeholder-1/>"
msgstr ""

#: xml/func.xml:6721(para)
msgid "A word is defined as in the specification of <literal>[[::]]</literal>and <literal>[[::]]</literal>above. Constraint escapes are illegal within bracket expressions."
msgstr ""

#: xml/func.xml:6726(title)
msgid "Regular Expression Back References"
msgstr ""

#: xml/func.xml:6740(entry)
msgid "(where <placeholder-1/>is a nonzero digit) a back reference to the <placeholder-2/>'th subexpression"
msgstr ""

#: xml/func.xml:6749(replaceable) xml/func.xml:6756(replaceable) xml/func.xml:6759(replaceable)
msgid "mnn"
msgstr ""

#: xml/func.xml:6754(replaceable)
msgid "nn"
msgstr ""

#: xml/func.xml:6751(entry)
msgid "(where <placeholder-1/>is a nonzero digit, and <placeholder-2/>is some more digits, and the decimal value <placeholder-3/>is not greater than the number of closing capturing parentheses seen so far) a back reference to the <placeholder-4/>'th subexpression"
msgstr ""

#: xml/func.xml:6766(para)
msgid "There is an inherent ambiguity between octal character-entry escapes and back references, which is resolved by the following heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e., the number is in the legal range for a back reference), and otherwise is taken as octal."
msgstr ""

#: xml/func.xml:6779(title)
msgid "Regular Expression Metasyntax"
msgstr ""

#: xml/func.xml:6780(para)
msgid "In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available."
msgstr ""

#: xml/func.xml:6783(para)
msgid "An RE can begin with one of two special <firstterm>director</firstterm>prefixes. If an RE begins with <literal>***:</literal>, the rest of the RE is taken as an ARE. (This normally has no effect in <productname>PostgreSQL</productname>, since REs are assumed to be AREs; but it does have an effect if ERE or BRE mode had been specified by the <replaceable>flags</replaceable>parameter to a regex function.) If an RE begins with <literal>***=</literal>, the rest of the RE is taken to be a literal string, with all characters considered ordinary characters."
msgstr ""

#: xml/func.xml:6796(para)
msgid "An ARE can begin with <firstterm>embedded options</firstterm>: a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>(where <replaceable>xyz</replaceable>is one or more alphabetic characters) specifies options affecting the rest of the RE. These options override any previously determined options in particular, they can override the case-sensitivity behavior implied by a regex operator, or the <replaceable>flags</replaceable>parameter to a regex function. The available option letters are shown in <xref linkend=\"posix-embedded-options-table\">. Note that these same option letters are used in the <replaceable>flags</replaceable>parameters of regex functions.</xref>"
msgstr ""

#: xml/func.xml:6813(title)
msgid "ARE Embedded-option Letters"
msgstr ""

#: xml/func.xml:6817(entry)
msgid "Option"
msgstr ""

#: xml/func.xml:6826(entry)
msgid "rest of RE is a BRE"
msgstr ""

#: xml/func.xml:6832(entry)
msgid "case-sensitive matching (overrides operator type)"
msgstr ""

#: xml/func.xml:6837(literal)
msgid "e"
msgstr ""

#: xml/func.xml:6839(entry)
msgid "rest of RE is an ERE"
msgstr ""

#: xml/func.xml:6843(literal)
msgid "i"
msgstr ""

#: xml/func.xml:6846(xref)
msgid ") (overrides operator type)"
msgstr ""

#: xml/func.xml:6845(entry)
msgid "case-insensitive matching (see <placeholder-1/>"
msgstr ""

#: xml/func.xml:6853(entry)
msgid "historical synonym for <placeholder-1/>"
msgstr ""

#: xml/func.xml:6860(entry)
msgid "newline-sensitive matching (see <placeholder-1/>"
msgstr ""

#: xml/func.xml:6866(literal)
msgid "p"
msgstr ""

#: xml/func.xml:6868(entry)
msgid "partial newline-sensitive matching (see <placeholder-1/>"
msgstr ""

#: xml/func.xml:6874(literal)
msgid "q"
msgstr ""

#: xml/func.xml:6877(quote)
msgid "quoted"
msgstr ""

#: xml/func.xml:6876(entry)
msgid "rest of RE is a literal ( <placeholder-1/>) string, all ordinary characters"
msgstr ""

#: xml/func.xml:6884(entry)
msgid "non-newline-sensitive matching (default)"
msgstr ""

#: xml/func.xml:6889(literal)
msgid "t"
msgstr ""

#: xml/func.xml:6891(entry)
msgid "tight syntax (default; see below)"
msgstr ""

#: xml/func.xml:6895(literal)
msgid "w"
msgstr ""

#: xml/func.xml:6898(quote)
msgid "weird"
msgstr ""

#: xml/func.xml:6897(entry)
msgid "inverse partial newline-sensitive ( <placeholder-1/>) matching (see <placeholder-2/>"
msgstr ""

#: xml/func.xml:6906(entry)
msgid "expanded syntax (see below)"
msgstr ""

#: xml/func.xml:6911(para)
msgid "Embedded options take effect at the <literal>)</literal>terminating the sequence. They can appear only at the start of an ARE (after the <literal>***:</literal>director if any)."
msgstr ""

#: xml/func.xml:6928(para)
msgid "a white-space character or <literal>#</literal>preceded by <literal>\\</literal>is retained"
msgstr ""

#: xml/func.xml:6933(para)
msgid "white space or <literal>#</literal>within a bracket expression is retained"
msgstr ""

#: xml/func.xml:6938(para)
msgid "white space and comments cannot appear within multi-character symbols, such as <literal>(?:</literal>"
msgstr ""

#: xml/func.xml:6915(para)
msgid "In addition to the usual ( <firstterm>tight</firstterm>) RE syntax, in which all characters are significant, there is an <firstterm>expanded</firstterm>syntax, available by specifying the embedded <literal>x</literal>option. In the expanded syntax, white-space characters in the RE are ignored, as are all characters between a <literal>#</literal>and the following newline (or the end of the RE). This permits paragraphing and commenting a complex RE. There are three exceptions to that basic rule: <placeholder-1/>For this purpose, white-space characters are blank, tab, newline, and any character that belongs to the <replaceable>space</replaceable>character class."
msgstr ""

#: xml/func.xml:6945(para)
msgid "Finally, in an ARE, outside bracket expressions, the sequence <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>(where <replaceable>ttt</replaceable>is any text not containing a <literal>)</literal>) is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols, like <literal>(?:</literal>. Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead."
msgstr ""

#: xml/func.xml:6957(para)
msgid "<emphasis>None</emphasis>of these metasyntax extensions is available if an initial <literal>***=</literal>director has specified that the user's input be treated as a literal string rather than as an RE."
msgstr ""

#: xml/func.xml:6965(title)
msgid "Regular Expression Matching Rules"
msgstr ""

#: xml/func.xml:6966(para)
msgid "In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, either the longest possible match or the shortest possible match will be taken, depending on whether the RE is <firstterm>greedy</firstterm>or <firstterm>non-greedy</firstterm>."
msgstr ""

#: xml/func.xml:6978(para)
msgid "Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway)."
msgstr ""

#: xml/func.xml:6983(para)
msgid "Adding parentheses around an RE does not change its greediness."
msgstr ""

#: xml/func.xml:6987(para)
msgid "A quantified atom with a fixed-repetition quantifier ( <literal>{</literal><replaceable>m</replaceable><literal>}</literal>or <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>) has the same greediness (possibly none) as the atom itself."
msgstr ""

#: xml/func.xml:6998(para)
msgid "A quantified atom with other normal quantifiers (including <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>with <replaceable>m</replaceable>equal to <replaceable>n</replaceable>) is greedy (prefers longest match)."
msgstr ""

#: xml/func.xml:7010(para)
msgid "A quantified atom with a non-greedy quantifier (including <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>with <replaceable>m</replaceable>equal to <replaceable>n</replaceable>) is non-greedy (prefers shortest match)."
msgstr ""

#: xml/func.xml:7022(para)
msgid "A branch that is, an RE that has no top-level <literal>|</literal>operator has the same greediness as the first quantified atom in it that has a greediness attribute."
msgstr ""

#: xml/func.xml:7028(para)
msgid "An RE consisting of two or more branches connected by the <literal>|</literal>operator is always greedy."
msgstr ""

#: xml/func.xml:6974(para)
msgid "Whether an RE is greedy or not is determined by the following rules: <placeholder-1/>"
msgstr ""

#: xml/func.xml:7033(para)
msgid "The above rules associate greediness attributes not only with individual quantified atoms, but with branches and entire REs that contain quantified atoms. What that means is that the matching is done in such a way that the branch, or whole RE, matches the longest or shortest possible substring <emphasis>as a whole</emphasis>. Once the length of the entire match is determined, the part of it that matches any particular subexpression is determined on the basis of the greediness attribute of that subexpression, with subexpressions starting earlier in the RE taking priority over ones starting later."
msgstr ""

#: xml/func.xml:7045(para)
msgid "An example of what this means: <screen>SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})'); \n        <lineannotation>Result:</lineannotation>\n        <computeroutput>123</computeroutput>SELECT\n        SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})'); \n        <lineannotation>Result:</lineannotation>\n        <computeroutput>1</computeroutput></screen>In the first case, the RE as a whole is greedy because <literal>Y*</literal>is greedy. It can match beginning at the <literal>Y</literal>, and it matches the longest possible string starting there, i.e., <literal>Y123</literal>. The output is the parenthesized part of that, or <literal>123</literal>. In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>is non-greedy. It can match beginning at the <literal>Y</literal>, and it matches the shortest possible string starting there, i.e., <literal>Y1</literal>. The subexpression <literal>[0-9]{1,3}</literal>is greedy but it cannot change the decision as to the overall match length; so it is forced to match just <literal>1</literal>."
msgstr ""

#: xml/func.xml:7070(para)
msgid "In short, when an RE contains both greedy and non-greedy subexpressions, the total match length is either as long as possible or as short as possible, according to the attribute assigned to the whole RE. The attributes assigned to the subexpressions only affect how much of that match they are allowed to <quote>eat</quote>relative to each other."
msgstr ""

#: xml/func.xml:7077(para)
msgid "The quantifiers <literal>{1,1}</literal>and <literal>{1,1}?</literal>can be used to force greediness or non-greediness, respectively, on a subexpression or a whole RE. This is useful when you need the whole RE to have a greediness attribute different from what's deduced from its elements. As an example, suppose that we are trying to separate a string containing some digits into the digits and the parts before and after them. We might try to do that like this: <screen>SELECT regexp_matches('abc01234xyz',\n        '(.*)(\\d+)(.*)'); \n        <lineannotation>Result:</lineannotation>\n        <computeroutput>\n        {abc0123,4,xyz}</computeroutput></screen>That didn't work: the first <literal>.*</literal>is greedy so it <quote>eats</quote>as much as it can, leaving the <literal>\\d+</literal>to match at the last possible place, the last digit. We might try to fix that by making it non-greedy: <screen>SELECT regexp_matches('abc01234xyz',\n        '(.*?)(\\d+)(.*)'); \n        <lineannotation>Result:</lineannotation>\n        <computeroutput>{abc,0,\"\"}</computeroutput></screen>That didn't work either, because now the RE as a whole is non-greedy and so it ends the overall match as soon as possible. We can get what we want by forcing the RE as a whole to be greedy: <screen>SELECT regexp_matches('abc01234xyz',\n        '(?:(.*?)(\\d+)(.*)){1,1}'); \n        <lineannotation>Result:</lineannotation>\n        <computeroutput>\n        {abc,01234,xyz}</computeroutput></screen>Controlling the RE's overall greediness separately from its components' greediness allows great flexibility in handling variable-length patterns."
msgstr ""

#: xml/func.xml:7114(para)
msgid "When deciding what is a longer or shorter match, match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example: <literal>bb*</literal>matches the three middle characters of <literal>abbbc</literal>; <literal>(week|wee)(night|knights)</literal>matches all ten characters of <literal>weeknights</literal>; when <literal>(.*).*</literal>is matched against <literal>abc</literal>the parenthesized subexpression matches all three characters; and when <literal>(a*)*</literal>is matched against <literal>bc</literal>both the whole RE and the parenthesized subexpression match an empty string."
msgstr ""

#: xml/func.xml:7130(para)
msgid "If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, e.g., <literal>x</literal>becomes <literal>[xX]</literal>. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, e.g., <literal>[x]</literal>becomes <literal>[xX]</literal>and <literal>[^x]</literal>becomes <literal>[^xX]</literal>."
msgstr ""

#: xml/func.xml:7144(para)
msgid "If newline-sensitive matching is specified, <literal>.</literal>and bracket expressions using <literal>^</literal>will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and <literal>^</literal>and <literal>$</literal>will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. But the ARE escapes <literal>\\A</literal>and <literal>\\Z</literal>continue to match beginning or end of string <emphasis>only</emphasis>."
msgstr ""

#: xml/func.xml:7158(para)
msgid "If partial newline-sensitive matching is specified, this affects <literal>.</literal>and bracket expressions as with newline-sensitive matching, but not <literal>^</literal>and <literal>$</literal>."
msgstr ""

#: xml/func.xml:7164(para)
msgid "If inverse partial newline-sensitive matching is specified, this affects <literal>^</literal>and <literal>$</literal>as with newline-sensitive matching, but not <literal>.</literal>and bracket expressions. This isn't very useful but is provided for symmetry."
msgstr ""

#: xml/func.xml:7173(title)
msgid "Limits and Compatibility"
msgstr ""

#: xml/func.xml:7174(para)
msgid "No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs."
msgstr ""

#: xml/func.xml:7179(para)
msgid "The only feature of AREs that is actually incompatible with POSIX EREs is that <literal>\\</literal>does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the <literal>***</literal>syntax of directors likewise is outside the POSIX syntax for both BREs and EREs."
msgstr ""

#: xml/func.xml:7187(para)
msgid "Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include <literal>\\b</literal>, <literal>\\B</literal>, the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead constraints, and the longest/shortest-match (rather than first-match) matching semantics."
msgstr ""

#: xml/func.xml:7204(para)
msgid "In AREs, <literal>\\</literal>followed by an alphanumeric character is either an escape or an error, while in previous releases, it was just another way of writing the alphanumeric. This should not be much of a problem because there was no reason to write such a sequence in earlier releases."
msgstr ""

#: xml/func.xml:7213(para)
msgid "In AREs, <literal>\\</literal>remains a special character within <literal>[]</literal>, so a literal <literal>\\</literal>within a bracket expression must be written <literal>\\\\</literal>."
msgstr ""

#: xml/func.xml:7199(para)
msgid "Two significant incompatibilities exist between AREs and the ERE syntax recognized by pre-7.4 releases of <productname>PostgreSQL</productname>: <placeholder-1/>"
msgstr ""

#: xml/func.xml:7223(title)
msgid "Basic Regular Expressions"
msgstr ""

#: xml/func.xml:7224(para)
msgid "BREs differ from EREs in several respects. In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are <literal>\\{</literal>and <literal>\\}</literal>, with <literal>{</literal>and <literal>}</literal>by themselves ordinary characters. The parentheses for nested subexpressions are <literal>\\(</literal>and <literal>\\)</literal>, with <literal>(</literal>and <literal>)</literal>by themselves ordinary characters. <literal>^</literal>is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, <literal>$</literal>is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and <literal>*</literal>is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading <literal>^</literal>). Finally, single-digit back references are available, and <literal>\\</literal>and <literal>\\</literal>are synonyms for <literal>[[::]]</literal>and <literal>[[::]]</literal>respectively; no other escapes are available in BREs."
msgstr ""

#: xml/func.xml:7259(title)
msgid "Data Type Formatting Functions"
msgstr ""

#: xml/func.xml:7261(primary)
msgid "formatting"
msgstr ""

#: xml/func.xml:7263(para)
msgid "The <productname>PostgreSQL</productname>formatting functions provide a powerful set of tools for converting various data types (date/time, integer, floating point, numeric) to formatted strings and for converting from formatted strings to specific data types. <xref linkend=\"functions-formatting-table\">lists them. These functions all follow a common calling convention: the first argument is the value to be formatted and the second argument is a template that defines the output or input format.</xref>"
msgstr ""

#: xml/func.xml:7274(para)
msgid "A single-argument <function>to_timestamp</function>function is also available; it accepts a <type>double precision</type>argument and converts from Unix epoch (seconds since 1970-01-01 00:00:00+00) to <type>timestamp with time zone</type>. ( <type>Integer</type>Unix epochs are implicitly cast to <type>double precision</type>.)"
msgstr ""

#: xml/func.xml:7283(title)
msgid "Formatting Functions"
msgstr ""

#: xml/func.xml:7297(primary) xml/func.xml:7350(function) xml/func.xml:8316(function)
msgid "to_char"
msgstr ""

#: xml/func.xml:7301(type) xml/func.xml:8914(type) xml/func.xml:8915(type) xml/func.xml:8936(type) xml/func.xml:9033(type) xml/func.xml:9082(type) xml/func.xml:9086(type) xml/func.xml:9129(type) xml/func.xml:9191(type) xml/func.xml:9322(type) xml/func.xml:9443(type)
msgid "timestamp"
msgstr ""

#: xml/func.xml:7300(function) xml/func.xml:7317(function) xml/func.xml:7334(function) xml/func.xml:7365(function)
msgid "to_char( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7308(entry)
msgid "convert time stamp to string"
msgstr ""

#: xml/func.xml:7310(literal)
msgid "to_char(current_timestamp, 'HH12:MI:SS')"
msgstr ""

#: xml/func.xml:7318(type) xml/func.xml:8919(type) xml/func.xml:8940(type) xml/func.xml:9056(type) xml/func.xml:9104(type) xml/func.xml:9108(type) xml/func.xml:9150(type) xml/func.xml:9211(type) xml/func.xml:9232(type) xml/func.xml:9236(type) xml/func.xml:9254(type) xml/func.xml:9258(type) xml/func.xml:9276(type) xml/func.xml:9280(type) xml/func.xml:9383(type)
msgid "interval"
msgstr ""

#: xml/func.xml:7325(entry)
msgid "convert interval to string"
msgstr ""

#: xml/func.xml:7327(literal)
msgid "to_char(interval '15h2m12s', 'HH24:MI:SS')"
msgstr ""

#: xml/func.xml:7342(entry)
msgid "convert integer to string"
msgstr ""

#: xml/func.xml:7344(literal)
msgid "to_char(125, '999')"
msgstr ""

#: xml/func.xml:7349(literal)
msgid "<placeholder-1/>( <placeholder-2/>, <placeholder-3/>)"
msgstr ""

#: xml/func.xml:7357(entry)
msgid "convert real/double precision to string"
msgstr ""

#: xml/func.xml:7359(literal)
msgid "to_char(125.8::real, '999D9')"
msgstr ""

#: xml/func.xml:7373(entry)
msgid "convert numeric to string"
msgstr ""

#: xml/func.xml:7375(literal)
msgid "to_char(-125.8, '999D99S')"
msgstr ""

#: xml/func.xml:7381(primary) xml/func.xml:7783(function)
msgid "to_date"
msgstr ""

#: xml/func.xml:7384(function)
msgid "to_date( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7390(type) xml/func.xml:8980(type) xml/func.xml:9173(type) xml/func.xml:9347(type) xml/func.xml:10302(primary)
msgid "date"
msgstr ""

#: xml/func.xml:7392(entry)
msgid "convert string to date"
msgstr ""

#: xml/func.xml:7394(literal)
msgid "to_date('05Dec2000', 'DDMonYYYY')"
msgstr ""

#: xml/func.xml:7400(primary)
msgid "to_number"
msgstr ""

#: xml/func.xml:7403(function)
msgid "to_number( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7411(entry)
msgid "convert string to numeric"
msgstr ""

#: xml/func.xml:7413(literal)
msgid "to_number('12,454.8-', '99G999D9S')"
msgstr ""

#: xml/func.xml:7420(primary) xml/func.xml:7784(function)
msgid "to_timestamp"
msgstr ""

#: xml/func.xml:7423(function)
msgid "to_timestamp( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7429(type) xml/func.xml:7445(type) xml/func.xml:8961(type) xml/func.xml:9016(type) xml/func.xml:9481(type) xml/func.xml:9505(type) xml/func.xml:9524(type) xml/func.xml:9563(type) xml/func.xml:10231(type) xml/func.xml:10240(type)
msgid "timestamp with time zone"
msgstr ""

#: xml/func.xml:7431(entry)
msgid "convert string to time stamp"
msgstr ""

#: xml/func.xml:7433(literal)
msgid "to_timestamp('05Dec2000', 'DDMonYYYY')"
msgstr ""

#: xml/func.xml:7440(function)
msgid "to_timestamp( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:7447(entry)
msgid "convert Unix epoch to time stamp"
msgstr ""

#: xml/func.xml:7449(literal)
msgid "to_timestamp(1284352323)"
msgstr ""

#: xml/func.xml:7455(para)
msgid "In a <function>to_char</function>output template string, there are certain patterns that are recognized and replaced with appropriately-formatted data based on the given value. Any text that is not a template pattern is simply copied verbatim. Similarly, in an input template string (for the other functions), template patterns identify the values to be supplied by the input data string."
msgstr ""

#: xml/func.xml:7464(xref)
msgid "shows the template patterns available for formatting date and time values."
msgstr ""

#: xml/func.xml:7469(title)
msgid "Template Patterns for Date/Time Formatting"
msgstr ""

#: xml/func.xml:7473(entry) xml/func.xml:8101(entry)
msgid "Pattern"
msgstr ""

#: xml/func.xml:7480(literal)
msgid "HH"
msgstr ""

#: xml/func.xml:7482(entry) xml/func.xml:7488(entry)
msgid "hour of day (01-12)"
msgstr ""

#: xml/func.xml:7486(literal)
msgid "HH12"
msgstr ""

#: xml/func.xml:7492(literal)
msgid "HH24"
msgstr ""

#: xml/func.xml:7494(entry)
msgid "hour of day (00-23)"
msgstr ""

#: xml/func.xml:7498(literal) xml/func.xml:8161(literal)
msgid "MI"
msgstr ""

#: xml/func.xml:7500(entry)
msgid "minute (00-59)"
msgstr ""

#: xml/func.xml:7504(literal)
msgid "SS"
msgstr ""

#: xml/func.xml:7506(entry)
msgid "second (00-59)"
msgstr ""

#: xml/func.xml:7510(literal)
msgid "MS"
msgstr ""

#: xml/func.xml:7512(entry)
msgid "millisecond (000-999)"
msgstr ""

#: xml/func.xml:7516(literal)
msgid "US"
msgstr ""

#: xml/func.xml:7518(entry)
msgid "microsecond (000000-999999)"
msgstr ""

#: xml/func.xml:7522(literal)
msgid "SSSS"
msgstr ""

#: xml/func.xml:7524(entry)
msgid "seconds past midnight (0-86399)"
msgstr ""

#: xml/func.xml:7528(literal)
msgid "AM"
msgstr ""

#: xml/func.xml:7529(literal)
msgid "am"
msgstr ""

#: xml/func.xml:7530(literal)
msgid "PM"
msgstr ""

#: xml/func.xml:7531(literal)
msgid "pm"
msgstr ""

#: xml/func.xml:7527(entry) xml/func.xml:7535(entry) xml/func.xml:7601(entry) xml/func.xml:7609(entry)
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/>or <placeholder-4/>"
msgstr ""

#: xml/func.xml:7532(entry)
msgid "meridiem indicator (without periods)"
msgstr ""

#: xml/func.xml:7536(literal)
msgid "A.M."
msgstr ""

#: xml/func.xml:7537(literal)
msgid "a.m."
msgstr ""

#: xml/func.xml:7538(literal)
msgid "P.M."
msgstr ""

#: xml/func.xml:7539(literal)
msgid "p.m."
msgstr ""

#: xml/func.xml:7540(entry)
msgid "meridiem indicator (with periods)"
msgstr ""

#: xml/func.xml:7544(literal)
msgid "Y,YYY"
msgstr ""

#: xml/func.xml:7546(entry)
msgid "year (4 or more digits) with comma"
msgstr ""

#: xml/func.xml:7550(literal)
msgid "YYYY"
msgstr ""

#: xml/func.xml:7552(entry)
msgid "year (4 or more digits)"
msgstr ""

#: xml/func.xml:7556(literal)
msgid "YYY"
msgstr ""

#: xml/func.xml:7558(entry)
msgid "last 3 digits of year"
msgstr ""

#: xml/func.xml:7562(literal)
msgid "YY"
msgstr ""

#: xml/func.xml:7564(entry)
msgid "last 2 digits of year"
msgstr ""

#: xml/func.xml:7568(literal)
msgid "Y"
msgstr ""

#: xml/func.xml:7570(entry)
msgid "last digit of year"
msgstr ""

#: xml/func.xml:7574(literal)
msgid "IYYY"
msgstr ""

#: xml/func.xml:7576(entry)
msgid "ISO 8601 week-numbering year (4 or more digits)"
msgstr ""

#: xml/func.xml:7581(literal)
msgid "IYY"
msgstr ""

#: xml/func.xml:7583(entry)
msgid "last 3 digits of ISO 8601 week-numbering year"
msgstr ""

#: xml/func.xml:7588(literal)
msgid "IY"
msgstr ""

#: xml/func.xml:7590(entry)
msgid "last 2 digits of ISO 8601 week-numbering year"
msgstr ""

#: xml/func.xml:7595(literal)
msgid "I"
msgstr ""

#: xml/func.xml:7597(entry)
msgid "last digit of ISO 8601 week-numbering year"
msgstr ""

#: xml/func.xml:7602(literal)
msgid "BC"
msgstr ""

#: xml/func.xml:7603(literal)
msgid "bc"
msgstr ""

#: xml/func.xml:7604(literal)
msgid "AD"
msgstr ""

#: xml/func.xml:7605(literal)
msgid "ad"
msgstr ""

#: xml/func.xml:7606(entry)
msgid "era indicator (without periods)"
msgstr ""

#: xml/func.xml:7610(literal)
msgid "B.C."
msgstr ""

#: xml/func.xml:7611(literal)
msgid "b.c."
msgstr ""

#: xml/func.xml:7612(literal)
msgid "A.D."
msgstr ""

#: xml/func.xml:7613(literal)
msgid "a.d."
msgstr ""

#: xml/func.xml:7614(entry)
msgid "era indicator (with periods)"
msgstr ""

#: xml/func.xml:7618(literal)
msgid "MONTH"
msgstr ""

#: xml/func.xml:7620(entry)
msgid "full upper case month name (blank-padded to 9 chars)"
msgstr ""

#: xml/func.xml:7625(literal)
msgid "Month"
msgstr ""

#: xml/func.xml:7627(entry)
msgid "full capitalized month name (blank-padded to 9 chars)"
msgstr ""

#: xml/func.xml:7632(literal) xml/func.xml:9340(parameter) xml/func.xml:9430(parameter) xml/func.xml:9464(parameter) xml/func.xml:9954(literal) xml/func.xml:10167(literal)
msgid "month"
msgstr ""

#: xml/func.xml:7634(entry)
msgid "full lower case month name (blank-padded to 9 chars)"
msgstr ""

#: xml/func.xml:7639(literal)
msgid "MON"
msgstr ""

#: xml/func.xml:7641(entry)
msgid "abbreviated upper case month name (3 chars in English, localized lengths vary)"
msgstr ""

#: xml/func.xml:7646(literal)
msgid "Mon"
msgstr ""

#: xml/func.xml:7648(entry)
msgid "abbreviated capitalized month name (3 chars in English, localized lengths vary)"
msgstr ""

#: xml/func.xml:7653(literal)
msgid "mon"
msgstr ""

#: xml/func.xml:7655(entry)
msgid "abbreviated lower case month name (3 chars in English, localized lengths vary)"
msgstr ""

#: xml/func.xml:7660(literal)
msgid "MM"
msgstr ""

#: xml/func.xml:7662(entry)
msgid "month number (01-12)"
msgstr ""

#: xml/func.xml:7666(literal)
msgid "DAY"
msgstr ""

#: xml/func.xml:7668(entry)
msgid "full upper case day name (blank-padded to 9 chars)"
msgstr ""

#: xml/func.xml:7673(literal)
msgid "Day"
msgstr ""

#: xml/func.xml:7675(entry)
msgid "full capitalized day name (blank-padded to 9 chars)"
msgstr ""

#: xml/func.xml:7680(literal) xml/func.xml:9342(parameter) xml/func.xml:9432(parameter) xml/func.xml:9466(parameter) xml/func.xml:9752(literal) xml/func.xml:10161(literal)
msgid "day"
msgstr ""

#: xml/func.xml:7682(entry)
msgid "full lower case day name (blank-padded to 9 chars)"
msgstr ""

#: xml/func.xml:7687(literal)
msgid "DY"
msgstr ""

#: xml/func.xml:7689(entry)
msgid "abbreviated upper case day name (3 chars in English, localized lengths vary)"
msgstr ""

#: xml/func.xml:7694(literal)
msgid "Dy"
msgstr ""

#: xml/func.xml:7696(entry)
msgid "abbreviated capitalized day name (3 chars in English, localized lengths vary)"
msgstr ""

#: xml/func.xml:7701(literal)
msgid "dy"
msgstr ""

#: xml/func.xml:7703(entry)
msgid "abbreviated lower case day name (3 chars in English, localized lengths vary)"
msgstr ""

#: xml/func.xml:7708(literal)
msgid "DDD"
msgstr ""

#: xml/func.xml:7710(entry)
msgid "day of year (001-366)"
msgstr ""

#: xml/func.xml:7714(literal)
msgid "IDDD"
msgstr ""

#: xml/func.xml:7716(entry)
msgid "day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of the first ISO week)"
msgstr ""

#: xml/func.xml:7722(literal)
msgid "DD"
msgstr ""

#: xml/func.xml:7724(entry)
msgid "day of month (01-31)"
msgstr ""

#: xml/func.xml:7728(literal) xml/func.xml:8149(literal)
msgid "D"
msgstr ""

#: xml/func.xml:7732(literal) xml/func.xml:7740(literal) xml/func.xml:9863(computeroutput) xml/func.xml:10066(computeroutput)
msgid "7"
msgstr ""

#: xml/func.xml:7730(entry)
msgid "day of the week, Sunday ( <placeholder-1/>) to Saturday ( <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7736(literal)
msgid "ID"
msgstr ""

#: xml/func.xml:7738(entry)
msgid "ISO 8601 day of the week, Monday ( <placeholder-1/>) to Sunday ( <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7744(literal)
msgid "W"
msgstr ""

#: xml/func.xml:7746(entry)
msgid "week of month (1-5) (the first week starts on the first day of the month)"
msgstr ""

#: xml/func.xml:7751(literal)
msgid "WW"
msgstr ""

#: xml/func.xml:7753(entry)
msgid "week number of year (1-53) (the first week starts on the first day of the year)"
msgstr ""

#: xml/func.xml:7758(literal)
msgid "IW"
msgstr ""

#: xml/func.xml:7760(entry)
msgid "week number of ISO 8601 week-numbering year (01-53; the first Thursday of the year is in week 1)"
msgstr ""

#: xml/func.xml:7766(literal)
msgid "CC"
msgstr ""

#: xml/func.xml:7768(entry)
msgid "century (2 digits) (the twenty-first century starts on 2001-01-01)"
msgstr ""

#: xml/func.xml:7773(literal)
msgid "J"
msgstr ""

#: xml/func.xml:7775(entry)
msgid "Julian Day (integer days since November 24, 4714 BC at midnight UTC)"
msgstr ""

#: xml/func.xml:7780(literal)
msgid "Q"
msgstr ""

#: xml/func.xml:7782(entry)
msgid "quarter (ignored by <placeholder-1/>and <placeholder-2/>)"
msgstr ""

#: xml/func.xml:7788(literal)
msgid "RM"
msgstr ""

#: xml/func.xml:7790(entry)
msgid "month in upper case Roman numerals (I-XII; I=January)"
msgstr ""

#: xml/func.xml:7795(literal)
msgid "rm"
msgstr ""

#: xml/func.xml:7797(entry)
msgid "month in lower case Roman numerals (i-xii; i=January)"
msgstr ""

#: xml/func.xml:7802(literal)
msgid "TZ"
msgstr ""

#: xml/func.xml:7804(entry)
msgid "upper case time-zone name"
msgstr ""

#: xml/func.xml:7808(literal)
msgid "tz"
msgstr ""

#: xml/func.xml:7810(entry)
msgid "lower case time-zone name"
msgstr ""

#: xml/func.xml:7814(literal)
msgid "OF"
msgstr ""

#: xml/func.xml:7816(entry)
msgid "time-zone offset"
msgstr ""

#: xml/func.xml:7821(para)
msgid "Modifiers can be applied to any template pattern to alter its behavior. For example, <literal>FMMonth</literal>is the <literal>Month</literal>pattern with the <literal>FM</literal>modifier. <xref linkend=\"functions-formatting-datetimemod-table\">shows the modifier patterns for date/time formatting.</xref>"
msgstr ""

#: xml/func.xml:7829(title)
msgid "Template Pattern Modifiers for Date/Time Formatting"
msgstr ""

#: xml/func.xml:7834(entry) xml/func.xml:8279(entry)
msgid "Modifier"
msgstr ""

#: xml/func.xml:7842(literal) xml/func.xml:8287(literal)
msgid "FM"
msgstr ""

#: xml/func.xml:7841(entry) xml/func.xml:7866(entry) xml/func.xml:7875(entry) xml/func.xml:8286(entry)
msgid "<placeholder-1/>prefix"
msgstr ""

#: xml/func.xml:7843(entry) xml/func.xml:8288(entry)
msgid "fill mode (suppress leading zeroes and padding blanks)"
msgstr ""

#: xml/func.xml:7846(literal)
msgid "FMMonth"
msgstr ""

#: xml/func.xml:7851(literal) xml/func.xml:8187(literal) xml/func.xml:8296(literal)
msgid "TH"
msgstr ""

#: xml/func.xml:7850(entry) xml/func.xml:7858(entry) xml/func.xml:7885(entry) xml/func.xml:8295(entry) xml/func.xml:8303(entry)
msgid "<placeholder-1/>suffix"
msgstr ""

#: xml/func.xml:7852(entry) xml/func.xml:8297(entry)
msgid "upper case ordinal number suffix"
msgstr ""

#: xml/func.xml:7854(literal)
msgid "DDTH"
msgstr ""

#: xml/func.xml:7855(literal)
msgid "12TH"
msgstr ""

#: xml/func.xml:7853(entry) xml/func.xml:7861(entry)
msgid "<placeholder-1/>, e.g., <placeholder-2/>"
msgstr ""

#: xml/func.xml:7859(literal) xml/func.xml:8188(literal) xml/func.xml:8304(literal)
msgid "th"
msgstr ""

#: xml/func.xml:7860(entry) xml/func.xml:8305(entry)
msgid "lower case ordinal number suffix"
msgstr ""

#: xml/func.xml:7862(literal)
msgid "DDth"
msgstr ""

#: xml/func.xml:7863(literal)
msgid "12th"
msgstr ""

#: xml/func.xml:7867(literal)
msgid "FX"
msgstr ""

#: xml/func.xml:7868(entry)
msgid "fixed format global option (see usage notes)"
msgstr ""

#: xml/func.xml:7871(literal)
msgid "FXMonthDDDay"
msgstr ""

#: xml/func.xml:7876(literal)
msgid "TM"
msgstr ""

#: xml/func.xml:7877(entry)
msgid "translation mode (print localized day and month names based on <placeholder-1/>"
msgstr ""

#: xml/func.xml:7881(literal)
msgid "TMMonth"
msgstr ""

#: xml/func.xml:7886(literal)
msgid "SP"
msgstr ""

#: xml/func.xml:7887(entry)
msgid "spell mode (not implemented)"
msgstr ""

#: xml/func.xml:7889(literal)
msgid "DDSP"
msgstr ""

#: xml/func.xml:7898(para)
msgid "<literal>FM</literal>suppresses leading zeroes and trailing blanks that would otherwise be added to make the output of a pattern be fixed-width. In <productname>PostgreSQL</productname>, <literal>FM</literal>modifies only the next specification, while in Oracle <literal>FM</literal>affects all subsequent specifications, and repeated <literal>FM</literal>modifiers toggle fill mode on and off."
msgstr ""

#: xml/func.xml:7911(para)
msgid "<literal>TM</literal>does not include trailing blanks. <function>to_timestamp</function>and <function>to_date</function>ignore the <literal>TM</literal>modifier."
msgstr ""

#: xml/func.xml:7918(para)
msgid "<function>to_timestamp</function>and <function>to_date</function>skip multiple blank spaces in the input string unless the <literal>FX</literal>option is used. For example, <literal>to_timestamp('2000JUN', 'YYYY MON')</literal>works, but <literal>to_timestamp('2000JUN', 'FXYYYY MON')</literal>returns an error because <function>to_timestamp</function>expects one space only. <literal>FX</literal>must be specified as the first item in the template."
msgstr ""

#: xml/func.xml:7932(para)
msgid "<function>to_timestamp</function>and <function>to_date</function>exist to handle input formats that cannot be converted by simple casting. These functions interpret input liberally, with minimal error checking. While they produce valid output, the conversion can yield unexpected results. For example, input to these functions is not restricted by normal ranges, thus <literal>to_date('20096040','YYYYMMDD')</literal>returns <literal>2014-01-17</literal>rather than causing an error. Casting does not have this behavior."
msgstr ""

#: xml/func.xml:7945(para)
msgid "Ordinary text is allowed in <function>to_char</function>templates and will be output literally. You can put a substring in double quotes to force it to be interpreted as literal text even if it contains pattern key words. For example, in <literal>'\"Hello Year \"YYYY'</literal>, the <literal>YYYY</literal>will be replaced by the year data, but the single <literal>Y</literal>in <literal>Year</literal>will not be. In <function>to_date</function>, <function>to_number</function>, and <function>to_timestamp</function>, double-quoted strings skip the number of input characters contained in the string, e.g. <literal>\"XX\"</literal>skips two input characters."
msgstr ""

#: xml/func.xml:7963(para)
msgid "If you want to have a double quote in the output you must precede it with a backslash, for example <literal>'\\\"YYYY Month\\\"'</literal>."
msgstr ""

#: xml/func.xml:7968(para)
msgid "If the year format specification is less than four digits, e.g. <literal>YYY</literal>, and the supplied year is less than four digits, the year will be adjusted to be nearest to the year 2020, e.g. <literal>95</literal>becomes 1995."
msgstr ""

#: xml/func.xml:7976(para)
msgid "The <literal>YYYY</literal>conversion from string to <type>timestamp</type>or <type>date</type>has a restriction when processing years with more than 4 digits. You must use some non-digit character or template after <literal>YYYY</literal>, otherwise the year is always interpreted as 4 digits. For example (with the year 20000): <literal>to_date('200001131', 'YYYYMMDD')</literal>will be interpreted as a 4-digit year; instead use a non-digit separator after the year, like <literal>to_date('20000-1131', 'YYYY-MMDD')</literal>or <literal>to_date('20000Nov31', 'YYYYMonDD')</literal>."
msgstr ""

#: xml/func.xml:7993(para)
msgid "In conversions from string to <type>timestamp</type>or <type>date</type>, the <literal>CC</literal>(century) field is ignored if there is a <literal>YYY</literal>, <literal>YYYY</literal>or <literal>Y,YYY</literal>field. If <literal>CC</literal>is used with <literal>YY</literal>or <literal>Y</literal>then the year is computed as the year in the specified century. If the century is specified but the year is not, the first year of the century is assumed."
msgstr ""

#: xml/func.xml:8015(para)
msgid "Year, week number, and weekday: for example <literal>to_date('2006-42-4', 'IYYY-IW-ID')</literal>returns the date <literal>2006-10-19</literal>. If you omit the weekday it is assumed to be 1 (Monday)."
msgstr ""

#: xml/func.xml:8022(para)
msgid "Year and day of year: for example <literal>to_date('2006-291', 'IYYY-IDDD')</literal>also returns <literal>2006-10-19</literal>."
msgstr ""

#: xml/func.xml:8009(para)
msgid "An ISO 8601 week-numbering date (as distinct from a Gregorian date) can be specified to <function>to_timestamp</function>and <function>to_date</function>in one of two ways: <placeholder-1/>"
msgstr ""

#: xml/func.xml:8028(para)
msgid "Attempting to enter a date using a mixture of ISO 8601 week-numbering fields and Gregorian date fields is nonsensical, and will cause an error. In the context of an ISO 8601 week-numbering year, the concept of a <quote>month</quote>or <quote>day of month</quote>has no meaning. In the context of a Gregorian year, the ISO week has no meaning."
msgstr ""

#: xml/func.xml:8036(para)
msgid "While <function>to_date</function>will reject a mixture of Gregorian and ISO week-numbering date fields, <function>to_char</function>will not, since output format specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal>can be useful. But avoid writing something like <literal>IYYY-MM-DD</literal>; that would yield surprising results near the start of the year. (See <xref linkend=\"functions-datetime-extract\">for more information.)</xref>"
msgstr ""

#: xml/func.xml:8050(para)
msgid "In a conversion from string to <type>timestamp</type>, millisecond ( <literal>MS</literal>) or microsecond ( <literal>US</literal>) values are used as the seconds digits after the decimal point. For example <literal>to_timestamp('12:3', 'SS:MS')</literal>is not 3 milliseconds, but 300, because the conversion counts it as 12 + 0.3 seconds. This means for the format <literal>SS:MS</literal>, the input values <literal>12:3</literal>, <literal>12:30</literal>, and <literal>12:300</literal>specify the same number of milliseconds. To get three milliseconds, one must use <literal>12:003</literal>, which the conversion counts as 12 + 0.003 = 12.003 seconds."
msgstr ""

#: xml/func.xml:8065(para)
msgid "Here is a more complex example: <literal>to_timestamp('15:12:02.020.001230', 'HH:MI:SS.MS.US')</literal>is 15 hours, 12 minutes, and 2 seconds + 20 milliseconds + 1230 microseconds = 2.021230 seconds."
msgstr ""

#: xml/func.xml:8072(para)
msgid "<function>to_char(..., 'ID')</function>'s day of the week numbering matches the <function>extract(isodow from ...)</function>function, but <function>to_char(..., 'D')</function>'s does not match <function>extract(dow from ...)</function>'s day numbering."
msgstr ""

#: xml/func.xml:8081(para)
msgid "<function>to_char(interval)</function>formats <literal>HH</literal>and <literal>HH12</literal>as shown on a 12-hour clock, i.e. zero hours and 36 hours output as <literal>12</literal>, while <literal>HH24</literal>outputs the full hour value, which can exceed 23 for intervals."
msgstr ""

#: xml/func.xml:7895(para)
msgid "Usage notes for date/time formatting: <placeholder-1/>"
msgstr ""

#: xml/func.xml:8092(xref)
msgid "shows the template patterns available for formatting numeric values."
msgstr ""

#: xml/func.xml:8097(title)
msgid "Template Patterns for Numeric Formatting"
msgstr ""

#: xml/func.xml:8108(literal)
msgid "9"
msgstr ""

#: xml/func.xml:8110(entry)
msgid "value with the specified number of digits"
msgstr ""

#: xml/func.xml:8117(entry)
msgid "value with leading zeros"
msgstr ""

#: xml/func.xml:8120(entry)
msgid "<placeholder-1/>(period)"
msgstr ""

#: xml/func.xml:8122(entry)
msgid "decimal point"
msgstr ""

#: xml/func.xml:8125(entry)
msgid "<placeholder-1/>(comma)"
msgstr ""

#: xml/func.xml:8127(entry)
msgid "group (thousand) separator"
msgstr ""

#: xml/func.xml:8131(literal)
msgid "PR"
msgstr ""

#: xml/func.xml:8133(entry)
msgid "negative value in angle brackets"
msgstr ""

#: xml/func.xml:8137(literal)
msgid "S"
msgstr ""

#: xml/func.xml:8139(entry)
msgid "sign anchored to number (uses locale)"
msgstr ""

#: xml/func.xml:8143(literal)
msgid "L"
msgstr ""

#: xml/func.xml:8145(entry)
msgid "currency symbol (uses locale)"
msgstr ""

#: xml/func.xml:8151(entry)
msgid "decimal point (uses locale)"
msgstr ""

#: xml/func.xml:8155(literal)
msgid "G"
msgstr ""

#: xml/func.xml:8157(entry)
msgid "group separator (uses locale)"
msgstr ""

#: xml/func.xml:8163(entry)
msgid "minus sign in specified position (if number 0)"
msgstr ""

#: xml/func.xml:8168(literal)
msgid "PL"
msgstr ""

#: xml/func.xml:8170(entry)
msgid "plus sign in specified position (if number 0)"
msgstr ""

#: xml/func.xml:8175(literal)
msgid "SG"
msgstr ""

#: xml/func.xml:8177(entry)
msgid "plus/minus sign in specified position"
msgstr ""

#: xml/func.xml:8181(literal)
msgid "RN"
msgstr ""

#: xml/func.xml:8183(entry)
msgid "Roman numeral (input between 1 and 3999)"
msgstr ""

#: xml/func.xml:8186(entry)
msgid "<placeholder-1/>or <placeholder-2/>"
msgstr ""

#: xml/func.xml:8189(entry)
msgid "ordinal number suffix"
msgstr ""

#: xml/func.xml:8193(literal)
msgid "V"
msgstr ""

#: xml/func.xml:8195(entry)
msgid "shift specified number of digits (see notes)"
msgstr ""

#: xml/func.xml:8200(literal)
msgid "EEEE"
msgstr ""

#: xml/func.xml:8202(entry)
msgid "exponent for scientific notation"
msgstr ""

#: xml/func.xml:8210(para)
msgid "A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or <literal>MI</literal>is not anchored to the number; for example, <literal>to_char(-12, 'MI9999')</literal>produces <literal>'-12'</literal>but <literal>to_char(-12, 'S9999')</literal>produces <literal>'-12'</literal>. The Oracle implementation does not allow the use of <literal>MI</literal>before <literal>9</literal>, but rather requires that <literal>9</literal>precede <literal>MI</literal>."
msgstr ""

#: xml/func.xml:8226(para)
msgid "<literal>9</literal>results in a value with the same number of digits as there are <literal>9</literal>s. If a digit is not available it outputs a space."
msgstr ""

#: xml/func.xml:8233(para)
msgid "<literal>TH</literal>does not convert values less than zero and does not convert fractional numbers."
msgstr ""

#: xml/func.xml:8238(para)
msgid "<literal>PL</literal>, <literal>SG</literal>, and <literal>TH</literal>are <productname>PostgreSQL</productname>extensions."
msgstr ""

#: xml/func.xml:8245(para)
msgid "<literal>V</literal>effectively multiplies the input values by <literal>10^ <replaceable>n</replaceable></literal>, where <replaceable>n</replaceable>is the number of digits following <literal>V</literal>. <function>to_char</function>does not support the use of <literal>V</literal>combined with a decimal point (e.g., <literal>99.9V99</literal>is not allowed)."
msgstr ""

#: xml/func.xml:8258(para)
msgid "<literal>EEEE</literal>(scientific notation) cannot be used in combination with any of the other formatting patterns or modifiers other than digit and decimal point patterns, and must be at the end of the format string (e.g., <literal>9.99EEEE</literal>is a valid pattern)."
msgstr ""

#: xml/func.xml:8207(para)
msgid "Usage notes for numeric formatting: <placeholder-1/>"
msgstr ""

#: xml/func.xml:8266(para)
msgid "Certain modifiers can be applied to any template pattern to alter its behavior. For example, <literal>FM9999</literal>is the <literal>9999</literal>pattern with the <literal>FM</literal>modifier. <xref linkend=\"functions-formatting-numericmod-table\">shows the modifier patterns for numeric formatting.</xref>"
msgstr ""

#: xml/func.xml:8274(title)
msgid "Template Pattern Modifiers for Numeric Formatting"
msgstr ""

#: xml/func.xml:8291(literal)
msgid "FM9999"
msgstr ""

#: xml/func.xml:8299(literal)
msgid "999TH"
msgstr ""

#: xml/func.xml:8307(literal)
msgid "999th"
msgstr ""

#: xml/func.xml:8314(xref)
msgid "shows some examples of the use of the <placeholder-1/>function."
msgstr ""

#: xml/func.xml:8319(title)
msgid "<function>to_char</function>Examples"
msgstr ""

#: xml/func.xml:8324(entry) xml/func.xml:10217(entry)
msgid "Expression"
msgstr ""

#: xml/func.xml:8331(literal)
msgid "to_char(current_timestamp, 'Day,DDHH12:MI:SS')"
msgstr ""

#: xml/func.xml:8335(literal)
msgid "'Tuesday,0605:39:18'"
msgstr ""

#: xml/func.xml:8340(literal)
msgid "to_char(current_timestamp, 'FMDay,FMDDHH12:MI:SS')"
msgstr ""

#: xml/func.xml:8344(literal)
msgid "'Tuesday,605:39:18'"
msgstr ""

#: xml/func.xml:8349(literal)
msgid "to_char(-0.1, '99.99')"
msgstr ""

#: xml/func.xml:8352(literal)
msgid "'-.10'"
msgstr ""

#: xml/func.xml:8357(literal)
msgid "to_char(-0.1, 'FM9.99')"
msgstr ""

#: xml/func.xml:8360(literal)
msgid "'-.1'"
msgstr ""

#: xml/func.xml:8365(literal)
msgid "to_char(0.1, '0.9')"
msgstr ""

#: xml/func.xml:8368(literal)
msgid "'0.1'"
msgstr ""

#: xml/func.xml:8373(literal)
msgid "to_char(12, '9990999.9')"
msgstr ""

#: xml/func.xml:8376(literal)
msgid "'0012.0'"
msgstr ""

#: xml/func.xml:8381(literal)
msgid "to_char(12, 'FM9990999.9')"
msgstr ""

#: xml/func.xml:8384(literal)
msgid "'0012.'"
msgstr ""

#: xml/func.xml:8389(literal) xml/func.xml:8405(literal)
msgid "to_char(485, '999')"
msgstr ""

#: xml/func.xml:8392(literal) xml/func.xml:8408(literal) xml/func.xml:8488(literal) xml/func.xml:8496(literal) xml/func.xml:8536(literal)
msgid "'485'"
msgstr ""

#: xml/func.xml:8397(literal)
msgid "to_char(-485, '999')"
msgstr ""

#: xml/func.xml:8400(literal) xml/func.xml:8520(literal)
msgid "'-485'"
msgstr ""

#: xml/func.xml:8413(literal)
msgid "to_char(1485, '9,999')"
msgstr ""

#: xml/func.xml:8416(literal)
msgid "'1,485'"
msgstr ""

#: xml/func.xml:8421(literal)
msgid "to_char(1485, '9G999')"
msgstr ""

#: xml/func.xml:8424(literal)
msgid "'1485'"
msgstr ""

#: xml/func.xml:8429(literal)
msgid "to_char(148.5, '999.999')"
msgstr ""

#: xml/func.xml:8432(literal) xml/func.xml:8448(literal)
msgid "'148.500'"
msgstr ""

#: xml/func.xml:8437(literal)
msgid "to_char(148.5, 'FM999.999')"
msgstr ""

#: xml/func.xml:8440(literal)
msgid "'148.5'"
msgstr ""

#: xml/func.xml:8445(literal)
msgid "to_char(148.5, 'FM999.990')"
msgstr ""

#: xml/func.xml:8453(literal)
msgid "to_char(148.5, '999D999')"
msgstr ""

#: xml/func.xml:8456(literal)
msgid "'148,500'"
msgstr ""

#: xml/func.xml:8461(literal)
msgid "to_char(3148.5, '9G999D999')"
msgstr ""

#: xml/func.xml:8464(literal)
msgid "'3148,500'"
msgstr ""

#: xml/func.xml:8469(literal)
msgid "to_char(-485, '999S')"
msgstr ""

#: xml/func.xml:8472(literal) xml/func.xml:8480(literal)
msgid "'485-'"
msgstr ""

#: xml/func.xml:8477(literal)
msgid "to_char(-485, '999MI')"
msgstr ""

#: xml/func.xml:8485(literal)
msgid "to_char(485, '999MI')"
msgstr ""

#: xml/func.xml:8493(literal)
msgid "to_char(485, 'FM999MI')"
msgstr ""

#: xml/func.xml:8501(literal)
msgid "to_char(485, 'PL999')"
msgstr ""

#: xml/func.xml:8504(literal) xml/func.xml:8512(literal)
msgid "'+485'"
msgstr ""

#: xml/func.xml:8509(literal)
msgid "to_char(485, 'SG999')"
msgstr ""

#: xml/func.xml:8517(literal)
msgid "to_char(-485, 'SG999')"
msgstr ""

#: xml/func.xml:8525(literal)
msgid "to_char(-485, '9SG99')"
msgstr ""

#: xml/func.xml:8528(literal)
msgid "'4-85'"
msgstr ""

#: xml/func.xml:8533(literal)
msgid "to_char(-485, '999PR')"
msgstr ""

#: xml/func.xml:8541(literal)
msgid "to_char(485, 'L999')"
msgstr ""

#: xml/func.xml:8544(literal)
msgid "'DM485'"
msgstr ""

#: xml/func.xml:8549(literal)
msgid "to_char(485, 'RN')"
msgstr ""

#: xml/func.xml:8552(literal) xml/func.xml:8560(literal)
msgid "'CDLXXXV'"
msgstr ""

#: xml/func.xml:8557(literal)
msgid "to_char(485, 'FMRN')"
msgstr ""

#: xml/func.xml:8565(literal)
msgid "to_char(5.2, 'FMRN')"
msgstr ""

#: xml/func.xml:8568(literal)
msgid "'V'"
msgstr ""

#: xml/func.xml:8573(literal)
msgid "to_char(482, '999th')"
msgstr ""

#: xml/func.xml:8576(literal)
msgid "'482nd'"
msgstr ""

#: xml/func.xml:8581(literal)
msgid "to_char(485, '\"Goodnumber:\"999')"
msgstr ""

#: xml/func.xml:8584(literal)
msgid "'Goodnumber:485'"
msgstr ""

#: xml/func.xml:8589(literal)
msgid "to_char(485.8, '\"Pre:\"999\"Post:\".999')"
msgstr ""

#: xml/func.xml:8593(literal)
msgid "'Pre:485Post:.800'"
msgstr ""

#: xml/func.xml:8598(literal)
msgid "to_char(12, '99V999')"
msgstr ""

#: xml/func.xml:8601(literal)
msgid "'12000'"
msgstr ""

#: xml/func.xml:8606(literal)
msgid "to_char(12.4, '99V999')"
msgstr ""

#: xml/func.xml:8609(literal)
msgid "'12400'"
msgstr ""

#: xml/func.xml:8614(literal)
msgid "to_char(12.45, '99V9')"
msgstr ""

#: xml/func.xml:8617(literal)
msgid "'125'"
msgstr ""

#: xml/func.xml:8622(literal)
msgid "to_char(0.0004859, '9.99EEEE')"
msgstr ""

#: xml/func.xml:8625(literal)
msgid "' 4.86e-04'"
msgstr ""

#: xml/func.xml:8633(title)
msgid "Date/Time Functions and Operators"
msgstr ""

#: xml/func.xml:8643(xref)
msgid ". You should be familiar with the background information on date/time data types from <placeholder-1/>"
msgstr ""

#: xml/func.xml:8638(xref)
msgid "illustrates the behaviors of the basic arithmetic operators ( <placeholder-1/>, <placeholder-2/>, etc.). For formatting functions, refer to <placeholder-3/>"
msgstr ""

#: xml/func.xml:8635(xref)
msgid "shows the available functions for date/time value processing, with details appearing in the following subsections. <placeholder-1/>"
msgstr ""

#: xml/func.xml:8648(para)
msgid "All the functions and operators described below that take <type>time</type>or <type>timestamp</type>inputs actually come in two variants: one that takes <type>time with time zone</type>or <type>timestamp with time zone</type>, and one that takes <type>time without time zone</type>or <type>timestamp without time zone</type>. For brevity, these variants are not shown separately. Also, the <literal>+</literal>and <literal>*</literal>operators come in commutative pairs (for example both date + integer and integer + date); we show only one of each such pair."
msgstr ""

#: xml/func.xml:8663(title)
msgid "Date/Time Operators"
msgstr ""

#: xml/func.xml:8678(literal)
msgid "date '2001-09-28' + integer '7'"
msgstr ""

#: xml/func.xml:8681(literal)
msgid "date '2001-10-05'"
msgstr ""

#: xml/func.xml:8689(literal)
msgid "date '2001-09-28' + interval '1 hour'"
msgstr ""

#: xml/func.xml:8693(literal)
msgid "timestamp '2001-09-28 01:00:00'"
msgstr ""

#: xml/func.xml:8701(literal)
msgid "date '2001-09-28' + time '03:00'"
msgstr ""

#: xml/func.xml:8704(literal)
msgid "timestamp '2001-09-28 03:00:00'"
msgstr ""

#: xml/func.xml:8712(literal)
msgid "interval '1 day' + interval '1 hour'"
msgstr ""

#: xml/func.xml:8716(literal)
msgid "interval '1 day 01:00:00'"
msgstr ""

#: xml/func.xml:8724(literal)
msgid "timestamp '2001-09-28 01:00' + interval '23 hours'"
msgstr ""

#: xml/func.xml:8728(literal)
msgid "timestamp '2001-09-29 00:00:00'"
msgstr ""

#: xml/func.xml:8736(literal)
msgid "time '01:00' + interval '3 hours'"
msgstr ""

#: xml/func.xml:8739(literal)
msgid "time '04:00:00'"
msgstr ""

#: xml/func.xml:8747(literal)
msgid "- interval '23 hours'"
msgstr ""

#: xml/func.xml:8750(literal)
msgid "interval '-23:00:00'"
msgstr ""

#: xml/func.xml:8758(literal)
msgid "date '2001-10-01' - date '2001-09-28'"
msgstr ""

#: xml/func.xml:8762(literal)
msgid "integer '3'"
msgstr ""

#: xml/func.xml:8761(entry)
msgid "<placeholder-1/>(days)"
msgstr ""

#: xml/func.xml:8769(literal)
msgid "date '2001-10-01' - integer '7'"
msgstr ""

#: xml/func.xml:8772(literal)
msgid "date '2001-09-24'"
msgstr ""

#: xml/func.xml:8780(literal)
msgid "date '2001-09-28' - interval '1 hour'"
msgstr ""

#: xml/func.xml:8784(literal)
msgid "timestamp '2001-09-27 23:00:00'"
msgstr ""

#: xml/func.xml:8792(literal)
msgid "time '05:00' - time '03:00'"
msgstr ""

#: xml/func.xml:8795(literal)
msgid "interval '02:00:00'"
msgstr ""

#: xml/func.xml:8803(literal)
msgid "time '05:00' - interval '2 hours'"
msgstr ""

#: xml/func.xml:8806(literal)
msgid "time '03:00:00'"
msgstr ""

#: xml/func.xml:8814(literal)
msgid "timestamp '2001-09-28 23:00' - interval '23 hours'"
msgstr ""

#: xml/func.xml:8818(literal)
msgid "timestamp '2001-09-28 00:00:00'"
msgstr ""

#: xml/func.xml:8826(literal)
msgid "interval '1 day' - interval '1 hour'"
msgstr ""

#: xml/func.xml:8830(literal)
msgid "interval '1 day -01:00:00'"
msgstr ""

#: xml/func.xml:8838(literal)
msgid "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"
msgstr ""

#: xml/func.xml:8842(literal)
msgid "interval '1 day 15:00:00'"
msgstr ""

#: xml/func.xml:8850(literal)
msgid "900 * interval '1 second'"
msgstr ""

#: xml/func.xml:8853(literal)
msgid "interval '00:15:00'"
msgstr ""

#: xml/func.xml:8861(literal)
msgid "21 * interval '1 day'"
msgstr ""

#: xml/func.xml:8864(literal)
msgid "interval '21 days'"
msgstr ""

#: xml/func.xml:8872(literal)
msgid "double precision '3.5' * interval '1 hour'"
msgstr ""

#: xml/func.xml:8876(literal)
msgid "interval '03:30:00'"
msgstr ""

#: xml/func.xml:8884(literal)
msgid "interval '1 hour' / double precision '1.5'"
msgstr ""

#: xml/func.xml:8888(literal)
msgid "interval '00:40:00'"
msgstr ""

#: xml/func.xml:8895(title)
msgid "Date/Time Functions"
msgstr ""

#: xml/func.xml:8910(primary)
msgid "age"
msgstr ""

#: xml/func.xml:8913(function)
msgid "age( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:8922(quote)
msgid "symbolic"
msgstr ""

#: xml/func.xml:8921(entry)
msgid "Subtract arguments, producing a <placeholder-1/>result that uses years and months, rather than just days"
msgstr ""

#: xml/func.xml:8925(literal)
msgid "age(timestamp '2001-04-10', timestamp '1957-06-13')"
msgstr ""

#: xml/func.xml:8929(literal)
msgid "43 years 9 mons 27 days"
msgstr ""

#: xml/func.xml:8935(function)
msgid "age( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:8943(function) xml/func.xml:8973(primary) xml/func.xml:8976(function)
msgid "current_date"
msgstr ""

#: xml/func.xml:8942(entry)
msgid "Subtract from <placeholder-1/>(at midnight)"
msgstr ""

#: xml/func.xml:8945(literal)
msgid "age(timestamp '1957-06-13')"
msgstr ""

#: xml/func.xml:8948(literal)
msgid "43 years 8 mons 3 days"
msgstr ""

#: xml/func.xml:8954(primary) xml/func.xml:9546(function)
msgid "clock_timestamp"
msgstr ""

#: xml/func.xml:8957(function)
msgid "clock_timestamp()"
msgstr ""

#: xml/func.xml:8963(entry)
msgid "Current date and time (changes during statement execution); see <placeholder-1/>"
msgstr ""

#: xml/func.xml:8982(entry)
msgid "Current date; see <placeholder-1/>"
msgstr ""

#: xml/func.xml:8991(primary) xml/func.xml:8994(function)
msgid "current_time"
msgstr ""

#: xml/func.xml:8998(type) xml/func.xml:10253(type) xml/func.xml:10257(type)
msgid "time with time zone"
msgstr ""

#: xml/func.xml:9000(entry) xml/func.xml:9306(entry)
msgid "Current time of day; see <placeholder-1/>"
msgstr ""

#: xml/func.xml:9009(primary) xml/func.xml:9012(function)
msgid "current_timestamp"
msgstr ""

#: xml/func.xml:9018(entry) xml/func.xml:9324(entry) xml/func.xml:9507(entry) xml/func.xml:9565(entry)
msgid "Current date and time (start of current transaction); see <placeholder-1/>"
msgstr ""

#: xml/func.xml:9028(primary) xml/func.xml:9703(primary)
msgid "date_part"
msgstr ""

#: xml/func.xml:9031(function) xml/func.xml:9054(function)
msgid "date_part( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:9040(function) xml/func.xml:9063(function) xml/func.xml:9124(primary) xml/func.xml:9127(function) xml/func.xml:9148(function) xml/func.xml:9706(primary)
msgid "extract"
msgstr ""

#: xml/func.xml:9039(entry) xml/func.xml:9062(entry)
msgid "Get subfield (equivalent to <placeholder-1/>); see <placeholder-2/>"
msgstr ""

#: xml/func.xml:9044(literal)
msgid "date_part('hour', timestamp '2001-02-16 20:38:40')"
msgstr ""

#: xml/func.xml:9067(literal)
msgid "date_part('month', interval '2 years 3 months')"
msgstr ""

#: xml/func.xml:9077(primary) xml/func.xml:10115(function) xml/func.xml:10118(primary)
msgid "date_trunc"
msgstr ""

#: xml/func.xml:9080(function) xml/func.xml:9102(function)
msgid "date_trunc( <placeholder-1/>, <placeholder-2/>)"
msgstr ""

#: xml/func.xml:9088(entry) xml/func.xml:9110(entry)
msgid "Truncate to specified precision; see also <placeholder-1/>"
msgstr ""

#: xml/func.xml:9092(literal)
msgid "date_trunc('hour', timestamp '2001-02-16 20:38:40')"
msgstr ""

#: xml/func.xml:9096(literal)
msgid "2001-02-16 20:00:00"
msgstr ""

#: xml/func.xml:9114(literal)
msgid "date_trunc('hour', interval '2 days 3 hours 40 minutes')"
msgstr ""

#: xml/func.xml:9118(literal)
msgid "2 days 03:00:00"
msgstr ""

#: xml/func.xml:9126(literal) xml/func.xml:9147(literal)
msgid "<placeholder-1/>( <placeholder-2/>from <placeholder-3/>)"
msgstr ""

#: xml/func.xml:9134(entry) xml/func.xml:9155(entry)
msgid "Get subfield; see <placeholder-1/>"
msgstr ""

#: xml/func.xml:9138(literal)
msgid "extract(hour from timestamp '2001-02-16 20:38:40')"
msgstr ""

#: xml/func.xml:9159(literal)
msgid "extract(month from interval '2 years 3 months')"
msgstr ""

#: xml/func.xml:9169(primary)
msgid "isfinite"
msgstr ""

#: xml/func.xml:9172(function) xml/func.xml:9190(function) xml/func.xml:9210(function)
msgid "isfinite( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:9177(type) xml/func.xml:9195(type) xml/func.xml:9215(type)
msgid "boolean"
msgstr ""

#: xml/func.xml:9179(entry)
msgid "Test for finite date (not +/-infinity)"
msgstr ""

#: xml/func.xml:9181(literal)
msgid "isfinite(date '2001-02-16')"
msgstr ""

#: xml/func.xml:9184(literal) xml/func.xml:9204(literal) xml/func.xml:9222(literal) xml/func.xml:9611(computeroutput) xml/func.xml:9623(computeroutput)
msgid "true"
msgstr ""

#: xml/func.xml:9197(entry)
msgid "Test for finite time stamp (not +/-infinity)"
msgstr ""

#: xml/func.xml:9200(literal)
msgid "isfinite(timestamp '2001-02-16 21:28:30')"
msgstr ""

#: xml/func.xml:9217(entry)
msgid "Test for finite interval"
msgstr ""

#: xml/func.xml:9219(literal)
msgid "isfinite(interval '4 hours')"
msgstr ""

#: xml/func.xml:9228(primary) xml/func.xml:9283(function)
msgid "justify_days"
msgstr ""

#: xml/func.xml:9231(function)
msgid "justify_days( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:9238(entry)
msgid "Adjust interval so 30-day time periods are represented as months"
msgstr ""

#: xml/func.xml:9241(literal)
msgid "justify_days(interval '35 days')"
msgstr ""

#: xml/func.xml:9244(literal)
msgid "1 mon 5 days"
msgstr ""

#: xml/func.xml:9250(primary) xml/func.xml:9284(function)
msgid "justify_hours"
msgstr ""

#: xml/func.xml:9253(function)
msgid "justify_hours( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:9260(entry)
msgid "Adjust interval so 24-hour time periods are represented as days"
msgstr ""

#: xml/func.xml:9263(literal)
msgid "justify_hours(interval '27 hours')"
msgstr ""

#: xml/func.xml:9266(literal)
msgid "1 day 03:00:00"
msgstr ""

#: xml/func.xml:9272(primary)
msgid "justify_interval"
msgstr ""

#: xml/func.xml:9275(function)
msgid "justify_interval( <placeholder-1/>)"
msgstr ""

#: xml/func.xml:9282(entry)
msgid "Adjust interval using <placeholder-1/>and <placeholder-2/>, with additional sign adjustments"
msgstr ""

#: xml/func.xml:9287(literal)
msgid "justify_interval(interval '1 mon -1 hour')"
msgstr ""

#: xml/func.xml:9291(literal)
msgid "29 days 23:00:00"
msgstr ""

#: xml/func.xml:9297(primary) xml/func.xml:9300(function)
msgid "localtime"
msgstr ""

#: xml/func.xml:9304(type) xml/func.xml:9410(type) xml/func.xml:10306(primary)
msgid "time"
msgstr ""

#: xml/func.xml:9315(primary) xml/func.xml:9318(function)
msgid "localtimestamp"
msgstr ""

#: xml/func.xml:9334(primary)
msgid "make_date"
msgstr ""

#: xml/func.xml:9338(parameter) xml/func.xml:9428(parameter) xml/func.xml:9462(parameter) xml/func.xml:10071(literal) xml/func.xml:10173(literal)
msgid "year"
msgstr ""

#: xml/func.xml:9337(function)
msgid "make_date( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>)"
msgstr ""

#: xml/func.xml:9349(entry)
msgid "Create date from year, month and day fields"
msgstr ""

#: xml/func.xml:9352(literal)
msgid "make_date(2013, 7, 15)"
msgstr ""

#: xml/func.xml:9355(literal)
msgid "2013-07-15"
msgstr ""

#: xml/func.xml:9361(primary)
msgid "make_interval"
msgstr ""

#: xml/func.xml:9365(parameter)
msgid "years"
msgstr ""

#: xml/func.xml:9367(parameter)
msgid "months"
msgstr ""

#: xml/func.xml:9369(parameter)
msgid "weeks"
msgstr ""

#: xml/func.xml:9371(parameter)
msgid "days"
msgstr ""

#: xml/func.xml:9373(parameter)
msgid "hours"
msgstr ""

#: xml/func.xml:9375(parameter)
msgid "mins"
msgstr ""

#: xml/func.xml:9377(parameter)
msgid "secs"
msgstr ""

#: xml/func.xml:9364(function)
msgid "make_interval( <placeholder-1/><placeholder-2/>DEFAULT 0, <placeholder-3/><placeholder-4/>DEFAULT 0, <placeholder-5/><placeholder-6/>DEFAULT 0, <placeholder-7/><placeholder-8/>DEFAULT 0, <placeholder-9/><placeholder-10/>DEFAULT 0, <placeholder-11/><placeholder-12/>DEFAULT 0, <placeholder-13/><placeholder-14/>DEFAULT 0.0)"
msgstr ""

#: xml/func.xml:9385(entry)
msgid "Create interval from years, months, weeks, days, hours, minutes and seconds fields"
msgstr ""

#: xml/func.xml:9388(literal)
msgid "make_interval(days =&gt; 10)"
msgstr ""

#: xml/func.xml:9391(literal)
msgid "10 days"
msgstr ""

#: xml/func.xml:9397(primary)
msgid "make_time"
msgstr ""

#: xml/func.xml:9401(parameter) xml/func.xml:9434(parameter) xml/func.xml:9468(parameter) xml/func.xml:9842(literal) xml/func.xml:10158(literal)
msgid "hour"
msgstr ""

#: xml/func.xml:9403(parameter) xml/func.xml:9436(parameter) xml/func.xml:9470(parameter)
msgid "min"
msgstr ""

#: xml/func.xml:9405(parameter) xml/func.xml:9438(parameter) xml/func.xml:9472(parameter)
msgid "sec"
msgstr ""

#: xml/func.xml:9400(function)
msgid "make_time( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>)"
msgstr ""

#: xml/func.xml:9412(entry)
msgid "Create time from hour, minute and seconds fields"
msgstr ""

#: xml/func.xml:9415(literal)
msgid "make_time(8, 15, 23.5)"
msgstr ""

#: xml/func.xml:9418(literal)
msgid "08:15:23.5"
msgstr ""

#: xml/func.xml:9424(primary)
msgid "make_timestamp"
msgstr ""

#: xml/func.xml:9427(function)
msgid "make_timestamp( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>, <placeholder-7/><placeholder-8/>, <placeholder-9/><placeholder-10/>, <placeholder-11/><placeholder-12/>)"
msgstr ""

#: xml/func.xml:9445(entry)
msgid "Create timestamp from year, month, day, hour, minute and seconds fields"
msgstr ""

#: xml/func.xml:9448(literal)
msgid "make_timestamp(2013, 7, 15, 8, 15, 23.5)"
msgstr ""

#: xml/func.xml:9452(literal)
msgid "2013-07-15 08:15:23.5"
msgstr ""

#: xml/func.xml:9458(primary)
msgid "make_timestamptz"
msgstr ""

#: xml/func.xml:9475(parameter) xml/func.xml:9485(parameter) xml/func.xml:10009(literal)
msgid "timezone"
msgstr ""

#: xml/func.xml:9461(function)
msgid "make_timestamptz( <placeholder-1/><placeholder-2/>, <placeholder-3/><placeholder-4/>, <placeholder-5/><placeholder-6/>, <placeholder-7/><placeholder-8/>, <placeholder-9/><placeholder-10/>, <placeholder-11/><placeholder-12/>, <optional><placeholder-13/><placeholder-14/></optional>)"
msgstr ""

#: xml/func.xml:9483(entry)
msgid "Create timestamp with time zone from year, month, day, hour, minute and seconds fields. When <placeholder-1/>is not specified, then current time zone is used."
msgstr ""

#: xml/func.xml:9488(literal)
msgid "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"
msgstr ""

#: xml/func.xml:9492(literal)
msgid "2013-07-15 08:15:23.5+01"
msgstr ""

#: xml/func.xml:9498(primary)
msgid "now"
msgstr ""

#: xml/func.xml:9501(function)
msgid "now()"
msgstr ""

#: xml/func.xml:9517(primary)
msgid "statement_timestamp"
msgstr ""

#: xml/func.xml:9520(function)
msgid "statement_timestamp()"
msgstr ""

#: xml/func.xml:9526(entry)
msgid "Current date and time (start of current statement); see <placeholder-1/>"
msgstr ""

#: xml/func.xml:9536(primary)
msgid "timeofday"
msgstr ""

#: xml/func.xml:9539(function)
msgid "timeofday()"
msgstr ""

#: xml/func.xml:9545(entry)
msgid "Current date and time (like <placeholder-1/>, but as a <placeholder-2/>string); see <placeholder-3/>"
msgstr ""

#: xml/func.xml:9556(primary)
msgid "transaction_timestamp"
msgstr ""

#: xml/func.xml:9559(function)
msgid "transaction_timestamp()"
msgstr ""

#: xml/func.xml:9575(para)
msgid "<indexterm><primary>OVERLAPS</primary></indexterm>In addition to these functions, the SQL <literal>OVERLAPS</literal>operator is supported: <synopsis>( \n    <replaceable>start1</replaceable>, \n    <replaceable>end1</replaceable>) OVERLAPS ( \n    <replaceable>start2</replaceable>, \n    <replaceable>end2</replaceable>) ( \n    <replaceable>start1</replaceable>, \n    <replaceable>length1</replaceable>) OVERLAPS ( \n    <replaceable>start2</replaceable>, \n    <replaceable>length2</replaceable>)</synopsis>This expression yields true when two time periods (defined by their endpoints) overlap, false when they do not overlap. The endpoints can be specified as pairs of dates, times, or time stamps; or as a date, time, or time stamp followed by an interval. When a pair of values is provided, either the start or the end can be written first; <literal>OVERLAPS</literal>automatically takes the earlier value of the pair as the start. Each time period is considered to represent the half-open interval <replaceable>start</replaceable><literal>=</literal><replaceable>time</replaceable><literal/><replaceable>end</replaceable>, unless <replaceable>start</replaceable>and <replaceable>end</replaceable>are equal in which case it represents that single time instant. This means for instance that two time periods with only an endpoint in common do not overlap."
msgstr ""

#: xml/func.xml:9610(lineannotation) xml/func.xml:9614(lineannotation) xml/func.xml:9618(lineannotation) xml/func.xml:9622(lineannotation) xml/func.xml:9684(lineannotation) xml/func.xml:9688(lineannotation) xml/func.xml:9692(lineannotation) xml/func.xml:9696(lineannotation) xml/func.xml:9736(lineannotation) xml/func.xml:9739(lineannotation) xml/func.xml:9761(lineannotation) xml/func.xml:9764(lineannotation) xml/func.xml:9776(lineannotation) xml/func.xml:9790(lineannotation) xml/func.xml:9806(lineannotation) xml/func.xml:9826(lineannotation) xml/func.xml:9829(lineannotation) xml/func.xml:9848(lineannotation) xml/func.xml:9862(lineannotation) xml/func.xml:9881(lineannotation) xml/func.xml:9884(lineannotation) xml/func.xml:9908(lineannotation) xml/func.xml:9920(lineannotation) xml/func.xml:9936(lineannotation) xml/func.xml:9948(lineannotation) xml/func.xml:9964(lineannotation) xml/func.xml:9967(lineannotation) xml/func.xml:9970(lineannotation) xml/func.xml:9983(lineannotation) xml/func.xml:10000(lineannotation) xml/func.xml:10003(lineannotation) xml/func.xml:10065(lineannotation) xml/func.xml:10081(lineannotation) xml/func.xml:10107(lineannotation) xml/func.xml:10110(lineannotation)
msgid "Result:"
msgstr ""

#: xml/func.xml:9615(computeroutput) xml/func.xml:9619(computeroutput)
#, no-wrap
msgid "false"
msgstr ""

#: xml/func.xml:9608(screen)
#, no-wrap
msgid "SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n    (DATE '2001-10-30', DATE '2002-10-30'); \n    <placeholder-1/>\n    <placeholder-2/>SELECT (DATE '2001-02-16',\n    INTERVAL '100 days') OVERLAPS (DATE '2001-10-30', DATE\n    '2002-10-30'); \n    <placeholder-3/>\n    <placeholder-4/>SELECT (DATE\n    '2001-10-29', DATE '2001-10-30') OVERLAPS (DATE '2001-10-30',\n    DATE '2001-10-31'); \n    <placeholder-5/>\n    <placeholder-6/>SELECT (DATE\n    '2001-10-30', DATE '2001-10-30') OVERLAPS (DATE '2001-10-30',\n    DATE '2001-10-31'); \n    <placeholder-7/>\n    <placeholder-8/>"
msgstr ""

#: xml/func.xml:9624(para)
msgid "When adding an <type>interval</type>value to (or subtracting an <type>interval</type>value from) a <type>timestamp with time zone</type>value, the days component advances or decrements the date of the <type>timestamp with time zone</type>by the indicated number of days. Across daylight saving time changes (when the session time zone is set to a time zone that recognizes DST), this means <literal>interval '1 day'</literal>does not necessarily equal <literal>interval '24 hours'</literal>. For example, with the session time zone set to <literal>CST7CDT</literal>, <literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</literal>will produce <literal>timestamp with time zone '2005-04-03 12:00-06'</literal>, while adding <literal>interval '24 hours'</literal>to the same initial <type>timestamp with time zone</type>produces <literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there is a change in daylight saving time at <literal>2005-04-03 02:00</literal>in time zone <literal>CST7CDT</literal>."
msgstr ""

#: xml/func.xml:9648(para)
msgid "Note there can be ambiguity in the <literal>months</literal>field returned by <function>age</function>because different months have different numbers of days. <productname>PostgreSQL</productname>'s approach uses the month from the earlier of the two dates when calculating partial months. For example, <literal>age('2004-06-01', '2004-04-30')</literal>uses April to yield <literal>1 mon 1 day</literal>, while using May would yield <literal>1 mon 2 days</literal>because May has 31 days, while April has only 30."
msgstr ""

#: xml/func.xml:9660(para)
msgid "Subtraction of dates and timestamps can also be complex. One conceptually simple way to perform subtraction is to convert each value to a number of seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the results; this produces the number of <emphasis>seconds</emphasis>between the two values. This will adjust for the number of days in each month, timezone changes, and daylight saving time adjustments. Subtraction of date or timestamp values with the <quote><literal>-</literal></quote>operator returns the number of days (24-hours) and hours/minutes/seconds between the values, making the same adjustments. The <function>age</function>function returns years, months, days, and hours/minutes/seconds, performing field-by-field subtraction and then adjusting for negative field values. The following queries illustrate the differences in these approaches. The sample results were produced with <literal>timezone = 'US/Eastern'</literal>; there is a daylight saving time change between the two dates used:"
msgstr ""

#: xml/func.xml:9685(computeroutput)
#, no-wrap
msgid "10537200"
msgstr ""

#: xml/func.xml:9689(computeroutput)
#, no-wrap
msgid "121.958333333333"
msgstr ""

#: xml/func.xml:9693(computeroutput)
#, no-wrap
msgid "121 days 23:00:00"
msgstr ""

#: xml/func.xml:9697(computeroutput)
#, no-wrap
msgid "4 mons"
msgstr ""

#: xml/func.xml:9681(screen)
#, no-wrap
msgid "SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01\n    12:00:00') - EXTRACT(EPOCH FROM timestamptz '2013-03-01\n    12:00:00'); \n    <placeholder-1/>\n    <placeholder-2/>SELECT (EXTRACT(EPOCH\n    FROM timestamptz '2013-07-01 12:00:00') - EXTRACT(EPOCH FROM\n    timestamptz '2013-03-01 12:00:00')) / 60 / 60 / 24; \n    <placeholder-3/>\n    <placeholder-4/>SELECT\n    timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01\n    12:00:00'; \n    <placeholder-5/>\n    <placeholder-6/>SELECT\n    age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01\n    12:00:00'); \n    <placeholder-7/>\n    <placeholder-8/>"
msgstr ""

#: xml/func.xml:9699(title)
msgid "<function>EXTRACT</function>, <function>date_part</function>"
msgstr ""

#: xml/func.xml:9710(replaceable)
msgid "source"
msgstr ""

#: xml/func.xml:9708(synopsis)
#, no-wrap
msgid "EXTRACT( \n      <placeholder-1/>FROM \n      <placeholder-2/>)"
msgstr ""

#: xml/func.xml:9730(literal) xml/func.xml:10179(literal)
msgid "century"
msgstr ""

#: xml/func.xml:9733(para)
msgid "The century"
msgstr ""

#: xml/func.xml:9740(computeroutput)
#, no-wrap
msgid "21"
msgstr ""

#: xml/func.xml:9734(screen)
#, no-wrap
msgid "SELECT EXTRACT(CENTURY FROM TIMESTAMP\n            '2000-12-16 12:21:13'); \n            <placeholder-1/>\n            <placeholder-2/>SELECT\n            EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40'); \n            <placeholder-3/>\n            <placeholder-4/>"
msgstr ""

#: xml/func.xml:9741(para)
msgid "The first century starts at 0001-01-01 00:00:00 AD, although they did not know it at the time. This definition applies to all Gregorian calendar countries. There is no century number 0, you go from -1 century to 1 century. If you disagree with this, please write your complaint to: Pope, Cathedral Saint-Peter of Roma, Vatican."
msgstr ""

#: xml/func.xml:9755(para)
msgid "For <type>timestamp</type>values, the day (of the month) field (1 - 31) ; for <type>interval</type>values, the number of days"
msgstr ""

#: xml/func.xml:9765(computeroutput) xml/func.xml:10001(computeroutput)
#, no-wrap
msgid "40"
msgstr ""

#: xml/func.xml:9759(screen)
#, no-wrap
msgid "SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>SELECT EXTRACT(DAY\n            FROM INTERVAL '40 days 1 minute'); \n            <placeholder-3/>\n            <placeholder-4/>"
msgstr ""

#: xml/func.xml:9770(literal) xml/func.xml:10176(literal)
msgid "decade"
msgstr ""

#: xml/func.xml:9773(para)
msgid "The year field divided by 10"
msgstr ""

#: xml/func.xml:9777(computeroutput)
#, no-wrap
msgid "200"
msgstr ""

#: xml/func.xml:9774(screen)
#, no-wrap
msgid "SELECT EXTRACT(DECADE FROM TIMESTAMP\n            '2001-02-16 20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9782(literal)
msgid "dow"
msgstr ""

#: xml/func.xml:9785(para)
msgid "The day of the week as Sunday ( <literal>0</literal>) to Saturday ( <literal>6</literal>)"
msgstr ""

#: xml/func.xml:9788(screen)
#, no-wrap
msgid "SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9792(para)
msgid "Note that <function>extract</function>'s day of the week numbering differs from that of the <function>to_char(..., 'D')</function>function."
msgstr ""

#: xml/func.xml:9800(literal)
msgid "doy"
msgstr ""

#: xml/func.xml:9803(para)
msgid "The day of the year (1 - 365/366)"
msgstr ""

#: xml/func.xml:9807(computeroutput)
#, no-wrap
msgid "47"
msgstr ""

#: xml/func.xml:9804(screen)
#, no-wrap
msgid "SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9812(literal)
msgid "epoch"
msgstr ""

#: xml/func.xml:9815(para)
msgid "For <type>timestamp with time zone</type>values, the number of seconds since 1970-01-01 00:00:00 UTC (can be negative); for <type>date</type>and <type>timestamp</type>values, the number of seconds since 1970-01-01 00:00:00 local time; for <type>interval</type>values, the total number of seconds in the interval"
msgstr ""

#: xml/func.xml:9827(computeroutput)
#, no-wrap
msgid "982384720.12"
msgstr ""

#: xml/func.xml:9830(computeroutput)
#, no-wrap
msgid "442800"
msgstr ""

#: xml/func.xml:9824(screen)
#, no-wrap
msgid "SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME\n            ZONE '2001-02-16 20:38:40.12-08'); \n            <placeholder-1/>\n            <placeholder-2/>SELECT\n            EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours'); \n            <placeholder-3/>\n            <placeholder-4/>"
msgstr ""

#: xml/func.xml:9831(para)
msgid "Here is how you can convert an epoch value back to a time stamp:"
msgstr ""

#: xml/func.xml:9833(screen)
#, no-wrap
msgid "SELECT TIMESTAMP WITH TIME ZONE 'epoch' +\n            982384720.12 * INTERVAL '1 second';"
msgstr ""

#: xml/func.xml:9835(para)
msgid "(The <function>to_timestamp</function>function encapsulates the above conversion.)"
msgstr ""

#: xml/func.xml:9845(para)
msgid "The hour field (0 - 23)"
msgstr ""

#: xml/func.xml:9846(screen)
#, no-wrap
msgid "SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9854(literal)
msgid "isodow"
msgstr ""

#: xml/func.xml:9857(para)
msgid "The day of the week as Monday ( <literal>1</literal>) to Sunday ( <literal>7</literal>)"
msgstr ""

#: xml/func.xml:9860(screen)
#, no-wrap
msgid "SELECT EXTRACT(ISODOW FROM TIMESTAMP\n            '2001-02-18 20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9864(para)
msgid "This is identical to <literal>dow</literal>except for Sunday. This matches the <acronym>ISO</acronym>8601 day of the week numbering."
msgstr ""

#: xml/func.xml:9873(literal)
msgid "isoyear"
msgstr ""

#: xml/func.xml:9876(para)
msgid "The <acronym>ISO</acronym>8601 week-numbering year that the date falls in (not applicable to intervals)"
msgstr ""

#: xml/func.xml:9882(computeroutput)
#, no-wrap
msgid "2005"
msgstr ""

#: xml/func.xml:9885(computeroutput)
#, no-wrap
msgid "2006"
msgstr ""

#: xml/func.xml:9879(screen)
#, no-wrap
msgid "SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n            \n            <placeholder-1/>\n            <placeholder-2/>SELECT\n            EXTRACT(ISOYEAR FROM DATE '2006-01-02'); \n            <placeholder-3/>\n            <placeholder-4/>"
msgstr ""

#: xml/func.xml:9886(para)
msgid "Each <acronym>ISO</acronym>8601 week-numbering year begins with the Monday of the week containing the 4th of January, so in early January or late December the <acronym>ISO</acronym>year may be different from the Gregorian year. See the <literal>week</literal>field for more information."
msgstr ""

#: xml/func.xml:9894(para)
msgid "This field is not available in PostgreSQL releases prior to 8.3."
msgstr ""

#: xml/func.xml:9900(literal) xml/func.xml:10146(literal)
msgid "microseconds"
msgstr ""

#: xml/func.xml:9903(para)
msgid "The seconds field, including fractional parts, multiplied by 1 000 000; note that this includes full seconds"
msgstr ""

#: xml/func.xml:9909(computeroutput)
#, no-wrap
msgid "28500000"
msgstr ""

#: xml/func.xml:9906(screen)
#, no-wrap
msgid "SELECT EXTRACT(MICROSECONDS FROM TIME\n            '17:12:28.5'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9914(literal) xml/func.xml:10182(literal)
msgid "millennium"
msgstr ""

#: xml/func.xml:9917(para)
msgid "The millennium"
msgstr ""

#: xml/func.xml:9918(screen)
#, no-wrap
msgid "SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP\n            '2001-02-16 20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9922(para)
msgid "Years in the 1900s are in the second millennium. The third millennium started January 1, 2001."
msgstr ""

#: xml/func.xml:9928(literal) xml/func.xml:10149(literal)
msgid "milliseconds"
msgstr ""

#: xml/func.xml:9931(para)
msgid "The seconds field, including fractional parts, multiplied by 1000. Note that this includes full seconds."
msgstr ""

#: xml/func.xml:9937(computeroutput)
#, no-wrap
msgid "28500"
msgstr ""

#: xml/func.xml:9934(screen)
#, no-wrap
msgid "SELECT EXTRACT(MILLISECONDS FROM TIME\n            '17:12:28.5'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9942(literal) xml/func.xml:10155(literal)
msgid "minute"
msgstr ""

#: xml/func.xml:9945(para)
msgid "The minutes field (0 - 59)"
msgstr ""

#: xml/func.xml:9949(computeroutput)
#, no-wrap
msgid "38"
msgstr ""

#: xml/func.xml:9946(screen)
#, no-wrap
msgid "SELECT EXTRACT(MINUTE FROM TIMESTAMP\n            '2001-02-16 20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9957(para)
msgid "For <type>timestamp</type>values, the number of the month within the year (1 - 12) ; for <type>interval</type>values, the number of months, modulo 12 (0 - 11)"
msgstr ""

#: xml/func.xml:9962(screen)
#, no-wrap
msgid "SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>SELECT EXTRACT(MONTH\n            FROM INTERVAL '2 years 3 months'); \n            <placeholder-3/>\n            <placeholder-4/>SELECT EXTRACT(MONTH\n            FROM INTERVAL '2 years 13 months'); \n            <placeholder-5/>\n            <placeholder-6/>"
msgstr ""

#: xml/func.xml:9976(literal) xml/func.xml:10170(literal)
msgid "quarter"
msgstr ""

#: xml/func.xml:9979(para)
msgid "The quarter of the year (1 - 4) that the date is in"
msgstr ""

#: xml/func.xml:9981(screen)
#, no-wrap
msgid "SELECT EXTRACT(QUARTER FROM TIMESTAMP\n            '2001-02-16 20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9989(literal) xml/func.xml:10152(literal)
msgid "second"
msgstr ""

#: xml/func.xml:9995(simpara)
msgid "60 if leap seconds are implemented by the operating system"
msgstr ""

#: xml/func.xml:9992(para)
msgid "The seconds field, including fractional parts (0 - 59 <placeholder-1/>)"
msgstr ""

#: xml/func.xml:10004(computeroutput)
#, no-wrap
msgid "28.5"
msgstr ""

#: xml/func.xml:9998(screen)
#, no-wrap
msgid "SELECT EXTRACT(SECOND FROM TIMESTAMP\n            '2001-02-16 20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>SELECT\n            EXTRACT(SECOND FROM TIME '17:12:28.5'); \n            <placeholder-3/>\n            <placeholder-4/>"
msgstr ""

#: xml/func.xml:10012(para)
msgid "The time zone offset from UTC, measured in seconds. Positive values correspond to time zones east of UTC, negative values to zones west of UTC. (Technically, <productname>PostgreSQL</productname>uses <acronym>UT1</acronym>because leap seconds are not handled.)"
msgstr ""

#: xml/func.xml:10023(literal)
msgid "timezone_hour"
msgstr ""

#: xml/func.xml:10026(para)
msgid "The hour component of the time zone offset"
msgstr ""

#: xml/func.xml:10031(literal)
msgid "timezone_minute"
msgstr ""

#: xml/func.xml:10034(para)
msgid "The minute component of the time zone offset"
msgstr ""

#: xml/func.xml:10040(literal) xml/func.xml:10164(literal)
msgid "week"
msgstr ""

#: xml/func.xml:10043(para)
msgid "The number of the <acronym>ISO</acronym>8601 week-numbering week of the year. By definition, ISO weeks start on Mondays and the first week of a year contains January 4 of that year. In other words, the first Thursday of a year is in week 1 of that year."
msgstr ""

#: xml/func.xml:10049(para)
msgid "In the ISO week-numbering system, it is possible for early-January dates to be part of the 52nd or 53rd week of the previous year, and for late-December dates to be part of the first week of the next year. For example, <literal>2005-01-01</literal>is part of the 53rd week of year 2004, and <literal>2006-01-01</literal>is part of the 52nd week of year 2005, while <literal>2012-12-31</literal>is part of the first week of 2013. It's recommended to use the <literal>isoyear</literal>field together with <literal>week</literal>to get consistent results."
msgstr ""

#: xml/func.xml:10063(screen)
#, no-wrap
msgid "SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:10074(para)
msgid "The year field. Keep in mind there is no <literal>0 AD</literal>, so subtracting <literal>BC</literal>years from <literal>AD</literal>years should be done with care."
msgstr ""

#: xml/func.xml:10082(computeroutput)
#, no-wrap
msgid "2001"
msgstr ""

#: xml/func.xml:10079(screen)
#, no-wrap
msgid "SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16\n            20:38:40'); \n            <placeholder-1/>\n            <placeholder-2/>"
msgstr ""

#: xml/func.xml:9711(para)
msgid "The <function>extract</function>function retrieves subfields such as year or hour from date/time values. <replaceable>source</replaceable>must be a value expression of type <type>timestamp</type>, <type>time</type>, or <type>interval</type>. (Expressions of type <type>date</type>are cast to <type>timestamp</type>and can therefore be used as well.) <replaceable>field</replaceable>is an identifier or string that selects what field to extract from the source value. The <function>extract</function>function returns values of type <type>double precision</type>. The following are valid field names: <placeholder-1/>"
msgstr ""

#: xml/func.xml:10086(para)
msgid "The <function>extract</function>function is primarily intended for computational processing. For formatting date/time values for display, see <xref linkend=\"functions-formatting\">.</xref>"
msgstr ""

#: xml/func.xml:10091(para)
msgid "The <function>date_part</function>function is modeled on the traditional <productname>Ingres</productname>equivalent to the <acronym>SQL</acronym>-standard function <function>extract</function>: <synopsis>date_part(' \n      <replaceable>field</replaceable>', \n      <replaceable>source</replaceable>)</synopsis>Note that here the <replaceable>field</replaceable>parameter needs to be a string value, not a name. The valid field names for <function>date_part</function>are the same as for <function>extract</function>."
msgstr ""

#: xml/func.xml:10105(screen)
#, no-wrap
msgid "SELECT date_part('day', TIMESTAMP '2001-02-16\n      20:38:40'); \n      <placeholder-1/>\n      <placeholder-2/>SELECT date_part('hour',\n      INTERVAL '4 hours 3 minutes'); \n      <placeholder-3/>\n      <placeholder-4/>"
msgstr ""

#: xml/func.xml:10120(para)
msgid "The function <function>date_trunc</function>is conceptually similar to the <function>trunc</function>function for numbers."
msgstr ""

#: xml/func.xml:10124(para)
msgid "<synopsis>date_trunc(' \n      <replaceable>field</replaceable>', \n      <replaceable>source</replaceable>)</synopsis><replaceable>source</replaceable>is a value expression of type <type>timestamp</type>or <type>interval</type>. (Values of type <type>date</type>and <type>time</type>are cast automatically to <type>timestamp</type>or <type>interval</type>, respectively.) <replaceable>field</replaceable>selects to which precision to truncate the input value. The return value is of type <type>timestamp</type>or <type>interval</type>with all fields that are less significant than the selected one set to zero (or one, for day and month)."
msgstr ""

#: xml/func.xml:10142(para)
msgid "Valid values for <replaceable>field</replaceable>are: <placeholder-1/>"
msgstr ""

#: xml/func.xml:10185(para)
msgid "Examples: <screen>SELECT date_trunc('hour', TIMESTAMP '2001-02-16\n      20:38:40'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-02-16 20:00:00</computeroutput>SELECT\n      date_trunc('year', TIMESTAMP '2001-02-16 20:38:40'); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-01-01\n      00:00:00</computeroutput></screen>"
msgstr ""

#: xml/func.xml:10197(literal) xml/func.xml:10204(primary)
msgid "AT TIME ZONE"
msgstr ""

#: xml/func.xml:10200(primary)
msgid "time zone"
msgstr ""

#: xml/func.xml:10201(secondary)
msgid "conversion"
msgstr ""

#: xml/func.xml:10206(para)
msgid "The <literal>AT TIME ZONE</literal>construct allows conversions of time stamps to different time zones. <xref linkend=\"functions-datetime-zoneconvert-table\">shows its variants.</xref>"
msgstr ""

#: xml/func.xml:10212(title)
msgid "<literal>AT TIME ZONE</literal>Variants"
msgstr ""

#: xml/func.xml:10226(type) xml/func.xml:10244(type)
msgid "timestamp without time zone"
msgstr ""

#: xml/func.xml:10228(replaceable) xml/func.xml:10241(replaceable) xml/func.xml:10254(replaceable)
msgid "zone"
msgstr ""

#: xml/func.xml:10225(literal) xml/func.xml:10239(literal) xml/func.xml:10252(literal)
msgid "<placeholder-1/>AT TIME ZONE <placeholder-2/>"
msgstr ""

#: xml/func.xml:10234(emphasis)
msgid "without time zone"
msgstr ""

#: xml/func.xml:10233(entry)
msgid "Treat given time stamp <placeholder-1/>as located in the specified time zone"
msgstr ""

#: xml/func.xml:10247(emphasis) xml/func.xml:10260(emphasis)
msgid "with time zone"
msgstr ""

#: xml/func.xml:10246(entry)
msgid "Convert given time stamp <placeholder-1/>to the new time zone, with no time zone designation"
msgstr ""

#: xml/func.xml:10259(entry)
msgid "Convert given time <placeholder-1/>to the new time zone"
msgstr ""

#: xml/func.xml:10266(para)
msgid "In these expressions, the desired time zone <replaceable>zone</replaceable>can be specified either as a text string (e.g., <literal>'PST'</literal>) or as an interval (e.g., <literal>INTERVAL '-08:00'</literal>). In the text case, a time zone name can be specified in any of the ways described in <xref linkend=\"datatype-timezones\">.</xref>"
msgstr ""

#: xml/func.xml:10274(para)
msgid "Examples (assuming the local time zone is <literal>PST8PDT</literal>): <screen>SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE\n      'MST'; \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-02-16 19:38:40-08</computeroutput>SELECT\n      TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME\n      ZONE 'MST'; \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-02-16\n      18:38:40</computeroutput></screen>The first example takes a time stamp without time zone and interprets it as MST time (UTC-7), which is then converted to PST (UTC-8) for display. The second example takes a time stamp specified in EST (UTC-5) and converts it to local time in MST (UTC-7)."
msgstr ""

#: xml/func.xml:10289(para)
msgid "The function <literal><function>timezone</function>( <replaceable>zone</replaceable>, <replaceable>timestamp</replaceable>)</literal>is equivalent to the SQL-conforming construct <literal><replaceable>timestamp</replaceable>AT TIME ZONE <replaceable>zone</replaceable></literal>."
msgstr ""

#: xml/func.xml:10300(title)
msgid "Current Date/Time"
msgstr ""

#: xml/func.xml:10303(secondary) xml/func.xml:10307(secondary)
msgid "current"
msgstr ""

#: xml/func.xml:10309(para)
msgid "<productname>PostgreSQL</productname>provides a number of functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction: <synopsis>CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP\n      CURRENT_TIME( \n      <replaceable>precision</replaceable>) CURRENT_TIMESTAMP( \n      <replaceable>precision</replaceable>) LOCALTIME\n      LOCALTIMESTAMP LOCALTIME( \n      <replaceable>precision</replaceable>) LOCALTIMESTAMP( \n      <replaceable>precision</replaceable>)</synopsis>"
msgstr ""

#: xml/func.xml:10321(para)
msgid "<function>CURRENT_TIME</function>and <function>CURRENT_TIMESTAMP</function>deliver values with time zone; <function>LOCALTIME</function>and <function>LOCALTIMESTAMP</function>deliver values without time zone."
msgstr ""

#: xml/func.xml:10328(para)
msgid "<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, <function>LOCALTIME</function>, and <function>LOCALTIMESTAMP</function>can optionally take a precision parameter, which causes the result to be rounded to that many fractional digits in the seconds field. Without a precision parameter, the result is given to the full available precision."
msgstr ""

#: xml/func.xml:10337(para)
msgid "Some examples: <screen>SELECT CURRENT_TIME; \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>14:39:53.662522-05</computeroutput>SELECT\n      CURRENT_DATE; \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-12-23</computeroutput>SELECT\n      CURRENT_TIMESTAMP; \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-12-23\n      14:39:53.662522-05</computeroutput>SELECT\n      CURRENT_TIMESTAMP(2); \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-12-23\n      14:39:53.66-05</computeroutput>SELECT LOCALTIMESTAMP; \n      <lineannotation>Result:</lineannotation>\n      <computeroutput>2001-12-23\n      14:39:53.662522</computeroutput></screen>"
msgstr ""

#: xml/func.xml:10355(para)
msgid "Since these functions return the start time of the current transaction, their values do not change during the transaction. This is considered a feature: the intent is to allow a single transaction to have a consistent notion of the <quote>current</quote>time, so that multiple modifications within the same transaction bear the same time stamp."
msgstr ""

#: xml/func.xml:10363(para)
msgid "Other database systems might advance these values more frequently."
msgstr ""

#: xml/func.xml:10366(para)
msgid "<productname>PostgreSQL</productname>also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is: <synopsis>transaction_timestamp() statement_timestamp()\n      clock_timestamp() timeofday() now()</synopsis>"
msgstr ""

#: xml/func.xml:10374(para)
msgid "<function>transaction_timestamp()</function>is equivalent to <function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect what it returns. <function>statement_timestamp()</function>returns the start time of the current statement (more specifically, the time of receipt of the latest command message from the client). <function>statement_timestamp()</function>and <function>transaction_timestamp()</function>return the same value during the first command of a transaction, but might differ during subsequent commands. <function>clock_timestamp()</function>returns the actual current time, and therefore its value changes even within a single SQL command. <function>timeofday()</function>is a historical <productname>PostgreSQL</productname>function. Like <function>clock_timestamp()</function>, it returns the actual current time, but as a formatted <type>text</type>string rather than a <type>timestamp with time zone</type>value. <function>now()</function>is a traditional <productname>PostgreSQL</productname>equivalent to <function>transaction_timestamp()</function>."
msgstr ""

#: xml/func.xml:10402(programlisting)
#, no-wrap
msgid "SELECT CURRENT_TIMESTAMP; SELECT now();\n      SELECT TIMESTAMP 'now'; -- incorrect for use with\n      DEFAULT"
msgstr ""

#: xml/func.xml:10397(para)
msgid "All the date/time data types also accept the special literal value <literal>now</literal>to specify the current date and time (again, interpreted as the transaction start time). Thus, the following three all return the same result: <placeholder-1/>"
msgstr ""

#: xml/func.xml:10406(para)
msgid "You do not want to use the third form when specifying a <literal>DEFAULT</literal>clause while creating a table. The system will convert <literal>now</literal>to a <type>timestamp</type>as soon as the constant is parsed, so that when the default value is needed, the time of the table creation would be used! The first two forms will not be evaluated until the default value is used, because they are function calls. Thus they will give the desired behavior of defaulting to the time of row insertion."
msgstr ""

#: xml/func.xml:10420(title)
msgid "Delaying Execution"
msgstr ""

#: xml/func.xml:10422(primary)
msgid "pg_sleep"
msgstr ""

#: xml/func.xml:10425(primary)
msgid "pg_sleep_for"
msgstr ""

#: xml/func.xml:10428(primary)
msgid "pg_sleep_until"
msgstr ""

#: xml/func.xml:10431(primary)
msgid "sleep"
msgstr ""

#: xml/func.xml:10434(primary)
msgid "delay"
msgstr ""

#: xml/func.xml:10453(programlisting)
#, no-wrap
msgid "SELECT pg_sleep(1.5); SELECT pg_sleep_for('5\n      minutes'); SELECT pg_sleep_until('tomorrow\n      03:00');"
msgstr ""

#: xml/func.xml:10436(para)
msgid "The following functions are available to delay execution of the server process: <synopsis>pg_sleep( \n      <replaceable>seconds</replaceable>) pg_sleep_for( \n      <type>interval</type>) pg_sleep_until( \n      <type>timestamp with time zone</type>)</synopsis><function>pg_sleep</function>makes the current session's process sleep until <replaceable>seconds</replaceable>seconds have elapsed. <replaceable>seconds</replaceable>is a value of type <type>double precision</type>, so fractional-second delays can be specified. <function>pg_sleep_for</function>is a convenience function for larger sleep times specified as an <type>interval</type>. <function>pg_sleep_until</function>is a convenience function for when a specific wake-up time is desired. For example: <placeholder-1/>"
msgstr ""

#: xml/func.xml:10457(para)
msgid "The effective resolution of the sleep interval is platform-specific; 0.01 seconds is a common value. The sleep delay will be at least as long as specified. It might be longer depending on factors such as server load. In particular, <function>pg_sleep_until</function>is not guaranteed to wake up exactly at the specified time, but it will not wake up any earlier."
msgstr ""

#: xml/func.xml:10467(para)
msgid "Make sure that your session does not hold more locks than necessary when calling <function>pg_sleep</function>or its variants. Otherwise other sessions might have to wait for your sleeping process, slowing down the entire system."
msgstr ""

#: xml/func.xml:10476(title) xml/func.xml:10487(title)
msgid "Enum Support Functions"
msgstr ""

#: xml/func.xml:10483(programlisting)
#, no-wrap
msgid "CREATE TYPE rainbow AS ENUM ('red', 'orange',\n    'yellow', 'green', 'blue',\n    'purple');"
msgstr ""

#: xml/func.xml:10477(para)
msgid "For enum types (described in <xref linkend=\"datatype-enum\">), there are several functions that allow cleaner programming without hard-coding particular values of an enum type. These are listed in <xref linkend=\"functions-enum-table\">. The examples assume an enum type created as: <placeholder-1/></xref></xref>"
msgstr ""

#: xml/func.xml:10494(entry)
msgid "Example Result"
msgstr ""

#: xml/func.xml:10501(primary)
msgid "enum_first"
msgstr ""

#: xml/func.xml:10503(literal)
msgid "enum_first(anyenum)"
msgstr ""

#: xml/func.xml:10505(entry)
msgid "Returns the first value of the input enum type"
msgstr ""

#: xml/func.xml:10508(literal)
msgid "enum_first(null::rainbow)"
msgstr ""

#: xml/func.xml:10511(literal)
msgid "red"
msgstr ""

#: xml/func.xml:10517(primary)
msgid "enum_last"
msgstr ""

#: xml/func.xml:10519(literal)
msgid "enum_last(anyenum)"
msgstr ""

#: xml/func.xml:10521(entry)
msgid "Returns the last value of the input enum type"
msgstr ""

#: xml/func.xml:10524(literal)
msgid "enum_last(null::rainbow)"
msgstr ""

#: xml/func.xml:10527(literal)
msgid "purple"
msgstr ""

#: xml/func.xml:10533(primary)
msgid "enum_range"
msgstr ""

#: xml/func.xml:10535(literal)
msgid "enum_range(anyenum)"
msgstr ""

#: xml/func.xml:10537(entry)
msgid "Returns all values of the input enum type in an ordered array"
msgstr ""

#: xml/func.xml:10540(literal)
msgid "enum_range(null::rainbow)"
msgstr ""

#: xml/func.xml:10543(literal)
msgid "{red,orange,yellow,green,blue,purple}"
msgstr ""

#: xml/func.xml:10549(literal)
msgid "enum_range(anyenum, anyenum)"
msgstr ""

#: xml/func.xml:10551(entry)
msgid "Returns the range between the two given enum values, as an ordered array. The values must be from the same enum type. If the first parameter is null, the result will start with the first value of the enum type. If the second parameter is null, the result will end with the last value of the enum type."
msgstr ""

#: xml/func.xml:10558(literal)
msgid "enum_range('orange'::rainbow, 'green'::rainbow)"
msgstr ""

#: xml/func.xml:10562(literal)
msgid "{orange,yellow,green}"
msgstr ""

#: xml/func.xml:10567(literal)
msgid "enum_range(NULL, 'green'::rainbow)"
msgstr ""

#: xml/func.xml:10570(literal)
msgid "{red,orange,yellow,green}"
msgstr ""

#: xml/func.xml:10575(literal)
msgid "enum_range('orange'::rainbow, NULL)"
msgstr ""

#: xml/func.xml:10579(literal)
msgid "{orange,yellow,green,blue,purple}"
msgstr ""

#: xml/func.xml:10585(para)
msgid "Notice that except for the two-argument form of <function>enum_range</function>, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as suggested by the examples."
msgstr ""

#: xml/func.xml:10594(title)
msgid "Geometric Functions and Operators"
msgstr ""

#: xml/func.xml:10595(para)
msgid "The geometric types <type>point</type>, <type>box</type>, <type>lseg</type>, <type>line</type>, <type>path</type>, <type>polygon</type>, and <type>circle</type>have a large set of native support functions and operators, shown in <xref linkend=\"functions-geometry-op-table\">, <xref linkend=\"functions-geometry-func-table\">, and <xref linkend=\"functions-geometry-conv-table\"> .</xref></xref></xref>"
msgstr ""

#: xml/func.xml:10609(para)
msgid "Note that the <quote>same as</quote>operator, <literal>~=</literal>, represents the usual notion of equality for the <type>point</type>, <type>box</type>, <type>polygon</type>, and <type>circle</type>types. Some of these types also have an <literal>=</literal>operator, but <literal>=</literal>compares for equal <emphasis>areas</emphasis>only. The other scalar comparison operators ( <literal>=</literal>and so on) likewise compare areas for these types."
msgstr ""

#: xml/func.xml:10625(title)
msgid "Geometric Operators"
msgstr ""

#: xml/func.xml:10639(entry) xml/func.xml:10649(entry)
msgid "Translation"
msgstr ""

#: xml/func.xml:10641(literal)
msgid "box '((0,0),(1,1))' + point '(2.0,0)'"
msgstr ""

#: xml/func.xml:10651(literal)
msgid "box '((0,0),(1,1))' - point '(2.0,0)'"
msgstr ""

#: xml/func.xml:10659(entry) xml/func.xml:10669(entry)
msgid "Scaling/rotation"
msgstr ""

#: xml/func.xml:10661(literal)
msgid "box '((0,0),(1,1))' * point '(2.0,0)'"
msgstr ""

#: xml/func.xml:10671(literal)
msgid "box '((0,0),(2,2))' / point '(2.0,0)'"
msgstr ""

#: xml/func.xml:10679(entry)
msgid "Point or box of intersection"
msgstr ""

#: xml/func.xml:10681(literal)
msgid "'((1,-1),(-1,1))' # '((1,1),(-1,-1))'"
msgstr ""

#: xml/func.xml:10689(entry)
msgid "Number of points in path or polygon"
msgstr ""

#: xml/func.xml:10691(literal)
msgid "# '((1,0),(0,1),(-1,0))'"
msgstr ""

#: xml/func.xml:10696(literal)
msgid "@-@"
msgstr ""

#: xml/func.xml:10698(entry)
msgid "Length or circumference"
msgstr ""

#: xml/func.xml:10700(literal)
msgid "@-@ path '((0,0),(1,0))'"
msgstr ""

#: xml/func.xml:10705(literal)
msgid "@@"
msgstr ""

#: xml/func.xml:10707(entry)
msgid "Center"
msgstr ""

#: xml/func.xml:10709(literal)
msgid "@@ circle '((0,0),10)'"
msgstr ""

#: xml/func.xml:10714(literal)
msgid "##"
msgstr ""

#: xml/func.xml:10716(entry)
msgid "Closest point to first operand on second operand"
msgstr ""

#: xml/func.xml:10719(literal)
msgid "point '(0,0)' ## lseg '((2,0),(0,2))'"
msgstr ""

#: xml/func.xml:10727(entry)
msgid "Distance between"
msgstr ""

#: xml/func.xml:10729(literal)
msgid "circle '((0,0),1)' - circle '((5,0),1)'"
msgstr ""

#: xml/func.xml:10737(entry)
msgid "Overlaps? (One point in common makes this true.)"
msgstr ""

#: xml/func.xml:10740(literal) xml/func.xml:10770(literal)
msgid "box '((0,0),(1,1))' box '((0,0),(2,2))'"
msgstr ""

#: xml/func.xml:10748(entry)
msgid "Is strictly left of?"
msgstr ""

#: xml/func.xml:10750(literal)
msgid "circle '((0,0),1)' circle '((5,0),1)'"
msgstr ""

#: xml/func.xml:10758(entry)
msgid "Is strictly right of?"
msgstr ""

#: xml/func.xml:10760(literal)
msgid "circle '((5,0),1)' circle '((0,0),1)'"
msgstr ""

#: xml/func.xml:10768(entry)
msgid "Does not extend to the right of?"
msgstr ""

#: xml/func.xml:10778(entry)
msgid "Does not extend to the left of?"
msgstr ""

#: xml/func.xml:10780(literal)
msgid "box '((0,0),(3,3))' box '((0,0),(2,2))'"
msgstr ""

#: xml/func.xml:10788(entry)
msgid "Is strictly below?"
msgstr ""

#: xml/func.xml:10790(literal)
msgid "box '((0,0),(3,3))' | box '((3,4),(5,5))'"
msgstr ""

#: xml/func.xml:10798(entry)
msgid "Is strictly above?"
msgstr ""

#: xml/func.xml:10800(literal)
msgid "box '((3,4),(5,5))' | box '((0,0),(3,3))'"
msgstr ""

#: xml/func.xml:10808(entry)
msgid "Does not extend above?"
msgstr ""

#: xml/func.xml:10810(literal)
msgid "box '((0,0),(1,1))' | box '((0,0),(2,2))'"
msgstr ""

#: xml/func.xml:10818(entry)
msgid "Does not extend below?"
msgstr ""

#: xml/func.xml:10820(literal)
msgid "box '((0,0),(3,3))' | box '((0,0),(2,2))'"
msgstr ""

#: xml/func.xml:10828(entry)
msgid "Is below (allows touching)?"
msgstr ""

#: xml/func.xml:10830(literal)
msgid "circle '((0,0),1)' ^ circle '((0,5),1)'"
msgstr ""

#: xml/func.xml:10838(entry)
msgid "Is above (allows touching)?"
msgstr ""

#: xml/func.xml:10840(literal)
msgid "circle '((0,5),1)'"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/func.xml:0(None)
msgid "translator-credits"
msgstr ""

