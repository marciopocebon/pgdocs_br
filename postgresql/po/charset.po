msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/charset.xml:3(title)
msgid "Localization"
msgstr ""

#: xml/charset.xml:10(para)
msgid "Using the locale features of the operating system to provide locale-specific collation order, number formatting, translated messages, and other aspects. This is covered in <xref linkend=\"locale\">and <xref linkend=\"collation\">.</xref></xref>"
msgstr ""

#: xml/charset.xml:17(para)
msgid "Providing a number of different character sets to support storing text in all kinds of languages, and providing character set translation between client and server. This is covered in <xref linkend=\"multibyte\">.</xref>"
msgstr ""

#: xml/charset.xml:4(para)
msgid "This chapter describes the available localization features from the point of view of the administrator. <productname>PostgreSQL</productname>supports two localization facilities: <placeholder-1/>"
msgstr ""

#: xml/charset.xml:25(title)
msgid "Locale Support"
msgstr ""

#: xml/charset.xml:27(primary)
msgid "locale"
msgstr ""

#: xml/charset.xml:29(para)
msgid "<firstterm>Locale</firstterm>support refers to an application respecting cultural preferences regarding alphabets, sorting, number formatting, etc. <productname>PostgreSQL</productname>uses the standard ISO C and <acronym>POSIX</acronym>locale facilities provided by the server operating system. For additional information refer to the documentation of your system."
msgstr ""

#: xml/charset.xml:39(title)
msgid "Overview"
msgstr ""

#: xml/charset.xml:40(para)
msgid "Locale support is automatically initialized when a database cluster is created using <command>initdb</command>. <command>initdb</command>will initialize the database cluster with the locale setting of its execution environment by default, so if your system is already set to use the locale that you want in your database cluster then there is nothing else you need to do. If you want to use a different locale (or you are not sure which locale your system is set to), you can instruct <command>initdb</command>exactly which locale to use by specifying the <option>--locale</option>option. For example: <screen>initdb --locale=sv_SE</screen>"
msgstr ""

#: xml/charset.xml:54(para)
msgid "This example for Unix systems sets the locale to Swedish ( <literal>sv</literal>) as spoken in Sweden ( <literal>SE</literal>). Other possibilities might include <literal>en_US</literal>(U.S. English) and <literal>fr_CA</literal>(French Canadian). If more than one character set can be used for a locale then the specifications can take the form <replaceable>language_territory.codeset</replaceable>. For example, <literal>fr_BE.UTF-8</literal>represents the French language (fr) as spoken in Belgium (BE), with a <acronym>UTF-8</acronym>character set encoding."
msgstr ""

#: xml/charset.xml:67(para)
msgid "What locales are available on your system under what names depends on what was provided by the operating system vendor and what was installed. On most Unix systems, the command <literal>locale -a</literal>will provide a list of available locales. Windows uses more verbose locale names, such as <literal>German_Germany</literal>or <literal>Swedish_Sweden.1252</literal>, but the principles are the same."
msgstr ""

#: xml/charset.xml:76(para)
msgid "Occasionally it is useful to mix rules from several locales, e.g., use English collation rules but Spanish messages. To support that, a set of locale subcategories exist that control only certain aspects of the localization rules: <informaltable><tgroup cols=\"2\"><tbody><row><entry><envar>LC_COLLATE</envar></entry><entry>String sort order</entry></row><row><entry><envar>LC_CTYPE</envar></entry><entry>Character classification (What is a letter? Its upper-case equivalent?)</entry></row><row><entry><envar>LC_MESSAGES</envar></entry><entry>Language of messages</entry></row><row><entry><envar>LC_MONETARY</envar></entry><entry>Formatting of currency amounts</entry></row><row><entry><envar>LC_NUMERIC</envar></entry><entry>Formatting of numbers</entry></row><row><entry><envar>LC_TIME</envar></entry><entry>Formatting of dates and times</entry></row></tbody></tgroup></informaltable>The category names translate into names of <command>initdb</command>options to override the locale choice for a specific category. For instance, to set the locale to French Canadian, but use U.S. rules for formatting currency, use <literal>initdb --locale=fr_CA --lc-monetary=en_US</literal>."
msgstr ""

#: xml/charset.xml:130(para)
msgid "If you want the system to behave as if it had no locale support, use the special locale name <literal>C</literal>, or equivalently <literal>POSIX</literal>."
msgstr ""

#: xml/charset.xml:134(para)
msgid "Some locale categories must have their values fixed when the database is created. You can use different settings for different databases, but once a database is created, you cannot change them for that database anymore. <literal>LC_COLLATE</literal>and <literal>LC_CTYPE</literal>are these categories. They affect the sort order of indexes, so they must be kept fixed, or indexes on text columns would become corrupt. (But you can alleviate this restriction using collations, as discussed in <xref linkend=\"collation\">.) The default values for these categories are determined when <command>initdb</command>is run, and those values are used when new databases are created, unless specified otherwise in the <command>CREATE DATABASE</command>command.</xref>"
msgstr ""

#: xml/charset.xml:149(para)
msgid "The other locale categories can be changed whenever desired by setting the server configuration parameters that have the same name as the locale categories (see <xref linkend=\"runtime-config-client-format\">for details). The values that are chosen by <command>initdb</command>are actually only written into the configuration file <filename>postgresql.conf</filename>to serve as defaults when the server is started. If you remove these assignments from <filename>postgresql.conf</filename>then the server will inherit the settings from its execution environment.</xref>"
msgstr ""

#: xml/charset.xml:161(para)
msgid "Note that the locale behavior of the server is determined by the environment variables seen by the server, not by the environment of any client. Therefore, be careful to configure the correct locale settings before starting the server. A consequence of this is that if client and server are set up in different locales, messages might appear in different languages depending on where they originated."
msgstr ""

#: xml/charset.xml:170(para)
msgid "When we speak of inheriting the locale from the execution environment, this means the following on most operating systems: For a given locale category, say the collation, the following environment variables are consulted in this order until one is found to be set: <envar>LC_ALL</envar>, <envar>LC_COLLATE</envar>(or the variable corresponding to the respective category), <envar>LANG</envar>. If none of these environment variables are set then the locale defaults to <literal>C</literal>."
msgstr ""

#: xml/charset.xml:181(para)
msgid "Some message localization libraries also look at the environment variable <envar>LANGUAGE</envar>which overrides all other locale settings for the purpose of setting the language of messages. If in doubt, please refer to the documentation of your operating system, in particular the documentation about <application>gettext</application>."
msgstr ""

#: xml/charset.xml:190(para)
msgid "To enable messages to be translated to the user's preferred language, <acronym>NLS</acronym>must have been selected at build time ( <literal>configure --enable-nls</literal>). All other locale support is built in automatically."
msgstr ""

#: xml/charset.xml:198(title)
msgid "Behavior"
msgstr ""

#: xml/charset.xml:203(para)
msgid "Sort order in queries using <literal>ORDER BY</literal>or the standard comparison operators on textual data <indexterm><primary>ORDER BY</primary><secondary>and locales</secondary></indexterm>"
msgstr ""

#: xml/charset.xml:212(para)
msgid "The <function>upper</function>, <function>lower</function>, and <function>initcap</function>functions <indexterm><primary>upper</primary><secondary>and locales</secondary></indexterm><indexterm><primary>lower</primary><secondary>and locales</secondary></indexterm>"
msgstr ""

#: xml/charset.xml:226(para)
msgid "Pattern matching operators ( <literal>LIKE</literal>, <literal>SIMILAR TO</literal>, and POSIX-style regular expressions); locales affect both case insensitive matching and the classification of characters by character-class regular expressions <indexterm><primary>LIKE</primary><secondary>and locales</secondary></indexterm><indexterm><primary>regular expressions</primary><secondary>and locales</secondary></indexterm>"
msgstr ""

#: xml/charset.xml:242(para)
msgid "The <function>to_char</function>family of functions <indexterm><primary>to_char</primary><secondary>and locales</secondary></indexterm>"
msgstr ""

#: xml/charset.xml:250(para)
msgid "The ability to use indexes with <literal>LIKE</literal>clauses"
msgstr ""

#: xml/charset.xml:199(para)
msgid "The locale settings influence the following SQL features: <placeholder-1/>"
msgstr ""

#: xml/charset.xml:254(para)
msgid "The drawback of using locales other than <literal>C</literal>or <literal>POSIX</literal>in <productname>PostgreSQL</productname>is its performance impact. It slows character handling and prevents ordinary indexes from being used by <literal>LIKE</literal>. For this reason use locales only if you actually need them."
msgstr ""

#: xml/charset.xml:262(para)
msgid "As a workaround to allow <productname>PostgreSQL</productname>to use indexes with <literal>LIKE</literal>clauses under a non-C locale, several custom operator classes exist. These allow the creation of an index that performs a strict character-by-character comparison, ignoring locale comparison rules. Refer to <xref linkend=\"indexes-opclass\">for more information. Another approach is to create indexes using the <literal>C</literal>collation, as discussed in <xref linkend=\"collation\">.</xref></xref>"
msgstr ""

#: xml/charset.xml:274(title)
msgid "Problems"
msgstr ""

#: xml/charset.xml:275(para)
msgid "If locale support doesn't work according to the explanation above, check that the locale support in your operating system is correctly configured. To check what locales are installed on your system, you can use the command <literal>locale -a</literal>if your operating system provides it."
msgstr ""

#: xml/charset.xml:282(para)
msgid "Check that <productname>PostgreSQL</productname>is actually using the locale that you think it is. The <envar>LC_COLLATE</envar>and <envar>LC_CTYPE</envar>settings are determined when a database is created, and cannot be changed except by creating a new database. Other locale settings including <envar>LC_MESSAGES</envar>and <envar>LC_MONETARY</envar>are initially determined by the environment the server is started in, but can be changed on-the-fly. You can check the active locale settings using the <command>SHOW</command>command."
msgstr ""

#: xml/charset.xml:295(para)
msgid "The directory <filename>src/test/locale</filename>in the source distribution contains a test suite for <productname>PostgreSQL</productname>'s locale support."
msgstr ""

#: xml/charset.xml:300(para)
msgid "Client applications that handle server-side errors by parsing the text of the error message will obviously have problems when the server's messages are in a different language. Authors of such applications are advised to make use of the error code scheme instead."
msgstr ""

#: xml/charset.xml:305(para)
msgid "Maintaining catalogs of message translations requires the on-going efforts of many volunteers that want to see <productname>PostgreSQL</productname>speak their preferred language well. If messages in your language are currently not available or not fully translated, your assistance would be appreciated. If you want to help, refer to <xref linkend=\"nls\">or write to the developers' mailing list.</xref>"
msgstr ""

#: xml/charset.xml:316(title)
msgid "Collation Support"
msgstr ""

#: xml/charset.xml:318(primary)
msgid "collation"
msgstr ""

#: xml/charset.xml:320(para)
msgid "The collation feature allows specifying the sort order and character classification behavior of data per-column, or even per-operation. This alleviates the restriction that the <symbol>LC_COLLATE</symbol>and <symbol>LC_CTYPE</symbol>settings of a database cannot be changed after its creation."
msgstr ""

#: xml/charset.xml:327(title)
msgid "Concepts"
msgstr ""

#: xml/charset.xml:328(para)
msgid "Conceptually, every expression of a collatable data type has a collation. (The built-in collatable data types are <type>text</type>, <type>varchar</type>, and <type>char</type>. User-defined base types can also be marked collatable, and of course a domain over a collatable data type is collatable.) If the expression is a column reference, the collation of the expression is the defined collation of the column. If the expression is a constant, the collation is the default collation of the data type of the constant. The collation of a more complex expression is derived from the collations of its inputs, as described below."
msgstr ""

#: xml/charset.xml:341(para)
msgid "The collation of an expression can be the <quote>default</quote>collation, which means the locale settings defined for the database. It is also possible for an expression's collation to be indeterminate. In such cases, ordering operations and other operations that need to know the collation will fail."
msgstr ""

#: xml/charset.xml:347(para)
msgid "When the database system has to perform an ordering or a character classification, it uses the collation of the input expression. This happens, for example, with <literal>ORDER BY</literal>clauses and function or operator calls such as <literal/>. The collation to apply for an <literal>ORDER BY</literal>clause is simply the collation of the sort key. The collation to apply for a function or operator call is derived from the arguments, as described below. In addition to comparison operators, collations are taken into account by functions that convert between lower and upper case letters, such as <function>lower</function>, <function>upper</function>, and <function>initcap</function>; by pattern matching operators; and by <function>to_char</function>and related functions."
msgstr ""

#: xml/charset.xml:364(para)
msgid "For a function or operator call, the collation that is derived by examining the argument collations is used at run time for performing the specified operation. If the result of the function or operator call is of a collatable data type, the collation is also used at parse time as the defined collation of the function or operator expression, in case there is a surrounding expression that requires knowledge of its collation."
msgstr ""

#: xml/charset.xml:384(para)
msgid "If any input expression has an explicit collation derivation, then all explicitly derived collations among the input expressions must be the same, otherwise an error is raised. If any explicitly derived collation is present, that is the result of the collation combination."
msgstr ""

#: xml/charset.xml:392(para)
msgid "Otherwise, all input expressions must have the same implicit collation derivation or the default collation. If any non-default collation is present, that is the result of the collation combination. Otherwise, the result is the default collation."
msgstr ""

#: xml/charset.xml:399(para)
msgid "If there are conflicting non-default implicit collations among the input expressions, then the combination is deemed to have indeterminate collation. This is not an error condition unless the particular function being invoked requires knowledge of the collation it should apply. If it does, an error will be raised at run-time."
msgstr ""

#: xml/charset.xml:408(programlisting)
#, no-wrap
msgid "CREATE TABLE test1 ( a text COLLATE \"de_DE\",\n      b text COLLATE \"es_ES\", ... );"
msgstr ""

#: xml/charset.xml:410(programlisting)
#, no-wrap
msgid "SELECT a 'foo' FROM\n      test1;"
msgstr ""

#: xml/charset.xml:416(programlisting)
#, no-wrap
msgid "SELECT a ('foo' COLLATE \"fr_FR\") FROM\n      test1;"
msgstr ""

#: xml/charset.xml:420(programlisting)
#, no-wrap
msgid "SELECT a b FROM test1;"
msgstr ""

#: xml/charset.xml:429(programlisting)
#, no-wrap
msgid "SELECT a b COLLATE \"de_DE\" FROM\n      test1;"
msgstr ""

#: xml/charset.xml:431(programlisting)
#, no-wrap
msgid "SELECT a COLLATE \"de_DE\" b FROM\n      test1;"
msgstr ""

#: xml/charset.xml:434(programlisting)
#, no-wrap
msgid "SELECT a || b FROM\n      test1;"
msgstr ""

#: xml/charset.xml:372(para)
msgid "The <firstterm>collation derivation</firstterm>of an expression can be implicit or explicit. This distinction affects how collations are combined when multiple different collations appear in an expression. An explicit collation derivation occurs when a <literal>COLLATE</literal>clause is used; all other collation derivations are implicit. When multiple collations need to be combined, for example in a function call, the following rules are used: <placeholder-1/>For example, consider this table definition: <placeholder-2/>Then in <placeholder-3/>the <literal/>comparison is performed according to <literal>de_DE</literal>rules, because the expression combines an implicitly derived collation with the default collation. But in <placeholder-4/>the comparison is performed using <literal>fr_FR</literal>rules, because the explicit collation derivation overrides the implicit one. Furthermore, given <placeholder-5/>the parser cannot determine which collation to apply, since the <structfield>a</structfield>and <structfield>b</structfield>columns have conflicting implicit collations. Since the <literal/>operator does need to know which collation to use, this will result in an error. The error can be resolved by attaching an explicit collation specifier to either input expression, thus: <placeholder-6/>or equivalently <placeholder-7/>On the other hand, the structurally similar case <placeholder-8/>does not result in an error, because the <literal>||</literal>operator does not care about collations: its result is the same regardless of the collation."
msgstr ""

#: xml/charset.xml:443(programlisting)
#, no-wrap
msgid "SELECT * FROM test1 ORDER BY a ||\n      'foo';"
msgstr ""

#: xml/charset.xml:447(programlisting)
#, no-wrap
msgid "SELECT * FROM test1 ORDER BY a ||\n      b;"
msgstr ""

#: xml/charset.xml:455(programlisting)
#, no-wrap
msgid "SELECT * FROM test1 ORDER BY a || b COLLATE\n      \"fr_FR\";"
msgstr ""

#: xml/charset.xml:439(para)
msgid "The collation assigned to a function or operator's combined input expressions is also considered to apply to the function or operator's result, if the function or operator delivers a result of a collatable data type. So, in <placeholder-1/>the ordering will be done according to <literal>de_DE</literal>rules. But this query: <placeholder-2/>results in an error, because even though the <literal>||</literal>operator doesn't need to know a collation, the <literal>ORDER BY</literal>clause does. As before, the conflict can be resolved with an explicit collation specifier: <placeholder-3/>"
msgstr ""

#: xml/charset.xml:459(title)
msgid "Managing Collations"
msgstr ""

#: xml/charset.xml:460(para)
msgid "A collation is an SQL schema object that maps an SQL name to operating system locales. In particular, it maps to a combination of <symbol>LC_COLLATE</symbol>and <symbol>LC_CTYPE</symbol>. (As the name would suggest, the main purpose of a collation is to set <symbol>LC_COLLATE</symbol>, which controls the sort order. But it is rarely necessary in practice to have an <symbol>LC_CTYPE</symbol>setting that is different from <symbol>LC_COLLATE</symbol>, so it is more convenient to collect these under one concept than to create another infrastructure for setting <symbol>LC_CTYPE</symbol>per expression.) Also, a collation is tied to a character set encoding (see <xref linkend=\"multibyte\">). The same collation name may exist for different encodings.</xref>"
msgstr ""

#: xml/charset.xml:476(para)
msgid "On all platforms, the collations named <literal>default</literal>, <literal>C</literal>, and <literal>POSIX</literal>are available. Additional collations may be available depending on operating system support. The <literal>default</literal>collation selects the <symbol>LC_COLLATE</symbol>and <symbol>LC_CTYPE</symbol>values specified at database creation time. The <literal>C</literal>and <literal>POSIX</literal>collations both specify <quote>traditional C</quote>behavior, in which only the ASCII letters <quote><literal>A</literal></quote>through <quote><literal>Z</literal></quote>are treated as letters, and sorting is done strictly by character code byte values."
msgstr ""

#: xml/charset.xml:496(para)
msgid "If the operating system provides support for using multiple locales within a single program ( <function>newlocale</function>and related functions), then when a database cluster is initialized, <command>initdb</command>populates the system catalog <literal>pg_collation</literal>with collations based on all the locales it finds on the operating system at the time. For example, the operating system might provide a locale named <literal>de_DE.utf8</literal>. <command>initdb</command>would then create a collation named <literal>de_DE.utf8</literal>for encoding <literal>UTF8</literal>that has both <symbol>LC_COLLATE</symbol>and <symbol>LC_CTYPE</symbol>set to <literal>de_DE.utf8</literal>. It will also create a collation with the <literal>.utf8</literal>tag stripped off the name. So you could also use the collation under the name <literal>de_DE</literal>, which is less cumbersome to write and makes the name less encoding-dependent. Note that, nevertheless, the initial set of collation names is platform-dependent."
msgstr ""

#: xml/charset.xml:518(para)
msgid "In case a collation is needed that has different values for <symbol>LC_COLLATE</symbol>and <symbol>LC_CTYPE</symbol>, a new collation may be created using the <xref linkend=\"sql-createcollation\">command. That command can also be used to create a new collation from an existing collation, which can be useful to be able to use operating-system-independent collation names in applications.</xref>"
msgstr ""

#: xml/charset.xml:528(para)
msgid "Within any particular database, only collations that use that database's encoding are of interest. Other entries in <literal>pg_collation</literal>are ignored. Thus, a stripped collation name such as <literal>de_DE</literal>can be considered unique within a given database even though it would not be unique globally. Use of the stripped collation names is recommended, since it will make one less thing you need to change if you decide to change to another database encoding. Note however that the <literal>default</literal>, <literal>C</literal>, and <literal>POSIX</literal>collations can be used regardless of the database encoding."
msgstr ""

#: xml/charset.xml:546(programlisting)
#, no-wrap
msgid "SELECT a COLLATE \"C\" b COLLATE \"POSIX\" FROM\n      test1;"
msgstr ""

#: xml/charset.xml:542(para)
msgid "<productname>PostgreSQL</productname>considers distinct collation objects to be incompatible even when they have identical properties. Thus for example, <placeholder-1/>will draw an error even though the <literal>C</literal>and <literal>POSIX</literal>collations have identical behaviors. Mixing stripped and non-stripped collation names is therefore not recommended."
msgstr ""

#: xml/charset.xml:555(title)
msgid "Character Set Support"
msgstr ""

#: xml/charset.xml:557(primary)
msgid "character set"
msgstr ""

#: xml/charset.xml:559(para)
msgid "The character set support in <productname>PostgreSQL</productname>allows you to store text in a variety of character sets (also called encodings), including single-byte character sets such as the ISO 8859 series and multiple-byte character sets such as <acronym>EUC</acronym>(Extended Unix Code), UTF-8, and Mule internal code. All supported character sets can be used transparently by clients, but a few are not supported for use within the server (that is, as a server-side encoding). The default character set is selected while initializing your <productname>PostgreSQL</productname>database cluster using <command>initdb</command>. It can be overridden when you create a database, so you can have multiple databases each with a different character set."
msgstr ""

#: xml/charset.xml:573(para)
msgid "An important restriction, however, is that each database's character set must be compatible with the database's <envar>LC_CTYPE</envar>(character classification) and <envar>LC_COLLATE</envar>(string sort order) locale settings. For <literal>C</literal>or <literal>POSIX</literal>locale, any character set is allowed, but for other locales there is only one character set that will work correctly. (On Windows, however, UTF-8 encoding can be used with any locale.)"
msgstr ""

#: xml/charset.xml:585(title)
msgid "Supported Character Sets"
msgstr ""

#: xml/charset.xml:589(productname)
msgid "PostgreSQL"
msgstr ""

#: xml/charset.xml:587(xref)
msgid "shows the character sets available for use in <placeholder-1/>."
msgstr ""

#: xml/charset.xml:592(title)
msgid "<productname>PostgreSQL</productname>Character Sets"
msgstr ""

#: xml/charset.xml:597(entry)
msgid "Name"
msgstr ""

#: xml/charset.xml:598(entry)
msgid "Description"
msgstr ""

#: xml/charset.xml:599(entry)
msgid "Language"
msgstr ""

#: xml/charset.xml:600(entry)
msgid "Server?"
msgstr ""

#: xml/charset.xml:601(entry)
msgid "Bytes/Char"
msgstr ""

#: xml/charset.xml:602(entry)
msgid "Aliases"
msgstr ""

#: xml/charset.xml:608(literal) xml/charset.xml:1222(literal) xml/charset.xml:1263(literal) xml/charset.xml:1440(literal)
msgid "BIG5"
msgstr ""

#: xml/charset.xml:610(entry)
msgid "Big Five"
msgstr ""

#: xml/charset.xml:611(entry)
msgid "Traditional Chinese"
msgstr ""

#: xml/charset.xml:612(entry) xml/charset.xml:674(entry) xml/charset.xml:684(entry) xml/charset.xml:742(entry) xml/charset.xml:913(entry) xml/charset.xml:927(entry) xml/charset.xml:949(entry)
msgid "No"
msgstr ""

#: xml/charset.xml:613(entry) xml/charset.xml:685(entry) xml/charset.xml:914(entry) xml/charset.xml:928(entry) xml/charset.xml:950(entry)
msgid "1-2"
msgstr ""

#: xml/charset.xml:615(literal)
msgid "WIN950"
msgstr ""

#: xml/charset.xml:616(literal)
msgid "Windows950"
msgstr ""

#: xml/charset.xml:614(entry) xml/charset.xml:686(entry) xml/charset.xml:951(entry) xml/charset.xml:1301(entry) xml/charset.xml:1309(entry) xml/charset.xml:1317(entry) xml/charset.xml:1325(entry) xml/charset.xml:1345(entry) xml/charset.xml:1390(entry) xml/charset.xml:1398(entry) xml/charset.xml:1406(entry) xml/charset.xml:1414(entry) xml/charset.xml:1422(entry) xml/charset.xml:1430(entry) xml/charset.xml:1505(entry) xml/charset.xml:1535(entry) xml/charset.xml:1543(entry) xml/charset.xml:1551(entry) xml/charset.xml:1559(entry) xml/charset.xml:1567(entry) xml/charset.xml:1575(entry) xml/charset.xml:1583(entry)
msgid "<placeholder-1/>, <placeholder-2/>"
msgstr ""

#: xml/charset.xml:620(literal) xml/charset.xml:1231(literal) xml/charset.xml:1234(emphasis) xml/charset.xml:1441(literal)
msgid "EUC_CN"
msgstr ""

#: xml/charset.xml:622(entry)
msgid "Extended UNIX Code-CN"
msgstr ""

#: xml/charset.xml:623(entry) xml/charset.xml:683(entry)
msgid "Simplified Chinese"
msgstr ""

#: xml/charset.xml:624(entry) xml/charset.xml:634(entry) xml/charset.xml:644(entry) xml/charset.xml:654(entry) xml/charset.xml:664(entry) xml/charset.xml:697(entry) xml/charset.xml:708(entry) xml/charset.xml:719(entry) xml/charset.xml:730(entry) xml/charset.xml:753(entry) xml/charset.xml:766(entry) xml/charset.xml:777(entry) xml/charset.xml:790(entry) xml/charset.xml:803(entry) xml/charset.xml:816(entry) xml/charset.xml:829(entry) xml/charset.xml:842(entry) xml/charset.xml:854(entry) xml/charset.xml:866(entry) xml/charset.xml:878(entry) xml/charset.xml:891(entry) xml/charset.xml:903(entry) xml/charset.xml:939(entry) xml/charset.xml:963(entry) xml/charset.xml:975(entry) xml/charset.xml:987(entry) xml/charset.xml:997(entry) xml/charset.xml:1007(entry) xml/charset.xml:1019(entry) xml/charset.xml:1029(entry) xml/charset.xml:1039(entry) xml/charset.xml:1049(entry) xml/charset.xml:1059(entry) xml/charset.xml:1069(entry) xml/charset.xml:1079(entry)
msgid "Yes"
msgstr ""

#: xml/charset.xml:625(entry) xml/charset.xml:635(entry) xml/charset.xml:645(entry) xml/charset.xml:655(entry) xml/charset.xml:665(entry) xml/charset.xml:743(entry)
msgid "1-3"
msgstr ""

#: xml/charset.xml:630(literal) xml/charset.xml:1240(literal) xml/charset.xml:1243(emphasis) xml/charset.xml:1442(literal)
msgid "EUC_JP"
msgstr ""

#: xml/charset.xml:632(entry)
msgid "Extended UNIX Code-JP"
msgstr ""

#: xml/charset.xml:633(entry) xml/charset.xml:643(entry) xml/charset.xml:912(entry) xml/charset.xml:926(entry)
msgid "Japanese"
msgstr ""

#: xml/charset.xml:640(literal)
msgid "EUC_JIS_2004"
msgstr ""

#: xml/charset.xml:642(entry)
msgid "Extended UNIX Code-JP, JIS X 0213"
msgstr ""

#: xml/charset.xml:650(literal) xml/charset.xml:1250(literal) xml/charset.xml:1253(emphasis) xml/charset.xml:1443(literal)
msgid "EUC_KR"
msgstr ""

#: xml/charset.xml:652(entry)
msgid "Extended UNIX Code-KR"
msgstr ""

#: xml/charset.xml:653(entry) xml/charset.xml:948(entry)
msgid "Korean"
msgstr ""

#: xml/charset.xml:660(literal) xml/charset.xml:1259(literal) xml/charset.xml:1262(emphasis) xml/charset.xml:1444(literal)
msgid "EUC_TW"
msgstr ""

#: xml/charset.xml:662(entry)
msgid "Extended UNIX Code-TW"
msgstr ""

#: xml/charset.xml:663(entry)
msgid "Traditional Chinese, Taiwanese"
msgstr ""

#: xml/charset.xml:670(literal) xml/charset.xml:1269(literal)
msgid "GB18030"
msgstr ""

#: xml/charset.xml:672(entry)
msgid "National Standard"
msgstr ""

#: xml/charset.xml:673(entry)
msgid "Chinese"
msgstr ""

#: xml/charset.xml:675(entry) xml/charset.xml:904(entry) xml/charset.xml:964(entry)
msgid "1-4"
msgstr ""

#: xml/charset.xml:680(literal) xml/charset.xml:1278(literal)
msgid "GBK"
msgstr ""

#: xml/charset.xml:682(entry)
msgid "Extended National Standard"
msgstr ""

#: xml/charset.xml:687(literal)
msgid "WIN936"
msgstr ""

#: xml/charset.xml:688(literal)
msgid "Windows936"
msgstr ""

#: xml/charset.xml:692(literal) xml/charset.xml:1287(literal) xml/charset.xml:1290(emphasis) xml/charset.xml:1335(literal) xml/charset.xml:1445(literal) xml/charset.xml:1495(literal) xml/charset.xml:1525(literal)
msgid "ISO_8859_5"
msgstr ""

#: xml/charset.xml:695(acronym) xml/charset.xml:706(acronym) xml/charset.xml:717(acronym) xml/charset.xml:728(acronym) xml/charset.xml:775(acronym) xml/charset.xml:788(acronym) xml/charset.xml:801(acronym) xml/charset.xml:814(acronym) xml/charset.xml:827(acronym) xml/charset.xml:840(acronym)
msgid "ECMA"
msgstr ""

#: xml/charset.xml:694(entry)
msgid "ISO 8859-5, <placeholder-1/>113"
msgstr ""

#: xml/charset.xml:696(entry)
msgid "Latin/Cyrillic"
msgstr ""

#: xml/charset.xml:698(entry) xml/charset.xml:709(entry) xml/charset.xml:720(entry) xml/charset.xml:731(entry) xml/charset.xml:754(entry) xml/charset.xml:767(entry) xml/charset.xml:778(entry) xml/charset.xml:791(entry) xml/charset.xml:804(entry) xml/charset.xml:817(entry) xml/charset.xml:830(entry) xml/charset.xml:843(entry) xml/charset.xml:855(entry) xml/charset.xml:867(entry) xml/charset.xml:879(entry) xml/charset.xml:892(entry) xml/charset.xml:940(entry) xml/charset.xml:976(entry) xml/charset.xml:988(entry) xml/charset.xml:998(entry) xml/charset.xml:1008(entry) xml/charset.xml:1020(entry) xml/charset.xml:1030(entry) xml/charset.xml:1040(entry) xml/charset.xml:1050(entry) xml/charset.xml:1060(entry) xml/charset.xml:1070(entry) xml/charset.xml:1080(entry)
msgid "1"
msgstr ""

#: xml/charset.xml:703(literal) xml/charset.xml:1299(literal) xml/charset.xml:1302(emphasis)
msgid "ISO_8859_6"
msgstr ""

#: xml/charset.xml:705(entry)
msgid "ISO 8859-6, <placeholder-1/>114"
msgstr ""

#: xml/charset.xml:707(entry)
msgid "Latin/Arabic"
msgstr ""

#: xml/charset.xml:714(literal) xml/charset.xml:1307(literal) xml/charset.xml:1310(emphasis)
msgid "ISO_8859_7"
msgstr ""

#: xml/charset.xml:716(entry)
msgid "ISO 8859-7, <placeholder-1/>118"
msgstr ""

#: xml/charset.xml:718(entry)
msgid "Latin/Greek"
msgstr ""

#: xml/charset.xml:725(literal) xml/charset.xml:1315(literal) xml/charset.xml:1318(emphasis)
msgid "ISO_8859_8"
msgstr ""

#: xml/charset.xml:727(entry)
msgid "ISO 8859-8, <placeholder-1/>121"
msgstr ""

#: xml/charset.xml:729(entry)
msgid "Latin/Hebrew"
msgstr ""

#: xml/charset.xml:736(literal) xml/charset.xml:739(acronym) xml/charset.xml:1323(literal) xml/charset.xml:1326(emphasis)
msgid "JOHAB"
msgstr ""

#: xml/charset.xml:741(entry)
msgid "Korean (Hangul)"
msgstr ""

#: xml/charset.xml:748(literal) xml/charset.xml:1291(literal) xml/charset.xml:1331(literal) xml/charset.xml:1334(emphasis) xml/charset.xml:1446(literal) xml/charset.xml:1496(literal) xml/charset.xml:1526(literal)
msgid "KOI8R"
msgstr ""

#: xml/charset.xml:751(acronym) xml/charset.xml:764(acronym)
msgid "KOI"
msgstr ""

#: xml/charset.xml:750(entry)
msgid "<placeholder-1/>8-R"
msgstr ""

#: xml/charset.xml:752(entry)
msgid "Cyrillic (Russian)"
msgstr ""

#: xml/charset.xml:756(literal)
msgid "KOI8"
msgstr ""

#: xml/charset.xml:761(literal) xml/charset.xml:1343(literal) xml/charset.xml:1346(emphasis)
msgid "KOI8U"
msgstr ""

#: xml/charset.xml:763(entry)
msgid "<placeholder-1/>8-U"
msgstr ""

#: xml/charset.xml:765(entry)
msgid "Cyrillic (Ukrainian)"
msgstr ""

#: xml/charset.xml:772(literal) xml/charset.xml:1351(literal) xml/charset.xml:1354(emphasis) xml/charset.xml:1447(literal)
msgid "LATIN1"
msgstr ""

#: xml/charset.xml:774(entry)
msgid "ISO 8859-1, <placeholder-1/>94"
msgstr ""

#: xml/charset.xml:776(entry) xml/charset.xml:1018(entry)
msgid "Western European"
msgstr ""

#: xml/charset.xml:780(literal)
msgid "ISO88591"
msgstr ""

#: xml/charset.xml:785(literal) xml/charset.xml:1360(literal) xml/charset.xml:1363(emphasis) xml/charset.xml:1515(literal)
msgid "LATIN2"
msgstr ""

#: xml/charset.xml:787(entry)
msgid "ISO 8859-2, <placeholder-1/>94"
msgstr ""

#: xml/charset.xml:789(entry) xml/charset.xml:996(entry)
msgid "Central European"
msgstr ""

#: xml/charset.xml:793(literal)
msgid "ISO88592"
msgstr ""

#: xml/charset.xml:798(literal) xml/charset.xml:1370(literal) xml/charset.xml:1373(emphasis)
msgid "LATIN3"
msgstr ""

#: xml/charset.xml:800(entry)
msgid "ISO 8859-3, <placeholder-1/>94"
msgstr ""

#: xml/charset.xml:802(entry)
msgid "South European"
msgstr ""

#: xml/charset.xml:806(literal)
msgid "ISO88593"
msgstr ""

#: xml/charset.xml:811(literal) xml/charset.xml:1379(literal) xml/charset.xml:1382(emphasis) xml/charset.xml:1448(literal)
msgid "LATIN4"
msgstr ""

#: xml/charset.xml:813(entry)
msgid "ISO 8859-4, <placeholder-1/>94"
msgstr ""

#: xml/charset.xml:815(entry)
msgid "North European"
msgstr ""

#: xml/charset.xml:819(literal)
msgid "ISO88594"
msgstr ""

#: xml/charset.xml:824(literal) xml/charset.xml:1388(literal) xml/charset.xml:1391(emphasis)
msgid "LATIN5"
msgstr ""

#: xml/charset.xml:826(entry)
msgid "ISO 8859-9, <placeholder-1/>128"
msgstr ""

#: xml/charset.xml:828(entry) xml/charset.xml:1038(entry)
msgid "Turkish"
msgstr ""

#: xml/charset.xml:832(literal)
msgid "ISO88599"
msgstr ""

#: xml/charset.xml:837(literal) xml/charset.xml:1396(literal) xml/charset.xml:1399(emphasis)
msgid "LATIN6"
msgstr ""

#: xml/charset.xml:839(entry)
msgid "ISO 8859-10, <placeholder-1/>144"
msgstr ""

#: xml/charset.xml:841(entry)
msgid "Nordic"
msgstr ""

#: xml/charset.xml:845(literal)
msgid "ISO885910"
msgstr ""

#: xml/charset.xml:850(literal) xml/charset.xml:1404(literal) xml/charset.xml:1407(emphasis)
msgid "LATIN7"
msgstr ""

#: xml/charset.xml:852(entry)
msgid "ISO 8859-13"
msgstr ""

#: xml/charset.xml:853(entry) xml/charset.xml:1068(entry)
msgid "Baltic"
msgstr ""

#: xml/charset.xml:857(literal)
msgid "ISO885913"
msgstr ""

#: xml/charset.xml:862(literal) xml/charset.xml:1412(literal) xml/charset.xml:1415(emphasis)
msgid "LATIN8"
msgstr ""

#: xml/charset.xml:864(entry)
msgid "ISO 8859-14"
msgstr ""

#: xml/charset.xml:865(entry)
msgid "Celtic"
msgstr ""

#: xml/charset.xml:869(literal)
msgid "ISO885914"
msgstr ""

#: xml/charset.xml:874(literal) xml/charset.xml:1420(literal) xml/charset.xml:1423(emphasis)
msgid "LATIN9"
msgstr ""

#: xml/charset.xml:876(entry)
msgid "ISO 8859-15"
msgstr ""

#: xml/charset.xml:877(entry)
msgid "LATIN1 with Euro and accents"
msgstr ""

#: xml/charset.xml:881(literal)
msgid "ISO885915"
msgstr ""

#: xml/charset.xml:886(literal) xml/charset.xml:1428(literal) xml/charset.xml:1431(emphasis)
msgid "LATIN10"
msgstr ""

#: xml/charset.xml:889(acronym)
msgid "ASRO"
msgstr ""

#: xml/charset.xml:888(entry)
msgid "ISO 8859-16, <placeholder-1/>SR 14111"
msgstr ""

#: xml/charset.xml:890(entry)
msgid "Romanian"
msgstr ""

#: xml/charset.xml:894(literal)
msgid "ISO885916"
msgstr ""

#: xml/charset.xml:899(literal) xml/charset.xml:1235(literal) xml/charset.xml:1244(literal) xml/charset.xml:1254(literal) xml/charset.xml:1264(literal) xml/charset.xml:1292(literal) xml/charset.xml:1336(literal) xml/charset.xml:1355(literal) xml/charset.xml:1364(literal) xml/charset.xml:1374(literal) xml/charset.xml:1383(literal) xml/charset.xml:1436(literal) xml/charset.xml:1439(emphasis) xml/charset.xml:1497(literal) xml/charset.xml:1516(literal) xml/charset.xml:1527(literal)
msgid "MULE_INTERNAL"
msgstr ""

#: xml/charset.xml:901(entry)
msgid "Mule internal code"
msgstr ""

#: xml/charset.xml:902(entry)
msgid "Multilingual Emacs"
msgstr ""

#: xml/charset.xml:909(literal) xml/charset.xml:1245(literal) xml/charset.xml:1449(literal) xml/charset.xml:1456(literal)
msgid "SJIS"
msgstr ""

#: xml/charset.xml:911(entry)
msgid "Shift JIS"
msgstr ""

#: xml/charset.xml:916(literal)
msgid "Mskanji"
msgstr ""

#: xml/charset.xml:917(literal)
msgid "ShiftJIS"
msgstr ""

#: xml/charset.xml:918(literal)
msgid "WIN932"
msgstr ""

#: xml/charset.xml:919(literal)
msgid "Windows932"
msgstr ""

#: xml/charset.xml:915(entry) xml/charset.xml:1081(entry) xml/charset.xml:1242(entry) xml/charset.xml:1261(entry) xml/charset.xml:1362(entry) xml/charset.xml:1513(entry)
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/>, <placeholder-4/>"
msgstr ""

#: xml/charset.xml:923(literal)
msgid "SHIFT_JIS_2004"
msgstr ""

#: xml/charset.xml:925(entry)
msgid "Shift JIS, JIS X 0213"
msgstr ""

#: xml/charset.xml:933(literal) xml/charset.xml:1465(literal)
msgid "SQL_ASCII"
msgstr ""

#: xml/charset.xml:935(entry)
msgid "unspecified (see text)"
msgstr ""

#: xml/charset.xml:937(emphasis)
msgid "any"
msgstr ""

#: xml/charset.xml:945(literal) xml/charset.xml:1474(literal)
msgid "UHC"
msgstr ""

#: xml/charset.xml:947(entry)
msgid "Unified Hangul Code"
msgstr ""

#: xml/charset.xml:952(literal)
msgid "WIN949"
msgstr ""

#: xml/charset.xml:953(literal)
msgid "Windows949"
msgstr ""

#: xml/charset.xml:957(literal) xml/charset.xml:1236(literal) xml/charset.xml:1246(literal) xml/charset.xml:1255(literal) xml/charset.xml:1265(literal) xml/charset.xml:1293(literal) xml/charset.xml:1303(literal) xml/charset.xml:1311(literal) xml/charset.xml:1319(literal) xml/charset.xml:1327(literal) xml/charset.xml:1337(literal) xml/charset.xml:1347(literal) xml/charset.xml:1356(literal) xml/charset.xml:1365(literal) xml/charset.xml:1375(literal) xml/charset.xml:1384(literal) xml/charset.xml:1392(literal) xml/charset.xml:1400(literal) xml/charset.xml:1408(literal) xml/charset.xml:1416(literal) xml/charset.xml:1424(literal) xml/charset.xml:1432(literal) xml/charset.xml:1483(literal) xml/charset.xml:1498(literal) xml/charset.xml:1507(literal) xml/charset.xml:1517(literal) xml/charset.xml:1528(literal) xml/charset.xml:1537(literal) xml/charset.xml:1545(literal) xml/charset.xml:1553(literal) xml/charset.xml:1561(literal) xml/charset.xml:1569(literal) xml/charset.xml:1577(literal) xml/charset.xml:1585(literal)
msgid "UTF8"
msgstr ""

#: xml/charset.xml:959(entry)
msgid "Unicode, 8-bit"
msgstr ""

#: xml/charset.xml:961(emphasis)
msgid "all"
msgstr ""

#: xml/charset.xml:966(literal)
msgid "Unicode"
msgstr ""

#: xml/charset.xml:971(literal) xml/charset.xml:1294(literal) xml/charset.xml:1338(literal) xml/charset.xml:1450(literal) xml/charset.xml:1491(literal) xml/charset.xml:1494(emphasis) xml/charset.xml:1529(literal)
msgid "WIN866"
msgstr ""

#: xml/charset.xml:973(entry)
msgid "Windows CP866"
msgstr ""

#: xml/charset.xml:974(entry) xml/charset.xml:1006(entry)
msgid "Cyrillic"
msgstr ""

#: xml/charset.xml:978(literal)
msgid "ALT"
msgstr ""

#: xml/charset.xml:983(literal) xml/charset.xml:1503(literal) xml/charset.xml:1506(emphasis)
msgid "WIN874"
msgstr ""

#: xml/charset.xml:985(entry)
msgid "Windows CP874"
msgstr ""

#: xml/charset.xml:986(entry)
msgid "Thai"
msgstr ""

#: xml/charset.xml:993(literal) xml/charset.xml:1366(literal) xml/charset.xml:1451(literal) xml/charset.xml:1511(literal) xml/charset.xml:1514(emphasis)
msgid "WIN1250"
msgstr ""

#: xml/charset.xml:995(entry)
msgid "Windows CP1250"
msgstr ""

#: xml/charset.xml:1003(literal) xml/charset.xml:1295(literal) xml/charset.xml:1339(literal) xml/charset.xml:1452(literal) xml/charset.xml:1499(literal) xml/charset.xml:1521(literal) xml/charset.xml:1524(emphasis)
msgid "WIN1251"
msgstr ""

#: xml/charset.xml:1005(entry)
msgid "Windows CP1251"
msgstr ""

#: xml/charset.xml:1010(literal)
msgid "WIN"
msgstr ""

#: xml/charset.xml:1015(literal) xml/charset.xml:1533(literal) xml/charset.xml:1536(emphasis)
msgid "WIN1252"
msgstr ""

#: xml/charset.xml:1017(entry)
msgid "Windows CP1252"
msgstr ""

#: xml/charset.xml:1025(literal) xml/charset.xml:1541(literal) xml/charset.xml:1544(emphasis)
msgid "WIN1253"
msgstr ""

#: xml/charset.xml:1027(entry)
msgid "Windows CP1253"
msgstr ""

#: xml/charset.xml:1028(entry)
msgid "Greek"
msgstr ""

#: xml/charset.xml:1035(literal) xml/charset.xml:1549(literal) xml/charset.xml:1552(emphasis)
msgid "WIN1254"
msgstr ""

#: xml/charset.xml:1037(entry)
msgid "Windows CP1254"
msgstr ""

#: xml/charset.xml:1045(literal) xml/charset.xml:1557(literal) xml/charset.xml:1560(emphasis)
msgid "WIN1255"
msgstr ""

#: xml/charset.xml:1047(entry)
msgid "Windows CP1255"
msgstr ""

#: xml/charset.xml:1048(entry)
msgid "Hebrew"
msgstr ""

#: xml/charset.xml:1055(literal) xml/charset.xml:1565(literal) xml/charset.xml:1568(emphasis)
msgid "WIN1256"
msgstr ""

#: xml/charset.xml:1057(entry)
msgid "Windows CP1256"
msgstr ""

#: xml/charset.xml:1058(entry)
msgid "Arabic"
msgstr ""

#: xml/charset.xml:1065(literal) xml/charset.xml:1573(literal) xml/charset.xml:1576(emphasis)
msgid "WIN1257"
msgstr ""

#: xml/charset.xml:1067(entry)
msgid "Windows CP1257"
msgstr ""

#: xml/charset.xml:1075(literal) xml/charset.xml:1581(literal) xml/charset.xml:1584(emphasis)
msgid "WIN1258"
msgstr ""

#: xml/charset.xml:1077(entry)
msgid "Windows CP1258"
msgstr ""

#: xml/charset.xml:1078(entry)
msgid "Vietnamese"
msgstr ""

#: xml/charset.xml:1082(literal)
msgid "ABC"
msgstr ""

#: xml/charset.xml:1083(literal)
msgid "TCVN"
msgstr ""

#: xml/charset.xml:1084(literal)
msgid "TCVN5712"
msgstr ""

#: xml/charset.xml:1085(literal)
msgid "VSCII"
msgstr ""

#: xml/charset.xml:1090(para)
msgid "Not all client <acronym>API</acronym>s support all the listed character sets. For example, the <productname>PostgreSQL</productname>JDBC driver does not support <literal>MULE_INTERNAL</literal>, <literal>LATIN6</literal>, <literal>LATIN8</literal>, and <literal>LATIN10</literal>."
msgstr ""

#: xml/charset.xml:1099(para)
msgid "The <literal>SQL_ASCII</literal>setting behaves considerably differently from the other settings. When the server character set is <literal>SQL_ASCII</literal>, the server interprets byte values 0-127 according to the ASCII standard, while byte values 128-255 are taken as uninterpreted characters. No encoding conversion will be done when the setting is <literal>SQL_ASCII</literal>. Thus, this setting is not so much a declaration that a specific encoding is in use, as a declaration of ignorance about the encoding. In most cases, if you are working with any non-ASCII data, it is unwise to use the <literal>SQL_ASCII</literal>setting because <productname>PostgreSQL</productname>will be unable to help you by converting or validating non-ASCII characters."
msgstr ""

#: xml/charset.xml:1117(title)
msgid "Setting the Character Set"
msgstr ""

#: xml/charset.xml:1118(para)
msgid "<command>initdb</command>defines the default character set (encoding) for a <productname>PostgreSQL</productname>cluster. For example, <screen>initdb -E EUC_JP</screen>sets the default character set to <literal>EUC_JP</literal>(Extended Unix Code for Japanese). You can use <option>--encoding</option>instead of <option>-E</option>if you prefer longer option strings. If no <option>-E</option>or <option>--encoding</option>option is given, <command>initdb</command>attempts to determine the appropriate encoding to use based on the specified or default locale."
msgstr ""

#: xml/charset.xml:1144(programlisting)
#, no-wrap
msgid "CREATE DATABASE korean WITH ENCODING 'EUC_KR'\n      LC_COLLATE='ko_KR.euckr' LC_CTYPE='ko_KR.euckr'\n      TEMPLATE=template0;"
msgstr ""

#: xml/charset.xml:1134(para)
msgid "You can specify a non-default encoding at database creation time, provided that the encoding is compatible with the selected locale: <screen>createdb -E EUC_KR -T template0\n      --lc-collate=ko_KR.euckr --lc-ctype=ko_KR.euckr\n      korean</screen>This will create a database named <literal>korean</literal>that uses the character set <literal>EUC_KR</literal>, and locale <literal>ko_KR</literal>. Another way to accomplish this is to use this SQL command: <placeholder-1/>Notice that the above commands specify copying the <literal>template0</literal>database. When copying any other database, the encoding and locale settings cannot be changed from those of the source database, because that might result in corrupt data. For more information see <xref linkend=\"manage-ag-templatedbs\">.</xref>"
msgstr ""

#: xml/charset.xml:1153(para)
msgid "The encoding for a database is stored in the system catalog <literal>pg_database</literal>. You can see it by using the <command>psql</command><option>-l</option>option or the <command>\\l</command>command. <screen>$ \n      <userinput>psql -l</userinput>List of databases Name | Owner\n      | Encoding | Collation | Ctype | Access Privileges\n      -----------+----------+-----------+-------------+-------------+-------------------------------------\n      clocaledb | hlinnaka | SQL_ASCII | C | C | englishdb |\n      hlinnaka | UTF8 | en_GB.UTF8 | en_GB.UTF8 | japanese |\n      hlinnaka | UTF8 | ja_JP.UTF8 | ja_JP.UTF8 | korean | hlinnaka\n      | EUC_KR | ko_KR.euckr | ko_KR.euckr | postgres | hlinnaka |\n      UTF8 | fi_FI.UTF8 | fi_FI.UTF8 | template0 | hlinnaka | UTF8\n      | fi_FI.UTF8 | fi_FI.UTF8 |\n      {=c/hlinnaka,hlinnaka=CTc/hlinnaka} template1 | hlinnaka |\n      UTF8 | fi_FI.UTF8 | fi_FI.UTF8 |\n      {=c/hlinnaka,hlinnaka=CTc/hlinnaka} (7 rows)</screen>"
msgstr ""

#: xml/charset.xml:1173(para)
msgid "On most modern operating systems, <productname>PostgreSQL</productname>can determine which character set is implied by the <envar>LC_CTYPE</envar>setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting."
msgstr ""

#: xml/charset.xml:1182(para)
msgid "<productname>PostgreSQL</productname>will allow superusers to create databases with <literal>SQL_ASCII</literal>encoding even when <envar>LC_CTYPE</envar>is not <literal>C</literal>or <literal>POSIX</literal>. As noted above, <literal>SQL_ASCII</literal>does not enforce that the data stored in the database has any particular encoding, and so this choice poses risks of locale-dependent misbehavior. Using this combination of settings is deprecated and may someday be forbidden altogether."
msgstr ""

#: xml/charset.xml:1197(title)
msgid "Automatic Character Set Conversion Between Server and Client"
msgstr ""

#: xml/charset.xml:1199(para)
msgid "<productname>PostgreSQL</productname>supports automatic character set conversion between server and client for certain character set combinations. The conversion information is stored in the <literal>pg_conversion</literal>system catalog. <productname>PostgreSQL</productname>comes with some predefined conversions, as shown in <xref linkend=\"multibyte-translation-table\">. You can create a new conversion using the SQL command <command>CREATE CONVERSION</command>.</xref>"
msgstr ""

#: xml/charset.xml:1211(title)
msgid "Client/Server Character Set Conversions"
msgstr ""

#: xml/charset.xml:1215(entry)
msgid "Server Character Set"
msgstr ""

#: xml/charset.xml:1216(entry)
msgid "Available Client Character Sets"
msgstr ""

#: xml/charset.xml:1225(emphasis) xml/charset.xml:1272(emphasis) xml/charset.xml:1281(emphasis) xml/charset.xml:1459(emphasis) xml/charset.xml:1477(emphasis)
msgid "not supported as a server encoding"
msgstr ""

#: xml/charset.xml:1233(entry) xml/charset.xml:1252(entry) xml/charset.xml:1353(entry) xml/charset.xml:1372(entry) xml/charset.xml:1381(entry)
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/>"
msgstr ""

#: xml/charset.xml:1289(entry) xml/charset.xml:1333(entry) xml/charset.xml:1493(entry) xml/charset.xml:1523(entry)
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/>, <placeholder-4/>, <placeholder-5/>, <placeholder-6/>"
msgstr ""

#: xml/charset.xml:1438(entry)
msgid "<placeholder-1/>, <placeholder-2/>, <placeholder-3/>, <placeholder-4/>, <placeholder-5/>, <placeholder-6/>, <placeholder-7/>, <placeholder-8/>, <placeholder-9/>to <placeholder-10/>, <placeholder-11/>, <placeholder-12/>, <placeholder-13/>, <placeholder-14/>"
msgstr ""

#: xml/charset.xml:1468(emphasis)
msgid "any (no conversion will be performed)"
msgstr ""

#: xml/charset.xml:1486(emphasis)
msgid "all supported encodings"
msgstr ""

#: xml/charset.xml:1604(programlisting)
#, no-wrap
msgid "\\encoding SJIS"
msgstr ""

#: xml/charset.xml:1597(para)
msgid "Using the <command>\\encoding</command>command in <application>psql</application>. <command>\\encoding</command>allows you to change client encoding on the fly. For example, to change the encoding to <literal>SJIS</literal>, type: <placeholder-1/>"
msgstr ""

#: xml/charset.xml:1607(para)
msgid "<application>libpq</application>( <xref linkend=\"libpq-control\">) has functions to control the client encoding.</xref>"
msgstr ""

#: xml/charset.xml:1616(programlisting)
#, no-wrap
msgid "SET CLIENT_ENCODING TO ' \n          <replaceable>value</replaceable>';"
msgstr ""

#: xml/charset.xml:1620(programlisting)
#, no-wrap
msgid "SET NAMES ' \n          <replaceable>value</replaceable>';"
msgstr ""

#: xml/charset.xml:1623(programlisting)
#, no-wrap
msgid "SHOW client_encoding;"
msgstr ""

#: xml/charset.xml:1625(programlisting)
#, no-wrap
msgid "RESET\n          client_encoding;"
msgstr ""

#: xml/charset.xml:1613(para)
msgid "Using <command>SET client_encoding TO</command>. Setting the client encoding can be done with this SQL command: <placeholder-1/>Also you can use the standard SQL syntax <literal>SET NAMES</literal>for this purpose: <placeholder-2/>To query the current client encoding: <placeholder-3/>To return to the default encoding: <placeholder-4/>"
msgstr ""

#: xml/charset.xml:1629(para)
msgid "Using <envar>PGCLIENTENCODING</envar>. If the environment variable <envar>PGCLIENTENCODING</envar>is defined in the client's environment, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)"
msgstr ""

#: xml/charset.xml:1639(para)
msgid "Using the configuration variable <xref linkend=\"guc-client-encoding\">. If the <varname>client_encoding</varname>variable is set, that client encoding is automatically selected when a connection to the server is made. (This can subsequently be overridden using any of the other methods mentioned above.)</xref>"
msgstr ""

#: xml/charset.xml:1590(para)
msgid "To enable automatic character set conversion, you have to tell <productname>PostgreSQL</productname>the character set (encoding) you would like to use in the client. There are several ways to accomplish this: <placeholder-1/>"
msgstr ""

#: xml/charset.xml:1648(para)
msgid "If the conversion of a particular character is not possible suppose you chose <literal>EUC_JP</literal>for the server and <literal>LATIN1</literal>for the client, and some Japanese characters are returned that do not have a representation in <literal>LATIN1</literal>an error is reported."
msgstr ""

#: xml/charset.xml:1654(para)
msgid "If the client character set is defined as <literal>SQL_ASCII</literal>, encoding conversion is disabled, regardless of the server's character set. Just as for the server, use of <literal>SQL_ASCII</literal>is unwise unless you are working with all-ASCII data."
msgstr ""

#: xml/charset.xml:1662(title)
msgid "Further Reading"
msgstr ""

#: xml/charset.xml:1668(citetitle)
msgid "CJKV Information Processing: Chinese, Japanese, Korean Vietnamese Computing"
msgstr ""

#: xml/charset.xml:1672(para)
msgid "Contains detailed explanations of <literal>EUC_JP</literal>, <literal>EUC_CN</literal>, <literal>EUC_KR</literal>, <literal>EUC_TW</literal>."
msgstr ""

#: xml/charset.xml:1684(para)
msgid "The web site of the Unicode Consortium."
msgstr ""

#: xml/charset.xml:1688(term)
msgid "RFC 3629"
msgstr ""

#: xml/charset.xml:1690(para)
msgid "<acronym>UTF</acronym>-8 (8-bit UCS/Unicode Transformation Format) is defined here."
msgstr ""

#: xml/charset.xml:1663(para)
msgid "These are good sources to start learning about various kinds of encoding systems. <placeholder-1/>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/charset.xml:0(None)
msgid "translator-credits"
msgstr ""

