msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/libpq.xml:3(title)
msgid "<application>libpq</application>- C Library"
msgstr ""

#: xml/libpq.xml:6(primary) xml/libpq.xml:2708(secondary) xml/libpq.xml:4286(primary)
msgid "libpq"
msgstr ""

#: xml/libpq.xml:9(primary)
msgid "C"
msgstr ""

#: xml/libpq.xml:11(para)
msgid "<application>libpq</application>is the <acronym>C</acronym>application programmer's interface to <productname>PostgreSQL</productname>. <application>libpq</application>is a set of library functions that allow client programs to pass queries to the <productname>PostgreSQL</productname>backend server and to receive the results of these queries."
msgstr ""

#: xml/libpq.xml:19(para)
msgid "<application>libpq</application>is also the underlying engine for several other <productname>PostgreSQL</productname>application interfaces, including those written for C++, Perl, Python, Tcl and <application>ECPG</application>. So some aspects of <application>libpq</application>'s behavior will be important to you if you use one of those packages. In particular, <xref linkend=\"libpq-envars\">, <xref linkend=\"libpq-pgpass\">and <xref linkend=\"libpq-ssl\">describe behavior that is visible to the user of any application that uses <application>libpq</application>.</xref></xref></xref>"
msgstr ""

#: xml/libpq.xml:32(para)
msgid "Some short programs are included at the end of this chapter ( <xref linkend=\"libpq-example\">) to show how to write programs that use <application>libpq</application>. There are also several complete examples of <application>libpq</application>applications in the directory <filename>src/test/examples</filename>in the source code distribution.</xref>"
msgstr ""

#: xml/libpq.xml:41(para)
msgid "Client programs that use <application>libpq</application>must include the header file <filename>libpq-fe.h</filename><indexterm><primary>libpq-fe.h</primary></indexterm>and must link with the <application>libpq</application>library."
msgstr ""

#: xml/libpq.xml:49(title)
msgid "Database Connection Control Functions"
msgstr ""

#: xml/libpq.xml:70(para)
msgid "On Unix, forking a process with open libpq connections can lead to unpredictable results because the parent and child processes share the same sockets and operating system resources. For this reason, such usage is not recommended, though doing an <function>exec</function>from the child process to load a new executable is safe."
msgstr ""

#: xml/libpq.xml:79(para)
msgid "On Windows, there is a way to improve performance if a single database connection is repeatedly started and shutdown. Internally, libpq calls <function>WSAStartup()</function>and <function>WSACleanup()</function>for connection startup and shutdown, respectively. <function>WSAStartup()</function>increments an internal Windows library reference count which is decremented by <function>WSACleanup()</function>. When the reference count is just one, calling <function>WSACleanup()</function>frees all resources and all DLLs are unloaded. This is an expensive operation. To avoid this, an application can manually call <function>WSAStartup()</function>so resources will not be freed when the last database connection is closed."
msgstr ""

#: xml/libpq.xml:98(function) xml/libpq.xml:100(primary)
msgid "PQconnectdbParams"
msgstr ""

#: xml/libpq.xml:104(para)
msgid "Makes a new connection to the database server. <synopsis>PGconn *PQconnectdbParams(const char * const\n          *keywords, const char * const *values, int\n          expand_dbname);</synopsis>"
msgstr ""

#: xml/libpq.xml:108(para)
msgid "This function opens a new database connection using the parameters taken from two <symbol>NULL</symbol>-terminated arrays. The first, <literal>keywords</literal>, is defined as an array of strings, each one being a key word. The second, <literal>values</literal>, gives the value for each key word. Unlike <function>PQsetdbLogin</function>below, the parameter set can be extended without changing the function signature, so use of this function (or its nonblocking analogs <function>PQconnectStartParams</function>and <function>PQconnectPoll</function>) is preferred for new application programming."
msgstr ""

#: xml/libpq.xml:121(para)
msgid "The currently recognized parameter key words are listed in <xref linkend=\"libpq-paramkeywords\">.</xref>"
msgstr ""

#: xml/libpq.xml:124(para)
msgid "When <literal>expand_dbname</literal>is non-zero, the <parameter>dbname</parameter>key word value is allowed to be recognized as a connection string. Only the first occurrence of <parameter>dbname</parameter>is expanded this way, any subsequent <parameter>dbname</parameter>value is processed as plain database name. More details on the possible connection string formats appear in <xref linkend=\"libpq-connstring\">.</xref>"
msgstr ""

#: xml/libpq.xml:135(para)
msgid "The passed arrays can be empty to use all default parameters, or can contain one or more parameter settings. They should be matched in length. Processing will stop at the first <symbol>NULL</symbol>element in the <literal>keywords</literal>array."
msgstr ""

#: xml/libpq.xml:141(para)
msgid "If any parameter is <symbol>NULL</symbol>or an empty string, the corresponding environment variable (see <xref linkend=\"libpq-envars\">) is checked. If the environment variable is not set either, then the indicated built-in defaults are used.</xref>"
msgstr ""

#: xml/libpq.xml:147(para)
msgid "In general key words are processed from the beginning of these arrays in index order. The effect of this is that when key words are repeated, the last processed value is retained. Therefore, through careful placement of the <parameter>dbname</parameter>key word, it is possible to determine what may be overridden by a <parameter>conninfo</parameter>string, and what may not."
msgstr ""

#: xml/libpq.xml:160(function) xml/libpq.xml:162(primary)
msgid "PQconnectdb"
msgstr ""

#: xml/libpq.xml:166(para)
msgid "Makes a new connection to the database server. <synopsis>PGconn *PQconnectdb(const char\n          *conninfo);</synopsis>"
msgstr ""

#: xml/libpq.xml:169(para)
msgid "This function opens a new database connection using the parameters taken from the string <literal>conninfo</literal>."
msgstr ""

#: xml/libpq.xml:172(para)
msgid "The passed string can be empty to use all default parameters, or it can contain one or more parameter settings separated by whitespace, or it can contain a <acronym>URI</acronym>. See <xref linkend=\"libpq-connstring\">for details.</xref>"
msgstr ""

#: xml/libpq.xml:182(function) xml/libpq.xml:184(primary)
msgid "PQsetdbLogin"
msgstr ""

#: xml/libpq.xml:188(para)
msgid "Makes a new connection to the database server. <synopsis>PGconn *PQsetdbLogin(const char *pghost, const\n          char *pgport, const char *pgoptions, const char *pgtty,\n          const char *dbName, const char *login, const char\n          *pwd);</synopsis>"
msgstr ""

#: xml/libpq.xml:193(para)
msgid "This is the predecessor of <function>PQconnectdb</function>with a fixed set of parameters. It has the same functionality except that the missing parameters will always take on default values. Write <symbol>NULL</symbol>or an empty string for any one of the fixed parameters that is to be defaulted."
msgstr ""

#: xml/libpq.xml:200(para)
msgid "If the <parameter>dbName</parameter>contains an <symbol>=</symbol>sign or has a valid connection <acronym>URI</acronym>prefix, it is taken as a <parameter>conninfo</parameter>string in exactly the same way as if it had been passed to <function>PQconnectdb</function>, and the remaining parameters are then applied as specified for <function>PQconnectdbParams</function>."
msgstr ""

#: xml/libpq.xml:213(function) xml/libpq.xml:215(primary)
msgid "PQsetdb"
msgstr ""

#: xml/libpq.xml:219(para)
msgid "Makes a new connection to the database server. <synopsis>PGconn *PQsetdb(char *pghost, char *pgport,\n          char *pgoptions, char *pgtty, char\n          *dbName);</synopsis>"
msgstr ""

#: xml/libpq.xml:223(para)
msgid "This is a macro that calls <function>PQsetdbLogin</function>with null pointers for the <parameter>login</parameter>and <parameter>pwd</parameter>parameters. It is provided for backward compatibility with very old programs."
msgstr ""

#: xml/libpq.xml:233(function) xml/libpq.xml:235(primary)
msgid "PQconnectStartParams"
msgstr ""

#: xml/libpq.xml:239(function) xml/libpq.xml:241(primary)
msgid "PQconnectStart"
msgstr ""

#: xml/libpq.xml:245(function) xml/libpq.xml:247(primary)
msgid "PQconnectPoll"
msgstr ""

#: xml/libpq.xml:251(para)
msgid "<indexterm><primary>nonblocking connection</primary></indexterm>Make a connection to the database server in a nonblocking manner. <synopsis>PGconn *PQconnectStartParams(const char * const\n          *keywords, const char * const *values, int\n          expand_dbname); PGconn *PQconnectStart(const char\n          *conninfo); PostgresPollingStatusType\n          PQconnectPoll(PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:261(para)
msgid "These three functions are used to open a connection to a database server such that your application's thread of execution is not blocked on remote I/O whilst doing so. The point of this approach is that the waits for I/O to complete can occur in the application's main loop, rather than down inside <function>PQconnectdbParams</function>or <function>PQconnectdb</function>, and so the application can manage this operation in parallel with other activities."
msgstr ""

#: xml/libpq.xml:271(para)
msgid "With <function>PQconnectStartParams</function>, the database connection is made using the parameters taken from the <literal>keywords</literal>and <literal>values</literal>arrays, and controlled by <literal>expand_dbname</literal>, as described above for <function>PQconnectdbParams</function>."
msgstr ""

#: xml/libpq.xml:278(para)
msgid "With <function>PQconnectStart</function>, the database connection is made using the parameters taken from the string <literal>conninfo</literal>as described above for <function>PQconnectdb</function>."
msgstr ""

#: xml/libpq.xml:291(para)
msgid "The <literal>hostaddr</literal>and <literal>host</literal>parameters are used appropriately to ensure that name and reverse name queries are not made. See the documentation of these parameters in <xref linkend=\"libpq-paramkeywords\">for details.</xref>"
msgstr ""

#: xml/libpq.xml:301(para)
msgid "If you call <function>PQtrace</function>, ensure that the stream object into which you trace will not block."
msgstr ""

#: xml/libpq.xml:306(para)
msgid "You ensure that the socket is in the appropriate state before calling <function>PQconnectPoll</function>, as described below."
msgstr ""

#: xml/libpq.xml:284(para)
msgid "Neither <function>PQconnectStartParams</function>nor <function>PQconnectStart</function>nor <function>PQconnectPoll</function>will block, so long as a number of restrictions are met: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:312(para)
msgid "Note: use of <function>PQconnectStartParams</function>is analogous to <function>PQconnectStart</function>shown below."
msgstr ""

#: xml/libpq.xml:315(para)
msgid "To begin a nonblocking connection request, call <literal>conn = PQconnectStart(\" <replaceable> connection_info_string</replaceable>\")</literal>. If <varname>conn</varname>is null, then <application>libpq</application>has been unable to allocate a new <structname>PGconn</structname>structure. Otherwise, a valid <structname>PGconn</structname>pointer is returned (though not yet representing a valid connection to the database). On return from <function>PQconnectStart</function>, call <literal>status = PQstatus(conn)</literal>. If <varname>status</varname>equals <symbol>CONNECTION_BAD</symbol>, <function>PQconnectStart</function>has failed."
msgstr ""

#: xml/libpq.xml:332(para)
msgid "If <function>PQconnectStart</function>succeeds, the next stage is to poll <application>libpq</application>so that it can proceed with the connection sequence. Use <function>PQsocket(conn)</function>to obtain the descriptor of the socket underlying the database connection. Loop thus: If <function>PQconnectPoll(conn)</function>last returned <symbol>PGRES_POLLING_READING</symbol>, wait until the socket is ready to read (as indicated by <function>select()</function>, <function>poll()</function>, or similar system function). Then call <function>PQconnectPoll(conn)</function>again. Conversely, if <function>PQconnectPoll(conn)</function>last returned <symbol>PGRES_POLLING_WRITING</symbol>, wait until the socket is ready to write, then call <function>PQconnectPoll(conn)</function>again. If you have yet to call <function>PQconnectPoll</function>, i.e., just after the call to <function>PQconnectStart</function>, behave as if it last returned <symbol>PGRES_POLLING_WRITING</symbol>. Continue this loop until <function>PQconnectPoll(conn)</function>returns <symbol>PGRES_POLLING_FAILED</symbol>, indicating the connection procedure has failed, or <symbol>PGRES_POLLING_OK</symbol>, indicating the connection has been successfully made."
msgstr ""

#: xml/libpq.xml:381(symbol)
msgid "CONNECTION_STARTED"
msgstr ""

#: xml/libpq.xml:384(para)
msgid "Waiting for connection to be made."
msgstr ""

#: xml/libpq.xml:389(symbol)
msgid "CONNECTION_MADE"
msgstr ""

#: xml/libpq.xml:392(para)
msgid "Connection OK; waiting to send."
msgstr ""

#: xml/libpq.xml:397(symbol)
msgid "CONNECTION_AWAITING_RESPONSE"
msgstr ""

#: xml/libpq.xml:400(para)
msgid "Waiting for a response from the server."
msgstr ""

#: xml/libpq.xml:406(symbol)
msgid "CONNECTION_AUTH_OK"
msgstr ""

#: xml/libpq.xml:409(para)
msgid "Received authentication; waiting for backend start-up to finish."
msgstr ""

#: xml/libpq.xml:415(symbol)
msgid "CONNECTION_SSL_STARTUP"
msgstr ""

#: xml/libpq.xml:418(para)
msgid "Negotiating SSL encryption."
msgstr ""

#: xml/libpq.xml:423(symbol)
msgid "CONNECTION_SETENV"
msgstr ""

#: xml/libpq.xml:426(para)
msgid "Negotiating environment-driven parameter settings."
msgstr ""

#: xml/libpq.xml:436(programlisting)
#, no-wrap
msgid "switch(PQstatus(conn)) { case\n          CONNECTION_STARTED: feedback = \"Connecting...\"; break;\n          case CONNECTION_MADE: feedback = \"Connected to\n          server...\"; break; . . . default: feedback =\n          \"Connecting...\"; }"
msgstr ""

#: xml/libpq.xml:364(para)
msgid "At any time during connection, the status of the connection can be checked by calling <function>PQstatus</function>. If this call returns <symbol>CONNECTION_BAD</symbol>, then the connection procedure has failed; if the call returns <function>CONNECTION_OK</function>, then the connection is ready. Both of these states are equally detectable from the return value of <function>PQconnectPoll</function>, described above. Other states might also occur during (and only during) an asynchronous connection procedure. These indicate the current stage of the connection procedure and might be useful to provide feedback to the user for example. These statuses are: <placeholder-1/>Note that, although these constants will remain (in order to maintain compatibility), an application should never rely upon these occurring in a particular order, or at all, or on the status always being one of these documented values. An application might do something like this: <placeholder-2/>"
msgstr ""

#: xml/libpq.xml:441(para)
msgid "The <literal>connect_timeout</literal>connection parameter is ignored when using <function>PQconnectPoll</function>; it is the application's responsibility to decide whether an excessive amount of time has elapsed. Otherwise, <function>PQconnectStart</function>followed by a <function>PQconnectPoll</function>loop is equivalent to <function>PQconnectdb</function>."
msgstr ""

#: xml/libpq.xml:450(para)
msgid "Note that if <function>PQconnectStart</function>returns a non-null pointer, you must call <function>PQfinish</function>when you are finished with it, in order to dispose of the structure and any associated memory blocks. This must be done even if the connection attempt fails or is abandoned."
msgstr ""

#: xml/libpq.xml:461(function) xml/libpq.xml:463(primary)
msgid "PQconndefaults"
msgstr ""

#: xml/libpq.xml:467(para)
msgid "Returns the default connection options. <synopsis>PQconninfoOption *PQconndefaults(void); typedef\n          struct { char *keyword; /* The keyword of the option */\n          char *envvar; /* Fallback environment variable name */\n          char *compiled; /* Fallback compiled in default value */\n          char *val; /* Option's current value, or NULL */ char\n          *label; /* Label for field in connect dialog */ char\n          *dispchar; /* Indicates how to display this field in a\n          connect dialog. Values are: \"\" Display entered value as\n          is \"*\" Password field - hide value \"D\" Debug option -\n          don't show by default */ int dispsize; /* Field size in\n          characters for dialog */ }\n          PQconninfoOption;</synopsis>"
msgstr ""

#: xml/libpq.xml:480(para)
msgid "Returns a connection options array. This can be used to determine all possible <function>PQconnectdb</function>options and their current default values. The return value points to an array of <structname>PQconninfoOption</structname>structures, which ends with an entry having a null <structfield>keyword</structfield>pointer. The null pointer is returned if memory could not be allocated. Note that the current default values ( <structfield>val</structfield>fields) will depend on environment variables and other context. A missing or invalid service file will be silently ignored. Callers must treat the connection options data as read-only."
msgstr ""

#: xml/libpq.xml:494(para)
msgid "After processing the options array, free it by passing it to <function>PQconninfoFree</function>. If this is not done, a small amount of memory is leaked for each call to <function>PQconndefaults</function>."
msgstr ""

#: xml/libpq.xml:503(function) xml/libpq.xml:505(primary)
msgid "PQconninfo"
msgstr ""

#: xml/libpq.xml:509(para)
msgid "Returns the connection options used by a live connection. <synopsis>PQconninfoOption *PQconninfo(PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:513(para)
msgid "Returns a connection options array. This can be used to determine all possible <function>PQconnectdb</function>options and the values that were used to connect to the server. The return value points to an array of <structname>PQconninfoOption</structname>structures, which ends with an entry having a null <structfield>keyword</structfield>pointer. All notes above for <function>PQconndefaults</function>also apply to the result of <function>PQconninfo</function>."
msgstr ""

#: xml/libpq.xml:529(function) xml/libpq.xml:531(primary)
msgid "PQconninfoParse"
msgstr ""

#: xml/libpq.xml:535(para)
msgid "Returns parsed connection options from the provided connection string. <synopsis>PQconninfoOption *PQconninfoParse(const char\n          *conninfo, char **errmsg);</synopsis>"
msgstr ""

#: xml/libpq.xml:539(para)
msgid "Parses a connection string and returns the resulting options as an array; or returns <symbol>NULL</symbol>if there is a problem with the connection string. This function can be used to extract the <function>PQconnectdb</function>options in the provided connection string. The return value points to an array of <structname>PQconninfoOption</structname>structures, which ends with an entry having a null <structfield>keyword</structfield>pointer."
msgstr ""

#: xml/libpq.xml:550(para)
msgid "All legal options will be present in the result array, but the <literal>PQconninfoOption</literal>for any option not present in the connection string will have <literal>val</literal>set to <literal>NULL</literal>; default values are not inserted."
msgstr ""

#: xml/libpq.xml:557(para)
msgid "If <literal>errmsg</literal>is not <symbol>NULL</symbol>, then <literal>*errmsg</literal>is set to <symbol>NULL</symbol>on success, else to a <function>malloc</function>'d error string explaining the problem. (It is also possible for <literal>*errmsg</literal>to be set to <symbol>NULL</symbol>and the function to return <symbol>NULL</symbol>; this indicates an out-of-memory condition.)"
msgstr ""

#: xml/libpq.xml:568(para)
msgid "After processing the options array, free it by passing it to <function>PQconninfoFree</function>. If this is not done, some memory is leaked for each call to <function>PQconninfoParse</function>. Conversely, if an error occurs and <literal>errmsg</literal>is not <symbol>NULL</symbol>, be sure to free the error string using <function>PQfreemem</function>."
msgstr ""

#: xml/libpq.xml:582(function) xml/libpq.xml:584(primary)
msgid "PQfinish"
msgstr ""

#: xml/libpq.xml:588(para)
msgid "Closes the connection to the server. Also frees memory used by the <structname>PGconn</structname>object. <synopsis>void PQfinish(PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:592(para)
msgid "Note that even if the server connection attempt fails (as indicated by <function>PQstatus</function>), the application should call <function>PQfinish</function>to free the memory used by the <structname>PGconn</structname>object. The <structname>PGconn</structname>pointer must not be used again after <function>PQfinish</function>has been called."
msgstr ""

#: xml/libpq.xml:606(function) xml/libpq.xml:608(primary)
msgid "PQreset"
msgstr ""

#: xml/libpq.xml:612(para)
msgid "Resets the communication channel to the server. <synopsis>void PQreset(PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:614(para)
msgid "This function will close the connection to the server and attempt to reestablish a new connection to the same server, using all the same parameters previously used. This might be useful for error recovery if a working connection is lost."
msgstr ""

#: xml/libpq.xml:623(function) xml/libpq.xml:625(primary)
msgid "PQresetStart"
msgstr ""

#: xml/libpq.xml:629(function) xml/libpq.xml:631(primary)
msgid "PQresetPoll"
msgstr ""

#: xml/libpq.xml:635(para)
msgid "Reset the communication channel to the server, in a nonblocking manner. <synopsis>int PQresetStart(PGconn *conn);\n          PostgresPollingStatusType PQresetPoll(PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:640(para)
msgid "These functions will close the connection to the server and attempt to reestablish a new connection to the same server, using all the same parameters previously used. This can be useful for error recovery if a working connection is lost. They differ from <function>PQreset</function>(above) in that they act in a nonblocking manner. These functions suffer from the same restrictions as <function>PQconnectStartParams</function>, <function>PQconnectStart</function>and <function>PQconnectPoll</function>."
msgstr ""

#: xml/libpq.xml:651(para)
msgid "To initiate a connection reset, call <function>PQresetStart</function>. If it returns 0, the reset has failed. If it returns 1, poll the reset using <function>PQresetPoll</function>in exactly the same way as you would create the connection using <function>PQconnectPoll</function>."
msgstr ""

#: xml/libpq.xml:661(function) xml/libpq.xml:663(primary)
msgid "PQpingParams"
msgstr ""

#: xml/libpq.xml:683(literal)
msgid "PQPING_OK"
msgstr ""

#: xml/libpq.xml:686(para)
msgid "The server is running and appears to be accepting connections."
msgstr ""

#: xml/libpq.xml:692(literal)
msgid "PQPING_REJECT"
msgstr ""

#: xml/libpq.xml:695(para)
msgid "The server is running but is in a state that disallows connections (startup, shutdown, or crash recovery)."
msgstr ""

#: xml/libpq.xml:703(literal)
msgid "PQPING_NO_RESPONSE"
msgstr ""

#: xml/libpq.xml:706(para)
msgid "The server could not be contacted. This might indicate that the server is not running, or that there is something wrong with the given connection parameters (for example, wrong port number), or that there is a network connectivity problem (for example, a firewall blocking the connection request)."
msgstr ""

#: xml/libpq.xml:718(literal)
msgid "PQPING_NO_ATTEMPT"
msgstr ""

#: xml/libpq.xml:721(para)
msgid "No attempt was made to contact the server, because the supplied parameters were obviously incorrect or there was some client-side problem (for example, out of memory)."
msgstr ""

#: xml/libpq.xml:667(para)
msgid "<function>PQpingParams</function>reports the status of the server. It accepts connection parameters identical to those of <function>PQconnectdbParams</function>, described above. It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt. <synopsis>PGPing PQpingParams(const char * const\n          *keywords, const char * const *values, int\n          expand_dbname);</synopsis>The function returns one of the following values: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:732(function) xml/libpq.xml:734(primary)
msgid "PQping"
msgstr ""

#: xml/libpq.xml:738(para)
msgid "<function>PQping</function>reports the status of the server. It accepts connection parameters identical to those of <function>PQconnectdb</function>, described above. It is not necessary to supply correct user name, password, or database name values to obtain the server status; however, if incorrect values are provided, the server will log a failed connection attempt. <synopsis>PGPing PQping(const char\n          *conninfo);</synopsis>"
msgstr ""

#: xml/libpq.xml:749(para)
msgid "The return values are the same as for <function>PQpingParams</function>."
msgstr ""

#: xml/libpq.xml:50(para)
msgid "The following functions deal with making a connection to a <productname>PostgreSQL</productname>backend server. An application program can have several backend connections open at one time. (One reason to do that is to access more than one database.) Each connection is represented by a <structname>PGconn</structname><indexterm><primary>PGconn</primary></indexterm>object, which is obtained from the function <function>PQconnectdb</function>, <function>PQconnectdbParams</function>, or <function>PQsetdbLogin</function>. Note that these functions will always return a non-null object pointer, unless perhaps there is too little memory even to allocate the <structname>PGconn</structname>object. The <function>PQstatus</function>function should be called to check the return value for a successful connection before queries are sent via the connection object. <placeholder-1/><placeholder-2/><placeholder-3/>"
msgstr ""

#: xml/libpq.xml:755(title)
msgid "Connection Strings"
msgstr ""

#: xml/libpq.xml:758(literal)
msgid "conninfo"
msgstr ""

#: xml/libpq.xml:763(literal)
msgid "URI"
msgstr ""

#: xml/libpq.xml:766(para)
msgid "Several <application>libpq</application>functions parse a user-specified string to obtain connection parameters. There are two accepted formats for these strings: plain <literal>keyword = value</literal>strings and <ulink url=\"http://www.ietf.org/rfc/rfc3986.txt\">RFC 3986</ulink>URIs."
msgstr ""

#: xml/libpq.xml:774(title)
msgid "Keyword/Value Connection Strings"
msgstr ""

#: xml/libpq.xml:775(para)
msgid "In the first format, each parameter setting is in the form <literal>keyword = value</literal>. Spaces around the equal sign are optional. To write an empty value, or a value containing spaces, surround it with single quotes, e.g., <literal>keyword = 'a value'</literal>. Single quotes and backslashes within the value must be escaped with a backslash, i.e., <literal>\\'</literal>and <literal>\\\\</literal>."
msgstr ""

#: xml/libpq.xml:786(programlisting)
#, no-wrap
msgid "host=localhost port=5432 dbname=mydb\n        connect_timeout=10"
msgstr ""

#: xml/libpq.xml:785(para)
msgid "Example: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:788(para)
msgid "The recognized parameter key words are listed in <xref linkend=\"libpq-paramkeywords\">.</xref>"
msgstr ""

#: xml/libpq.xml:792(title)
msgid "Connection URIs"
msgstr ""

#: xml/libpq.xml:793(para)
msgid "The general form for a connection <acronym>URI</acronym>is: <synopsis>\n        postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1...]</synopsis>"
msgstr ""

#: xml/libpq.xml:804(programlisting)
#, no-wrap
msgid "postgresql:// postgresql://localhost\n        postgresql://localhost:5433 postgresql://localhost/mydb\n        postgresql://user@localhost\n        postgresql://user:secret@localhost\n        postgresql://other@localhost/otherdb?connect_timeout=10application_name=myapp"
msgstr ""

#: xml/libpq.xml:812(programlisting)
#, no-wrap
msgid "\n        postgresql:///mydb?host=localhostport=5433"
msgstr ""

#: xml/libpq.xml:797(para)
msgid "The <acronym>URI</acronym>scheme designator can be either <literal>postgresql://</literal>or <literal>postgres://</literal>. Each of the <acronym>URI</acronym>parts is optional. The following examples illustrate valid <acronym>URI</acronym>syntax uses: <placeholder-1/>Components of the hierarchical part of the <acronym>URI</acronym>can also be given as parameters. For example: <placeholder-2/>"
msgstr ""

#: xml/libpq.xml:814(para)
msgid "Percent-encoding may be used to include symbols with special meaning in any of the <acronym>URI</acronym>parts."
msgstr ""

#: xml/libpq.xml:817(para)
msgid "Any connection parameters not corresponding to key words listed in <xref linkend=\"libpq-paramkeywords\">are ignored and a warning message about them is sent to <filename>stderr</filename>.</xref>"
msgstr ""

#: xml/libpq.xml:822(para)
msgid "For improved compatibility with JDBC connection <acronym>URI</acronym>s, instances of parameter <literal>ssl=true</literal>are translated into <literal>sslmode=require</literal>."
msgstr ""

#: xml/libpq.xml:826(para)
msgid "The host part may be either host name or an IP address. To specify an IPv6 host address, enclose it in square brackets: <synopsis>\n        postgresql://[2001:db8::1234]/database</synopsis>"
msgstr ""

#: xml/libpq.xml:842(programlisting)
#, no-wrap
msgid "\n        postgresql:///dbname?host=/var/lib/postgresql\n        postgresql://%2Fvar%2Flib%2Fpostgresql/dbname"
msgstr ""

#: xml/libpq.xml:831(para)
msgid "The host component is interpreted as described for the parameter <xref linkend=\"libpq-connect-host\">. In particular, a Unix-domain socket connection is chosen if the host part is either empty or starts with a slash, otherwise a TCP/IP connection is initiated. Note, however, that the slash is a reserved character in the hierarchical part of the URI. So, to specify a non-standard Unix-domain socket directory, either omit the host specification in the URI and specify the host as a parameter, or percent-encode the path in the host component of the URI: <placeholder-1/></xref>"
msgstr ""

#: xml/libpq.xml:848(title)
msgid "Parameter Key Words"
msgstr ""

#: xml/libpq.xml:853(literal)
msgid "host"
msgstr ""

#: xml/libpq.xml:856(para)
msgid "Name of host to connect to. <indexterm><primary>host name</primary></indexterm>If this begins with a slash, it specifies Unix-domain communication rather than TCP/IP communication; the value is the name of the directory in which the socket file is stored. The default behavior when <literal>host</literal>is not specified is to connect to a Unix-domain socket <indexterm><primary>Unix domain socket</primary></indexterm>in <filename>/tmp</filename>(or whatever socket directory was specified when <productname>PostgreSQL</productname>was built). On machines without Unix-domain sockets, the default is to connect to <literal>localhost</literal>."
msgstr ""

#: xml/libpq.xml:880(literal)
msgid "hostaddr"
msgstr ""

#: xml/libpq.xml:883(para)
msgid "Numeric IP address of host to connect to. This should be in the standard IPv4 address format, e.g., <literal>172.28.40.9</literal>. If your machine supports IPv6, you can also use those addresses. TCP/IP communication is always used when a nonempty string is specified for this parameter."
msgstr ""

#: xml/libpq.xml:900(para)
msgid "If <literal>host</literal>is specified without <literal>hostaddr</literal>, a host name lookup occurs."
msgstr ""

#: xml/libpq.xml:906(para)
msgid "If <literal>hostaddr</literal>is specified without <literal>host</literal>, the value for <literal>hostaddr</literal>gives the server network address. The connection attempt will fail if the authentication method requires a host name."
msgstr ""

#: xml/libpq.xml:914(para)
msgid "If both <literal>host</literal>and <literal>hostaddr</literal>are specified, the value for <literal>hostaddr</literal>gives the server network address. The value for <literal>host</literal>is ignored unless the authentication method requires it, in which case it will be used as the host name."
msgstr ""

#: xml/libpq.xml:889(para)
msgid "Using <literal>hostaddr</literal>instead of <literal>host</literal>allows the application to avoid a host name look-up, which might be important in applications with time constraints. However, a host name is required for GSSAPI or SSPI authentication methods, as well as for <literal>verify-full</literal>SSL certificate verification. The following rules are used: <placeholder-1/>Note that authentication is likely to fail if <literal>host</literal>is not the name of the server at network address <literal>hostaddr</literal>. Also, note that <literal>host</literal>rather than <literal>hostaddr</literal>is used to identify the connection in <filename>~/.pgpass</filename>(see <xref linkend=\"libpq-pgpass\">).</xref>"
msgstr ""

#: xml/libpq.xml:934(para)
msgid "Without either a host name or host address, <application>libpq</application>will connect using a local Unix-domain socket; or on machines without Unix-domain sockets, it will attempt to connect to <literal>localhost</literal>."
msgstr ""

#: xml/libpq.xml:943(literal)
msgid "port"
msgstr ""

#: xml/libpq.xml:946(para)
msgid "Port number to connect to at the server host, or socket file name extension for Unix-domain connections. <indexterm><primary>port</primary></indexterm>"
msgstr ""

#: xml/libpq.xml:956(literal)
msgid "dbname"
msgstr ""

#: xml/libpq.xml:959(para)
msgid "The database name. Defaults to be the same as the user name. In certain contexts, the value is checked for extended formats; see <xref linkend=\"libpq-connstring\">for more details on those.</xref>"
msgstr ""

#: xml/libpq.xml:968(literal)
msgid "user"
msgstr ""

#: xml/libpq.xml:971(para)
msgid "<productname>PostgreSQL</productname>user name to connect as. Defaults to be the same as the operating system name of the user running the application."
msgstr ""

#: xml/libpq.xml:980(literal)
msgid "password"
msgstr ""

#: xml/libpq.xml:983(para)
msgid "Password to be used if the server demands password authentication."
msgstr ""

#: xml/libpq.xml:990(literal)
msgid "connect_timeout"
msgstr ""

#: xml/libpq.xml:993(para)
msgid "Maximum wait for connection, in seconds (write as a decimal integer string). Zero or not specified means wait indefinitely. It is not recommended to use a timeout of less than 2 seconds."
msgstr ""

#: xml/libpq.xml:1002(literal)
msgid "client_encoding"
msgstr ""

#: xml/libpq.xml:1005(para)
msgid "This sets the <varname>client_encoding</varname>configuration parameter for this connection. In addition to the values accepted by the corresponding server option, you can use <literal>auto</literal>to determine the right encoding from the current locale in the client ( <envar>LC_CTYPE</envar>environment variable on Unix systems)."
msgstr ""

#: xml/libpq.xml:1019(literal)
msgid "options"
msgstr ""

#: xml/libpq.xml:1022(para)
msgid "Specifies command-line options to send to the server at connection start. For example, setting this to <literal>-c geqo=off</literal>sets the session's value of the <varname>geqo</varname>parameter to <literal>off</literal>. Spaces within this string are considered to separate command-line arguments, unless escaped with a backslash ( <literal>\\</literal>); write <literal>\\\\</literal>to represent a literal backslash. For a detailed discussion of the available options, consult <xref linkend=\"runtime-config\">.</xref>"
msgstr ""

#: xml/libpq.xml:1041(literal)
msgid "application_name"
msgstr ""

#: xml/libpq.xml:1044(para)
msgid "Specifies a value for the <xref linkend=\"guc-application-name\">configuration parameter.</xref>"
msgstr ""

#: xml/libpq.xml:1052(literal)
msgid "fallback_application_name"
msgstr ""

#: xml/libpq.xml:1055(para)
msgid "Specifies a fallback value for the <xref linkend=\"guc-application-name\">configuration parameter. This value will be used if no value has been given for <literal>application_name</literal>via a connection parameter or the <envar>PGAPPNAME</envar>environment variable. Specifying a fallback name is useful in generic utility programs that wish to set a default application name but allow it to be overridden by the user.</xref>"
msgstr ""

#: xml/libpq.xml:1070(literal)
msgid "keepalives"
msgstr ""

#: xml/libpq.xml:1073(para)
msgid "Controls whether client-side TCP keepalives are used. The default value is 1, meaning on, but you can change this to 0, meaning off, if keepalives are not wanted. This parameter is ignored for connections made via a Unix-domain socket."
msgstr ""

#: xml/libpq.xml:1083(literal)
msgid "keepalives_idle"
msgstr ""

#: xml/libpq.xml:1086(para)
msgid "Controls the number of seconds of inactivity after which TCP should send a keepalive message to the server. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket, or if keepalives are disabled. It is only supported on systems where the <symbol>TCP_KEEPIDLE</symbol>or <symbol>TCP_KEEPALIVE</symbol>socket option is available, and on Windows; on other systems, it has no effect."
msgstr ""

#: xml/libpq.xml:1101(literal)
msgid "keepalives_interval"
msgstr ""

#: xml/libpq.xml:1104(para)
msgid "Controls the number of seconds after which a TCP keepalive message that is not acknowledged by the server should be retransmitted. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket, or if keepalives are disabled. It is only supported on systems where the <symbol>TCP_KEEPINTVL</symbol>socket option is available, and on Windows; on other systems, it has no effect."
msgstr ""

#: xml/libpq.xml:1119(literal)
msgid "keepalives_count"
msgstr ""

#: xml/libpq.xml:1122(para)
msgid "Controls the number of TCP keepalives that can be lost before the client's connection to the server is considered dead. A value of zero uses the system default. This parameter is ignored for connections made via a Unix-domain socket, or if keepalives are disabled. It is only supported on systems where the <symbol>TCP_KEEPCNT</symbol>socket option is available; on other systems, it has no effect."
msgstr ""

#: xml/libpq.xml:1134(literal)
msgid "tty"
msgstr ""

#: xml/libpq.xml:1137(para)
msgid "Ignored (formerly, this specified where to send server debug output)."
msgstr ""

#: xml/libpq.xml:1144(literal) xml/libpq.xml:6923(literal)
msgid "sslmode"
msgstr ""

#: xml/libpq.xml:1154(literal) xml/libpq.xml:6934(literal)
msgid "disable"
msgstr ""

#: xml/libpq.xml:1157(para)
msgid "only try a non- <acronym>SSL</acronym>connection"
msgstr ""

#: xml/libpq.xml:1163(literal) xml/libpq.xml:6943(literal)
msgid "allow"
msgstr ""

#: xml/libpq.xml:1166(para)
msgid "first try a non- <acronym>SSL</acronym>connection; if that fails, try an <acronym>SSL</acronym>connection"
msgstr ""

#: xml/libpq.xml:1173(term)
msgid "<literal>prefer</literal>(default)"
msgstr ""

#: xml/libpq.xml:1176(para)
msgid "first try an <acronym>SSL</acronym>connection; if that fails, try a non- <acronym>SSL</acronym>connection"
msgstr ""

#: xml/libpq.xml:1184(literal) xml/libpq.xml:6963(literal)
msgid "require"
msgstr ""

#: xml/libpq.xml:1187(para)
msgid "only try an <acronym>SSL</acronym>connection. If a root CA file is present, verify the certificate in the same way as if <literal>verify-ca</literal>was specified"
msgstr ""

#: xml/libpq.xml:1196(literal) xml/libpq.xml:6973(literal)
msgid "verify-ca"
msgstr ""

#: xml/libpq.xml:1199(para)
msgid "only try an <acronym>SSL</acronym>connection, and verify that the server certificate is issued by a trusted certificate authority ( <acronym>CA</acronym>)"
msgstr ""

#: xml/libpq.xml:1208(literal) xml/libpq.xml:6984(literal)
msgid "verify-full"
msgstr ""

#: xml/libpq.xml:1211(para)
msgid "only try an <acronym>SSL</acronym>connection, verify that the server certificate is issued by a trusted <acronym>CA</acronym>and that the requested server host name matches that in the certificate"
msgstr ""

#: xml/libpq.xml:1147(para)
msgid "This option determines whether or with what priority a secure <acronym>SSL</acronym>TCP/IP connection will be negotiated with the server. There are six modes: <placeholder-1/>See <xref linkend=\"libpq-ssl\">for a detailed description of how these options work.</xref>"
msgstr ""

#: xml/libpq.xml:1222(para)
msgid "<literal>sslmode</literal>is ignored for Unix domain socket communication. If <productname>PostgreSQL</productname>is compiled without SSL support, using options <literal>require</literal>, <literal>verify-ca</literal>, or <literal>verify-full</literal>will cause an error, while options <literal>allow</literal>and <literal>prefer</literal>will be accepted but <application>libpq</application>will not actually attempt an <acronym>SSL</acronym>connection. <indexterm><primary>SSL</primary><secondary sortas=\"libpq\">with libpq</secondary></indexterm>"
msgstr ""

#: xml/libpq.xml:1245(literal)
msgid "requiressl"
msgstr ""

#: xml/libpq.xml:1248(para)
msgid "This option is deprecated in favor of the <literal>sslmode</literal>setting."
msgstr ""

#: xml/libpq.xml:1250(para)
msgid "If set to 1, an <acronym>SSL</acronym>connection to the server is required (this is equivalent to <literal>sslmode</literal><literal>require</literal>). <application>libpq</application>will then refuse to connect if the server does not accept an <acronym>SSL</acronym>connection. If set to 0 (default), <application>libpq</application>will negotiate the connection type with the server (equivalent to <literal>sslmode</literal><literal>prefer</literal>). This option is only available if <productname>PostgreSQL</productname>is compiled with SSL support."
msgstr ""

#: xml/libpq.xml:1271(literal)
msgid "sslcompression"
msgstr ""

#: xml/libpq.xml:1274(para)
msgid "If set to 1 (default), data sent over SSL connections will be compressed (this requires <productname>OpenSSL</productname>version 0.9.8 or later). If set to 0, compression will be disabled (this requires <productname>OpenSSL</productname>1.0.0 or later). This parameter is ignored if a connection without SSL is made, or if the version of <productname>OpenSSL</productname>used does not support it."
msgstr ""

#: xml/libpq.xml:1284(para)
msgid "Compression uses CPU time, but can improve throughput if the network is the bottleneck. Disabling compression can improve response time and throughput if CPU performance is the limiting factor."
msgstr ""

#: xml/libpq.xml:1293(literal)
msgid "sslcert"
msgstr ""

#: xml/libpq.xml:1296(para)
msgid "This parameter specifies the file name of the client SSL certificate, replacing the default <filename>~/.postgresql/postgresql.crt</filename>. This parameter is ignored if an SSL connection is not made."
msgstr ""

#: xml/libpq.xml:1305(literal)
msgid "sslkey"
msgstr ""

#: xml/libpq.xml:1308(para)
msgid "This parameter specifies the location for the secret key used for the client certificate. It can either specify a file name that will be used instead of the default <filename>~/.postgresql/postgresql.key</filename>, or it can specify a key obtained from an external <quote>engine</quote>(engines are <productname>OpenSSL</productname>loadable modules). An external engine specification should consist of a colon-separated engine name and an engine-specific key identifier. This parameter is ignored if an SSL connection is not made."
msgstr ""

#: xml/libpq.xml:1325(literal)
msgid "sslrootcert"
msgstr ""

#: xml/libpq.xml:1328(para)
msgid "This parameter specifies the name of a file containing SSL certificate authority ( <acronym>CA</acronym>) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities. The default is <filename>~/.postgresql/root.crt</filename>."
msgstr ""

#: xml/libpq.xml:1338(literal)
msgid "sslcrl"
msgstr ""

#: xml/libpq.xml:1341(para)
msgid "This parameter specifies the file name of the SSL certificate revocation list (CRL). Certificates listed in this file, if it exists, will be rejected while attempting to authenticate the server's certificate. The default is <filename>~/.postgresql/root.crl</filename>."
msgstr ""

#: xml/libpq.xml:1352(literal)
msgid "requirepeer"
msgstr ""

#: xml/libpq.xml:1355(para)
msgid "This parameter specifies the operating-system user name of the server, for example <literal>requirepeer=postgres</literal>. When making a Unix-domain socket connection, if this parameter is set, the client checks at the beginning of the connection that the server process is running under the specified user name; if it is not, the connection is aborted with an error. This parameter can be used to provide server authentication similar to that available with SSL certificates on TCP/IP connections. (Note that if the Unix-domain socket is in <filename>/tmp</filename>or another publicly writable location, any user could start a server listening there. Use this parameter to ensure that you are connected to a server run by a trusted user.) This option is only supported on platforms for which the <literal>peer</literal>authentication method is implemented; see <xref linkend=\"auth-peer\">.</xref>"
msgstr ""

#: xml/libpq.xml:1379(literal)
msgid "krbsrvname"
msgstr ""

#: xml/libpq.xml:1382(para)
msgid "Kerberos service name to use when authenticating with GSSAPI. This must match the service name specified in the server configuration for Kerberos authentication to succeed. (See also <xref linkend=\"gssapi-auth\">.)</xref>"
msgstr ""

#: xml/libpq.xml:1391(literal)
msgid "gsslib"
msgstr ""

#: xml/libpq.xml:1394(para)
msgid "GSS library to use for GSSAPI authentication. Only used on Windows. Set to <literal>gssapi</literal>to force libpq to use the GSSAPI library for authentication instead of the default SSPI."
msgstr ""

#: xml/libpq.xml:1404(literal)
msgid "service"
msgstr ""

#: xml/libpq.xml:1407(para)
msgid "Service name to use for additional parameters. It specifies a service name in <filename>pg_service.conf</filename>that holds additional connection parameters. This allows applications to specify only a service name so connection parameters can be centrally maintained. See <xref linkend=\"libpq-pgservice\">.</xref>"
msgstr ""

#: xml/libpq.xml:849(para)
msgid "The currently recognized parameter key words are: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:1420(title)
msgid "Connection Status Functions"
msgstr ""

#: xml/libpq.xml:1421(para)
msgid "These functions can be used to interrogate the status of an existing database connection object."
msgstr ""

#: xml/libpq.xml:1424(para)
msgid "<indexterm><primary>libpq-fe.h</primary></indexterm><indexterm><primary>libpq-int.h</primary></indexterm><application>libpq</application>application programmers should be careful to maintain the <structname>PGconn</structname>abstraction. Use the accessor functions described below to get at the contents of <structname>PGconn</structname>. Reference to internal <structname>PGconn</structname>fields using <filename>libpq-int.h</filename>is not recommended because they are subject to change in the future."
msgstr ""

#: xml/libpq.xml:1447(function) xml/libpq.xml:1449(primary)
msgid "PQdb"
msgstr ""

#: xml/libpq.xml:1453(para)
msgid "Returns the database name of the connection. <synopsis>char *PQdb(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1460(function) xml/libpq.xml:1462(primary)
msgid "PQuser"
msgstr ""

#: xml/libpq.xml:1466(para)
msgid "Returns the user name of the connection. <synopsis>char *PQuser(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1473(function) xml/libpq.xml:1475(primary)
msgid "PQpass"
msgstr ""

#: xml/libpq.xml:1479(para)
msgid "Returns the password of the connection. <synopsis>char *PQpass(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1486(function) xml/libpq.xml:1488(primary)
msgid "PQhost"
msgstr ""

#: xml/libpq.xml:1492(para)
msgid "Returns the server host name of the connection. <synopsis>char *PQhost(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1499(function) xml/libpq.xml:1501(primary)
msgid "PQport"
msgstr ""

#: xml/libpq.xml:1505(para)
msgid "Returns the port of the connection. <synopsis>char *PQport(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1512(function) xml/libpq.xml:1514(primary)
msgid "PQtty"
msgstr ""

#: xml/libpq.xml:1518(para)
msgid "Returns the debug <acronym>TTY</acronym>of the connection. (This is obsolete, since the server no longer pays attention to the <acronym>TTY</acronym>setting, but the function remains for backward compatibility.) <synopsis>char *PQtty(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1530(function) xml/libpq.xml:1532(primary)
msgid "PQoptions"
msgstr ""

#: xml/libpq.xml:1536(para)
msgid "Returns the command-line options passed in the connection request. <synopsis>char *PQoptions(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1440(para)
msgid "The following functions return parameter values established at connection. These values are fixed for the life of the <structname>PGconn</structname>object. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:1549(function) xml/libpq.xml:1551(primary)
msgid "PQstatus"
msgstr ""

#: xml/libpq.xml:1555(para)
msgid "Returns the status of the connection. <synopsis>ConnStatusType PQstatus(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1558(para)
msgid "The status can be one of a number of values. However, only two of these are seen outside of an asynchronous connection procedure: <literal>CONNECTION_OK</literal>and <literal>CONNECTION_BAD</literal>. A good connection to the database has the status <literal>CONNECTION_OK</literal>. A failed connection attempt is signaled by status <literal>CONNECTION_BAD</literal>. Ordinarily, an OK status will remain so until <function>PQfinish</function>, but a communications failure might result in the status changing to <literal>CONNECTION_BAD</literal>prematurely. In that case the application could try to recover by calling <function>PQreset</function>."
msgstr ""

#: xml/libpq.xml:1573(para)
msgid "See the entry for <function>PQconnectStartParams</function>, <function>PQconnectStart</function>and <function>PQconnectPoll</function>with regards to other status codes that might be returned."
msgstr ""

#: xml/libpq.xml:1582(function) xml/libpq.xml:1584(primary)
msgid "PQtransactionStatus"
msgstr ""

#: xml/libpq.xml:1588(para)
msgid "Returns the current in-transaction status of the server. <synopsis>PGTransactionStatusType\n          PQtransactionStatus(const PGconn *conn);</synopsis>The status can be <literal>PQTRANS_IDLE</literal>(currently idle), <literal>PQTRANS_ACTIVE</literal>(a command is in progress), <literal>PQTRANS_INTRANS</literal>(idle, in a valid transaction block), or <literal>PQTRANS_INERROR</literal>(idle, in a failed transaction block). <literal>PQTRANS_UNKNOWN</literal>is reported if the connection is bad. <literal>PQTRANS_ACTIVE</literal>is reported only when a query has been sent to the server and not yet completed."
msgstr ""

#: xml/libpq.xml:1609(function) xml/libpq.xml:1611(primary)
msgid "PQparameterStatus"
msgstr ""

#: xml/libpq.xml:1615(para)
msgid "Looks up a current parameter setting of the server. <synopsis>const char *PQparameterStatus(const PGconn\n          *conn, const char *paramName);</synopsis>Certain parameter values are reported by the server automatically at connection startup or whenever their values change. <function>PQparameterStatus</function>can be used to interrogate these settings. It returns the current value of a parameter if known, or <symbol>NULL</symbol>if the parameter is not known."
msgstr ""

#: xml/libpq.xml:1626(para)
msgid "Parameters reported as of the current release include <varname>server_version</varname>, <varname>server_encoding</varname>, <varname>client_encoding</varname>, <varname>application_name</varname>, <varname>is_superuser</varname>, <varname>session_authorization</varname>, <varname>DateStyle</varname>, <varname>IntervalStyle</varname>, <varname>TimeZone</varname>, <varname>integer_datetimes</varname>, and <varname>standard_conforming_strings</varname>. ( <varname>server_encoding</varname>, <varname>TimeZone</varname>, and <varname>integer_datetimes</varname>were not reported by releases before 8.0; <varname>standard_conforming_strings</varname>was not reported by releases before 8.1; <varname>IntervalStyle</varname>was not reported by releases before 8.4; <varname>application_name</varname>was not reported by releases before 9.0.) Note that <varname>server_version</varname>, <varname>server_encoding</varname>and <varname>integer_datetimes</varname>cannot change after startup."
msgstr ""

#: xml/libpq.xml:1653(para)
msgid "Pre-3.0-protocol servers do not report parameter settings, but <application>libpq</application>includes logic to obtain values for <varname>server_version</varname>and <varname>client_encoding</varname>anyway. Applications are encouraged to use <function>PQparameterStatus</function>rather than <foreignphrase>ad hoc</foreignphrase>code to determine these values. (Beware however that on a pre-3.0 connection, changing <varname>client_encoding</varname>via <command>SET</command>after connection startup will not be reflected by <function>PQparameterStatus</function>.) For <varname>server_version</varname>, see also <function>PQserverVersion</function>, which returns the information in a numeric form that is much easier to compare against."
msgstr ""

#: xml/libpq.xml:1672(para)
msgid "If no value for <varname>standard_conforming_strings</varname>is reported, applications can assume it is <literal>off</literal>, that is, backslashes are treated as escapes in string literals. Also, the presence of this parameter can be taken as an indication that the escape string syntax ( <literal>E'...'</literal>) is accepted."
msgstr ""

#: xml/libpq.xml:1680(para)
msgid "Although the returned pointer is declared <literal>const</literal>, it in fact points to mutable storage associated with the <literal>PGconn</literal>structure. It is unwise to assume the pointer will remain valid across queries."
msgstr ""

#: xml/libpq.xml:1690(function) xml/libpq.xml:1692(primary)
msgid "PQprotocolVersion"
msgstr ""

#: xml/libpq.xml:1696(para)
msgid "Interrogates the frontend/backend protocol being used. <synopsis>int PQprotocolVersion(const PGconn\n          *conn);</synopsis>Applications might wish to use this function to determine whether certain features are supported. Currently, the possible values are 2 (2.0 protocol), 3 (3.0 protocol), or zero (connection bad). The protocol version will not change after connection startup is complete, but it could theoretically change during a connection reset. The 3.0 protocol will normally be used when communicating with <productname>PostgreSQL</productname>7.4 or later servers; pre-7.4 servers support only protocol 2.0. (Protocol 1.0 is obsolete and not supported by <application>libpq</application>.)"
msgstr ""

#: xml/libpq.xml:1715(function) xml/libpq.xml:1717(primary) xml/libpq.xml:5569(seealso)
msgid "PQserverVersion"
msgstr ""

#: xml/libpq.xml:1721(para)
msgid "Returns an integer representing the backend version. <synopsis>int PQserverVersion(const PGconn\n          *conn);</synopsis>Applications might use this function to determine the version of the database server they are connected to. The number is formed by converting the major, minor, and revision numbers into two-decimal-digit numbers and appending them together. For example, version 8.1.5 will be returned as 80105, and version 8.2 will be returned as 80200 (leading zeroes are not shown). Zero is returned if the connection is bad."
msgstr ""

#: xml/libpq.xml:1736(function) xml/libpq.xml:1738(primary)
msgid "PQerrorMessage"
msgstr ""

#: xml/libpq.xml:1742(para)
msgid "<indexterm><primary>error message</primary></indexterm>Returns the error message most recently generated by an operation on the connection. <synopsis>char *PQerrorMessage(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1749(para)
msgid "Nearly all <application>libpq</application>functions will set a message for <function>PQerrorMessage</function>if they fail. Note that by <application>libpq</application>convention, a nonempty <function>PQerrorMessage</function>result can consist of multiple lines, and will include a trailing newline. The caller should not free the result directly. It will be freed when the associated <structname>PGconn</structname>handle is passed to <function>PQfinish</function>. The result string should not be expected to remain the same across operations on the <literal>PGconn</literal>structure."
msgstr ""

#: xml/libpq.xml:1768(function) xml/libpq.xml:1770(primary)
msgid "PQsocket"
msgstr ""

#: xml/libpq.xml:1774(para)
msgid "Obtains the file descriptor number of the connection socket to the server. A valid descriptor will be greater than or equal to 0; a result of -1 indicates that no server connection is currently open. (This will not change during normal operation, but could change during connection setup or reset.) <synopsis>int PQsocket(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1786(function) xml/libpq.xml:1788(primary)
msgid "PQbackendPID"
msgstr ""

#: xml/libpq.xml:1792(para)
msgid "Returns the process <acronym>ID</acronym>(PID) <indexterm><primary>PID</primary><secondary>determining PID of server process</secondary><tertiary>in libpq</tertiary></indexterm>of the backend process handling this connection. <synopsis>int PQbackendPID(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1803(para)
msgid "The backend <acronym>PID</acronym>is useful for debugging purposes and for comparison to <command>NOTIFY</command>messages (which include the <acronym>PID</acronym>of the notifying backend process). Note that the <acronym>PID</acronym>belongs to a process executing on the database server host, not the local host!"
msgstr ""

#: xml/libpq.xml:1815(function) xml/libpq.xml:1817(primary)
msgid "PQconnectionNeedsPassword"
msgstr ""

#: xml/libpq.xml:1821(para)
msgid "Returns true (1) if the connection authentication method required a password, but none was available. Returns false (0) if not. <synopsis>int PQconnectionNeedsPassword(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1826(para)
msgid "This function can be applied after a failed connection attempt to decide whether to prompt the user for a password."
msgstr ""

#: xml/libpq.xml:1833(function) xml/libpq.xml:1835(primary)
msgid "PQconnectionUsedPassword"
msgstr ""

#: xml/libpq.xml:1839(para)
msgid "Returns true (1) if the connection authentication method used a password. Returns false (0) if not. <synopsis>int PQconnectionUsedPassword(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1843(para)
msgid "This function can be applied after either a failed or successful connection attempt to detect whether the server demanded a password."
msgstr ""

#: xml/libpq.xml:1543(para)
msgid "The following functions return status data that can change as operations are executed on the <structname>PGconn</structname>object. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:1855(function) xml/libpq.xml:1857(primary)
msgid "PQsslInUse"
msgstr ""

#: xml/libpq.xml:1861(para)
msgid "Returns true (1) if the connection uses SSL, false (0) if not. <synopsis>int PQsslInUse(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1869(function) xml/libpq.xml:1871(primary)
msgid "PQsslAttribute"
msgstr ""

#: xml/libpq.xml:1875(para)
msgid "Returns SSL-related information about the connection. <synopsis>const char *PQsslAttribute(const PGconn *conn,\n          const char *attribute_name);</synopsis>"
msgstr ""

#: xml/libpq.xml:1879(para)
msgid "The list of available attributes varies depending on the SSL library being used, and the type of connection. If an attribute is not available, returns NULL."
msgstr ""

#: xml/libpq.xml:1887(literal)
msgid "library"
msgstr ""

#: xml/libpq.xml:1890(para)
msgid "Name of the SSL implementation in use. (Currently, only <literal>\"OpenSSL\"</literal>is implemented)"
msgstr ""

#: xml/libpq.xml:1897(literal)
msgid "protocol"
msgstr ""

#: xml/libpq.xml:1900(para)
msgid "SSL/TLS version in use. Common values are <literal>\"SSLv2\"</literal>, <literal>\"SSLv3\"</literal>, <literal>\"TLSv1\"</literal>, <literal>\"TLSv1.1\"</literal>and <literal>\"TLSv1.2\"</literal>, but an implementation may return other strings if some other protocol is used."
msgstr ""

#: xml/libpq.xml:1912(literal)
msgid "key_bits"
msgstr ""

#: xml/libpq.xml:1915(para)
msgid "Number of key bits used by the encryption algorithm."
msgstr ""

#: xml/libpq.xml:1921(literal)
msgid "cipher"
msgstr ""

#: xml/libpq.xml:1924(para)
msgid "A short name of the ciphersuite used, e.g. <literal>\"DHE-RSA-DES-CBC3-SHA\"</literal>. The names are specific to each SSL implementation."
msgstr ""

#: xml/libpq.xml:1932(literal)
msgid "compression"
msgstr ""

#: xml/libpq.xml:1935(para)
msgid "If SSL compression is in use, returns the name of the compression algorithm, or \"on\" if compression is used but the algorithm is not known. If compression is not in use, returns \"off\"."
msgstr ""

#: xml/libpq.xml:1883(para)
msgid "The following attributes are commonly available: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:1946(function) xml/libpq.xml:1948(primary)
msgid "PQsslAttributeNames"
msgstr ""

#: xml/libpq.xml:1952(para)
msgid "Return an array of SSL attribute names available. The array is terminated by a NULL pointer. <synopsis>const char * const * PQsslAttributeNames(const\n          PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:1960(function) xml/libpq.xml:1962(primary)
msgid "PQsslStruct"
msgstr ""

#: xml/libpq.xml:1966(para)
msgid "Return a pointer to an SSL-implementation-specific object describing the connection. <synopsis>void *PQsslStruct(const PGconn *conn, const\n          char *struct_name);</synopsis>"
msgstr ""

#: xml/libpq.xml:1976(programlisting)
#, no-wrap
msgid "#include &lt;libpq-fe.h&gt; #include\n          &lt;openssl/ssl.h&gt; ... SSL *ssl; dbconn =\n          PQconnectdb(...); ... ssl = PQsslStruct(dbconn,\n          \"OpenSSL\"); if (ssl) { /* use OpenSSL functions to access\n          ssl */ }"
msgstr ""

#: xml/libpq.xml:1970(para)
msgid "The struct(s) available depend on the SSL implementation in use. For OpenSSL, there is one struct, available under the name \"OpenSSL\", and it returns a pointer to the OpenSSL <literal>SSL</literal>struct. To use this function, code along the following lines could be used: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:1981(para)
msgid "This structure can be used to verify encryption levels, check server certificates, and more. Refer to the <productname>OpenSSL</productname>documentation for information about this structure."
msgstr ""

#: xml/libpq.xml:1990(function) xml/libpq.xml:1992(primary)
msgid "PQgetssl"
msgstr ""

#: xml/libpq.xml:1996(para)
msgid "<indexterm><primary>SSL</primary><secondary sortas=\"libpq\">in libpq</secondary></indexterm>Returns the SSL structure used in the connection, or null if SSL is not in use. <synopsis>void *PQgetssl(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:2004(para)
msgid "This function is equivalent to <literal>PQsslStruct(conn, \"OpenSSL\")</literal>. It should not be used in new applications, because the returned struct is specific to OpenSSL and will not be available if another SSL implementation is used. To check if a connection uses SSL, call <function>PQsslInUse</function>instead, and for more details about the connection, use <function>PQsslAttribute</function>."
msgstr ""

#: xml/libpq.xml:1849(para)
msgid "The following functions return information related to SSL. This information usually doesn't change after a connection is established. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:2018(title)
msgid "Command Execution Functions"
msgstr ""

#: xml/libpq.xml:2019(para)
msgid "Once a connection to a database server has been successfully established, the functions described here are used to perform SQL queries and commands."
msgstr ""

#: xml/libpq.xml:2023(title)
msgid "Main Functions"
msgstr ""

#: xml/libpq.xml:2028(function) xml/libpq.xml:2030(primary)
msgid "PQexec"
msgstr ""

#: xml/libpq.xml:2034(para)
msgid "Submits a command to the server and waits for the result. <synopsis>PGresult *PQexec(PGconn *conn, const char\n            *command);</synopsis>"
msgstr ""

#: xml/libpq.xml:2038(para)
msgid "Returns a <structname>PGresult</structname>pointer or possibly a null pointer. A non-null pointer will generally be returned except in out-of-memory conditions or serious errors such as inability to send the command to the server. The <function>PQresultStatus</function>function should be called to check the return value for any errors (including the value of a null pointer, in which case it will return <symbol>PGRES_FATAL_ERROR</symbol>). Use <function>PQerrorMessage</function>to get more information about such errors."
msgstr ""

#: xml/libpq.xml:2024(para)
msgid "<placeholder-1/>The command string can include multiple SQL commands (separated by semicolons). Multiple queries sent in a single <function>PQexec</function>call are processed in a single transaction, unless there are explicit <command>BEGIN</command>/ <command>COMMIT</command>commands included in the query string to divide it into multiple transactions. Note however that the returned <structname>PGresult</structname>structure describes only the result of the last command executed from the string. Should one of the commands fail, processing of the string stops with it and the returned <structname>PGresult</structname>describes the error condition."
msgstr ""

#: xml/libpq.xml:2072(function) xml/libpq.xml:2074(primary)
msgid "PQexecParams"
msgstr ""

#: xml/libpq.xml:2078(para)
msgid "Submits a command to the server and waits for the result, with the ability to pass parameters separately from the SQL command text. <synopsis>PGresult *PQexecParams(PGconn *conn, const\n              char *command, int nParams, const Oid *paramTypes,\n              const char * const *paramValues, const int\n              *paramLengths, const int *paramFormats, int\n              resultFormat);</synopsis>"
msgstr ""

#: xml/libpq.xml:2086(para)
msgid "<function>PQexecParams</function>is like <function>PQexec</function>, but offers additional functionality: parameter values can be specified separately from the command string proper, and query results can be requested in either text or binary format. <function>PQexecParams</function>is supported only in protocol 3.0 and later connections; it will fail when using protocol 2.0."
msgstr ""

#: xml/libpq.xml:2100(parameter)
msgid "conn"
msgstr ""

#: xml/libpq.xml:2103(para)
msgid "The connection object to send the command through."
msgstr ""

#: xml/libpq.xml:2109(parameter)
msgid "command"
msgstr ""

#: xml/libpq.xml:2112(para)
msgid "The SQL command string to be executed. If parameters are used, they are referred to in the command string as <literal>$1</literal>, <literal>$2</literal>, etc."
msgstr ""

#: xml/libpq.xml:2121(parameter)
msgid "nParams"
msgstr ""

#: xml/libpq.xml:2124(para)
msgid "The number of parameters supplied; it is the length of the arrays <parameter>paramTypes[]</parameter>, <parameter>paramValues[]</parameter>, <parameter>paramLengths[]</parameter>, and <parameter>paramFormats[]</parameter>. (The array pointers can be <symbol>NULL</symbol>when <parameter>nParams</parameter>is zero.)"
msgstr ""

#: xml/libpq.xml:2137(parameter)
msgid "paramTypes[]"
msgstr ""

#: xml/libpq.xml:2140(para)
msgid "Specifies, by OID, the data types to be assigned to the parameter symbols. If <parameter>paramTypes</parameter>is <symbol>NULL</symbol>, or any particular element in the array is zero, the server infers a data type for the parameter symbol in the same way it would do for an untyped literal string."
msgstr ""

#: xml/libpq.xml:2152(parameter)
msgid "paramValues[]"
msgstr ""

#: xml/libpq.xml:2155(para)
msgid "Specifies the actual values of the parameters. A null pointer in this array means the corresponding parameter is null; otherwise the pointer points to a zero-terminated text string (for text format) or binary data in the format expected by the server (for binary format)."
msgstr ""

#: xml/libpq.xml:2166(parameter)
msgid "paramLengths[]"
msgstr ""

#: xml/libpq.xml:2169(para)
msgid "Specifies the actual data lengths of binary-format parameters. It is ignored for null parameters and text-format parameters. The array pointer can be null when there are no binary parameters."
msgstr ""

#: xml/libpq.xml:2178(parameter)
msgid "paramFormats[]"
msgstr ""

#: xml/libpq.xml:2181(para)
msgid "Specifies whether parameters are text (put a zero in the array entry for the corresponding parameter) or binary (put a one in the array entry for the corresponding parameter). If the array pointer is null then all parameters are presumed to be text strings."
msgstr ""

#: xml/libpq.xml:2188(para)
msgid "Values passed in binary format require knowledge of the internal representation expected by the backend. For example, integers must be passed in network byte order. Passing <type>numeric</type>values requires knowledge of the server storage format, as implemented in <filename> src/backend/utils/adt/numeric.c::numeric_send()</filename>and <filename> src/backend/utils/adt/numeric.c::numeric_recv()</filename>."
msgstr ""

#: xml/libpq.xml:2204(parameter)
msgid "resultFormat"
msgstr ""

#: xml/libpq.xml:2207(para)
msgid "Specify zero to obtain results in text format, or one to obtain results in binary format. (There is not currently a provision to obtain different result columns in different formats, although that is possible in the underlying protocol.)"
msgstr ""

#: xml/libpq.xml:2096(para)
msgid "The function arguments are: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:2220(para)
msgid "The primary advantage of <function>PQexecParams</function>over <function>PQexec</function>is that parameter values can be separated from the command string, thus avoiding the need for tedious and error-prone quoting and escaping."
msgstr ""

#: xml/libpq.xml:2225(para)
msgid "Unlike <function>PQexec</function>, <function>PQexecParams</function>allows at most one SQL command in the given string. (There can be semicolons in it, but not more than one nonempty command.) This is a limitation of the underlying protocol, but has some usefulness as an extra defense against SQL-injection attacks."
msgstr ""

#: xml/libpq.xml:2241(programlisting)
#, no-wrap
msgid "SELECT * FROM mytable WHERE x =\n        $1::bigint;"
msgstr ""

#: xml/libpq.xml:2233(para)
msgid "Specifying parameter types via OIDs is tedious, particularly if you prefer not to hard-wire particular OID values into your program. However, you can avoid doing so even in cases where the server by itself cannot determine the type of the parameter, or chooses a different type than you want. In the SQL command text, attach an explicit cast to the parameter symbol to show what data type you will send. For example: <placeholder-1/>This forces parameter <literal>$1</literal>to be treated as <type>bigint</type>, whereas by default it would be assigned the same type as <literal>x</literal>. Forcing the parameter type decision, either this way or by specifying a numeric type OID, is strongly recommended when sending parameter values in binary format, because binary format has less redundancy than text format and so there is less chance that the server will detect a type mismatch mistake for you."
msgstr ""

#: xml/libpq.xml:2257(function) xml/libpq.xml:2259(primary)
msgid "PQprepare"
msgstr ""

#: xml/libpq.xml:2263(para)
msgid "Submits a request to create a prepared statement with the given parameters, and waits for completion. <synopsis>PGresult *PQprepare(PGconn *conn, const char\n            *stmtName, const char *query, int nParams, const Oid\n            *paramTypes);</synopsis>"
msgstr ""

#: xml/libpq.xml:2268(para)
msgid "<function>PQprepare</function>creates a prepared statement for later execution with <function>PQexecPrepared</function>. This feature allows commands that will be used repeatedly to be parsed and planned just once, rather than each time they are executed. <function>PQprepare</function>is supported only in protocol 3.0 and later connections; it will fail when using protocol 2.0."
msgstr ""

#: xml/libpq.xml:2278(para)
msgid "The function creates a prepared statement named <parameter>stmtName</parameter>from the <parameter>query</parameter>string, which must contain a single SQL command. <parameter>stmtName</parameter>can be <literal>\"\"</literal>to create an unnamed statement, in which case any pre-existing unnamed statement is automatically replaced; otherwise it is an error if the statement name is already defined in the current session. If any parameters are used, they are referred to in the query as <literal>$1</literal>, <literal>$2</literal>, etc. <parameter>nParams</parameter>is the number of parameters for which types are pre-specified in the array <parameter>paramTypes[]</parameter>. (The array pointer can be <symbol>NULL</symbol>when <parameter>nParams</parameter>is zero.) <parameter>paramTypes[]</parameter>specifies, by OID, the data types to be assigned to the parameter symbols. If <parameter>paramTypes</parameter>is <symbol>NULL</symbol>, or any particular element in the array is zero, the server assigns a data type to the parameter symbol in the same way it would do for an untyped literal string. Also, the query can use parameter symbols with numbers higher than <parameter>nParams</parameter>; data types will be inferred for these symbols as well. (See <function>PQdescribePrepared</function>for a means to find out what data types were inferred.)"
msgstr ""

#: xml/libpq.xml:2311(para)
msgid "As with <function>PQexec</function>, the result is normally a <structname>PGresult</structname>object whose contents indicate server-side success or failure. A null result indicates out-of-memory or inability to send the command at all. Use <function>PQerrorMessage</function>to get more information about such errors."
msgstr ""

#: xml/libpq.xml:2253(para)
msgid "<placeholder-1/>Prepared statements for use with <function>PQexecPrepared</function>can also be created by executing SQL <xref linkend=\"sql-prepare\">statements. Also, although there is no <application>libpq</application>function for deleting a prepared statement, the SQL <xref linkend=\"sql-deallocate\">statement can be used for that purpose.</xref></xref>"
msgstr ""

#: xml/libpq.xml:2334(function) xml/libpq.xml:2336(primary)
msgid "PQexecPrepared"
msgstr ""

#: xml/libpq.xml:2340(para)
msgid "Sends a request to execute a prepared statement with given parameters, and waits for the result. <synopsis>PGresult *PQexecPrepared(PGconn *conn,\n              const char *stmtName, int nParams, const char * const\n              *paramValues, const int *paramLengths, const int\n              *paramFormats, int resultFormat);</synopsis>"
msgstr ""

#: xml/libpq.xml:2346(para)
msgid "<function>PQexecPrepared</function>is like <function>PQexecParams</function>, but the command to be executed is specified by naming a previously-prepared statement, instead of giving a query string. This feature allows commands that will be used repeatedly to be parsed and planned just once, rather than each time they are executed. The statement must have been prepared previously in the current session. <function>PQexecPrepared</function>is supported only in protocol 3.0 and later connections; it will fail when using protocol 2.0."
msgstr ""

#: xml/libpq.xml:2359(para)
msgid "The parameters are identical to <function>PQexecParams</function>, except that the name of a prepared statement is given instead of a query string, and the <parameter>paramTypes[]</parameter>parameter is not present (it is not needed since the prepared statement's parameter types were determined when it was created)."
msgstr ""

#: xml/libpq.xml:2371(function) xml/libpq.xml:2373(primary)
msgid "PQdescribePrepared"
msgstr ""

#: xml/libpq.xml:2377(para)
msgid "Submits a request to obtain information about the specified prepared statement, and waits for completion. <synopsis>PGresult *PQdescribePrepared(PGconn *conn,\n              const char *stmtName);</synopsis>"
msgstr ""

#: xml/libpq.xml:2382(para)
msgid "<function>PQdescribePrepared</function>allows an application to obtain information about a previously prepared statement. <function>PQdescribePrepared</function>is supported only in protocol 3.0 and later connections; it will fail when using protocol 2.0."
msgstr ""

#: xml/libpq.xml:2389(para)
msgid "<parameter>stmtName</parameter>can be <literal>\"\"</literal>or <symbol>NULL</symbol>to reference the unnamed statement, otherwise it must be the name of an existing prepared statement. On success, a <structname>PGresult</structname>with status <literal>PGRES_COMMAND_OK</literal>is returned. The functions <function>PQnparams</function>and <function>PQparamtype</function>can be applied to this <structname>PGresult</structname>to obtain information about the parameters of the prepared statement, and the functions <function>PQnfields</function>, <function>PQfname</function>, <function>PQftype</function>, etc provide information about the result columns (if any) of the statement."
msgstr ""

#: xml/libpq.xml:2413(function) xml/libpq.xml:2415(primary)
msgid "PQdescribePortal"
msgstr ""

#: xml/libpq.xml:2419(para)
msgid "Submits a request to obtain information about the specified portal, and waits for completion. <synopsis>PGresult *PQdescribePortal(PGconn *conn,\n              const char *portalName);</synopsis>"
msgstr ""

#: xml/libpq.xml:2423(para)
msgid "<function>PQdescribePortal</function>allows an application to obtain information about a previously created portal. ( <application>libpq</application>does not provide any direct access to portals, but you can use this function to inspect the properties of a cursor created with a <command>DECLARE CURSOR</command>SQL command.) <function>PQdescribePortal</function>is supported only in protocol 3.0 and later connections; it will fail when using protocol 2.0."
msgstr ""

#: xml/libpq.xml:2435(para)
msgid "<parameter>portalName</parameter>can be <literal>\"\"</literal>or <symbol>NULL</symbol>to reference the unnamed portal, otherwise it must be the name of an existing portal. On success, a <structname>PGresult</structname>with status <literal>PGRES_COMMAND_OK</literal>is returned. The functions <function>PQnfields</function>, <function>PQfname</function>, <function>PQftype</function>, etc can be applied to the <structname>PGresult</structname>to obtain information about the result columns (if any) of the portal."
msgstr ""

#: xml/libpq.xml:2472(function) xml/libpq.xml:2474(primary)
msgid "PQresultStatus"
msgstr ""

#: xml/libpq.xml:2478(para)
msgid "Returns the result status of the command. <synopsis>ExecStatusType PQresultStatus(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:2487(literal)
msgid "PGRES_EMPTY_QUERY"
msgstr ""

#: xml/libpq.xml:2490(para)
msgid "The string sent to the server was empty."
msgstr ""

#: xml/libpq.xml:2496(literal)
msgid "PGRES_COMMAND_OK"
msgstr ""

#: xml/libpq.xml:2499(para)
msgid "Successful completion of a command returning no data."
msgstr ""

#: xml/libpq.xml:2505(literal)
msgid "PGRES_TUPLES_OK"
msgstr ""

#: xml/libpq.xml:2508(para)
msgid "Successful completion of a command returning data (such as a <command>SELECT</command>or <command>SHOW</command>)."
msgstr ""

#: xml/libpq.xml:2516(literal)
msgid "PGRES_COPY_OUT"
msgstr ""

#: xml/libpq.xml:2519(para)
msgid "Copy Out (from server) data transfer started."
msgstr ""

#: xml/libpq.xml:2525(literal)
msgid "PGRES_COPY_IN"
msgstr ""

#: xml/libpq.xml:2528(para)
msgid "Copy In (to server) data transfer started."
msgstr ""

#: xml/libpq.xml:2534(literal)
msgid "PGRES_BAD_RESPONSE"
msgstr ""

#: xml/libpq.xml:2537(para)
msgid "The server's response was not understood."
msgstr ""

#: xml/libpq.xml:2543(literal)
msgid "PGRES_NONFATAL_ERROR"
msgstr ""

#: xml/libpq.xml:2546(para)
msgid "A nonfatal error (a notice or warning) occurred."
msgstr ""

#: xml/libpq.xml:2552(literal)
msgid "PGRES_FATAL_ERROR"
msgstr ""

#: xml/libpq.xml:2555(para)
msgid "A fatal error occurred."
msgstr ""

#: xml/libpq.xml:2560(literal)
msgid "PGRES_COPY_BOTH"
msgstr ""

#: xml/libpq.xml:2563(para)
msgid "Copy In/Out (to and from server) data transfer started. This feature is currently used only for streaming replication, so this status should not occur in ordinary applications."
msgstr ""

#: xml/libpq.xml:2571(literal)
msgid "PGRES_SINGLE_TUPLE"
msgstr ""

#: xml/libpq.xml:2574(para)
msgid "The <structname>PGresult</structname>contains a single result tuple from the current command. This status occurs only when single-row mode has been selected for the query (see <xref linkend=\"libpq-single-row-mode\"> ).</xref>"
msgstr ""

#: xml/libpq.xml:2481(para)
msgid "<function>PQresultStatus</function>can return one of the following values: <placeholder-1/>If the result status is <literal>PGRES_TUPLES_OK</literal>or <literal>PGRES_SINGLE_TUPLE</literal>, then the functions described below can be used to retrieve the rows returned by the query. Note that a <command>SELECT</command>command that happens to retrieve zero rows still shows <literal>PGRES_TUPLES_OK</literal>. <literal>PGRES_COMMAND_OK</literal>is for commands that can never return rows ( <command>INSERT</command>or <command>UPDATE</command>without a <literal>RETURNING</literal>clause, etc.). A response of <literal>PGRES_EMPTY_QUERY</literal>might indicate a bug in the client software."
msgstr ""

#: xml/libpq.xml:2599(para)
msgid "A result of status <symbol>PGRES_NONFATAL_ERROR</symbol>will never be returned directly by <function>PQexec</function>or other query execution functions; results of this kind are instead passed to the notice processor (see <xref linkend=\"libpq-notice-processing\"> ).</xref>"
msgstr ""

#: xml/libpq.xml:2611(function) xml/libpq.xml:2613(primary)
msgid "PQresStatus"
msgstr ""

#: xml/libpq.xml:2617(para)
msgid "Converts the enumerated type returned by <function>PQresultStatus</function>into a string constant describing the status code. The caller should not free the result. <synopsis>char *PQresStatus(ExecStatusType\n            status);</synopsis>"
msgstr ""

#: xml/libpq.xml:2627(function) xml/libpq.xml:2629(primary)
msgid "PQresultErrorMessage"
msgstr ""

#: xml/libpq.xml:2633(para)
msgid "Returns the error message associated with the command, or an empty string if there was no error. <synopsis>char *PQresultErrorMessage(const PGresult\n            *res);</synopsis>If there was an error, the returned string will include a trailing newline. The caller should not free the result directly. It will be freed when the associated <structname>PGresult</structname>handle is passed to <function>PQclear</function>."
msgstr ""

#: xml/libpq.xml:2642(para)
msgid "Immediately following a <function>PQexec</function>or <function>PQgetResult</function>call, <function>PQerrorMessage</function>(on the connection) will return the same string as <function>PQresultErrorMessage</function>(on the result). However, a <structname>PGresult</structname>will retain its error message until destroyed, whereas the connection's error message will change when subsequent operations are done. Use <function>PQresultErrorMessage</function>when you want to know the status associated with a particular <structname>PGresult</structname>; use <function>PQerrorMessage</function>when you want to know the status from the latest operation on the connection."
msgstr ""

#: xml/libpq.xml:2663(function) xml/libpq.xml:2665(primary)
msgid "PQresultErrorField"
msgstr ""

#: xml/libpq.xml:2669(para)
msgid "Returns an individual field of an error report. <synopsis>char *PQresultErrorField(const PGresult *res,\n            int fieldcode);</synopsis><parameter>fieldcode</parameter>is an error field identifier; see the symbols listed below. <symbol>NULL</symbol>is returned if the <structname>PGresult</structname>is not an error or warning result, or does not include the specified field. Field values will normally not include a trailing newline. The caller should not free the result directly. It will be freed when the associated <structname>PGresult</structname>handle is passed to <function>PQclear</function>."
msgstr ""

#: xml/libpq.xml:2686(symbol)
msgid "PG_DIAG_SEVERITY"
msgstr ""

#: xml/libpq.xml:2689(para)
msgid "The severity; the field contents are <literal>ERROR</literal>, <literal>FATAL</literal>, or <literal>PANIC</literal>(in an error message), or <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, <literal>INFO</literal>, or <literal>LOG</literal>(in a notice message), or a localized translation of one of these. Always present."
msgstr ""

#: xml/libpq.xml:2705(symbol)
msgid "PG_DIAG_SQLSTATE"
msgstr ""

#: xml/libpq.xml:2707(primary)
msgid "error codes"
msgstr ""

#: xml/libpq.xml:2712(para)
msgid "The SQLSTATE code for the error. The SQLSTATE code identifies the type of error that has occurred; it can be used by front-end applications to perform specific operations (such as error handling) in response to a particular database error. For a list of the possible SQLSTATE codes, see <xref linkend=\"errcodes-appendix\">. This field is not localizable, and is always present.</xref>"
msgstr ""

#: xml/libpq.xml:2726(symbol)
msgid "PG_DIAG_MESSAGE_PRIMARY"
msgstr ""

#: xml/libpq.xml:2729(para)
msgid "The primary human-readable error message (typically one line). Always present."
msgstr ""

#: xml/libpq.xml:2735(symbol)
msgid "PG_DIAG_MESSAGE_DETAIL"
msgstr ""

#: xml/libpq.xml:2738(para)
msgid "Detail: an optional secondary error message carrying more detail about the problem. Might run to multiple lines."
msgstr ""

#: xml/libpq.xml:2745(symbol)
msgid "PG_DIAG_MESSAGE_HINT"
msgstr ""

#: xml/libpq.xml:2748(para)
msgid "Hint: an optional suggestion what to do about the problem. This is intended to differ from detail in that it offers advice (potentially inappropriate) rather than hard facts. Might run to multiple lines."
msgstr ""

#: xml/libpq.xml:2757(symbol)
msgid "PG_DIAG_STATEMENT_POSITION"
msgstr ""

#: xml/libpq.xml:2760(para)
msgid "A string containing a decimal integer indicating an error cursor position as an index into the original statement string. The first character has index 1, and positions are measured in characters not bytes."
msgstr ""

#: xml/libpq.xml:2769(symbol)
msgid "PG_DIAG_INTERNAL_POSITION"
msgstr ""

#: xml/libpq.xml:2772(para)
msgid "This is defined the same as the <symbol>PG_DIAG_STATEMENT_POSITION</symbol>field, but it is used when the cursor position refers to an internally generated command rather than the one submitted by the client. The <symbol>PG_DIAG_INTERNAL_QUERY</symbol>field will always appear when this field appears."
msgstr ""

#: xml/libpq.xml:2783(symbol)
msgid "PG_DIAG_INTERNAL_QUERY"
msgstr ""

#: xml/libpq.xml:2786(para)
msgid "The text of a failed internally-generated command. This could be, for example, a SQL query issued by a PL/pgSQL function."
msgstr ""

#: xml/libpq.xml:2793(symbol)
msgid "PG_DIAG_CONTEXT"
msgstr ""

#: xml/libpq.xml:2796(para)
msgid "An indication of the context in which the error occurred. Presently this includes a call stack traceback of active procedural language functions and internally-generated queries. The trace is one entry per line, most recent first."
msgstr ""

#: xml/libpq.xml:2806(symbol)
msgid "PG_DIAG_SCHEMA_NAME"
msgstr ""

#: xml/libpq.xml:2809(para)
msgid "If the error was associated with a specific database object, the name of the schema containing that object, if any."
msgstr ""

#: xml/libpq.xml:2816(symbol)
msgid "PG_DIAG_TABLE_NAME"
msgstr ""

#: xml/libpq.xml:2819(para)
msgid "If the error was associated with a specific table, the name of the table. (Refer to the schema name field for the name of the table's schema.)"
msgstr ""

#: xml/libpq.xml:2827(symbol)
msgid "PG_DIAG_COLUMN_NAME"
msgstr ""

#: xml/libpq.xml:2830(para)
msgid "If the error was associated with a specific table column, the name of the column. (Refer to the schema and table name fields to identify the table.)"
msgstr ""

#: xml/libpq.xml:2838(symbol)
msgid "PG_DIAG_DATATYPE_NAME"
msgstr ""

#: xml/libpq.xml:2841(para)
msgid "If the error was associated with a specific data type, the name of the data type. (Refer to the schema name field for the name of the data type's schema.)"
msgstr ""

#: xml/libpq.xml:2849(symbol)
msgid "PG_DIAG_CONSTRAINT_NAME"
msgstr ""

#: xml/libpq.xml:2852(para)
msgid "If the error was associated with a specific constraint, the name of the constraint. Refer to fields listed above for the associated table or domain. (For this purpose, indexes are treated as constraints, even if they weren't created with constraint syntax.)"
msgstr ""

#: xml/libpq.xml:2862(symbol)
msgid "PG_DIAG_SOURCE_FILE"
msgstr ""

#: xml/libpq.xml:2865(para)
msgid "The file name of the source-code location where the error was reported."
msgstr ""

#: xml/libpq.xml:2871(symbol)
msgid "PG_DIAG_SOURCE_LINE"
msgstr ""

#: xml/libpq.xml:2874(para)
msgid "The line number of the source-code location where the error was reported."
msgstr ""

#: xml/libpq.xml:2880(symbol)
msgid "PG_DIAG_SOURCE_FUNCTION"
msgstr ""

#: xml/libpq.xml:2883(para)
msgid "The name of the source-code function reporting the error."
msgstr ""

#: xml/libpq.xml:2682(para)
msgid "The following field codes are available: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:2889(para)
msgid "The fields for schema name, table name, column name, data type name, and constraint name are supplied only for a limited number of error types; see <xref linkend=\"errcodes-appendix\">. Do not assume that the presence of any of these fields guarantees the presence of another field. Core error sources observe the interrelationships noted above, but user-defined functions may use these fields in other ways. In the same vein, do not assume that these fields denote contemporary objects in the current database.</xref>"
msgstr ""

#: xml/libpq.xml:2902(para)
msgid "The client is responsible for formatting displayed information to meet its needs; in particular it should break long lines as needed. Newline characters appearing in the error message fields should be treated as paragraph breaks, not line breaks."
msgstr ""

#: xml/libpq.xml:2907(para)
msgid "Errors generated internally by <application>libpq</application>will have severity and primary message, but typically no other fields. Errors returned by a pre-3.0-protocol server will include severity and primary message, and sometimes a detail message, but no other fields."
msgstr ""

#: xml/libpq.xml:2913(para)
msgid "Note that error fields are only available from <structname>PGresult</structname>objects, not <structname>PGconn</structname>objects; there is no <function>PQerrorField</function>function."
msgstr ""

#: xml/libpq.xml:2921(function) xml/libpq.xml:2923(primary)
msgid "PQclear"
msgstr ""

#: xml/libpq.xml:2927(para)
msgid "Frees the storage associated with a <structname>PGresult</structname>. Every command result should be freed via <function>PQclear</function>when it is no longer needed. <synopsis>void PQclear(PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:2934(para)
msgid "You can keep a <structname>PGresult</structname>object around for as long as you need it; it does not go away when you issue a new command, nor even if you close the connection. To get rid of it, you must call <function>PQclear</function>. Failure to do this will result in memory leaks in your application."
msgstr ""

#: xml/libpq.xml:2455(para)
msgid "The <structname>PGresult</structname><indexterm><primary>PGresult</primary></indexterm>structure encapsulates the result returned by the server. <application>libpq</application>application programmers should be careful to maintain the <structname>PGresult</structname>abstraction. Use the accessor functions below to get at the contents of <structname>PGresult</structname>. Avoid directly referencing the fields of the <structname>PGresult</structname>structure because they are subject to change in the future. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:2946(title)
msgid "Retrieving Query Result Information"
msgstr ""

#: xml/libpq.xml:2947(para)
msgid "These functions are used to extract information from a <structname>PGresult</structname>object that represents a successful query result (that is, one that has status <literal>PGRES_TUPLES_OK</literal>or <literal>PGRES_SINGLE_TUPLE</literal>). They can also be used to extract information from a successful Describe operation: a Describe's result has all the same column information that actual execution of the query would provide, but it has zero rows. For objects with other status values, these functions will act as though the result has zero rows and zero columns."
msgstr ""

#: xml/libpq.xml:2961(function) xml/libpq.xml:2963(primary)
msgid "PQntuples"
msgstr ""

#: xml/libpq.xml:2967(para)
msgid "Returns the number of rows (tuples) in the query result. Because it returns an integer result, large result sets might overflow the return value on 32-bit operating systems. <synopsis>int PQntuples(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:2977(function) xml/libpq.xml:2979(primary) xml/libpq.xml:4740(function) xml/libpq.xml:4742(primary)
msgid "PQnfields"
msgstr ""

#: xml/libpq.xml:2983(para)
msgid "Returns the number of columns (fields) in each row of the query result. <synopsis>int PQnfields(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:2991(function) xml/libpq.xml:2993(primary)
msgid "PQfname"
msgstr ""

#: xml/libpq.xml:2997(para)
msgid "Returns the column name associated with the given column number. Column numbers start at 0. The caller should not free the result directly. It will be freed when the associated <structname>PGresult</structname>handle is passed to <function>PQclear</function>. <synopsis>char *PQfname(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3005(para)
msgid "<symbol>NULL</symbol>is returned if the column number is out of range."
msgstr ""

#: xml/libpq.xml:3012(function) xml/libpq.xml:3014(primary)
msgid "PQfnumber"
msgstr ""

#: xml/libpq.xml:3018(para)
msgid "Returns the column number associated with the given column name. <synopsis>int PQfnumber(const PGresult *res, const char\n            *column_name);</synopsis>"
msgstr ""

#: xml/libpq.xml:3022(para)
msgid "-1 is returned if the given name does not match any column."
msgstr ""

#: xml/libpq.xml:3028(programlisting)
#, no-wrap
msgid "SELECT 1 AS FOO, 2 AS\n            \"BAR\";"
msgstr ""

#: xml/libpq.xml:3030(programlisting)
#, no-wrap
msgid "PQfname(res, 0) \n            <lineannotation>foo</lineannotation>PQfname(res, 1) \n            <lineannotation>BAR</lineannotation>PQfnumber(res,\n            \"FOO\") \n            <lineannotation>0</lineannotation>PQfnumber(res, \"foo\")\n            \n            <lineannotation>0</lineannotation>PQfnumber(res, \"BAR\")\n            \n            <lineannotation>-1</lineannotation>PQfnumber(res,\n            \"\\\"BAR\\\"\") \n            <lineannotation>\n            1</lineannotation>"
msgstr ""

#: xml/libpq.xml:3024(para)
msgid "The given name is treated like an identifier in an SQL command, that is, it is downcased unless double-quoted. For example, given a query result generated from the SQL command: <placeholder-1/>we would have the results: <placeholder-2/>"
msgstr ""

#: xml/libpq.xml:3046(function) xml/libpq.xml:3048(primary)
msgid "PQftable"
msgstr ""

#: xml/libpq.xml:3052(para)
msgid "Returns the OID of the table from which the given column was fetched. Column numbers start at 0. <synopsis>Oid PQftable(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3056(para)
msgid "<literal>InvalidOid</literal>is returned if the column number is out of range, or if the specified column is not a simple reference to a table column, or when using pre-3.0 protocol. You can query the system table <literal>pg_class</literal>to determine exactly which table is referenced."
msgstr ""

#: xml/libpq.xml:3063(para)
msgid "The type <type>Oid</type>and the constant <literal>InvalidOid</literal>will be defined when you include the <application>libpq</application>header file. They will both be some integer type."
msgstr ""

#: xml/libpq.xml:3073(function) xml/libpq.xml:3075(primary)
msgid "PQftablecol"
msgstr ""

#: xml/libpq.xml:3079(para)
msgid "Returns the column number (within its table) of the column making up the specified query result column. Query-result column numbers start at 0, but table columns have nonzero numbers. <synopsis>int PQftablecol(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3085(para)
msgid "Zero is returned if the column number is out of range, or if the specified column is not a simple reference to a table column, or when using pre-3.0 protocol."
msgstr ""

#: xml/libpq.xml:3093(function) xml/libpq.xml:3095(primary) xml/libpq.xml:4770(function) xml/libpq.xml:4772(primary)
msgid "PQfformat"
msgstr ""

#: xml/libpq.xml:3099(para)
msgid "Returns the format code indicating the format of the given column. Column numbers start at 0. <synopsis>int PQfformat(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3103(para)
msgid "Format code zero indicates textual data representation, while format code one indicates binary representation. (Other codes are reserved for future definition.)"
msgstr ""

#: xml/libpq.xml:3111(function) xml/libpq.xml:3113(primary)
msgid "PQftype"
msgstr ""

#: xml/libpq.xml:3117(para)
msgid "Returns the data type associated with the given column number. The integer returned is the internal OID number of the type. Column numbers start at 0. <synopsis>Oid PQftype(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3122(para)
msgid "You can query the system table <literal>pg_type</literal>to obtain the names and properties of the various data types. The <acronym>OID</acronym>s of the built-in data types are defined in the file <filename>src/include/catalog/pg_type.h</filename>in the source tree."
msgstr ""

#: xml/libpq.xml:3133(function) xml/libpq.xml:3135(primary)
msgid "PQfmod"
msgstr ""

#: xml/libpq.xml:3139(para)
msgid "Returns the type modifier of the column associated with the given column number. Column numbers start at 0. <synopsis>int PQfmod(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3144(para)
msgid "The interpretation of modifier values is type-specific; they typically indicate precision or size limits. The value -1 is used to indicate <quote>no information available</quote>. Most data types do not use modifiers, in which case the value is always -1."
msgstr ""

#: xml/libpq.xml:3154(function) xml/libpq.xml:3156(primary)
msgid "PQfsize"
msgstr ""

#: xml/libpq.xml:3160(para)
msgid "Returns the size in bytes of the column associated with the given column number. Column numbers start at 0. <synopsis>int PQfsize(const PGresult *res, int\n            column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3165(para)
msgid "<function>PQfsize</function>returns the space allocated for this column in a database row, in other words the size of the server's internal representation of the data type. (Accordingly, it is not really very useful to clients.) A negative value indicates the data type is variable-length."
msgstr ""

#: xml/libpq.xml:3176(function) xml/libpq.xml:3178(primary) xml/libpq.xml:4753(function) xml/libpq.xml:4755(primary)
msgid "PQbinaryTuples"
msgstr ""

#: xml/libpq.xml:3182(para)
msgid "Returns 1 if the <structname>PGresult</structname>contains binary data and 0 if it contains text data. <synopsis>int PQbinaryTuples(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:3187(para)
msgid "This function is deprecated (except for its use in connection with <command>COPY</command>), because it is possible for a single <structname>PGresult</structname>to contain text data in some columns and binary data in others. <function>PQfformat</function>is preferred. <function>PQbinaryTuples</function>returns 1 only if all columns of the result are binary (format 1)."
msgstr ""

#: xml/libpq.xml:3200(function) xml/libpq.xml:3202(primary)
msgid "PQgetvalue"
msgstr ""

#: xml/libpq.xml:3206(para)
msgid "Returns a single field value of one row of a <structname>PGresult</structname>. Row and column numbers start at 0. The caller should not free the result directly. It will be freed when the associated <structname>PGresult</structname>handle is passed to <function>PQclear</function>. <synopsis>char *PQgetvalue(const PGresult *res, int\n            row_number, int column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3214(para)
msgid "For data in text format, the value returned by <function>PQgetvalue</function>is a null-terminated character string representation of the field value. For data in binary format, the value is in the binary representation determined by the data type's <function>typsend</function>and <function>typreceive</function>functions. (The value is actually followed by a zero byte in this case too, but that is not ordinarily useful, since the value is likely to contain embedded nulls.)"
msgstr ""

#: xml/libpq.xml:3224(para)
msgid "An empty string is returned if the field value is null. See <function>PQgetisnull</function>to distinguish null values from empty-string values."
msgstr ""

#: xml/libpq.xml:3228(para)
msgid "The pointer returned by <function>PQgetvalue</function>points to storage that is part of the <structname>PGresult</structname>structure. One should not modify the data it points to, and one must explicitly copy the data into other storage if it is to be used past the lifetime of the <structname>PGresult</structname>structure itself."
msgstr ""

#: xml/libpq.xml:3241(function) xml/libpq.xml:3243(primary)
msgid "PQgetisnull"
msgstr ""

#: xml/libpq.xml:3246(primary)
msgid "null value"
msgstr ""

#: xml/libpq.xml:3247(secondary) xml/libpq.xml:3470(secondary) xml/libpq.xml:4591(secondary) xml/libpq.xml:5605(secondary)
msgid "in libpq"
msgstr ""

#: xml/libpq.xml:3251(para)
msgid "Tests a field for a null value. Row and column numbers start at 0. <synopsis>int PQgetisnull(const PGresult *res, int\n            row_number, int column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3255(para)
msgid "This function returns 1 if the field is null and 0 if it contains a non-null value. (Note that <function>PQgetvalue</function>will return an empty string, not a null pointer, for a null field.)"
msgstr ""

#: xml/libpq.xml:3263(function) xml/libpq.xml:3265(primary)
msgid "PQgetlength"
msgstr ""

#: xml/libpq.xml:3269(para)
msgid "Returns the actual length of a field value in bytes. Row and column numbers start at 0. <synopsis>int PQgetlength(const PGresult *res, int\n            row_number, int column_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3273(para)
msgid "This is the actual data length for the particular data value, that is, the size of the object pointed to by <function>PQgetvalue</function>. For text data format this is the same as <function>strlen()</function>. For binary format this is essential information. Note that one should <emphasis>not</emphasis>rely on <function>PQfsize</function>to obtain the actual data length."
msgstr ""

#: xml/libpq.xml:3287(function) xml/libpq.xml:3289(primary)
msgid "PQnparams"
msgstr ""

#: xml/libpq.xml:3293(para)
msgid "Returns the number of parameters of a prepared statement. <synopsis>int PQnparams(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:3297(para) xml/libpq.xml:3315(para)
msgid "This function is only useful when inspecting the result of <function>PQdescribePrepared</function>. For other types of queries it will return zero."
msgstr ""

#: xml/libpq.xml:3305(function) xml/libpq.xml:3307(primary)
msgid "PQparamtype"
msgstr ""

#: xml/libpq.xml:3311(para)
msgid "Returns the data type of the indicated statement parameter. Parameter numbers start at 0. <synopsis>Oid PQparamtype(const PGresult *res, int\n            param_number);</synopsis>"
msgstr ""

#: xml/libpq.xml:3323(function) xml/libpq.xml:3325(primary)
msgid "PQprint"
msgstr ""

#: xml/libpq.xml:3329(para)
msgid "Prints out all the rows and, optionally, the column names to the specified output stream. <synopsis>void PQprint(FILE *fout, /* output stream */\n            const PGresult *res, const PQprintOpt *po); typedef\n            struct { pqbool header; /* print output field headings\n            and row count */ pqbool align; /* fill align the fields\n            */ pqbool standard; /* old brain dead format */ pqbool\n            html3; /* output HTML tables */ pqbool expanded; /*\n            expand tables */ pqbool pager; /* use pager for output\n            if needed */ char *fieldSep; /* field separator */ char\n            *tableOpt; /* attributes for HTML table element */ char\n            *caption; /* HTML table caption */ char **fieldName; /*\n            null-terminated array of replacement field names */ }\n            PQprintOpt;</synopsis>"
msgstr ""

#: xml/libpq.xml:3343(para)
msgid "This function was formerly used by <application>psql</application>to print query results, but this is no longer the case. Note that it assumes all the data is in text format."
msgstr ""

#: xml/libpq.xml:3352(title)
msgid "Retrieving Other Result Information"
msgstr ""

#: xml/libpq.xml:3353(para)
msgid "These functions are used to extract other information from <structname>PGresult</structname>objects."
msgstr ""

#: xml/libpq.xml:3359(function) xml/libpq.xml:3361(primary)
msgid "PQcmdStatus"
msgstr ""

#: xml/libpq.xml:3365(para)
msgid "Returns the command status tag from the SQL command that generated the <structname>PGresult</structname>. <synopsis>char *PQcmdStatus(PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:3370(para)
msgid "Commonly this is just the name of the command, but it might include additional data such as the number of rows processed. The caller should not free the result directly. It will be freed when the associated <structname>PGresult</structname>handle is passed to <function>PQclear</function>."
msgstr ""

#: xml/libpq.xml:3380(function) xml/libpq.xml:3382(primary)
msgid "PQcmdTuples"
msgstr ""

#: xml/libpq.xml:3386(para)
msgid "Returns the number of rows affected by the SQL command. <synopsis>char *PQcmdTuples(PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:3390(para)
msgid "This function returns a string containing the number of rows affected by the <acronym>SQL</acronym>statement that generated the <structname>PGresult</structname>. This function can only be used following the execution of a <command>SELECT</command>, <command>CREATE TABLE AS</command>, <command>INSERT</command>, <command>UPDATE</command>, <command>DELETE</command>, <command>MOVE</command>, <command>FETCH</command>, or <command>COPY</command>statement, or an <command>EXECUTE</command>of a prepared query that contains an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>statement. If the command that generated the <structname>PGresult</structname>was anything else, <function>PQcmdTuples</function>returns an empty string. The caller should not free the return value directly. It will be freed when the associated <structname>PGresult</structname>handle is passed to <function>PQclear</function>."
msgstr ""

#: xml/libpq.xml:3419(function) xml/libpq.xml:3421(primary)
msgid "PQoidValue"
msgstr ""

#: xml/libpq.xml:3425(para)
msgid "Returns the OID <indexterm><primary>OID</primary><secondary>in libpq</secondary></indexterm>of the inserted row, if the <acronym>SQL</acronym>command was an <command>INSERT</command>that inserted exactly one row into a table that has OIDs, or a <command>EXECUTE</command>of a prepared query containing a suitable <command>INSERT</command>statement. Otherwise, this function returns <literal>InvalidOid</literal>. This function will also return <literal>InvalidOid</literal>if the table affected by the <command>INSERT</command>statement does not contain OIDs. <synopsis>Oid PQoidValue(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:3449(function) xml/libpq.xml:3451(primary)
msgid "PQoidStatus"
msgstr ""

#: xml/libpq.xml:3455(para)
msgid "This function is deprecated in favor of <function>PQoidValue</function>and is not thread-safe. It returns a string with the OID of the inserted row, while <function>PQoidValue</function>returns the OID value. <synopsis>char *PQoidStatus(const PGresult\n            *res);</synopsis>"
msgstr ""

#: xml/libpq.xml:3467(title)
msgid "Escaping Strings for Inclusion in SQL Commands"
msgstr ""

#: xml/libpq.xml:3469(primary)
msgid "escaping strings"
msgstr ""

#: xml/libpq.xml:3475(function) xml/libpq.xml:3477(primary)
msgid "PQescapeLiteral"
msgstr ""

#: xml/libpq.xml:3482(synopsis)
#, no-wrap
msgid "char *PQescapeLiteral(PGconn *conn, const\n              char *str, size_t length);"
msgstr ""

#: xml/libpq.xml:3485(para)
msgid "<function>PQescapeLiteral</function>escapes a string for use within an SQL command. This is useful when inserting data values as literal constants in SQL commands. Certain characters (such as quotes and backslashes) must be escaped to prevent them from being interpreted specially by the SQL parser. <function>PQescapeLiteral</function>performs this operation."
msgstr ""

#: xml/libpq.xml:3494(para)
msgid "<function>PQescapeLiteral</function>returns an escaped version of the <parameter>str</parameter>parameter in memory allocated with <function>malloc()</function>. This memory should be freed using <function>PQfreemem()</function>when the result is no longer needed. A terminating zero byte is not required, and should not be counted in <parameter>length</parameter>. (If a terminating zero byte is found before <parameter>length</parameter>bytes are processed, <function>PQescapeLiteral</function>stops at the zero; the behavior is thus rather like <function>strncpy</function>.) The return string has all special characters replaced so that they can be properly processed by the <productname>PostgreSQL</productname>string literal parser. A terminating zero byte is also added. The single quotes that must surround <productname>PostgreSQL</productname>string literals are included in the result string."
msgstr ""

#: xml/libpq.xml:3517(para)
msgid "On error, <function>PQescapeLiteral</function>returns <symbol>NULL</symbol>and a suitable message is stored in the <parameter>conn</parameter>object."
msgstr ""

#: xml/libpq.xml:3523(para)
msgid "It is especially important to do proper escaping when handling strings that were received from an untrustworthy source. Otherwise there is a security risk: you are vulnerable to <quote>SQL injection</quote>attacks wherein unwanted SQL commands are fed to your database."
msgstr ""

#: xml/libpq.xml:3530(para)
msgid "Note that it is not necessary nor correct to do escaping when a data value is passed as a separate parameter in <function>PQexecParams</function>or its sibling routines."
msgstr ""

#: xml/libpq.xml:3539(function) xml/libpq.xml:3541(primary)
msgid "PQescapeIdentifier"
msgstr ""

#: xml/libpq.xml:3546(synopsis)
#, no-wrap
msgid "char *PQescapeIdentifier(PGconn *conn,\n              const char *str, size_t length);"
msgstr ""

#: xml/libpq.xml:3549(para)
msgid "<function>PQescapeIdentifier</function>escapes a string for use as an SQL identifier, such as a table, column, or function name. This is useful when a user-supplied identifier might contain special characters that would otherwise not be interpreted as part of the identifier by the SQL parser, or when the identifier might contain upper case characters whose case should be preserved."
msgstr ""

#: xml/libpq.xml:3558(para)
msgid "<function>PQescapeIdentifier</function>returns a version of the <parameter>str</parameter>parameter escaped as an SQL identifier in memory allocated with <function>malloc()</function>. This memory must be freed using <function>PQfreemem()</function>when the result is no longer needed. A terminating zero byte is not required, and should not be counted in <parameter>length</parameter>. (If a terminating zero byte is found before <parameter>length</parameter>bytes are processed, <function>PQescapeIdentifier</function>stops at the zero; the behavior is thus rather like <function>strncpy</function>.) The return string has all special characters replaced so that it will be properly processed as an SQL identifier. A terminating zero byte is also added. The return string will also be surrounded by double quotes."
msgstr ""

#: xml/libpq.xml:3578(para)
msgid "On error, <function>PQescapeIdentifier</function>returns <symbol>NULL</symbol>and a suitable message is stored in the <parameter>conn</parameter>object."
msgstr ""

#: xml/libpq.xml:3584(para)
msgid "As with string literals, to prevent SQL injection attacks, SQL identifiers must be escaped when they are received from an untrustworthy source."
msgstr ""

#: xml/libpq.xml:3593(function) xml/libpq.xml:3595(primary)
msgid "PQescapeStringConn"
msgstr ""

#: xml/libpq.xml:3600(synopsis)
#, no-wrap
msgid "size_t PQescapeStringConn(PGconn *conn,\n              char *to, const char *from, size_t length, int\n              *error);"
msgstr ""

#: xml/libpq.xml:3604(para)
msgid "<function>PQescapeStringConn</function>escapes string literals, much like <function>PQescapeLiteral</function>. Unlike <function>PQescapeLiteral</function>, the caller is responsible for providing an appropriately sized buffer. Furthermore, <function>PQescapeStringConn</function>does not generate the single quotes that must surround <productname>PostgreSQL</productname>string literals; they should be provided in the SQL command that the result is inserted into. The parameter <parameter>from</parameter>points to the first character of the string that is to be escaped, and the <parameter>length</parameter>parameter gives the number of bytes in this string. A terminating zero byte is not required, and should not be counted in <parameter>length</parameter>. (If a terminating zero byte is found before <parameter>length</parameter>bytes are processed, <function>PQescapeStringConn</function>stops at the zero; the behavior is thus rather like <function>strncpy</function>.) <parameter>to</parameter>shall point to a buffer that is able to hold at least one more byte than twice the value of <parameter>length</parameter>, otherwise the behavior is undefined. Behavior is likewise undefined if the <parameter>to</parameter>and <parameter>from</parameter>strings overlap."
msgstr ""

#: xml/libpq.xml:3634(para)
msgid "If the <parameter>error</parameter>parameter is not <symbol>NULL</symbol>, then <literal>*error</literal>is set to zero on success, nonzero on error. Presently the only possible error conditions involve invalid multibyte encoding in the source string. The output string is still generated on error, but it can be expected that the server will reject it as malformed. On error, a suitable message is stored in the <parameter>conn</parameter>object, whether or not <parameter>error</parameter>is <symbol>NULL</symbol>."
msgstr ""

#: xml/libpq.xml:3647(para)
msgid "<function>PQescapeStringConn</function>returns the number of bytes written to <parameter>to</parameter>, not including the terminating zero byte."
msgstr ""

#: xml/libpq.xml:3656(function) xml/libpq.xml:3658(primary)
msgid "PQescapeString"
msgstr ""

#: xml/libpq.xml:3662(para)
msgid "<function>PQescapeString</function>is an older, deprecated version of <function>PQescapeStringConn</function>. <synopsis>size_t PQescapeString (char *to, const char\n            *from, size_t length);</synopsis>"
msgstr ""

#: xml/libpq.xml:3668(para)
msgid "The only difference from <function>PQescapeStringConn</function>is that <function>PQescapeString</function>does not take <structname>PGconn</structname>or <parameter>error</parameter>parameters. Because of this, it cannot adjust its behavior depending on the connection properties (such as character encoding) and therefore <emphasis>it might give the wrong results</emphasis>. Also, it has no way to report error conditions."
msgstr ""

#: xml/libpq.xml:3678(para)
msgid "<function>PQescapeString</function>can be used safely in client programs that work with only one <productname>PostgreSQL</productname>connection at a time (in this case it can find out what it needs to know <quote>behind the scenes</quote>). In other contexts it is a security hazard and should be avoided in favor of <function>PQescapeStringConn</function>."
msgstr ""

#: xml/libpq.xml:3691(function) xml/libpq.xml:3693(primary)
msgid "PQescapeByteaConn"
msgstr ""

#: xml/libpq.xml:3697(para)
msgid "Escapes binary data for use within an SQL command with the type <type>bytea</type>. As with <function>PQescapeStringConn</function>, this is only used when inserting data directly into an SQL command string. <synopsis>unsigned char *PQescapeByteaConn(PGconn\n            *conn, const unsigned char *from, size_t from_length,\n            size_t *to_length);</synopsis>"
msgstr ""

#: xml/libpq.xml:3706(para)
msgid "Certain byte values must be escaped when used as part of a <type>bytea</type>literal in an <acronym>SQL</acronym>statement. <function>PQescapeByteaConn</function>escapes bytes using either hex encoding or backslash escaping. See <xref linkend=\"datatype-binary\">for more information.</xref>"
msgstr ""

#: xml/libpq.xml:3714(para)
msgid "The <parameter>from</parameter>parameter points to the first byte of the string that is to be escaped, and the <parameter>from_length</parameter>parameter gives the number of bytes in this binary string. (A terminating zero byte is neither necessary nor counted.) The <parameter>to_length</parameter>parameter points to a variable that will hold the resultant escaped string length. This result string length includes the terminating zero byte of the result."
msgstr ""

#: xml/libpq.xml:3725(para)
msgid "<function>PQescapeByteaConn</function>returns an escaped version of the <parameter>from</parameter>parameter binary string in memory allocated with <function>malloc()</function>. This memory should be freed using <function>PQfreemem()</function>when the result is no longer needed. The return string has all special characters replaced so that they can be properly processed by the <productname>PostgreSQL</productname>string literal parser, and the <type>bytea</type>input function. A terminating zero byte is also added. The single quotes that must surround <productname>PostgreSQL</productname>string literals are not part of the result string."
msgstr ""

#: xml/libpq.xml:3743(para)
msgid "On error, a null pointer is returned, and a suitable error message is stored in the <parameter>conn</parameter>object. Currently, the only possible error is insufficient memory for the result string."
msgstr ""

#: xml/libpq.xml:3752(function) xml/libpq.xml:3754(primary)
msgid "PQescapeBytea"
msgstr ""

#: xml/libpq.xml:3758(para)
msgid "<function>PQescapeBytea</function>is an older, deprecated version of <function>PQescapeByteaConn</function>. <synopsis>unsigned char *PQescapeBytea(const unsigned\n            char *from, size_t from_length, size_t\n            *to_length);</synopsis>"
msgstr ""

#: xml/libpq.xml:3765(para)
msgid "The only difference from <function>PQescapeByteaConn</function>is that <function>PQescapeBytea</function>does not take a <structname>PGconn</structname>parameter. Because of this, <function>PQescapeBytea</function>can only be used safely in client programs that use a single <productname>PostgreSQL</productname>connection at a time (in this case it can find out what it needs to know <quote>behind the scenes</quote>). It <emphasis>might give the wrong results</emphasis>if used in programs that use multiple database connections (use <function>PQescapeByteaConn</function>in such cases)."
msgstr ""

#: xml/libpq.xml:3785(function) xml/libpq.xml:3787(primary)
msgid "PQunescapeBytea"
msgstr ""

#: xml/libpq.xml:3791(para)
msgid "Converts a string representation of binary data into binary data the reverse of <function>PQescapeBytea</function>. This is needed when retrieving <type>bytea</type>data in text format, but not when retrieving it in binary format. <synopsis>unsigned char *PQunescapeBytea(const unsigned\n            char *from, size_t *to_length);</synopsis>"
msgstr ""

#: xml/libpq.xml:3799(para)
msgid "The <parameter>from</parameter>parameter points to a string such as might be returned by <function>PQgetvalue</function>when applied to a <type>bytea</type>column. <function>PQunescapeBytea</function>converts this string representation into its binary representation. It returns a pointer to a buffer allocated with <function>malloc()</function>, or <symbol>NULL</symbol>on error, and puts the size of the buffer in <parameter>to_length</parameter>. The result must be freed using <function>PQfreemem</function>when it is no longer needed."
msgstr ""

#: xml/libpq.xml:3814(para)
msgid "This conversion is not exactly the inverse of <function>PQescapeBytea</function>, because the string is not expected to be <quote>escaped</quote>when received from <function>PQgetvalue</function>. In particular this means there is no need for string quoting considerations, and so no need for a <structname>PGconn</structname>parameter."
msgstr ""

#: xml/libpq.xml:3828(title)
msgid "Asynchronous Command Processing"
msgstr ""

#: xml/libpq.xml:3830(primary)
msgid "nonblocking connection"
msgstr ""

#: xml/libpq.xml:3839(para)
msgid "<function>PQexec</function>waits for the command to be completed. The application might have other work to do (such as maintaining a user interface), in which case it won't want to block waiting for the response."
msgstr ""

#: xml/libpq.xml:3846(para)
msgid "Since the execution of the client application is suspended while it waits for the result, it is hard for the application to decide that it would like to try to cancel the ongoing command. (It can be done from a signal handler, but not otherwise.)"
msgstr ""

#: xml/libpq.xml:3853(para)
msgid "<function>PQexec</function>can return only one <structname>PGresult</structname>structure. If the submitted command string contains multiple <acronym>SQL</acronym>commands, all but the last <structname>PGresult</structname>are discarded by <function>PQexec</function>."
msgstr ""

#: xml/libpq.xml:3862(para)
msgid "<function>PQexec</function>always collects the command's entire result, buffering it in a single <structname>PGresult</structname>. While this simplifies error-handling logic for the application, it can be impractical for results containing many rows."
msgstr ""

#: xml/libpq.xml:3832(para)
msgid "The <function>PQexec</function>function is adequate for submitting commands in normal, synchronous applications. It has a few deficiencies, however, that can be of importance to some users: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:3891(function) xml/libpq.xml:3893(primary)
msgid "PQsendQuery"
msgstr ""

#: xml/libpq.xml:3897(para)
msgid "Submits a command to the server without waiting for the result(s). 1 is returned if the command was successfully dispatched and 0 if not (in which case, use <function>PQerrorMessage</function>to get more information about the failure). <synopsis>int PQsendQuery(PGconn *conn, const char\n          *command);</synopsis>After successfully calling <function>PQsendQuery</function>, call <function>PQgetResult</function>one or more times to obtain the results. <function>PQsendQuery</function>cannot be called again (on the same connection) until <function>PQgetResult</function>has returned a null pointer, indicating that the command is done."
msgstr ""

#: xml/libpq.xml:3915(function) xml/libpq.xml:3917(primary)
msgid "PQsendQueryParams"
msgstr ""

#: xml/libpq.xml:3921(para)
msgid "Submits a command and separate parameters to the server without waiting for the result(s). <synopsis>int PQsendQueryParams(PGconn *conn, const char\n          *command, int nParams, const Oid *paramTypes, const char\n          * const *paramValues, const int *paramLengths, const int\n          *paramFormats, int resultFormat);</synopsis>This is equivalent to <function>PQsendQuery</function>except that query parameters can be specified separately from the query string. The function's parameters are handled identically to <function>PQexecParams</function>. Like <function>PQexecParams</function>, it will not work on 2.0-protocol connections, and it allows only one command in the query string."
msgstr ""

#: xml/libpq.xml:3940(function) xml/libpq.xml:3942(primary)
msgid "PQsendPrepare"
msgstr ""

#: xml/libpq.xml:3946(para)
msgid "Sends a request to create a prepared statement with the given parameters, without waiting for completion. <synopsis>int PQsendPrepare(PGconn *conn, const char\n          *stmtName, const char *query, int nParams, const Oid\n          *paramTypes);</synopsis>This is an asynchronous version of <function>PQprepare</function>: it returns 1 if it was able to dispatch the request, and 0 if not. After a successful call, call <function>PQgetResult</function>to determine whether the server successfully created the prepared statement. The function's parameters are handled identically to <function>PQprepare</function>. Like <function>PQprepare</function>, it will not work on 2.0-protocol connections."
msgstr ""

#: xml/libpq.xml:3965(function) xml/libpq.xml:3967(primary)
msgid "PQsendQueryPrepared"
msgstr ""

#: xml/libpq.xml:3971(para)
msgid "Sends a request to execute a prepared statement with given parameters, without waiting for the result(s). <synopsis>int PQsendQueryPrepared(PGconn *conn, const\n          char *stmtName, int nParams, const char * const\n          *paramValues, const int *paramLengths, const int\n          *paramFormats, int resultFormat);</synopsis>This is similar to <function>PQsendQueryParams</function>, but the command to be executed is specified by naming a previously-prepared statement, instead of giving a query string. The function's parameters are handled identically to <function>PQexecPrepared</function>. Like <function>PQexecPrepared</function>, it will not work on 2.0-protocol connections."
msgstr ""

#: xml/libpq.xml:3991(function) xml/libpq.xml:3993(primary)
msgid "PQsendDescribePrepared"
msgstr ""

#: xml/libpq.xml:3997(para)
msgid "Submits a request to obtain information about the specified prepared statement, without waiting for completion. <synopsis>int PQsendDescribePrepared(PGconn *conn, const\n          char *stmtName);</synopsis>This is an asynchronous version of <function>PQdescribePrepared</function>: it returns 1 if it was able to dispatch the request, and 0 if not. After a successful call, call <function>PQgetResult</function>to obtain the results. The function's parameters are handled identically to <function>PQdescribePrepared</function>. Like <function>PQdescribePrepared</function>, it will not work on 2.0-protocol connections."
msgstr ""

#: xml/libpq.xml:4015(function) xml/libpq.xml:4017(primary)
msgid "PQsendDescribePortal"
msgstr ""

#: xml/libpq.xml:4021(para)
msgid "Submits a request to obtain information about the specified portal, without waiting for completion. <synopsis>int PQsendDescribePortal(PGconn *conn, const\n          char *portalName);</synopsis>This is an asynchronous version of <function>PQdescribePortal</function>: it returns 1 if it was able to dispatch the request, and 0 if not. After a successful call, call <function>PQgetResult</function>to obtain the results. The function's parameters are handled identically to <function>PQdescribePortal</function>. Like <function>PQdescribePortal</function>, it will not work on 2.0-protocol connections."
msgstr ""

#: xml/libpq.xml:4038(function) xml/libpq.xml:4040(primary)
msgid "PQgetResult"
msgstr ""

#: xml/libpq.xml:4044(para)
msgid "Waits for the next result from a prior <function>PQsendQuery</function>, <function>PQsendQueryParams</function>, <function>PQsendPrepare</function>, <function>PQsendQueryPrepared</function>, <function>PQsendDescribePrepared</function>, or <function>PQsendDescribePortal</function>call, and returns it. A null pointer is returned when the command is complete and there will be no more results. <synopsis>PGresult *PQgetResult(PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4055(para)
msgid "<function>PQgetResult</function>must be called repeatedly until it returns a null pointer, indicating that the command is done. (If called when no command is active, <function>PQgetResult</function>will just return a null pointer at once.) Each non-null result from <function>PQgetResult</function>should be processed using the same <structname>PGresult</structname>accessor functions previously described. Don't forget to free each result object with <function>PQclear</function>when done with it. Note that <function>PQgetResult</function>will block only if a command is active and the necessary response data has not yet been read by <function>PQconsumeInput</function>."
msgstr ""

#: xml/libpq.xml:4072(para)
msgid "Even when <function>PQresultStatus</function>indicates a fatal error, <function>PQgetResult</function>should be called until it returns a null pointer, to allow <application>libpq</application>to process the error information completely."
msgstr ""

#: xml/libpq.xml:3870(para)
msgid "Applications that do not like these limitations can instead use the underlying functions that <function>PQexec</function>is built from: <function>PQsendQuery</function>and <function>PQgetResult</function>. There are also <function>PQsendQueryParams</function>, <function>PQsendPrepare</function>, <function>PQsendQueryPrepared</function>, <function>PQsendDescribePrepared</function>, and <function>PQsendDescribePortal</function>, which can be used with <function>PQgetResult</function>to duplicate the functionality of <function>PQexecParams</function>, <function>PQprepare</function>, <function>PQexecPrepared</function>, <function>PQdescribePrepared</function>, and <function>PQdescribePortal</function>respectively. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:4083(para)
msgid "Using <function>PQsendQuery</function>and <function>PQgetResult</function>solves one of <function>PQexec</function>'s problems: If a command string contains multiple <acronym>SQL</acronym>commands, the results of those commands can be obtained individually. (This allows a simple form of overlapped processing, by the way: the client can be handling the results of one command while the server is still working on later queries in the same command string.)"
msgstr ""

#: xml/libpq.xml:4093(para)
msgid "Another frequently-desired feature that can be obtained with <function>PQsendQuery</function>and <function>PQgetResult</function>is retrieving large query results a row at a time. This is discussed in <xref linkend=\"libpq-single-row-mode\">.</xref>"
msgstr ""

#: xml/libpq.xml:4107(function) xml/libpq.xml:4109(primary)
msgid "PQconsumeInput"
msgstr ""

#: xml/libpq.xml:4113(para)
msgid "If input is available from the server, consume it. <synopsis>int PQconsumeInput(PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4116(para)
msgid "<function>PQconsumeInput</function>normally returns 1 indicating <quote>no error</quote>, but returns 0 if there was some kind of trouble (in which case <function>PQerrorMessage</function>can be consulted). Note that the result does not say whether any input data was actually collected. After calling <function>PQconsumeInput</function>, the application can check <function>PQisBusy</function>and/or <function>PQnotifies</function>to see if their state has changed."
msgstr ""

#: xml/libpq.xml:4129(para)
msgid "<function>PQconsumeInput</function>can be called even if the application is not prepared to deal with a result or notification just yet. The function will read available data and save it in a buffer, thereby causing a <function>select()</function>read-ready indication to go away. The application can thus use <function>PQconsumeInput</function>to clear the <function>select()</function>condition immediately, and then examine the results at leisure."
msgstr ""

#: xml/libpq.xml:4143(function) xml/libpq.xml:4145(primary)
msgid "PQisBusy"
msgstr ""

#: xml/libpq.xml:4149(para)
msgid "Returns 1 if a command is busy, that is, <function>PQgetResult</function>would block waiting for input. A 0 return indicates that <function>PQgetResult</function>can be called with assurance of not blocking. <synopsis>int PQisBusy(PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4155(para)
msgid "<function>PQisBusy</function>will not itself attempt to read data from the server; therefore <function>PQconsumeInput</function>must be invoked first, or the busy state will never end."
msgstr ""

#: xml/libpq.xml:4099(para)
msgid "By itself, calling <function>PQgetResult</function>will still cause the client to block until the server completes the next <acronym>SQL</acronym>command. This can be avoided by proper use of two more functions: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:4163(para)
msgid "A typical application using these functions will have a main loop that uses <function>select()</function>or <function>poll()</function>to wait for all the conditions that it must respond to. One of the conditions will be input available from the server, which in terms of <function>select()</function>means readable data on the file descriptor identified by <function>PQsocket</function>. When the main loop detects input ready, it should call <function>PQconsumeInput</function>to read the input. It can then call <function>PQisBusy</function>, followed by <function>PQgetResult</function>if <function>PQisBusy</function>returns false (0). It can also call <function>PQnotifies</function>to detect <command>NOTIFY</command>messages (see <xref linkend=\"libpq-notify\">).</xref>"
msgstr ""

#: xml/libpq.xml:4182(para)
msgid "A client that uses <function>PQsendQuery</function>/ <function>PQgetResult</function>can also attempt to cancel a command that is still being processed by the server; see <xref linkend=\"libpq-cancel\">. But regardless of the return value of <function>PQcancel</function>, the application must continue with the normal result-reading sequence using <function>PQgetResult</function>. A successful cancellation will simply cause the command to terminate sooner than it would have otherwise.</xref>"
msgstr ""

#: xml/libpq.xml:4206(function) xml/libpq.xml:4208(primary)
msgid "PQsetnonblocking"
msgstr ""

#: xml/libpq.xml:4212(para)
msgid "Sets the nonblocking status of the connection. <synopsis>int PQsetnonblocking(PGconn *conn, int\n          arg);</synopsis>"
msgstr ""

#: xml/libpq.xml:4215(para)
msgid "Sets the state of the connection to nonblocking if <parameter>arg</parameter>is 1, or blocking if <parameter>arg</parameter>is 0. Returns 0 if OK, -1 if error."
msgstr ""

#: xml/libpq.xml:4219(para)
msgid "In the nonblocking state, calls to <function>PQsendQuery</function>, <function>PQputline</function>, <function>PQputnbytes</function>, <function>PQputCopyData</function>, and <function>PQendcopy</function>will not block but instead return an error if they need to be called again."
msgstr ""

#: xml/libpq.xml:4226(para)
msgid "Note that <function>PQexec</function>does not honor nonblocking mode; if it is called, it will act in blocking fashion anyway."
msgstr ""

#: xml/libpq.xml:4234(function) xml/libpq.xml:4236(primary)
msgid "PQisnonblocking"
msgstr ""

#: xml/libpq.xml:4240(para)
msgid "Returns the blocking status of the database connection. <synopsis>int PQisnonblocking(const PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4244(para)
msgid "Returns 1 if the connection is set to nonblocking mode and 0 if blocking."
msgstr ""

#: xml/libpq.xml:4250(function) xml/libpq.xml:4252(primary)
msgid "PQflush"
msgstr ""

#: xml/libpq.xml:4256(para)
msgid "Attempts to flush any queued output data to the server. Returns 0 if successful (or if the send queue is empty), -1 if it failed for some reason, or 1 if it was unable to send all the data in the send queue yet (this case can only occur if the connection is nonblocking). <synopsis>int PQflush(PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4193(para)
msgid "By using the functions described above, it is possible to avoid blocking while waiting for input from the database server. However, it is still possible that the application will block waiting to send output to the server. This is relatively uncommon but can happen if very long SQL commands or data values are sent. (It is much more probable if the application sends data via <command>COPY IN</command>, however.) To prevent this possibility and achieve completely nonblocking database operation, the following additional functions can be used. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:4265(para)
msgid "After sending any command or data on a nonblocking connection, call <function>PQflush</function>. If it returns 1, wait for the socket to become read- or write-ready. If it becomes write-ready, call <function>PQflush</function>again. If it becomes read-ready, call <function>PQconsumeInput</function>, then call <function>PQflush</function>again. Repeat until <function>PQflush</function>returns 0. (It is necessary to check for read-ready and drain the input with <function>PQconsumeInput</function>, because the server can block trying to send us data, e.g. NOTICE messages, and won't read our data until we read its.) Once <function>PQflush</function>returns 0, wait for the socket to be read-ready and then read the response as described above."
msgstr ""

#: xml/libpq.xml:4284(title)
msgid "Retrieving Query Results Row-By-Row"
msgstr ""

#: xml/libpq.xml:4287(secondary)
msgid "single-row mode"
msgstr ""

#: xml/libpq.xml:4289(para)
msgid "Ordinarily, <application>libpq</application>collects a SQL command's entire result and returns it to the application as a single <structname>PGresult</structname>. This can be unworkable for commands that return a large number of rows. For such cases, applications can use <function>PQsendQuery</function>and <function>PQgetResult</function>in <firstterm>single-row mode</firstterm>. In this mode, the result row(s) are returned to the application one at a time, as they are received from the server."
msgstr ""

#: xml/libpq.xml:4300(para)
msgid "To enter single-row mode, call <function>PQsetSingleRowMode</function>immediately after a successful call of <function>PQsendQuery</function>(or a sibling function). This mode selection is effective only for the currently executing query. Then call <function>PQgetResult</function>repeatedly, until it returns null, as documented in <xref linkend=\"libpq-async\">. If the query returns any rows, they are returned as individual <structname>PGresult</structname>objects, which look like normal query results except for having status code <literal>PGRES_SINGLE_TUPLE</literal>instead of <literal>PGRES_TUPLES_OK</literal>. After the last row, or immediately if the query returns zero rows, a zero-row object with status <literal>PGRES_TUPLES_OK</literal>is returned; this is the signal that no more rows will arrive. (But note that it is still necessary to continue calling <function>PQgetResult</function>until it returns null.) All of these <structname>PGresult</structname>objects will contain the same row description data (column names, types, etc) that an ordinary <structname>PGresult</structname>object for the query would have. Each object should be freed with <function>PQclear</function>as usual.</xref>"
msgstr ""

#: xml/libpq.xml:4331(function) xml/libpq.xml:4333(primary)
msgid "PQsetSingleRowMode"
msgstr ""

#: xml/libpq.xml:4337(para)
msgid "Select single-row mode for the currently-executing query. <synopsis>int PQsetSingleRowMode(PGconn\n            *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4341(para)
msgid "This function can only be called immediately after <function>PQsendQuery</function>or one of its sibling functions, before any other operation on the connection such as <function>PQconsumeInput</function>or <function>PQgetResult</function>. If called at the correct time, the function activates single-row mode for the current query and returns 1. Otherwise the mode stays unchanged and the function returns 0. In any case, the mode reverts to normal after completion of the current query."
msgstr ""

#: xml/libpq.xml:4358(para)
msgid "While processing a query, the server may return some rows and then encounter an error, causing the query to be aborted. Ordinarily, <application>libpq</application>discards any such rows and reports only the error. But in single-row mode, those rows will have already been returned to the application. Hence, the application will see some <literal>PGRES_SINGLE_TUPLE</literal><structname>PGresult</structname>objects followed by a <literal>PGRES_FATAL_ERROR</literal>object. For proper transactional behavior, the application must be designed to discard or undo whatever has been done with the previously-processed rows, if the query ultimately fails."
msgstr ""

#: xml/libpq.xml:4375(title)
msgid "Canceling Queries in Progress"
msgstr ""

#: xml/libpq.xml:4377(primary)
msgid "canceling"
msgstr ""

#: xml/libpq.xml:4378(secondary)
msgid "SQL command"
msgstr ""

#: xml/libpq.xml:4386(function) xml/libpq.xml:4388(primary)
msgid "PQgetCancel"
msgstr ""

#: xml/libpq.xml:4392(para)
msgid "Creates a data structure containing the information needed to cancel a command issued through a particular database connection. <synopsis>PGcancel *PQgetCancel(PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4397(para)
msgid "<function>PQgetCancel</function>creates a <structname>PGcancel</structname><indexterm><primary>PGcancel</primary></indexterm>object given a <structname>PGconn</structname>connection object. It will return <symbol>NULL</symbol>if the given <parameter>conn</parameter>is <symbol>NULL</symbol>or an invalid connection. The <structname>PGcancel</structname>object is an opaque structure that is not meant to be accessed directly by the application; it can only be passed to <function>PQcancel</function>or <function>PQfreeCancel</function>."
msgstr ""

#: xml/libpq.xml:4417(function) xml/libpq.xml:4419(primary)
msgid "PQfreeCancel"
msgstr ""

#: xml/libpq.xml:4423(para)
msgid "Frees a data structure created by <function>PQgetCancel</function>. <synopsis>void PQfreeCancel(PGcancel\n          *cancel);</synopsis>"
msgstr ""

#: xml/libpq.xml:4427(para)
msgid "<function>PQfreeCancel</function>frees a data object previously created by <function>PQgetCancel</function>."
msgstr ""

#: xml/libpq.xml:4435(function) xml/libpq.xml:4437(primary)
msgid "PQcancel"
msgstr ""

#: xml/libpq.xml:4441(para)
msgid "Requests that the server abandon processing of the current command. <synopsis>int PQcancel(PGcancel *cancel, char *errbuf,\n          int errbufsize);</synopsis>"
msgstr ""

#: xml/libpq.xml:4445(para)
msgid "The return value is 1 if the cancel request was successfully dispatched and 0 if not. If not, <parameter>errbuf</parameter>is filled with an explanatory error message. <parameter>errbuf</parameter>must be a char array of size <parameter>errbufsize</parameter>(the recommended size is 256 bytes)."
msgstr ""

#: xml/libpq.xml:4453(para)
msgid "Successful dispatch is no guarantee that the request will have any effect, however. If the cancellation is effective, the current command will terminate early and return an error result. If the cancellation fails (say, because the server was already done processing the command), then there will be no visible result at all."
msgstr ""

#: xml/libpq.xml:4460(para)
msgid "<function>PQcancel</function>can safely be invoked from a signal handler, if the <parameter>errbuf</parameter>is a local variable in the signal handler. The <structname>PGcancel</structname>object is read-only as far as <function>PQcancel</function>is concerned, so it can also be invoked from a thread that is separate from the one manipulating the <structname>PGconn</structname>object."
msgstr ""

#: xml/libpq.xml:4477(function) xml/libpq.xml:4479(primary)
msgid "PQrequestCancel"
msgstr ""

#: xml/libpq.xml:4483(para)
msgid "<function>PQrequestCancel</function>is a deprecated variant of <function>PQcancel</function>. <synopsis>int PQrequestCancel(PGconn\n          *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:4489(para)
msgid "Requests that the server abandon processing of the current command. It operates directly on the <structname>PGconn</structname>object, and in case of failure stores the error message in the <structname>PGconn</structname>object (whence it can be retrieved by <function>PQerrorMessage</function>). Although the functionality is the same, this approach creates hazards for multiple-thread programs and signal handlers, since it is possible that overwriting the <structname>PGconn</structname>'s error message will mess up the operation currently in progress on the connection."
msgstr ""

#: xml/libpq.xml:4380(para)
msgid "A client application can request cancellation of a command that is still being processed by the server, using the functions described in this section. <placeholder-1/><placeholder-2/>"
msgstr ""

#: xml/libpq.xml:4507(title)
msgid "The Fast-Path Interface"
msgstr ""

#: xml/libpq.xml:4509(primary)
msgid "fast path"
msgstr ""

#: xml/libpq.xml:4511(para)
msgid "<productname>PostgreSQL</productname>provides a fast-path interface to send simple function calls to the server."
msgstr ""

#: xml/libpq.xml:4515(para)
msgid "This interface is somewhat obsolete, as one can achieve similar performance and greater functionality by setting up a prepared statement to define the function call. Then, executing the statement with binary transmission of parameters and results substitutes for a fast-path function call."
msgstr ""

#: xml/libpq.xml:4522(para)
msgid "The function <function>PQfn</function><indexterm><primary>PQfn</primary></indexterm>requests execution of a server function via the fast-path interface: <synopsis>PGresult *PQfn(PGconn *conn, int fnid, int\n    *result_buf, int *result_len, int result_is_int, const\n    PQArgBlock *args, int nargs); typedef struct { int len; int\n    isint; union { int *ptr; int integer; } u; }\n    PQArgBlock;</synopsis>"
msgstr ""

#: xml/libpq.xml:4533(para)
msgid "The <parameter>fnid</parameter>argument is the OID of the function to be executed. <parameter>args</parameter>and <parameter>nargs</parameter>define the parameters to be passed to the function; they must match the declared function argument list. When the <parameter>isint</parameter>field of a parameter structure is true, the <parameter>u.integer</parameter>value is sent to the server as an integer of the indicated length (this must be 2 or 4 bytes); proper byte-swapping occurs. When <parameter>isint</parameter>is false, the indicated number of bytes at <parameter>*u.ptr</parameter>are sent with no processing; the data must be in the format expected by the server for binary transmission of the function's argument data type. (The declaration of <parameter>u.ptr</parameter>as being of type <type>int *</type>is historical; it would be better to consider it <type>void *</type>.) <parameter>result_buf</parameter>points to the buffer in which to place the function's return value. The caller must have allocated sufficient space to store the return value. (There is no check!) The actual result length in bytes will be returned in the integer pointed to by <parameter>result_len</parameter>. If a 2- or 4-byte integer result is expected, set <parameter>result_is_int</parameter>to 1, otherwise set it to 0. Setting <parameter>result_is_int</parameter>to 1 causes <application>libpq</application>to byte-swap the value if necessary, so that it is delivered as a proper <type>int</type>value for the client machine; note that a 4-byte integer is delivered into <parameter>*result_buf</parameter>for either allowed result size. When <parameter>result_is_int</parameter>is 0, the binary-format byte string sent by the server is returned unmodified. (In this case it's better to consider <parameter>result_buf</parameter>as being of type <type>void *</type>.)"
msgstr ""

#: xml/libpq.xml:4576(para)
msgid "<function>PQfn</function>always returns a valid <structname>PGresult</structname>pointer. The result status should be checked before the result is used. The caller is responsible for freeing the <structname>PGresult</structname>with <function>PQclear</function>when it is no longer needed."
msgstr ""

#: xml/libpq.xml:4583(para)
msgid "Note that it is not possible to handle null arguments, null results, nor set-valued results when using this interface."
msgstr ""

#: xml/libpq.xml:4588(title)
msgid "Asynchronous Notification"
msgstr ""

#: xml/libpq.xml:4590(primary)
msgid "NOTIFY"
msgstr ""

#: xml/libpq.xml:4593(para)
msgid "<productname>PostgreSQL</productname>offers asynchronous notification via the <command>LISTEN</command>and <command>NOTIFY</command>commands. A client session registers its interest in a particular notification channel with the <command>LISTEN</command>command (and can stop listening with the <command>UNLISTEN</command>command). All sessions listening on a particular channel will be notified asynchronously when a <command>NOTIFY</command>command with that channel name is executed by any session. A <quote>payload</quote>string can be passed to communicate additional data to the listeners."
msgstr ""

#: xml/libpq.xml:4607(para)
msgid "<application>libpq</application>applications submit <command>LISTEN</command>, <command>UNLISTEN</command>, and <command>NOTIFY</command>commands as ordinary SQL commands. The arrival of <command>NOTIFY</command>messages can subsequently be detected by calling <function>PQnotifies</function>. <indexterm><primary>PQnotifies</primary></indexterm>"
msgstr ""

#: xml/libpq.xml:4619(para)
msgid "The function <function>PQnotifies</function>returns the next notification from a list of unhandled notification messages received from the server. It returns a null pointer if there are no pending notifications. Once a notification is returned from <function>PQnotifies</function>, it is considered handled and will be removed from the list of notifications. <synopsis>PGnotify *PQnotifies(PGconn *conn); typedef struct\n    pgNotify { char *relname; /* notification channel name */ int\n    be_pid; /* process ID of notifying server process */ char\n    *extra; /* notification payload string */ }\n    PGnotify;</synopsis>After processing a <structname>PGnotify</structname>object returned by <function>PQnotifies</function>, be sure to free it with <function>PQfreemem</function>. It is sufficient to free the <structname>PGnotify</structname>pointer; the <structfield>relname</structfield>and <structfield>extra</structfield>fields do not represent separate allocations. (The names of these fields are historical; in particular, channel names need not have anything to do with relation names.)"
msgstr ""

#: xml/libpq.xml:4641(xref)
msgid "gives a sample program that illustrates the use of asynchronous notification."
msgstr ""

#: xml/libpq.xml:4644(para)
msgid "<function>PQnotifies</function>does not actually read data from the server; it just returns messages previously absorbed by another <application>libpq</application>function. In prior releases of <application>libpq</application>, the only way to ensure timely receipt of <command>NOTIFY</command>messages was to constantly submit commands, even empty ones, and then check <function>PQnotifies</function>after each <function>PQexec</function>. While this still works, it is deprecated as a waste of processing power."
msgstr ""

#: xml/libpq.xml:4656(para)
msgid "A better way to check for <command>NOTIFY</command>messages when you have no useful commands to execute is to call <function>PQconsumeInput</function>, then check <function>PQnotifies</function>. You can use <function>select()</function>to wait for data to arrive from the server, thereby using no <acronym>CPU</acronym>power unless there is something to do. (See <function>PQsocket</function>to obtain the file descriptor number to use with <function>select()</function>.) Note that this will work OK whether you submit commands with <function>PQsendQuery</function>/ <function>PQgetResult</function>or simply use <function>PQexec</function>. You should, however, remember to check <function>PQnotifies</function>after each <function>PQgetResult</function>or <function>PQexec</function>, to see if any notifications came in during the processing of the command."
msgstr ""

#: xml/libpq.xml:4679(title)
msgid "Functions Associated with the <command>COPY</command>Command"
msgstr ""

#: xml/libpq.xml:4682(primary)
msgid "COPY"
msgstr ""

#: xml/libpq.xml:4683(secondary) xml/libpq.xml:7164(secondary)
msgid "with libpq"
msgstr ""

#: xml/libpq.xml:4685(para)
msgid "The <command>COPY</command>command in <productname>PostgreSQL</productname>has options to read from or write to the network connection used by <application>libpq</application>. The functions described in this section allow applications to take advantage of this capability by supplying or consuming copied data."
msgstr ""

#: xml/libpq.xml:4692(para)
msgid "The overall process is that the application first issues the SQL <command>COPY</command>command via <function>PQexec</function>or one of the equivalent functions. The response to this (if there is no error in the command) will be a <structname>PGresult</structname>object bearing a status code of <literal>PGRES_COPY_OUT</literal>or <literal>PGRES_COPY_IN</literal>(depending on the specified copy direction). The application should then use the functions of this section to receive or transmit data rows. When the data transfer is complete, another <structname>PGresult</structname>object is returned to indicate success or failure of the transfer. Its status will be <literal>PGRES_COMMAND_OK</literal>for success or <literal>PGRES_FATAL_ERROR</literal>if some problem was encountered. At this point further SQL commands can be issued via <function>PQexec</function>. (It is not possible to execute other SQL commands using the same connection while the <command>COPY</command>operation is in progress.)"
msgstr ""

#: xml/libpq.xml:4714(para)
msgid "If a <command>COPY</command>command is issued via <function>PQexec</function>in a string that could contain additional commands, the application must continue fetching results via <function>PQgetResult</function>after completing the <command>COPY</command>sequence. Only when <function>PQgetResult</function>returns <symbol>NULL</symbol>is it certain that the <function>PQexec</function>command string is done and it is safe to issue more commands."
msgstr ""

#: xml/libpq.xml:4725(para)
msgid "The functions of this section should be executed only after obtaining a result status of <literal>PGRES_COPY_OUT</literal>or <literal>PGRES_COPY_IN</literal>from <function>PQexec</function>or <function>PQgetResult</function>."
msgstr ""

#: xml/libpq.xml:4743(secondary) xml/libpq.xml:4756(secondary) xml/libpq.xml:4773(secondary)
msgid "with COPY"
msgstr ""

#: xml/libpq.xml:4747(para)
msgid "Returns the number of columns (fields) to be copied."
msgstr ""

#: xml/libpq.xml:4760(para)
msgid "0 indicates the overall copy format is textual (rows separated by newlines, columns separated by separator characters, etc). 1 indicates the overall copy format is binary. See <xref linkend=\"sql-copy\">for more information.</xref>"
msgstr ""

#: xml/libpq.xml:4777(para)
msgid "Returns the format code (0 for text, 1 for binary) associated with each column of the copy operation. The per-column format codes will always be zero when the overall copy format is textual, but the binary format can support both text and binary columns. (However, as of the current implementation of <command>COPY</command>, only binary columns appear in a binary copy; so the per-column formats always match the overall format at present.)"
msgstr ""

#: xml/libpq.xml:4731(para)
msgid "A <structname>PGresult</structname>object bearing one of these status values carries some additional data about the <command>COPY</command>operation that is starting. This additional data is available using functions that are also used in connection with query results: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:4790(para)
msgid "These additional data values are only available when using protocol 3.0. When using protocol 2.0, all these functions will return 0."
msgstr ""

#: xml/libpq.xml:4795(title)
msgid "Functions for Sending <command>COPY</command>Data"
msgstr ""

#: xml/libpq.xml:4797(para)
msgid "These functions are used to send data during <literal>COPY FROM STDIN</literal>. They will fail if called when the connection is not in <literal>COPY_IN</literal>state."
msgstr ""

#: xml/libpq.xml:4804(function) xml/libpq.xml:4806(primary)
msgid "PQputCopyData"
msgstr ""

#: xml/libpq.xml:4810(para)
msgid "Sends data to the server during <literal>COPY_IN</literal>state. <synopsis>int PQputCopyData(PGconn *conn, const char\n            *buffer, int nbytes);</synopsis>"
msgstr ""

#: xml/libpq.xml:4814(para)
msgid "Transmits the <command>COPY</command>data in the specified <parameter>buffer</parameter>, of length <parameter>nbytes</parameter>, to the server. The result is 1 if the data was queued, zero if it was not queued because of full buffers (this will only happen in nonblocking mode), or -1 if an error occurred. (Use <function>PQerrorMessage</function>to retrieve details if the return value is -1. If the value is zero, wait for write-ready and try again.)"
msgstr ""

#: xml/libpq.xml:4824(para)
msgid "The application can divide the <command>COPY</command>data stream into buffer loads of any convenient size. Buffer-load boundaries have no semantic significance when sending. The contents of the data stream must match the data format expected by the <command>COPY</command>command; see <xref linkend=\"sql-copy\">for details.</xref>"
msgstr ""

#: xml/libpq.xml:4835(function) xml/libpq.xml:4837(primary)
msgid "PQputCopyEnd"
msgstr ""

#: xml/libpq.xml:4841(para)
msgid "Sends end-of-data indication to the server during <literal>COPY_IN</literal>state. <synopsis>int PQputCopyEnd(PGconn *conn, const char\n            *errormsg);</synopsis>"
msgstr ""

#: xml/libpq.xml:4846(para)
msgid "Ends the <literal>COPY_IN</literal>operation successfully if <parameter>errormsg</parameter>is <symbol>NULL</symbol>. If <parameter>errormsg</parameter>is not <symbol>NULL</symbol>then the <command>COPY</command>is forced to fail, with the string pointed to by <parameter>errormsg</parameter>used as the error message. (One should not assume that this exact error message will come back from the server, however, as the server might have already failed the <command>COPY</command>for its own reasons. Also note that the option to force failure does not work when using pre-3.0-protocol connections.)"
msgstr ""

#: xml/libpq.xml:4861(para)
msgid "The result is 1 if the termination message was sent; or in nonblocking mode, this may only indicate that the termination message was successfully queued. (In nonblocking mode, to be certain that the data has been sent, you should next wait for write-ready and call <function>PQflush</function>, repeating until it returns zero.) Zero indicates that the function could not queue the termination message because of full buffers; this will only happen in nonblocking mode. (In this case, wait for write-ready and try the <function>PQputCopyEnd</function>call again.) If a hard error occurs, -1 is returned; you can use <function>PQerrorMessage</function>to retrieve details."
msgstr ""

#: xml/libpq.xml:4876(para)
msgid "After successfully calling <function>PQputCopyEnd</function>, call <function>PQgetResult</function>to obtain the final result status of the <command>COPY</command>command. One can wait for this result to be available in the usual way. Then return to normal operation."
msgstr ""

#: xml/libpq.xml:4888(title)
msgid "Functions for Receiving <command>COPY</command>Data"
msgstr ""

#: xml/libpq.xml:4890(para)
msgid "These functions are used to receive data during <literal>COPY TO STDOUT</literal>. They will fail if called when the connection is not in <literal>COPY_OUT</literal>state."
msgstr ""

#: xml/libpq.xml:4897(function) xml/libpq.xml:4899(primary)
msgid "PQgetCopyData"
msgstr ""

#: xml/libpq.xml:4903(para)
msgid "Receives data from the server during <literal>COPY_OUT</literal>state. <synopsis>int PQgetCopyData(PGconn *conn, char\n            **buffer, int async);</synopsis>"
msgstr ""

#: xml/libpq.xml:4907(para)
msgid "Attempts to obtain another row of data from the server during a <command>COPY</command>. Data is always returned one data row at a time; if only a partial row is available, it is not returned. Successful return of a data row involves allocating a chunk of memory to hold the data. The <parameter>buffer</parameter>parameter must be non- <symbol>NULL</symbol>. <parameter>*buffer</parameter>is set to point to the allocated memory, or to <symbol>NULL</symbol>in cases where no buffer is returned. A non- <symbol>NULL</symbol>result buffer should be freed using <function>PQfreemem</function>when no longer needed."
msgstr ""

#: xml/libpq.xml:4924(para)
msgid "When a row is successfully returned, the return value is the number of data bytes in the row (this will always be greater than zero). The returned string is always null-terminated, though this is probably only useful for textual <command>COPY</command>. A result of zero indicates that the <command>COPY</command>is still in progress, but no row is yet available (this is only possible when <parameter>async</parameter>is true). A result of -1 indicates that the <command>COPY</command>is done. A result of -2 indicates that an error occurred (consult <function>PQerrorMessage</function>for the reason)."
msgstr ""

#: xml/libpq.xml:4939(para)
msgid "When <parameter>async</parameter>is true (not zero), <function>PQgetCopyData</function>will not block waiting for input; it will return zero if the <command>COPY</command>is still in progress but no complete row is available. (In this case wait for read-ready and then call <function>PQconsumeInput</function>before calling <function>PQgetCopyData</function>again.) When <parameter>async</parameter>is false (zero), <function>PQgetCopyData</function>will block until data is available or the operation completes."
msgstr ""

#: xml/libpq.xml:4951(para)
msgid "After <function>PQgetCopyData</function>returns -1, call <function>PQgetResult</function>to obtain the final result status of the <command>COPY</command>command. One can wait for this result to be available in the usual way. Then return to normal operation."
msgstr ""

#: xml/libpq.xml:4963(title)
msgid "Obsolete Functions for <command>COPY</command>"
msgstr ""

#: xml/libpq.xml:4965(para)
msgid "These functions represent older methods of handling <command>COPY</command>. Although they still work, they are deprecated due to poor error handling, inconvenient methods of detecting end-of-data, and lack of support for binary or nonblocking transfers."
msgstr ""

#: xml/libpq.xml:4973(function) xml/libpq.xml:4975(primary)
msgid "PQgetline"
msgstr ""

#: xml/libpq.xml:4979(para)
msgid "Reads a newline-terminated line of characters (transmitted by the server) into a buffer string of size <parameter>length</parameter>. <synopsis>int PQgetline(PGconn *conn, char *buffer, int\n            length);</synopsis>"
msgstr ""

#: xml/libpq.xml:4985(para)
msgid "This function copies up to <parameter>length</parameter>-1 characters into the buffer and converts the terminating newline into a zero byte. <function>PQgetline</function>returns <symbol>EOF</symbol>at the end of input, 0 if the entire line has been read, and 1 if the buffer is full but the terminating newline has not yet been read."
msgstr ""

#: xml/libpq.xml:4994(para)
msgid "Note that the application must check to see if a new line consists of the two characters <literal>\\.</literal>, which indicates that the server has finished sending the results of the <command>COPY</command>command. If the application might receive lines that are more than <parameter>length</parameter>-1 characters long, care is needed to be sure it recognizes the <literal>\\.</literal>line correctly (and does not, for example, mistake the end of a long data line for a terminator line)."
msgstr ""

#: xml/libpq.xml:5009(function) xml/libpq.xml:5011(primary)
msgid "PQgetlineAsync"
msgstr ""

#: xml/libpq.xml:5015(para)
msgid "Reads a row of <command>COPY</command>data (transmitted by the server) into a buffer without blocking. <synopsis>int PQgetlineAsync(PGconn *conn, char\n            *buffer, int bufsize);</synopsis>"
msgstr ""

#: xml/libpq.xml:5020(para)
msgid "This function is similar to <function>PQgetline</function>, but it can be used by applications that must read <command>COPY</command>data asynchronously, that is, without blocking. Having issued the <command>COPY</command>command and gotten a <literal>PGRES_COPY_OUT</literal>response, the application should call <function>PQconsumeInput</function>and <function>PQgetlineAsync</function>until the end-of-data signal is detected."
msgstr ""

#: xml/libpq.xml:5031(para)
msgid "Unlike <function>PQgetline</function>, this function takes responsibility for detecting end-of-data."
msgstr ""

#: xml/libpq.xml:5034(para)
msgid "On each call, <function>PQgetlineAsync</function>will return data if a complete data row is available in <application>libpq</application>'s input buffer. Otherwise, no data is returned until the rest of the row arrives. The function returns -1 if the end-of-copy-data marker has been recognized, or 0 if no data is available, or a positive number giving the number of bytes of data returned. If -1 is returned, the caller must next call <function>PQendcopy</function>, and then return to normal processing."
msgstr ""

#: xml/libpq.xml:5046(para)
msgid "The data returned will not extend beyond a data-row boundary. If possible a whole row will be returned at one time. But if the buffer offered by the caller is too small to hold a row sent by the server, then a partial data row will be returned. With textual data this can be detected by testing whether the last returned byte is <literal>\\n</literal>or not. (In a binary <command>COPY</command>, actual parsing of the <command>COPY</command>data format will be needed to make the equivalent determination.) The returned string is not null-terminated. (If you want to add a terminating null, be sure to pass a <parameter>bufsize</parameter>one smaller than the room actually available.)"
msgstr ""

#: xml/libpq.xml:5065(function) xml/libpq.xml:5067(primary)
msgid "PQputline"
msgstr ""

#: xml/libpq.xml:5071(para)
msgid "Sends a null-terminated string to the server. Returns 0 if OK and <symbol>EOF</symbol>if unable to send the string. <synopsis>int PQputline(PGconn *conn, const char\n            *string);</synopsis>"
msgstr ""

#: xml/libpq.xml:5076(para)
msgid "The <command>COPY</command>data stream sent by a series of calls to <function>PQputline</function>has the same format as that returned by <function>PQgetlineAsync</function>, except that applications are not obliged to send exactly one data row per <function>PQputline</function>call; it is okay to send a partial line or multiple lines per call."
msgstr ""

#: xml/libpq.xml:5087(para)
msgid "Before <productname>PostgreSQL</productname>protocol 3.0, it was necessary for the application to explicitly send the two characters <literal>\\.</literal>as a final line to indicate to the server that it had finished sending <command>COPY</command>data. While this still works, it is deprecated and the special meaning of <literal>\\.</literal>can be expected to be removed in a future release. It is sufficient to call <function>PQendcopy</function>after having sent the actual data."
msgstr ""

#: xml/libpq.xml:5104(function) xml/libpq.xml:5106(primary)
msgid "PQputnbytes"
msgstr ""

#: xml/libpq.xml:5110(para)
msgid "Sends a non-null-terminated string to the server. Returns 0 if OK and <symbol>EOF</symbol>if unable to send the string. <synopsis>int PQputnbytes(PGconn *conn, const char\n            *buffer, int nbytes);</synopsis>"
msgstr ""

#: xml/libpq.xml:5115(para)
msgid "This is exactly like <function>PQputline</function>, except that the data buffer need not be null-terminated since the number of bytes to send is specified directly. Use this procedure when sending binary data."
msgstr ""

#: xml/libpq.xml:5124(function) xml/libpq.xml:5126(primary)
msgid "PQendcopy"
msgstr ""

#: xml/libpq.xml:5130(para)
msgid "Synchronizes with the server. <synopsis>int PQendcopy(PGconn *conn);</synopsis>This function waits until the server has finished the copying. It should either be issued when the last string has been sent to the server using <function>PQputline</function>or when the last string has been received from the server using <function>PGgetline</function>. It must be issued or the server will get <quote>out of sync</quote>with the client. Upon return from this function, the server is ready to receive the next SQL command. The return value is 0 on successful completion, nonzero otherwise. (Use <function>PQerrorMessage</function>to retrieve details if the return value is nonzero.)"
msgstr ""

#: xml/libpq.xml:5145(para)
msgid "When using <function>PQgetResult</function>, the application should respond to a <literal>PGRES_COPY_OUT</literal>result by executing <function>PQgetline</function>repeatedly, followed by <function>PQendcopy</function>after the terminator line is seen. It should then return to the <function>PQgetResult</function>loop until <function>PQgetResult</function>returns a null pointer. Similarly a <literal>PGRES_COPY_IN</literal>result is processed by a series of <function>PQputline</function>calls followed by <function>PQendcopy</function>, then return to the <function>PQgetResult</function>loop. This arrangement will ensure that a <command>COPY</command>command embedded in a series of <acronym>SQL</acronym>commands will be executed correctly."
msgstr ""

#: xml/libpq.xml:5164(para)
msgid "Older applications are likely to submit a <command>COPY</command>via <function>PQexec</function>and assume that the transaction is done after <function>PQendcopy</function>. This will work correctly only if the <command>COPY</command>is the only <acronym>SQL</acronym>command in the command string."
msgstr ""

#: xml/libpq.xml:5179(title)
msgid "Control Functions"
msgstr ""

#: xml/libpq.xml:5180(para)
msgid "These functions control miscellaneous details of <application>libpq</application>'s behavior."
msgstr ""

#: xml/libpq.xml:5185(function) xml/libpq.xml:5187(primary)
msgid "PQclientEncoding"
msgstr ""

#: xml/libpq.xml:5191(para)
msgid "Returns the client encoding. <synopsis>int PQclientEncoding(const PGconn * \n          <replaceable>conn</replaceable>);</synopsis>Note that it returns the encoding ID, not a symbolic string such as <literal>EUC_JP</literal>. If unsuccessful, it returns -1. To convert an encoding ID to an encoding name, you can use: <synopsis>char *pg_encoding_to_char(int \n          <replaceable>\n          encoding_id</replaceable>);</synopsis>"
msgstr ""

#: xml/libpq.xml:5205(function) xml/libpq.xml:5207(primary)
msgid "PQsetClientEncoding"
msgstr ""

#: xml/libpq.xml:5211(para)
msgid "Sets the client encoding. <synopsis>int PQsetClientEncoding(PGconn * \n          <replaceable>conn</replaceable>, const char * \n          <replaceable>encoding</replaceable>);</synopsis><replaceable>conn</replaceable>is a connection to the server, and <replaceable>encoding</replaceable>is the encoding you want to use. If the function successfully sets the encoding, it returns 0, otherwise -1. The current encoding for this connection can be determined by using <function>PQclientEncoding</function>."
msgstr ""

#: xml/libpq.xml:5226(function) xml/libpq.xml:5228(primary)
msgid "PQsetErrorVerbosity"
msgstr ""

#: xml/libpq.xml:5232(para)
msgid "Determines the verbosity of messages returned by <function>PQerrorMessage</function>and <function>PQresultErrorMessage</function>. <synopsis>typedef enum { PQERRORS_TERSE,\n          PQERRORS_DEFAULT, PQERRORS_VERBOSE } PGVerbosity;\n          PGVerbosity PQsetErrorVerbosity(PGconn *conn, PGVerbosity\n          verbosity);</synopsis><function>PQsetErrorVerbosity</function>sets the verbosity mode, returning the connection's previous setting. In <firstterm>TERSE</firstterm>mode, returned messages include severity, primary text, and position only; this will normally fit on a single line. The default mode produces messages that include the above plus any detail, hint, or context fields (these might span multiple lines). The <firstterm>VERBOSE</firstterm>mode includes all available fields. Changing the verbosity does not affect the messages available from already-existing <structname>PGresult</structname>objects, only subsequently-created ones."
msgstr ""

#: xml/libpq.xml:5257(function) xml/libpq.xml:5259(primary)
msgid "PQtrace"
msgstr ""

#: xml/libpq.xml:5263(para)
msgid "Enables tracing of the client/server communication to a debugging file stream. <synopsis>void PQtrace(PGconn *conn, FILE\n          *stream);</synopsis>"
msgstr ""

#: xml/libpq.xml:5268(para)
msgid "On Windows, if the <application>libpq</application>library and an application are compiled with different flags, this function call will crash the application because the internal representation of the <literal>FILE</literal>pointers differ. Specifically, multithreaded/single-threaded, release/debug, and static/dynamic flags should be the same for the library and all applications using that library."
msgstr ""

#: xml/libpq.xml:5282(function) xml/libpq.xml:5284(primary)
msgid "PQuntrace"
msgstr ""

#: xml/libpq.xml:5288(para)
msgid "Disables tracing started by <function>PQtrace</function>. <synopsis>void PQuntrace(PGconn *conn);</synopsis>"
msgstr ""

#: xml/libpq.xml:5296(title)
msgid "Miscellaneous Functions"
msgstr ""

#: xml/libpq.xml:5297(para)
msgid "As always, there are some functions that just don't fit anywhere."
msgstr ""

#: xml/libpq.xml:5302(function) xml/libpq.xml:5304(primary)
msgid "PQfreemem"
msgstr ""

#: xml/libpq.xml:5308(para)
msgid "Frees memory allocated by <application>libpq</application>. <synopsis>void PQfreemem(void *ptr);</synopsis>"
msgstr ""

#: xml/libpq.xml:5311(para)
msgid "Frees memory allocated by <application>libpq</application>, particularly <function>PQescapeByteaConn</function>, <function>PQescapeBytea</function>, <function>PQunescapeBytea</function>, and <function>PQnotifies</function>. It is particularly important that this function, rather than <function>free()</function>, be used on Microsoft Windows. This is because allocating memory in a DLL and releasing it in the application works only if multithreaded/single-threaded, release/debug, and static/dynamic flags are the same for the DLL and the application. On non-Microsoft Windows platforms, this function is the same as the standard library function <function>free()</function>."
msgstr ""

#: xml/libpq.xml:5330(function) xml/libpq.xml:5332(primary)
msgid "PQconninfoFree"
msgstr ""

#: xml/libpq.xml:5336(para)
msgid "Frees the data structures allocated by <function>PQconndefaults</function>or <function>PQconninfoParse</function>. <synopsis>void PQconninfoFree(PQconninfoOption\n          *connOptions);</synopsis>"
msgstr ""

#: xml/libpq.xml:5341(para)
msgid "A simple <function>PQfreemem</function>will not do for this, since the array contains references to subsidiary strings."
msgstr ""

#: xml/libpq.xml:5349(function) xml/libpq.xml:5351(primary)
msgid "PQencryptPassword"
msgstr ""

#: xml/libpq.xml:5355(para)
msgid "Prepares the encrypted form of a <productname>PostgreSQL</productname>password. <synopsis>char * PQencryptPassword(const char *passwd,\n          const char *user);</synopsis>This function is intended to be used by client applications that wish to send commands like <literal>ALTER USER joe PASSWORD 'pwd'</literal>. It is good practice not to send the original cleartext password in such a command, because it might be exposed in command logs, activity displays, and so on. Instead, use this function to convert the password to encrypted form before it is sent. The arguments are the cleartext password, and the SQL name of the user it is for. The return value is a string allocated by <function>malloc</function>, or <symbol>NULL</symbol>if out of memory. The caller can assume the string doesn't contain any special characters that would require escaping. Use <function>PQfreemem</function>to free the result when done with it."
msgstr ""

#: xml/libpq.xml:5379(function) xml/libpq.xml:5381(primary)
msgid "PQmakeEmptyPGresult"
msgstr ""

#: xml/libpq.xml:5385(para)
msgid "Constructs an empty <structname>PGresult</structname>object with the given status. <synopsis>PGresult *PQmakeEmptyPGresult(PGconn *conn,\n          ExecStatusType status);</synopsis>"
msgstr ""

#: xml/libpq.xml:5390(para)
msgid "This is <application>libpq</application>'s internal function to allocate and initialize an empty <structname>PGresult</structname>object. This function returns <symbol>NULL</symbol>if memory could not be allocated. It is exported because some applications find it useful to generate result objects (particularly objects with error status) themselves. If <parameter>conn</parameter>is not null and <parameter>status</parameter>indicates an error, the current error message of the specified connection is copied into the <structname>PGresult</structname>. Also, if <parameter>conn</parameter>is not null, any event procedures registered in the connection are copied into the <structname>PGresult</structname>. (They do not get <literal>PGEVT_RESULTCREATE</literal>calls, but see <function>PQfireResultCreateEvents</function>.) Note that <function>PQclear</function>should eventually be called on the object, just as with a <structname>PGresult</structname>returned by <application>libpq</application>itself."
msgstr ""

#: xml/libpq.xml:5419(function) xml/libpq.xml:5421(primary)
msgid "PQfireResultCreateEvents"
msgstr ""

#: xml/libpq.xml:5425(para)
msgid "Fires a <literal>PGEVT_RESULTCREATE</literal>event (see <xref linkend=\"libpq-events\">) for each event procedure registered in the <structname>PGresult</structname>object. Returns non-zero for success, zero if any event procedure fails. <synopsis>int PQfireResultCreateEvents(PGconn *conn,\n          PGresult *res);</synopsis></xref>"
msgstr ""

#: xml/libpq.xml:5433(para)
msgid "The <literal>conn</literal>argument is passed through to event procedures but not used directly. It can be <symbol>NULL</symbol>if the event procedures won't use it."
msgstr ""

#: xml/libpq.xml:5438(para)
msgid "Event procedures that have already received a <literal>PGEVT_RESULTCREATE</literal>or <literal>PGEVT_RESULTCOPY</literal>event for this object are not fired again."
msgstr ""

#: xml/libpq.xml:5442(para)
msgid "The main reason that this function is separate from <function>PQmakeEmptyPGresult</function>is that it is often appropriate to create a <structname>PGresult</structname>and fill it with data before invoking the event procedures."
msgstr ""

#: xml/libpq.xml:5452(function) xml/libpq.xml:5454(primary)
msgid "PQcopyResult"
msgstr ""

#: xml/libpq.xml:5458(para)
msgid "Makes a copy of a <structname>PGresult</structname>object. The copy is not linked to the source result in any way and <function>PQclear</function>must be called when the copy is no longer needed. If the function fails, <symbol>NULL</symbol>is returned. <synopsis>PGresult *PQcopyResult(const PGresult *src, int\n          flags);</synopsis>"
msgstr ""

#: xml/libpq.xml:5466(para)
msgid "This is not intended to make an exact copy. The returned result is always put into <literal>PGRES_TUPLES_OK</literal>status, and does not copy any error message in the source. (It does copy the command status string, however.) The <parameter>flags</parameter>argument determines what else is copied. It is a bitwise OR of several flags. <literal>PG_COPYRES_ATTRS</literal>specifies copying the source result's attributes (column definitions). <literal>PG_COPYRES_TUPLES</literal>specifies copying the source result's tuples. (This implies copying the attributes, too.) <literal>PG_COPYRES_NOTICEHOOKS</literal>specifies copying the source result's notify hooks. <literal>PG_COPYRES_EVENTS</literal>specifies copying the source result's events. (But any instance data associated with the source is not copied.)"
msgstr ""

#: xml/libpq.xml:5487(function) xml/libpq.xml:5489(primary)
msgid "PQsetResultAttrs"
msgstr ""

#: xml/libpq.xml:5493(para)
msgid "Sets the attributes of a <structname>PGresult</structname>object. <synopsis>int PQsetResultAttrs(PGresult *res, int\n          numAttributes, PGresAttDesc *attDescs);</synopsis>"
msgstr ""

#: xml/libpq.xml:5497(para)
msgid "The provided <parameter>attDescs</parameter>are copied into the result. If the <parameter>attDescs</parameter>pointer is <symbol>NULL</symbol>or <parameter>numAttributes</parameter>is less than one, the request is ignored and the function succeeds. If <parameter>res</parameter>already contains attributes, the function will fail. If the function fails, the return value is zero. If the function succeeds, the return value is non-zero."
msgstr ""

#: xml/libpq.xml:5512(function) xml/libpq.xml:5514(primary)
msgid "PQsetvalue"
msgstr ""

#: xml/libpq.xml:5518(para)
msgid "Sets a tuple field value of a <structname>PGresult</structname>object. <synopsis>int PQsetvalue(PGresult *res, int tup_num, int\n          field_num, char *value, int len);</synopsis>"
msgstr ""

#: xml/libpq.xml:5522(para)
msgid "The function will automatically grow the result's internal tuples array as needed. However, the <parameter>tup_num</parameter>argument must be less than or equal to <function>PQntuples</function>, meaning this function can only grow the tuples array one tuple at a time. But any field of any existing tuple can be modified in any order. If a value at <parameter>field_num</parameter>already exists, it will be overwritten. If <parameter>len</parameter>is -1 or <parameter>value</parameter>is <symbol>NULL</symbol>, the field value will be set to an SQL null value. The <parameter>value</parameter>is copied into the result's private storage, thus is no longer needed after the function returns. If the function fails, the return value is zero. If the function succeeds, the return value is non-zero."
msgstr ""

#: xml/libpq.xml:5545(function) xml/libpq.xml:5547(primary)
msgid "PQresultAlloc"
msgstr ""

#: xml/libpq.xml:5551(para)
msgid "Allocate subsidiary storage for a <structname>PGresult</structname>object. <synopsis>void *PQresultAlloc(PGresult *res, size_t\n          nBytes);</synopsis>"
msgstr ""

#: xml/libpq.xml:5555(para)
msgid "Any memory allocated with this function will be freed when <parameter>res</parameter>is cleared. If the function fails, the return value is <symbol>NULL</symbol>. The result is guaranteed to be adequately aligned for any type of data, just as for <function>malloc</function>."
msgstr ""

#: xml/libpq.xml:5566(function) xml/libpq.xml:5568(primary)
msgid "PQlibVersion"
msgstr ""

#: xml/libpq.xml:5573(para)
msgid "Return the version of <productname>libpq</productname>that is being used. <synopsis>int PQlibVersion(void);</synopsis>"
msgstr ""

#: xml/libpq.xml:5576(para)
msgid "The result of this function can be used to determine, at run time, if specific functionality is available in the currently loaded version of libpq. The function can be used, for example, to determine which connection options are available for <function>PQconnectdb</function>or if the <literal>hex</literal><type>bytea</type>output added in PostgreSQL 9.0 is supported."
msgstr ""

#: xml/libpq.xml:5585(para)
msgid "The number is formed by converting the major, minor, and revision numbers into two-decimal-digit numbers and appending them together. For example, version 9.1 will be returned as 90100, and version 9.1.2 will be returned as 90102 (leading zeroes are not shown)."
msgstr ""

#: xml/libpq.xml:5591(para)
msgid "This function appeared in <productname>PostgreSQL</productname>version 9.1, so it cannot be used to detect required functionality in earlier versions, since linking to it will create a link dependency on version 9.1."
msgstr ""

#: xml/libpq.xml:5602(title)
msgid "Notice Processing"
msgstr ""

#: xml/libpq.xml:5604(primary)
msgid "notice processing"
msgstr ""

#: xml/libpq.xml:5607(para)
msgid "Notice and warning messages generated by the server are not returned by the query execution functions, since they do not imply failure of the query. Instead they are passed to a notice handling function, and execution continues normally after the handler returns. The default notice handling function prints the message on <filename>stderr</filename>, but the application can override this behavior by supplying its own handling function."
msgstr ""

#: xml/libpq.xml:5615(para)
msgid "For historical reasons, there are two levels of notice handling, called the notice receiver and notice processor. The default behavior is for the notice receiver to format the notice and pass a string to the notice processor for printing. However, an application that chooses to provide its own notice receiver will typically ignore the notice processor layer and just do all the work in the notice receiver."
msgstr ""

#: xml/libpq.xml:5622(para)
msgid "The function <function>PQsetNoticeReceiver</function><indexterm><primary>notice receiver</primary></indexterm><indexterm><primary>PQsetNoticeReceiver</primary></indexterm>sets or examines the current notice receiver for a connection object. Similarly, <function>PQsetNoticeProcessor</function><indexterm><primary>notice processor</primary></indexterm><indexterm><primary>PQsetNoticeProcessor</primary></indexterm>sets or examines the current notice processor. <synopsis>typedef void (*PQnoticeReceiver) (void *arg, const\n    PGresult *res); PQnoticeReceiver PQsetNoticeReceiver(PGconn\n    *conn, PQnoticeReceiver proc, void *arg); typedef void\n    (*PQnoticeProcessor) (void *arg, const char *message);\n    PQnoticeProcessor PQsetNoticeProcessor(PGconn *conn,\n    PQnoticeProcessor proc, void *arg);</synopsis>Each of these functions returns the previous notice receiver or processor function pointer, and sets the new value. If you supply a null function pointer, no action is taken, but the current pointer is returned."
msgstr ""

#: xml/libpq.xml:5648(para)
msgid "When a notice or warning message is received from the server, or generated internally by <application>libpq</application>, the notice receiver function is called. It is passed the message in the form of a <symbol>PGRES_NONFATAL_ERROR</symbol><structname>PGresult</structname>. (This allows the receiver to extract individual fields using <function>PQresultErrorField</function>, or the complete preformatted message using <function>PQresultErrorMessage</function>.) The same void pointer passed to <function>PQsetNoticeReceiver</function>is also passed. (This pointer can be used to access application-specific state if needed.)"
msgstr ""

#: xml/libpq.xml:5662(para)
msgid "The default notice receiver simply extracts the message (using <function>PQresultErrorMessage</function>) and passes it to the notice processor."
msgstr ""

#: xml/libpq.xml:5666(para)
msgid "The notice processor is responsible for handling a notice or warning message given in text form. It is passed the string text of the message (including a trailing newline), plus a void pointer that is the same one passed to <function>PQsetNoticeProcessor</function>. (This pointer can be used to access application-specific state if needed.)"
msgstr ""

#: xml/libpq.xml:5673(programlisting)
#, no-wrap
msgid "static void defaultNoticeProcessor(void *arg,\n    const char *message) { fprintf(stderr, \"%s\", message);\n    }"
msgstr ""

#: xml/libpq.xml:5672(para)
msgid "The default notice processor is simply: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:5676(para)
msgid "Once you have set a notice receiver or processor, you should expect that that function could be called as long as either the <structname>PGconn</structname>object or <structname>PGresult</structname>objects made from it exist. At creation of a <structname>PGresult</structname>, the <structname>PGconn</structname>'s current notice handling pointers are copied into the <structname>PGresult</structname>for possible use by functions like <function>PQgetvalue</function>."
msgstr ""

#: xml/libpq.xml:5690(title)
msgid "Event System"
msgstr ""

#: xml/libpq.xml:5691(para)
msgid "<application>libpq</application>'s event system is designed to notify registered event handlers about interesting <application>libpq</application>events, such as the creation or destruction of <structname>PGconn</structname>and <structname>PGresult</structname>objects. A principal use case is that this allows applications to associate their own data with a <structname>PGconn</structname>or <structname>PGresult</structname>and ensure that that data is freed at an appropriate time."
msgstr ""

#: xml/libpq.xml:5703(para)
msgid "Each registered event handler is associated with two pieces of data, known to <application>libpq</application>only as opaque <literal>void *</literal>pointers. There is a <firstterm>passthrough</firstterm>pointer that is provided by the application when the event handler is registered with a <structname>PGconn</structname>. The passthrough pointer never changes for the life of the <structname>PGconn</structname>and all <structname>PGresult</structname>s generated from it; so if used, it must point to long-lived data. In addition there is an <firstterm>instance data</firstterm>pointer, which starts out <symbol>NULL</symbol>in every <structname>PGconn</structname>and <structname>PGresult</structname>. This pointer can be manipulated using the <function>PQinstanceData</function>, <function>PQsetInstanceData</function>, <function>PQresultInstanceData</function>and <function>PQsetResultInstanceData</function>functions. Note that unlike the passthrough pointer, instance data of a <structname>PGconn</structname>is not automatically inherited by <structname>PGresult</structname>s created from it. <application>libpq</application>does not know what passthrough and instance data pointers point to (if anything) and will never attempt to free them that is the responsibility of the event handler."
msgstr ""

#: xml/libpq.xml:5733(title)
msgid "Event Types"
msgstr ""

#: xml/libpq.xml:5734(para)
msgid "The enum <literal>PGEventId</literal>names the types of events handled by the event system. All its values have names beginning with <literal>PGEVT</literal>. For each event type, there is a corresponding event info structure that carries the parameters passed to the event handlers. The event types are:"
msgstr ""

#: xml/libpq.xml:5745(literal)
msgid "PGEVT_REGISTER"
msgstr ""

#: xml/libpq.xml:5748(para)
msgid "The register event occurs when <function>PQregisterEventProc</function>is called. It is the ideal time to initialize any <literal>instanceData</literal>an event procedure may need. Only one register event will be fired per event handler per connection. If the event procedure fails, the registration is aborted. <synopsis>typedef struct { PGconn *conn; }\n            PGEventRegister;</synopsis>When a <literal>PGEVT_REGISTER</literal>event is received, the <parameter>evtInfo</parameter>pointer should be cast to a <structname>PGEventRegister *</structname>. This structure contains a <structname>PGconn</structname>that should be in the <literal>CONNECTION_OK</literal>status; guaranteed if one calls <function>PQregisterEventProc</function>right after obtaining a good <structname>PGconn</structname>. When returning a failure code, all cleanup must be performed as no <literal>PGEVT_CONNDESTROY</literal>event will be sent."
msgstr ""

#: xml/libpq.xml:5776(literal)
msgid "PGEVT_CONNRESET"
msgstr ""

#: xml/libpq.xml:5779(para)
msgid "The connection reset event is fired on completion of <function>PQreset</function>or <function>PQresetPoll</function>. In both cases, the event is only fired if the reset was successful. If the event procedure fails, the entire connection reset will fail; the <structname>PGconn</structname>is put into <literal>CONNECTION_BAD</literal>status and <function>PQresetPoll</function>will return <literal>PGRES_POLLING_FAILED</literal>. <synopsis>typedef struct { PGconn *conn; }\n            PGEventConnReset;</synopsis>When a <literal>PGEVT_CONNRESET</literal>event is received, the <parameter>evtInfo</parameter>pointer should be cast to a <structname>PGEventConnReset *</structname>. Although the contained <structname>PGconn</structname>was just reset, all event data remains unchanged. This event should be used to reset/reload/requery any associated <literal>instanceData</literal>. Note that even if the event procedure fails to process <literal>PGEVT_CONNRESET</literal>, it will still receive a <literal>PGEVT_CONNDESTROY</literal>event when the connection is closed."
msgstr ""

#: xml/libpq.xml:5811(literal)
msgid "PGEVT_CONNDESTROY"
msgstr ""

#: xml/libpq.xml:5814(para)
msgid "The connection destroy event is fired in response to <function>PQfinish</function>. It is the event procedure's responsibility to properly clean up its event data as libpq has no ability to manage this memory. Failure to clean up will lead to memory leaks. <synopsis>typedef struct { PGconn *conn; }\n            PGEventConnDestroy;</synopsis>When a <literal>PGEVT_CONNDESTROY</literal>event is received, the <parameter>evtInfo</parameter>pointer should be cast to a <structname>PGEventConnDestroy *</structname>. This event is fired prior to <function>PQfinish</function>performing any other cleanup. The return value of the event procedure is ignored since there is no way of indicating a failure from <function>PQfinish</function>. Also, an event procedure failure should not abort the process of cleaning up unwanted memory."
msgstr ""

#: xml/libpq.xml:5839(literal)
msgid "PGEVT_RESULTCREATE"
msgstr ""

#: xml/libpq.xml:5842(para)
msgid "The result creation event is fired in response to any query execution function that generates a result, including <function>PQgetResult</function>. This event will only be fired after the result has been created successfully. <synopsis>typedef struct { PGconn *conn; PGresult\n            *result; } PGEventResultCreate;</synopsis>When a <literal>PGEVT_RESULTCREATE</literal>event is received, the <parameter>evtInfo</parameter>pointer should be cast to a <structname>PGEventResultCreate *</structname>. The <parameter>conn</parameter>is the connection used to generate the result. This is the ideal place to initialize any <literal>instanceData</literal>that needs to be associated with the result. If the event procedure fails, the result will be cleared and the failure will be propagated. The event procedure must not try to <function>PQclear</function>the result object for itself. When returning a failure code, all cleanup must be performed as no <literal>PGEVT_RESULTDESTROY</literal>event will be sent."
msgstr ""

#: xml/libpq.xml:5871(literal)
msgid "PGEVT_RESULTCOPY"
msgstr ""

#: xml/libpq.xml:5874(para)
msgid "The result copy event is fired in response to <function>PQcopyResult</function>. This event will only be fired after the copy is complete. Only event procedures that have successfully handled the <literal>PGEVT_RESULTCREATE</literal>or <literal>PGEVT_RESULTCOPY</literal>event for the source result will receive <literal>PGEVT_RESULTCOPY</literal>events. <synopsis>typedef struct { const PGresult *src;\n            PGresult *dest; } PGEventResultCopy;</synopsis>When a <literal>PGEVT_RESULTCOPY</literal>event is received, the <parameter>evtInfo</parameter>pointer should be cast to a <structname>PGEventResultCopy *</structname>. The <parameter>src</parameter>result is what was copied while the <parameter>dest</parameter>result is the copy destination. This event can be used to provide a deep copy of <literal>instanceData</literal>, since <literal>PQcopyResult</literal>cannot do that. If the event procedure fails, the entire copy operation will fail and the <parameter>dest</parameter>result will be cleared. When returning a failure code, all cleanup must be performed as no <literal>PGEVT_RESULTDESTROY</literal>event will be sent for the destination result."
msgstr ""

#: xml/libpq.xml:5907(literal)
msgid "PGEVT_RESULTDESTROY"
msgstr ""

#: xml/libpq.xml:5910(para)
msgid "The result destroy event is fired in response to a <function>PQclear</function>. It is the event procedure's responsibility to properly clean up its event data as libpq has no ability to manage this memory. Failure to clean up will lead to memory leaks. <synopsis>typedef struct { PGresult *result; }\n            PGEventResultDestroy;</synopsis>When a <literal>PGEVT_RESULTDESTROY</literal>event is received, the <parameter>evtInfo</parameter>pointer should be cast to a <structname>PGEventResultDestroy *</structname>. This event is fired prior to <function>PQclear</function>performing any other cleanup. The return value of the event procedure is ignored since there is no way of indicating a failure from <function>PQclear</function>. Also, an event procedure failure should not abort the process of cleaning up unwanted memory."
msgstr ""

#: xml/libpq.xml:5936(title)
msgid "Event Callback Procedure"
msgstr ""

#: xml/libpq.xml:5940(literal) xml/libpq.xml:5942(primary)
msgid "PGEventProc"
msgstr ""

#: xml/libpq.xml:5946(para)
msgid "<literal>PGEventProc</literal>is a typedef for a pointer to an event procedure, that is, the user callback function that receives events from libpq. The signature of an event procedure must be <synopsis>int eventproc(PGEventId evtId, void *evtInfo,\n            void *passThrough)</synopsis>The <parameter>evtId</parameter>parameter indicates which <literal>PGEVT</literal>event occurred. The <parameter>evtInfo</parameter>pointer must be cast to the appropriate structure type to obtain further information about the event. The <parameter>passThrough</parameter>parameter is the pointer provided to <function>PQregisterEventProc</function>when the event procedure was registered. The function should return a non-zero value if it succeeds and zero if it fails."
msgstr ""

#: xml/libpq.xml:5964(para)
msgid "A particular event procedure can be registered only once in any <structname>PGconn</structname>. This is because the address of the procedure is used as a lookup key to identify the associated instance data."
msgstr ""

#: xml/libpq.xml:5970(para)
msgid "On Windows, functions can have two different addresses: one visible from outside a DLL and another visible from inside the DLL. One should be careful that only one of these addresses is used with <application>libpq</application>'s event-procedure functions, else confusion will result. The simplest rule for writing code that will work is to ensure that event procedures are declared <literal>static</literal>. If the procedure's address must be available outside its own source file, expose a separate function to return the address."
msgstr ""

#: xml/libpq.xml:5987(title)
msgid "Event Support Functions"
msgstr ""

#: xml/libpq.xml:5991(function) xml/libpq.xml:5993(primary)
msgid "PQregisterEventProc"
msgstr ""

#: xml/libpq.xml:5997(para)
msgid "Registers an event callback procedure with libpq. <synopsis>int PQregisterEventProc(PGconn *conn,\n            PGEventProc proc, const char *name, void\n            *passThrough);</synopsis>"
msgstr ""

#: xml/libpq.xml:6002(para)
msgid "An event procedure must be registered once on each <structname>PGconn</structname>you want to receive events about. There is no limit, other than memory, on the number of event procedures that can be registered with a connection. The function returns a non-zero value if it succeeds and zero if it fails."
msgstr ""

#: xml/libpq.xml:6009(para)
msgid "The <parameter>proc</parameter>argument will be called when a libpq event is fired. Its memory address is also used to lookup <literal>instanceData</literal>. The <parameter>name</parameter>argument is used to refer to the event procedure in error messages. This value cannot be <symbol>NULL</symbol>or a zero-length string. The name string is copied into the <structname>PGconn</structname>, so what is passed need not be long-lived. The <parameter>passThrough</parameter>pointer is passed to the <parameter>proc</parameter>whenever an event occurs. This argument can be <symbol>NULL</symbol>."
msgstr ""

#: xml/libpq.xml:6030(function) xml/libpq.xml:6032(primary)
msgid "PQsetInstanceData"
msgstr ""

#: xml/libpq.xml:6036(para)
msgid "Sets the connection <parameter>conn</parameter>'s <literal>instanceData</literal>for procedure <parameter>proc</parameter>to <parameter>data</parameter>. This returns non-zero for success and zero for failure. (Failure is only possible if <parameter>proc</parameter>has not been properly registered in <parameter>conn</parameter>.) <synopsis>int PQsetInstanceData(PGconn *conn,\n            PGEventProc proc, void *data);</synopsis>"
msgstr ""

#: xml/libpq.xml:6052(function) xml/libpq.xml:6054(primary)
msgid "PQinstanceData"
msgstr ""

#: xml/libpq.xml:6058(para)
msgid "Returns the connection <parameter>conn</parameter>'s <literal>instanceData</literal>associated with procedure <parameter>proc</parameter>, or <symbol>NULL</symbol>if there is none. <synopsis>void *PQinstanceData(const PGconn *conn,\n            PGEventProc proc);</synopsis>"
msgstr ""

#: xml/libpq.xml:6070(function) xml/libpq.xml:6072(primary)
msgid "PQresultSetInstanceData"
msgstr ""

#: xml/libpq.xml:6076(para)
msgid "Sets the result's <literal>instanceData</literal>for <parameter>proc</parameter>to <parameter>data</parameter>. This returns non-zero for success and zero for failure. (Failure is only possible if <parameter>proc</parameter>has not been properly registered in the result.) <synopsis>int PQresultSetInstanceData(PGresult *res,\n            PGEventProc proc, void *data);</synopsis>"
msgstr ""

#: xml/libpq.xml:6090(function) xml/libpq.xml:6092(primary)
msgid "PQresultInstanceData"
msgstr ""

#: xml/libpq.xml:6096(para)
msgid "Returns the result's <literal>instanceData</literal>associated with <parameter>proc</parameter>, or <symbol>NULL</symbol>if there is none. <synopsis>void *PQresultInstanceData(const PGresult\n            *res, PGEventProc proc);</synopsis>"
msgstr ""

#: xml/libpq.xml:6107(title)
msgid "Event Example"
msgstr ""

#: xml/libpq.xml:6108(para)
msgid "Here is a skeleton example of managing private data associated with libpq connections and results."
msgstr ""

#: xml/libpq.xml:6110(programlisting)
#, no-wrap
msgid "/* required header for libpq events (note:\n      includes libpq-fe.h) */ #include &lt;libpq-events.h&gt; /*\n      The instanceData */ typedef struct { int n; char *str; }\n      mydata; /* PGEventProc */ static int myEventProc(PGEventId\n      evtId, void *evtInfo, void *passThrough); int main(void) {\n      mydata *data; PGresult *res; PGconn *conn =\n      PQconnectdb(\"dbname = postgres\"); if (PQstatus(conn) !=\n      CONNECTION_OK) { fprintf(stderr, \"Connection to database\n      failed: %s\", PQerrorMessage(conn)); PQfinish(conn); return 1;\n      } /* called once on any connection that should receive\n      events. * Sends a PGEVT_REGISTER to myEventProc. */ if\n      (!PQregisterEventProc(conn, myEventProc, \"mydata_proc\",\n      NULL)) { fprintf(stderr, \"Cannot register PGEventProc\\n\");\n      PQfinish(conn); return 1; } /* conn instanceData is available\n      */ data = PQinstanceData(conn, myEventProc); /* Sends a\n      PGEVT_RESULTCREATE to myEventProc */ res = PQexec(conn,\n      \"SELECT 1 + 1\"); /* result instanceData is available */ data\n      = PQresultInstanceData(res, myEventProc); /* If\n      PG_COPYRES_EVENTS is used, sends a PGEVT_RESULTCOPY to\n      myEventProc */ res_copy = PQcopyResult(res, PG_COPYRES_TUPLES\n      | PG_COPYRES_EVENTS); /* result instanceData is available if\n      PG_COPYRES_EVENTS was * used during the PQcopyResult call. */\n      data = PQresultInstanceData(res_copy, myEventProc); /* Both\n      clears send a PGEVT_RESULTDESTROY to myEventProc */\n      PQclear(res); PQclear(res_copy); /* Sends a PGEVT_CONNDESTROY\n      to myEventProc */ PQfinish(conn); return 0; } static int\n      myEventProc(PGEventId evtId, void *evtInfo, void\n      *passThrough) { switch (evtId) { case PGEVT_REGISTER: {\n      PGEventRegister *e = (PGEventRegister *)evtInfo; mydata *data\n      = get_mydata(e-&gt;conn); /* associate app specific data with\n      connection */ PQsetInstanceData(e-&gt;conn, myEventProc,\n      data); break; } case PGEVT_CONNRESET: { PGEventConnReset *e =\n      (PGEventConnReset *)evtInfo; mydata *data =\n      PQinstanceData(e-&gt;conn, myEventProc); if (data)\n      memset(data, 0, sizeof(mydata)); break; } case\n      PGEVT_CONNDESTROY: { PGEventConnDestroy *e =\n      (PGEventConnDestroy *)evtInfo; mydata *data =\n      PQinstanceData(e-&gt;conn, myEventProc); /* free instance\n      data because the conn is being destroyed */ if (data)\n      free_mydata(data); break; } case PGEVT_RESULTCREATE: {\n      PGEventResultCreate *e = (PGEventResultCreate *)evtInfo;\n      mydata *conn_data = PQinstanceData(e-&gt;conn, myEventProc);\n      mydata *res_data = dup_mydata(conn_data); /* associate app\n      specific data with result (copy it from conn) */\n      PQsetResultInstanceData(e-&gt;result, myEventProc, res_data);\n      break; } case PGEVT_RESULTCOPY: { PGEventResultCopy *e =\n      (PGEventResultCopy *)evtInfo; mydata *src_data =\n      PQresultInstanceData(e-&gt;src, myEventProc); mydata\n      *dest_data = dup_mydata(src_data); /* associate app specific\n      data with result (copy it from a result) */\n      PQsetResultInstanceData(e-&gt;dest, myEventProc, dest_data);\n      break; } case PGEVT_RESULTDESTROY: { PGEventResultDestroy *e\n      = (PGEventResultDestroy *)evtInfo; mydata *data =\n      PQresultInstanceData(e-&gt;result, myEventProc); /* free\n      instance data because the result is being destroyed */ if\n      (data) free_mydata(data); break; } /* unknown event ID, just\n      return TRUE. */ default: break; } return TRUE; /* event\n      processing succeeded */ }"
msgstr ""

#: xml/libpq.xml:6171(title)
msgid "Environment Variables"
msgstr ""

#: xml/libpq.xml:6173(primary)
msgid "environment variable"
msgstr ""

#: xml/libpq.xml:6185(para)
msgid "<indexterm><primary><envar>PGHOST</envar></primary></indexterm><envar>PGHOST</envar>behaves the same as the <xref linkend=\"libpq-connect-host\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6196(para)
msgid "<indexterm><primary><envar>PGHOSTADDR</envar></primary></indexterm><envar>PGHOSTADDR</envar>behaves the same as the <xref linkend=\"libpq-connect-hostaddr\">connection parameter. This can be set instead of or in addition to <envar>PGHOST</envar>to avoid DNS lookup overhead.</xref>"
msgstr ""

#: xml/libpq.xml:6209(para)
msgid "<indexterm><primary><envar>PGPORT</envar></primary></indexterm><envar>PGPORT</envar>behaves the same as the <xref linkend=\"libpq-connect-port\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6220(para)
msgid "<indexterm><primary><envar>PGDATABASE</envar></primary></indexterm><envar>PGDATABASE</envar>behaves the same as the <xref linkend=\"libpq-connect-dbname\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6231(para)
msgid "<indexterm><primary><envar>PGUSER</envar></primary></indexterm><envar>PGUSER</envar>behaves the same as the <xref linkend=\"libpq-connect-user\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6242(para)
msgid "<indexterm><primary><envar>PGPASSWORD</envar></primary></indexterm><envar>PGPASSWORD</envar>behaves the same as the <xref linkend=\"libpq-connect-password\">connection parameter. Use of this environment variable is not recommended for security reasons, as some operating systems allow non-root users to see process environment variables via <application>ps</application>; instead consider using the <filename>~/.pgpass</filename>file (see <xref linkend=\"libpq-pgpass\">).</xref></xref>"
msgstr ""

#: xml/libpq.xml:6259(para)
msgid "<indexterm><primary><envar>PGPASSFILE</envar></primary></indexterm><envar>PGPASSFILE</envar>specifies the name of the password file to use for lookups. If not set, it defaults to <filename>~/.pgpass</filename>(see <xref linkend=\"libpq-pgpass\">).</xref>"
msgstr ""

#: xml/libpq.xml:6271(para)
msgid "<indexterm><primary><envar>PGSERVICE</envar></primary></indexterm><envar>PGSERVICE</envar>behaves the same as the <xref linkend=\"libpq-connect-service\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6282(para)
msgid "<indexterm><primary><envar>PGSERVICEFILE</envar></primary></indexterm><envar>PGSERVICEFILE</envar>specifies the name of the per-user connection service file. If not set, it defaults to <filename>~/.pg_service.conf</filename>(see <xref linkend=\"libpq-pgservice\">).</xref>"
msgstr ""

#: xml/libpq.xml:6295(para)
msgid "<indexterm><primary><envar>PGREALM</envar></primary></indexterm><envar>PGREALM</envar>sets the Kerberos realm to use with <productname>PostgreSQL</productname>, if it is different from the local realm. If <envar>PGREALM</envar>is set, <application>libpq</application>applications will attempt authentication with servers for this realm and use separate ticket files to avoid conflicts with local ticket files. This environment variable is only used if GSSAPI authentication is selected by the server."
msgstr ""

#: xml/libpq.xml:6312(para)
msgid "<indexterm><primary><envar>PGOPTIONS</envar></primary></indexterm><envar>PGOPTIONS</envar>behaves the same as the <xref linkend=\"libpq-connect-options\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6323(para)
msgid "<indexterm><primary><envar>PGAPPNAME</envar></primary></indexterm><envar>PGAPPNAME</envar>behaves the same as the <xref linkend=\"libpq-connect-application-name\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6334(para)
msgid "<indexterm><primary><envar>PGSSLMODE</envar></primary></indexterm><envar>PGSSLMODE</envar>behaves the same as the <xref linkend=\"libpq-connect-sslmode\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6345(para)
msgid "<indexterm><primary><envar>PGREQUIRESSL</envar></primary></indexterm><envar>PGREQUIRESSL</envar>behaves the same as the <xref linkend=\"libpq-connect-requiressl\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6356(para)
msgid "<indexterm><primary><envar>PGSSLCOMPRESSION</envar></primary></indexterm><envar>PGSSLCOMPRESSION</envar>behaves the same as the <xref linkend=\"libpq-connect-sslcompression\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6367(para)
msgid "<indexterm><primary><envar>PGSSLCERT</envar></primary></indexterm><envar>PGSSLCERT</envar>behaves the same as the <xref linkend=\"libpq-connect-sslcert\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6378(para)
msgid "<indexterm><primary><envar>PGSSLKEY</envar></primary></indexterm><envar>PGSSLKEY</envar>behaves the same as the <xref linkend=\"libpq-connect-sslkey\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6389(para)
msgid "<indexterm><primary><envar>PGSSLROOTCERT</envar></primary></indexterm><envar>PGSSLROOTCERT</envar>behaves the same as the <xref linkend=\"libpq-connect-sslrootcert\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6400(para)
msgid "<indexterm><primary><envar>PGSSLCRL</envar></primary></indexterm><envar>PGSSLCRL</envar>behaves the same as the <xref linkend=\"libpq-connect-sslcrl\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6411(para)
msgid "<indexterm><primary><envar>PGREQUIREPEER</envar></primary></indexterm><envar>PGREQUIREPEER</envar>behaves the same as the <xref linkend=\"libpq-connect-requirepeer\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6422(para)
msgid "<indexterm><primary><envar>PGKRBSRVNAME</envar></primary></indexterm><envar>PGKRBSRVNAME</envar>behaves the same as the <xref linkend=\"libpq-connect-krbsrvname\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6433(para)
msgid "<indexterm><primary><envar>PGGSSLIB</envar></primary></indexterm><envar>PGGSSLIB</envar>behaves the same as the <xref linkend=\"libpq-connect-gsslib\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6444(para)
msgid "<indexterm><primary><envar>PGCONNECT_TIMEOUT</envar></primary></indexterm><envar>PGCONNECT_TIMEOUT</envar>behaves the same as the <xref linkend=\"libpq-connect-connect-timeout\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6455(para)
msgid "<indexterm><primary><envar>PGCLIENTENCODING</envar></primary></indexterm><envar>PGCLIENTENCODING</envar>behaves the same as the <xref linkend=\"libpq-connect-client-encoding\">connection parameter.</xref>"
msgstr ""

#: xml/libpq.xml:6175(para)
msgid "The following environment variables can be used to select default connection parameter values, which will be used by <function>PQconnectdb</function>, <function>PQsetdbLogin</function>and <function>PQsetdb</function>if no value is directly specified by the calling code. These are useful to avoid hard-coding database connection information into simple client applications, for example. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:6474(para)
msgid "<indexterm><primary><envar>PGDATESTYLE</envar></primary></indexterm><envar>PGDATESTYLE</envar>sets the default style of date/time representation. (Equivalent to <literal>SET datestyle TO ...</literal>.)"
msgstr ""

#: xml/libpq.xml:6485(para)
msgid "<indexterm><primary><envar>PGTZ</envar></primary></indexterm><envar>PGTZ</envar>sets the default time zone. (Equivalent to <literal>SET timezone TO ...</literal>.)"
msgstr ""

#: xml/libpq.xml:6496(para)
msgid "<indexterm><primary><envar>PGGEQO</envar></primary></indexterm><envar>PGGEQO</envar>sets the default mode for the genetic query optimizer. (Equivalent to <literal>SET geqo TO ...</literal>.)"
msgstr ""

#: xml/libpq.xml:6466(para)
msgid "The following environment variables can be used to specify default behavior for each <productname>PostgreSQL</productname>session. (See also the <xref linkend=\"sql-alterrole\">and <xref linkend=\"sql-alterdatabase\">commands for ways to set default behavior on a per-user or per-database basis.) <placeholder-1/>Refer to the <acronym>SQL</acronym>command <xref linkend=\"sql-set\">for information on correct values for these environment variables.</xref></xref></xref>"
msgstr ""

#: xml/libpq.xml:6516(para)
msgid "<indexterm><primary><envar>PGSYSCONFDIR</envar></primary></indexterm><envar>PGSYSCONFDIR</envar>sets the directory containing the <filename>pg_service.conf</filename>file and in a future version possibly other system-wide configuration files."
msgstr ""

#: xml/libpq.xml:6529(para)
msgid "<indexterm><primary><envar>PGLOCALEDIR</envar></primary></indexterm><envar>PGLOCALEDIR</envar>sets the directory containing the <literal>locale</literal>files for message localization."
msgstr ""

#: xml/libpq.xml:6510(para)
msgid "The following environment variables determine internal behavior of <application>libpq</application>; they override compiled-in defaults. <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:6543(title)
msgid "The Password File"
msgstr ""

#: xml/libpq.xml:6545(primary)
msgid "password file"
msgstr ""

#: xml/libpq.xml:6548(primary)
msgid ".pgpass"
msgstr ""

#: xml/libpq.xml:6550(para)
msgid "The file <filename>.pgpass</filename>in a user's home directory or the file referenced by <envar>PGPASSFILE</envar>can contain passwords to be used if the connection requires a password (and no password has been specified otherwise). On Microsoft Windows the file is named <filename>%APPDATA%\\postgresql\\pgpass.conf</filename>(where <filename>%APPDATA%</filename>refers to the Application Data subdirectory in the user's profile)."
msgstr ""

#: xml/libpq.xml:6559(para)
msgid "This file should contain lines of the following format: <synopsis>\n    <replaceable>hostname</replaceable>: \n    <replaceable>port</replaceable>: \n    <replaceable>database</replaceable>: \n    <replaceable>username</replaceable>: \n    <replaceable>password</replaceable></synopsis>(You can add a reminder comment to the file by copying the line above and preceding it with <literal>#</literal>.) Each of the first four fields can be a literal value, or <literal>*</literal>, which matches anything. The password field from the first line that matches the current connection parameters will be used. (Therefore, put more-specific entries first when you are using wildcards.) If an entry needs to contain <literal>:</literal>or <literal>\\</literal>, escape this character with <literal>\\</literal>. A host name of <literal>localhost</literal>matches both TCP (host name <literal>localhost</literal>) and Unix domain socket ( <literal>pghost</literal>empty or the default socket directory) connections coming from the local machine. In a standby server, a database name of <literal>replication</literal>matches streaming replication connections made to the master server. The <literal>database</literal>field is of limited usefulness because users have the same password for all databases in the same cluster."
msgstr ""

#: xml/libpq.xml:6588(para)
msgid "On Unix systems, the permissions on <filename>.pgpass</filename>must disallow any access to world or group; achieve this by the command <command>chmod 0600 ~/.pgpass</command>. If the permissions are less strict than this, the file will be ignored. On Microsoft Windows, it is assumed that the file is stored in a directory that is secure, so no special permissions check is made."
msgstr ""

#: xml/libpq.xml:6597(title)
msgid "The Connection Service File"
msgstr ""

#: xml/libpq.xml:6599(primary)
msgid "connection service file"
msgstr ""

#: xml/libpq.xml:6602(primary)
msgid "pg_service.conf"
msgstr ""

#: xml/libpq.xml:6605(primary)
msgid ".pg_service.conf"
msgstr ""

#: xml/libpq.xml:6607(para)
msgid "The connection service file allows libpq connection parameters to be associated with a single service name. That service name can then be specified by a libpq connection, and the associated settings will be used. This allows connection parameters to be modified without requiring a recompile of the libpq application. The service name can also be specified using the <envar>PGSERVICE</envar>environment variable."
msgstr ""

#: xml/libpq.xml:6615(para)
msgid "The connection service file can be a per-user service file at <filename>~/.pg_service.conf</filename>or the location specified by the environment variable <envar>PGSERVICEFILE</envar>, or it can be a system-wide file at <filename>`pg_config --sysconfdir`/pg_service.conf</filename>or in the directory specified by the environment variable <envar>PGSYSCONFDIR</envar>. If service definitions with the same name exist in the user and the system file, the user file takes precedence."
msgstr ""

#: xml/libpq.xml:6630(programlisting)
#, no-wrap
msgid "# comment [mydb] host=somehost port=5433\n    user=admin"
msgstr ""

#: xml/libpq.xml:6626(para)
msgid "The file uses an <quote>INI file</quote>format where the section name is the service name and the parameters are connection parameters; see <xref linkend=\"libpq-paramkeywords\">for a list. For example: <placeholder-1/>An example file is provided at <filename> share/pg_service.conf.sample</filename>.</xref>"
msgstr ""

#: xml/libpq.xml:6636(title)
msgid "LDAP Lookup of Connection Parameters"
msgstr ""

#: xml/libpq.xml:6638(primary)
msgid "LDAP connection parameter lookup"
msgstr ""

#: xml/libpq.xml:6640(para)
msgid "If <application>libpq</application>has been compiled with LDAP support (option <literal><option>--with-ldap</option></literal>for <command>configure</command>) it is possible to retrieve connection options like <literal>host</literal>or <literal>dbname</literal>via LDAP from a central server. The advantage is that if the connection parameters for a database change, the connection information doesn't have to be updated on all client machines."
msgstr ""

#: xml/libpq.xml:6653(para)
msgid "LDAP connection parameter lookup uses the connection service file <filename>pg_service.conf</filename>(see <xref linkend=\"libpq-pgservice\">). A line in a <filename>pg_service.conf</filename>stanza that starts with <literal>ldap://</literal>will be recognized as an LDAP URL and an LDAP query will be performed. The result must be a list of <literal>keyword = value</literal>pairs which will be used to set connection options. The URL must conform to RFC 1959 and be of the form <synopsis>ldap://[ \n    <replaceable>hostname</replaceable>[: \n    <replaceable>port</replaceable>]]/ \n    <replaceable>search_base</replaceable>? \n    <replaceable>attribute</replaceable>? \n    <replaceable>search_scope</replaceable>? \n    <replaceable>filter</replaceable></synopsis>where <replaceable>hostname</replaceable>defaults to <literal>localhost</literal>and <replaceable>port</replaceable>defaults to 389.</xref>"
msgstr ""

#: xml/libpq.xml:6673(para)
msgid "Processing of <filename>pg_service.conf</filename>is terminated after a successful LDAP lookup, but is continued if the LDAP server cannot be contacted. This is to provide a fallback with further LDAP URL lines that point to different LDAP servers, classical <literal>keyword = value</literal>pairs, or default connection options. If you would rather get an error message in this case, add a syntactically incorrect line after the LDAP URL."
msgstr ""

#: xml/libpq.xml:6683(programlisting)
#, no-wrap
msgid "version:1 dn:cn=mydatabase,dc=mycompany,dc=com\n    changetype:add objectclass:top objectclass:device cn:mydatabase\n    description:host=dbserver.mycompany.com description:port=5439\n    description:dbname=mydb description:user=mydb_user\n    description:sslmode=require"
msgstr ""

#: xml/libpq.xml:6689(programlisting)
#, no-wrap
msgid "\n    ldap://ldap.mycompany.com/dc=mycompany,dc=com?description?one?(cn=mydatabase)"
msgstr ""

#: xml/libpq.xml:6681(para)
msgid "A sample LDAP entry that has been created with the LDIF file <placeholder-1/>might be queried with the following LDAP URL: <placeholder-2/>"
msgstr ""

#: xml/libpq.xml:6694(programlisting)
#, no-wrap
msgid "# only host and port are stored in LDAP,\n    specify dbname and user explicitly [customerdb] dbname=customer\n    user=appuser\n    ldap://ldap.acme.com/cn=dbserver,cn=hosts?pgconnectinfo?base?(objectclass=*)"
msgstr ""

#: xml/libpq.xml:6691(para)
msgid "You can also mix regular service file entries with LDAP lookups. A complete example for a stanza in <filename>pg_service.conf</filename>would be: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:6700(title)
msgid "SSL Support"
msgstr ""

#: xml/libpq.xml:6702(primary)
msgid "SSL"
msgstr ""

#: xml/libpq.xml:6704(para)
msgid "<productname>PostgreSQL</productname>has native support for using <acronym>SSL</acronym>connections to encrypt client/server communications for increased security. See <xref linkend=\"ssl-tcp\">for details about the server-side <acronym>SSL</acronym>functionality.</xref>"
msgstr ""

#: xml/libpq.xml:6711(para)
msgid "<application>libpq</application>reads the system-wide <productname>OpenSSL</productname>configuration file. By default, this file is named <filename>openssl.cnf</filename>and is located in the directory reported by <literal>openssl version -d</literal>. This default can be overridden by setting environment variable <envar>OPENSSL_CONF</envar>to the name of the desired configuration file."
msgstr ""

#: xml/libpq.xml:6722(title)
msgid "Client Verification of Server Certificates"
msgstr ""

#: xml/libpq.xml:6723(para)
msgid "By default, <productname>PostgreSQL</productname>will not perform any verification of the server certificate. This means that it is possible to spoof the server identity (for example by modifying a DNS record or by taking over the server IP address) without the client knowing. In order to prevent spoofing, <acronym>SSL</acronym>certificate verification must be used."
msgstr ""

#: xml/libpq.xml:6732(para)
msgid "If the parameter <literal>sslmode</literal>is set to <literal>verify-ca</literal>, libpq will verify that the server is trustworthy by checking the certificate chain up to a trusted certificate authority ( <acronym>CA</acronym>). If <literal>sslmode</literal>is set to <literal>verify-full</literal>, libpq will <emphasis>also</emphasis>verify that the server host name matches its certificate. The SSL connection will fail if the server certificate cannot be verified. <literal>verify-full</literal>is recommended in most security-sensitive environments."
msgstr ""

#: xml/libpq.xml:6745(para)
msgid "In <literal>verify-full</literal>mode, the host name is matched against the certificate's Subject Alternative Name attribute(s), or against the Common Name attribute if no Subject Alternative Name of type dNSName is present. If the certificate's name attribute starts with an asterisk ( <literal>*</literal>), the asterisk will be treated as a wildcard, which will match all characters <emphasis>except</emphasis>a dot ( <literal>.</literal>). This means the certificate will not match subdomains. If the connection is made using an IP address instead of a host name, the IP address will be matched (without doing any DNS lookups)."
msgstr ""

#: xml/libpq.xml:6758(para)
msgid "To allow server certificate verification, the certificate(s) of one or more trusted <acronym>CA</acronym>s must be placed in the file <filename>~/.postgresql/root.crt</filename>in the user's home directory. If intermediate <acronym>CA</acronym>s appear in <filename>root.crt</filename>, the file must also contain certificate chains to their root <acronym>CA</acronym>s. (On Microsoft Windows the file is named <filename>%APPDATA%\\postgresql\\root.crt</filename>.)"
msgstr ""

#: xml/libpq.xml:6769(para)
msgid "Certificate Revocation List (CRL) entries are also checked if the file <filename>~/.postgresql/root.crl</filename>exists ( <filename>%APPDATA%\\postgresql\\root.crl</filename>on Microsoft Windows)."
msgstr ""

#: xml/libpq.xml:6774(para)
msgid "The location of the root certificate file and the CRL can be changed by setting the connection parameters <literal>sslrootcert</literal>and <literal>sslcrl</literal>or the environment variables <envar>PGSSLROOTCERT</envar>and <envar>PGSSLCRL</envar>."
msgstr ""

#: xml/libpq.xml:6781(para)
msgid "For backwards compatibility with earlier versions of PostgreSQL, if a root CA file exists, the behavior of <literal>sslmode</literal>= <literal>require</literal>will be the same as that of <literal>verify-ca</literal>, meaning the server certificate is validated against the CA. Relying on this behavior is discouraged, and applications that need certificate validation should always use <literal>verify-ca</literal>or <literal>verify-full</literal>."
msgstr ""

#: xml/libpq.xml:6794(title)
msgid "Client Certificates"
msgstr ""

#: xml/libpq.xml:6795(para)
msgid "If the server requests a trusted client certificate, <application>libpq</application>will send the certificate stored in file <filename>~/.postgresql/postgresql.crt</filename>in the user's home directory. The certificate must be signed by one of the certificate authorities ( <acronym>CA</acronym>) trusted by the server. A matching private key file <filename>~/.postgresql/postgresql.key</filename>must also be present. The private key file must not allow any access to world or group; achieve this by the command <command>chmod 0600 ~/.postgresql/postgresql.key</command>. On Microsoft Windows these files are named <filename>%APPDATA%\\postgresql\\postgresql.crt</filename>and <filename>%APPDATA%\\postgresql\\postgresql.key</filename>, and there is no special permissions check since the directory is presumed secure. The location of the certificate and key files can be overridden by the connection parameters <literal>sslcert</literal>and <literal>sslkey</literal>or the environment variables <envar>PGSSLCERT</envar>and <envar>PGSSLKEY</envar>."
msgstr ""

#: xml/libpq.xml:6817(para)
msgid "In some cases, the client certificate might be signed by an <quote>intermediate</quote>certificate authority, rather than one that is directly trusted by the server. To use such a certificate, append the certificate of the signing authority to the <filename>postgresql.crt</filename>file, then its parent authority's certificate, and so on up to a certificate authority, <quote>root</quote>or <quote>intermediate</quote>, that is trusted by the server, i.e. signed by a certificate in the server's <filename>root.crt</filename>file."
msgstr ""

#: xml/libpq.xml:6830(para)
msgid "Note that the client's <filename>~/.postgresql/root.crt</filename>lists the top-level CAs that are considered trusted for signing server certificates. In principle it need not list the CA that signed the client's certificate, though in most cases that CA would also be trusted for server certificates."
msgstr ""

#: xml/libpq.xml:6838(title)
msgid "Protection Provided in Different Modes"
msgstr ""

#: xml/libpq.xml:6845(term)
msgid "Eavesdropping"
msgstr ""

#: xml/libpq.xml:6847(para)
msgid "If a third party can examine the network traffic between the client and the server, it can read both connection information (including the user name and password) and the data that is passed. <acronym>SSL</acronym>uses encryption to prevent this."
msgstr ""

#: xml/libpq.xml:6856(term)
msgid "Man in the middle ( <acronym>MITM</acronym>)"
msgstr ""

#: xml/libpq.xml:6859(para)
msgid "If a third party can modify the data while passing between the client and server, it can pretend to be the server and therefore see and modify data <emphasis>even if it is encrypted</emphasis>. The third party can then forward the connection information and data to the original server, making it impossible to detect this attack. Common vectors to do this include DNS poisoning and address hijacking, whereby the client is directed to a different server than intended. There are also several other attack methods that can accomplish this. <acronym>SSL</acronym>uses certificate verification to prevent this, by authenticating the server to the client."
msgstr ""

#: xml/libpq.xml:6876(term)
msgid "Impersonation"
msgstr ""

#: xml/libpq.xml:6878(para)
msgid "If a third party can pretend to be an authorized client, it can simply access data it should not have access to. Typically this can happen through insecure password management. <acronym>SSL</acronym>uses client certificates to prevent this, by making sure that only holders of valid certificates can access the server."
msgstr ""

#: xml/libpq.xml:6839(para)
msgid "The different values for the <literal>sslmode</literal>parameter provide different levels of protection. SSL can provide protection against three types of attacks: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:6888(para)
msgid "For a connection to be known secure, SSL usage must be configured on <emphasis>both the client and the server</emphasis>before the connection is made. If it is only configured on the server, the client may end up sending sensitive information (e.g. passwords) before it knows that the server requires high security. In libpq, secure connections can be ensured by setting the <literal>sslmode</literal>parameter to <literal>verify-full</literal>or <literal>verify-ca</literal>, and providing the system with a root certificate to verify against. This is analogous to using an <literal>https</literal><acronym>URL</acronym>for encrypted web browsing."
msgstr ""

#: xml/libpq.xml:6903(para)
msgid "Once the server has been authenticated, the client can pass sensitive data. This means that up until this point, the client does not need to know if certificates will be used for authentication, making it safe to specify that only in the server configuration."
msgstr ""

#: xml/libpq.xml:6908(para)
msgid "All <acronym>SSL</acronym>options carry overhead in the form of encryption and key-exchange, so there is a tradeoff that has to be made between performance and security. <xref linkend=\"libpq-ssl-sslmode-statements\">illustrates the risks the different <literal>sslmode</literal>values protect against, and what statement they make about security and overhead.</xref>"
msgstr ""

#: xml/libpq.xml:6918(title)
msgid "SSL Mode Descriptions"
msgstr ""

#: xml/libpq.xml:6925(entry)
msgid "Eavesdropping protection"
msgstr ""

#: xml/libpq.xml:6927(acronym)
msgid "MITM"
msgstr ""

#: xml/libpq.xml:6926(entry)
msgid "<placeholder-1/>protection"
msgstr ""

#: xml/libpq.xml:6928(entry)
msgid "Statement"
msgstr ""

#: xml/libpq.xml:6936(entry) xml/libpq.xml:6937(entry) xml/libpq.xml:6946(entry) xml/libpq.xml:6956(entry) xml/libpq.xml:6966(entry)
msgid "No"
msgstr ""

#: xml/libpq.xml:6938(entry)
msgid "I don't care about security, and I don't want to pay the overhead of encryption."
msgstr ""

#: xml/libpq.xml:6945(entry) xml/libpq.xml:6955(entry)
msgid "Maybe"
msgstr ""

#: xml/libpq.xml:6947(entry)
msgid "I don't care about security, but I will pay the overhead of encryption if the server insists on it."
msgstr ""

#: xml/libpq.xml:6953(literal)
msgid "prefer"
msgstr ""

#: xml/libpq.xml:6957(entry)
msgid "I don't care about encryption, but I wish to pay the overhead of encryption if the server supports it."
msgstr ""

#: xml/libpq.xml:6965(entry) xml/libpq.xml:6975(entry) xml/libpq.xml:6986(entry) xml/libpq.xml:6987(entry)
msgid "Yes"
msgstr ""

#: xml/libpq.xml:6967(entry)
msgid "I want my data to be encrypted, and I accept the overhead. I trust that the network will make sure I always connect to the server I want."
msgstr ""

#: xml/libpq.xml:6977(literal)
msgid "Depends on CA"
msgstr ""

#: xml/libpq.xml:6976(entry)
msgid "<placeholder-1/>-policy"
msgstr ""

#: xml/libpq.xml:6978(entry)
msgid "I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server that I trust."
msgstr ""

#: xml/libpq.xml:6988(entry)
msgid "I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server I trust, and that it's the one I specify."
msgstr ""

#: xml/libpq.xml:6996(para)
msgid "The difference between <literal>verify-ca</literal>and <literal>verify-full</literal>depends on the policy of the root <acronym>CA</acronym>. If a public <acronym>CA</acronym>is used, <literal>verify-ca</literal>allows connections to a server that <emphasis>somebody else</emphasis>may have registered with the <acronym>CA</acronym>. In this case, <literal>verify-full</literal>should always be used. If a local <acronym>CA</acronym>is used, or even a self-signed certificate, using <literal>verify-ca</literal>often provides enough protection."
msgstr ""

#: xml/libpq.xml:7013(para)
msgid "The default value for <literal>sslmode</literal>is <literal>prefer</literal>. As is shown in the table, this makes no sense from a security point of view, and it only promises performance overhead if possible. It is only provided as the default for backward compatibility, and is not recommended in secure deployments."
msgstr ""

#: xml/libpq.xml:7022(title)
msgid "SSL Client File Usage"
msgstr ""

#: xml/libpq.xml:7024(xref)
msgid "summarizes the files that are relevant to the SSL setup on the client."
msgstr ""

#: xml/libpq.xml:7028(title)
msgid "Libpq/Client SSL File Usage"
msgstr ""

#: xml/libpq.xml:7032(entry)
msgid "File"
msgstr ""

#: xml/libpq.xml:7033(entry)
msgid "Contents"
msgstr ""

#: xml/libpq.xml:7034(entry)
msgid "Effect"
msgstr ""

#: xml/libpq.xml:7040(filename)
msgid "~/.postgresql/postgresql.crt"
msgstr ""

#: xml/libpq.xml:7042(entry)
msgid "client certificate"
msgstr ""

#: xml/libpq.xml:7043(entry)
msgid "requested by server"
msgstr ""

#: xml/libpq.xml:7047(filename)
msgid "~/.postgresql/postgresql.key"
msgstr ""

#: xml/libpq.xml:7049(entry)
msgid "client private key"
msgstr ""

#: xml/libpq.xml:7050(entry)
msgid "proves client certificate sent by owner; does not indicate certificate owner is trustworthy"
msgstr ""

#: xml/libpq.xml:7055(filename)
msgid "~/.postgresql/root.crt"
msgstr ""

#: xml/libpq.xml:7057(entry)
msgid "trusted certificate authorities"
msgstr ""

#: xml/libpq.xml:7058(entry)
msgid "checks that server certificate is signed by a trusted certificate authority"
msgstr ""

#: xml/libpq.xml:7063(filename)
msgid "~/.postgresql/root.crl"
msgstr ""

#: xml/libpq.xml:7065(entry)
msgid "certificates revoked by certificate authorities"
msgstr ""

#: xml/libpq.xml:7067(entry)
msgid "server certificate must not be on this list"
msgstr ""

#: xml/libpq.xml:7075(title)
msgid "SSL Library Initialization"
msgstr ""

#: xml/libpq.xml:7076(para)
msgid "If your application initializes <literal>libssl</literal>and/or <literal>libcrypto</literal>libraries and <application>libpq</application>is built with <acronym>SSL</acronym>support, you should call <function>PQinitOpenSSL</function>to tell <application>libpq</application>that the <literal>libssl</literal>and/or <literal>libcrypto</literal>libraries have been initialized by your application, so that <application>libpq</application>will not also initialize those libraries. See <placeholder-1/>for details on the SSL API."
msgstr ""

#: xml/libpq.xml:7094(function) xml/libpq.xml:7096(primary)
msgid "PQinitOpenSSL"
msgstr ""

#: xml/libpq.xml:7100(para)
msgid "Allows applications to select which security libraries to initialize. <synopsis>void PQinitOpenSSL(int do_ssl, int\n              do_crypto);</synopsis>"
msgstr ""

#: xml/libpq.xml:7104(para)
msgid "When <parameter>do_ssl</parameter>is non-zero, <application>libpq</application>will initialize the <application>OpenSSL</application>library before first opening a database connection. When <parameter>do_crypto</parameter>is non-zero, the <literal>libcrypto</literal>library will be initialized. By default (if <function>PQinitOpenSSL</function>is not called), both libraries are initialized. When SSL support is not compiled in, this function is present but does nothing."
msgstr ""

#: xml/libpq.xml:7116(para)
msgid "If your application uses and initializes either <application>OpenSSL</application>or its underlying <literal>libcrypto</literal>library, you <emphasis>must</emphasis>call this function with zeroes for the appropriate parameter(s) before first opening a database connection. Also be sure that you have done that initialization before opening a database connection."
msgstr ""

#: xml/libpq.xml:7129(function) xml/libpq.xml:7131(primary)
msgid "PQinitSSL"
msgstr ""

#: xml/libpq.xml:7135(para)
msgid "Allows applications to select which security libraries to initialize. <synopsis>void PQinitSSL(int\n              do_ssl);</synopsis>"
msgstr ""

#: xml/libpq.xml:7139(para)
msgid "This function is equivalent to <literal>PQinitOpenSSL(do_ssl, do_ssl)</literal>. It is sufficient for applications that initialize both or neither of <application>OpenSSL</application>and <literal>libcrypto</literal>."
msgstr ""

#: xml/libpq.xml:7145(para)
msgid "<function>PQinitSSL</function>has been present since <productname>PostgreSQL</productname>8.0, while <function>PQinitOpenSSL</function>was added in <productname>PostgreSQL</productname>8.4, so <function>PQinitSSL</function>might be preferable for applications that need to work with older versions of <application>libpq</application>."
msgstr ""

#: xml/libpq.xml:7161(title)
msgid "Behavior in Threaded Programs"
msgstr ""

#: xml/libpq.xml:7163(primary)
msgid "threads"
msgstr ""

#: xml/libpq.xml:7166(para)
msgid "<application>libpq</application>is reentrant and thread-safe by default. You might need to use special compiler command-line options when you compile your application code. Refer to your system's documentation for information about how to build thread-enabled applications, or look in <filename>src/Makefile.global</filename>for <literal>PTHREAD_CFLAGS</literal>and <literal>PTHREAD_LIBS</literal>. This function allows the querying of <application>libpq</application>'s thread-safe status:"
msgstr ""

#: xml/libpq.xml:7180(function) xml/libpq.xml:7182(primary)
msgid "PQisthreadsafe"
msgstr ""

#: xml/libpq.xml:7186(para)
msgid "Returns the thread safety status of the <application>libpq</application>library. <synopsis>int PQisthreadsafe();</synopsis>"
msgstr ""

#: xml/libpq.xml:7189(para)
msgid "Returns 1 if the <application>libpq</application>is thread-safe and 0 if it is not."
msgstr ""

#: xml/libpq.xml:7195(para)
msgid "One thread restriction is that no two threads attempt to manipulate the same <structname>PGconn</structname>object at the same time. In particular, you cannot issue concurrent commands from different threads through the same connection object. (If you need to run concurrent commands, use multiple connections.)"
msgstr ""

#: xml/libpq.xml:7201(para)
msgid "<structname>PGresult</structname>objects are normally read-only after creation, and so can be passed around freely between threads. However, if you use any of the <structname>PGresult</structname>-modifying functions described in <xref linkend=\"libpq-misc\">or <xref linkend=\"libpq-events\">, it's up to you to avoid concurrent operations on the same <structname>PGresult</structname>, too.</xref></xref>"
msgstr ""

#: xml/libpq.xml:7211(para)
msgid "The deprecated functions <function>PQrequestCancel</function>and <function>PQoidStatus</function>are not thread-safe and should not be used in multithread programs. <function>PQrequestCancel</function>can be replaced by <function>PQcancel</function>. <function>PQoidStatus</function>can be replaced by <function>PQoidValue</function>."
msgstr ""

#: xml/libpq.xml:7219(para)
msgid "If you are using Kerberos inside your application (in addition to inside <application>libpq</application>), you will need to do locking around Kerberos calls because Kerberos functions are not thread-safe. See function <function>PQregisterThreadLock</function>in the <application>libpq</application>source code for a way to do cooperative locking between <application>libpq</application>and your application."
msgstr ""

#: xml/libpq.xml:7228(para)
msgid "If you experience problems with threaded applications, run the program in <filename>src/tools/thread</filename>to see if your platform has thread-unsafe functions. This program is run by <filename>configure</filename>, but for binary distributions your library might not match the library used to build the binaries."
msgstr ""

#: xml/libpq.xml:7237(title)
msgid "Building <application>libpq</application>Programs"
msgstr ""

#: xml/libpq.xml:7240(primary)
msgid "compiling"
msgstr ""

#: xml/libpq.xml:7241(secondary)
msgid "libpq applications"
msgstr ""

#: xml/libpq.xml:7250(programlisting)
#, no-wrap
msgid "#include libpq-fe.h"
msgstr ""

#: xml/libpq.xml:7248(para)
msgid "Include the <filename>libpq-fe.h</filename>header file: <placeholder-1/>If you failed to do that then you will normally get error messages from your compiler similar to: <screen>foo.c: In function `main': foo.c:34: `PGconn'\n        undeclared (first use in this function) foo.c:35:\n        `PGresult' undeclared (first use in this function)\n        foo.c:54: `CONNECTION_BAD' undeclared (first use in this\n        function) foo.c:68: `PGRES_COMMAND_OK' undeclared (first\n        use in this function) foo.c:95: `PGRES_TUPLES_OK'\n        undeclared (first use in this function)</screen>"
msgstr ""

#: xml/libpq.xml:7271(programlisting)
#, no-wrap
msgid "cc -c -I/usr/local/pgsql/include\n        testprog.c"
msgstr ""

#: xml/libpq.xml:7275(programlisting)
#, no-wrap
msgid "CPPFLAGS +=\n        -I/usr/local/pgsql/include"
msgstr ""

#: xml/libpq.xml:7262(para)
msgid "Point your compiler to the directory where the <productname>PostgreSQL</productname>header files were installed, by supplying the <literal>-I <replaceable>directory</replaceable></literal>option to your compiler. (In some cases the compiler will look into the directory in question by default, so you can omit this option.) For instance, your compile command line could look like: <placeholder-1/>If you are using makefiles then add the option to the <varname>CPPFLAGS</varname>variable: <placeholder-2/>"
msgstr ""

#: xml/libpq.xml:7277(para)
msgid "If there is any chance that your program might be compiled by other users then you should not hardcode the directory location like that. Instead, you can run the utility <command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas=\"libpq\">with libpq</secondary></indexterm>to find out where the header files are on the local system: <screen>\n        <prompt>$</prompt>pg_config --includedir \n        <computeroutput>\n        /usr/local/include</computeroutput></screen>"
msgstr ""

#: xml/libpq.xml:7291(para)
msgid "If you have <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas=\"libpq\">with libpq</secondary></indexterm>installed, you can run instead: <screen>\n        <prompt>$</prompt>pkg-config --cflags libpq \n        <computeroutput>\n        -I/usr/local/include</computeroutput></screen>Note that this will already include the <option>-I</option>in front of the path."
msgstr ""

#: xml/libpq.xml:7303(para)
msgid "Failure to specify the correct option to the compiler will result in an error message such as: <screen>testlibpq.c:8:22: libpq-fe.h: No such file or\n        directory</screen>"
msgstr ""

#: xml/libpq.xml:7321(programlisting)
#, no-wrap
msgid "cc -o testprog testprog1.o testprog2.o\n        -L/usr/local/pgsql/lib -lpq"
msgstr ""

#: xml/libpq.xml:7309(para)
msgid "When linking the final program, specify the option <literal>-lpq</literal>so that the <application>libpq</application>library gets pulled in, as well as the option <literal>-L <replaceable>directory</replaceable></literal>to point the compiler to the directory where the <application>libpq</application>library resides. (Again, the compiler will search some directories by default.) For maximum portability, put the <option>-L</option>option before the <option>-lpq</option>option. For example: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:7323(para)
msgid "You can find out the library directory using <command>pg_config</command>as well: <screen>\n        <prompt>$</prompt>pg_config --libdir \n        <computeroutput>\n        /usr/local/pgsql/lib</computeroutput></screen>"
msgstr ""

#: xml/libpq.xml:7329(para)
msgid "Or again use <command>pkg-config</command>: <screen>\n        <prompt>$</prompt>pkg-config --libs libpq \n        <computeroutput>-L/usr/local/pgsql/lib\n        -lpq</computeroutput></screen>Note again that this prints the full options, not only the path."
msgstr ""

#: xml/libpq.xml:7336(para)
msgid "Error messages that point to problems in this area could look like the following: <screen>testlibpq.o: In function `main':\n        testlibpq.o(.text+0x60): undefined reference to\n        `PQsetdbLogin' testlibpq.o(.text+0x71): undefined reference\n        to `PQstatus' testlibpq.o(.text+0xa4): undefined reference\n        to `PQerrorMessage'</screen>This means you forgot <option>-lpq</option>. <screen>/usr/bin/ld: cannot find -lpq</screen>This means you forgot the <option>-L</option>option or did not specify the right directory."
msgstr ""

#: xml/libpq.xml:7243(para)
msgid "To build (i.e., compile and link) a program using <application>libpq</application>you need to do all of the following things: <placeholder-1/>"
msgstr ""

#: xml/libpq.xml:7352(title)
msgid "Example Programs"
msgstr ""

#: xml/libpq.xml:7353(para)
msgid "These examples and others can be found in the directory <filename>src/test/examples</filename>in the source code distribution."
msgstr ""

#: xml/libpq.xml:7357(title)
msgid "<application>libpq</application>Example Program 1"
msgstr ""

#: xml/libpq.xml:7359(programlisting)
#, no-wrap
msgid "/* * testlibpq.c * * Test the C version of\n      libpq, the PostgreSQL frontend library. */ #include\n      &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include\n      &lt;libpq-fe.h&gt; static void exit_nicely(PGconn *conn) {\n      PQfinish(conn); exit(1); } int main(int argc, char **argv) {\n      const char *conninfo; PGconn *conn; PGresult *res; int\n      nFields; int i, j; /* * If the user supplies a parameter on\n      the command line, use it as the * conninfo string; otherwise\n      default to setting dbname=postgres and using * environment\n      variables or defaults for all other connection parameters. */\n      if (argc &gt; 1) conninfo = argv[1]; else conninfo = \"dbname\n      = postgres\"; /* Make a connection to the database */ conn =\n      PQconnectdb(conninfo); /* Check to see that the backend\n      connection was successfully made */ if (PQstatus(conn) !=\n      CONNECTION_OK) { fprintf(stderr, \"Connection to database\n      failed: %s\", PQerrorMessage(conn)); exit_nicely(conn); } /* *\n      Our test case here involves using a cursor, for which we must\n      be inside * a transaction block. We could do the whole thing\n      with a single * PQexec() of \"select * from pg_database\", but\n      that's too trivial to make * a good example. */ /* Start a\n      transaction block */ res = PQexec(conn, \"BEGIN\"); if\n      (PQresultStatus(res) != PGRES_COMMAND_OK) { fprintf(stderr,\n      \"BEGIN command failed: %s\", PQerrorMessage(conn));\n      PQclear(res); exit_nicely(conn); } /* * Should PQclear\n      PGresult whenever it is no longer needed to avoid memory *\n      leaks */ PQclear(res); /* * Fetch rows from pg_database, the\n      system catalog of databases */ res = PQexec(conn, \"DECLARE\n      myportal CURSOR FOR select * from pg_database\"); if\n      (PQresultStatus(res) != PGRES_COMMAND_OK) { fprintf(stderr,\n      \"DECLARE CURSOR failed: %s\", PQerrorMessage(conn));\n      PQclear(res); exit_nicely(conn); } PQclear(res); res =\n      PQexec(conn, \"FETCH ALL in myportal\"); if\n      (PQresultStatus(res) != PGRES_TUPLES_OK) { fprintf(stderr,\n      \"FETCH ALL failed: %s\", PQerrorMessage(conn)); PQclear(res);\n      exit_nicely(conn); } /* first, print out the attribute names\n      */ nFields = PQnfields(res); for (i = 0; i &lt; nFields; i++)\n      printf(\"%-15s\", PQfname(res, i)); printf(\"\\n\\n\"); /* next,\n      print out the rows */ for (i = 0; i &lt; PQntuples(res); i++)\n      { for (j = 0; j &lt; nFields; j++) printf(\"%-15s\",\n      PQgetvalue(res, i, j)); printf(\"\\n\"); } PQclear(res); /*\n      close the portal ... we don't bother to check for errors ...\n      */ res = PQexec(conn, \"CLOSE myportal\"); PQclear(res); /* end\n      the transaction */ res = PQexec(conn, \"END\"); PQclear(res);\n      /* close the connection to the database and cleanup */\n      PQfinish(conn); return 0; }"
msgstr ""

#: xml/libpq.xml:7406(title)
msgid "<application>libpq</application>Example Program 2"
msgstr ""

#: xml/libpq.xml:7408(programlisting)
#, no-wrap
msgid "/* * testlibpq2.c * Test of the asynchronous\n      notification interface * * Start this program, then from psql\n      in another window do * NOTIFY TBL2; * Repeat four times to\n      get this program to exit. * * Or, if you want to get fancy,\n      try this: * populate a database with the following commands *\n      (provided in src/test/examples/testlibpq2.sql): * * CREATE\n      TABLE TBL1 (i int4); * * CREATE TABLE TBL2 (i int4); * *\n      CREATE RULE r1 AS ON INSERT TO TBL1 DO * (INSERT INTO TBL2\n      VALUES (new.i); NOTIFY TBL2); * * and do this four times: * *\n      INSERT INTO TBL1 VALUES (10); */ #ifdef WIN32 #include\n      &lt;windows.h&gt; #endif #include &lt;stdio.h&gt; #include\n      &lt;stdlib.h&gt; #include &lt;string.h&gt; #include\n      &lt;errno.h&gt; #include &lt;sys/time.h&gt; #include\n      &lt;sys/types.h&gt; #include \"libpq-fe.h\" static void\n      exit_nicely(PGconn *conn) { PQfinish(conn); exit(1); } int\n      main(int argc, char **argv) { const char *conninfo; PGconn\n      *conn; PGresult *res; PGnotify *notify; int nnotifies; /* *\n      If the user supplies a parameter on the command line, use it\n      as the * conninfo string; otherwise default to setting\n      dbname=postgres and using * environment variables or defaults\n      for all other connection parameters. */ if (argc &gt; 1)\n      conninfo = argv[1]; else conninfo = \"dbname = postgres\"; /*\n      Make a connection to the database */ conn =\n      PQconnectdb(conninfo); /* Check to see that the backend\n      connection was successfully made */ if (PQstatus(conn) !=\n      CONNECTION_OK) { fprintf(stderr, \"Connection to database\n      failed: %s\", PQerrorMessage(conn)); exit_nicely(conn); } /* *\n      Issue LISTEN command to enable notifications from the rule's\n      NOTIFY. */ res = PQexec(conn, \"LISTEN TBL2\"); if\n      (PQresultStatus(res) != PGRES_COMMAND_OK) { fprintf(stderr,\n      \"LISTEN command failed: %s\", PQerrorMessage(conn));\n      PQclear(res); exit_nicely(conn); } /* * should PQclear\n      PGresult whenever it is no longer needed to avoid memory *\n      leaks */ PQclear(res); /* Quit after four notifies are\n      received. */ nnotifies = 0; while (nnotifies &lt; 4) { /* *\n      Sleep until something happens on the connection. We use\n      select(2) * to wait for input, but you could also use poll()\n      or similar * facilities. */ int sock; fd_set input_mask; sock\n      = PQsocket(conn); if (sock &lt; 0) break; /* shouldn't happen\n      */ FD_ZERO(&amp;input_mask); FD_SET(sock, &amp;input_mask);\n      if (select(sock + 1, &amp;input_mask, NULL, NULL, NULL) &lt;\n      0) { fprintf(stderr, \"select() failed: %s\\n\",\n      strerror(errno)); exit_nicely(conn); } /* Now check for input\n      */ PQconsumeInput(conn); while ((notify = PQnotifies(conn))\n      != NULL) { fprintf(stderr, \"ASYNC NOTIFY of '%s' received\n      from backend PID %d\\n\", notify-&gt;relname,\n      notify-&gt;be_pid); PQfreemem(notify); nnotifies++; } }\n      fprintf(stderr, \"Done.\\n\"); /* close the connection to the\n      database and cleanup */ PQfinish(conn); return 0;\n      }"
msgstr ""

#: xml/libpq.xml:7460(title)
msgid "<application>libpq</application>Example Program 3"
msgstr ""

#: xml/libpq.xml:7462(programlisting)
#, no-wrap
msgid "/* * testlibpq3.c * Test out-of-line\n      parameters and binary I/O. * * Before running this, populate\n      a database with the following commands * (provided in\n      src/test/examples/testlibpq3.sql): * * CREATE TABLE test1 (i\n      int4, t text, b bytea); * * INSERT INTO test1 values (1,\n      'joe''s place', '\\\\000\\\\001\\\\002\\\\003\\\\004'); * INSERT INTO\n      test1 values (2, 'ho there', '\\\\004\\\\003\\\\002\\\\001\\\\000'); *\n      * The expected output is: * * tuple 0: got * i = (4 bytes) 1\n      * t = (11 bytes) 'joe's place' * b = (5 bytes)\n      \\000\\001\\002\\003\\004 * * tuple 0: got * i = (4 bytes) 2 * t =\n      (8 bytes) 'ho there' * b = (5 bytes) \\004\\003\\002\\001\\000 */\n      #ifdef WIN32 #include &lt;windows.h&gt; #endif #include\n      &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include\n      &lt;stdint.h&gt; #include &lt;string.h&gt; #include\n      &lt;sys/types.h&gt; #include \"libpq-fe.h\" /* for ntohl/htonl\n      */ #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt;\n      static void exit_nicely(PGconn *conn) { PQfinish(conn);\n      exit(1); } /* * This function prints a query result that is a\n      binary-format fetch from * a table defined as in the comment\n      above. We split it out because the * main() function uses it\n      twice. */ static void show_binary_results(PGresult *res) {\n      int i, j; int i_fnum, t_fnum, b_fnum; /* Use PQfnumber to\n      avoid assumptions about field order in result */ i_fnum =\n      PQfnumber(res, \"i\"); t_fnum = PQfnumber(res, \"t\"); b_fnum =\n      PQfnumber(res, \"b\"); for (i = 0; i &lt; PQntuples(res); i++)\n      { char *iptr; char *tptr; char *bptr; int blen; int ival; /*\n      Get the field values (we ignore possibility they are null!)\n      */ iptr = PQgetvalue(res, i, i_fnum); tptr = PQgetvalue(res,\n      i, t_fnum); bptr = PQgetvalue(res, i, b_fnum); /* * The\n      binary representation of INT4 is in network byte order, which\n      * we'd better coerce to the local byte order. */ ival =\n      ntohl(*((uint32_t *) iptr)); /* * The binary representation\n      of TEXT is, well, text, and since libpq * was nice enough to\n      append a zero byte to it, it'll work just fine * as a C\n      string. * * The binary representation of BYTEA is a bunch of\n      bytes, which could * include embedded nulls so we have to pay\n      attention to field length. */ blen = PQgetlength(res, i,\n      b_fnum); printf(\"tuple %d: got\\n\", i); printf(\" i = (%d\n      bytes) %d\\n\", PQgetlength(res, i, i_fnum), ival); printf(\" t\n      = (%d bytes) '%s'\\n\", PQgetlength(res, i, t_fnum), tptr);\n      printf(\" b = (%d bytes) \", blen); for (j = 0; j &lt; blen;\n      j++) printf(\"\\\\%03o\", bptr[j]); printf(\"\\n\\n\"); } } int\n      main(int argc, char **argv) { const char *conninfo; PGconn\n      *conn; PGresult *res; const char *paramValues[1]; int\n      paramLengths[1]; int paramFormats[1]; uint32_t binaryIntVal;\n      /* * If the user supplies a parameter on the command line,\n      use it as the * conninfo string; otherwise default to setting\n      dbname=postgres and using * environment variables or defaults\n      for all other connection parameters. */ if (argc &gt; 1)\n      conninfo = argv[1]; else conninfo = \"dbname = postgres\"; /*\n      Make a connection to the database */ conn =\n      PQconnectdb(conninfo); /* Check to see that the backend\n      connection was successfully made */ if (PQstatus(conn) !=\n      CONNECTION_OK) { fprintf(stderr, \"Connection to database\n      failed: %s\", PQerrorMessage(conn)); exit_nicely(conn); } /* *\n      The point of this program is to illustrate use of\n      PQexecParams() with * out-of-line parameters, as well as\n      binary transmission of data. * * This first example transmits\n      the parameters as text, but receives the * results in binary\n      format. By using out-of-line parameters we can avoid * a lot\n      of tedious mucking about with quoting and escaping, even\n      though * the data is text. Notice how we don't have to do\n      anything special with * the quote mark in the parameter\n      value. */ /* Here is our out-of-line parameter value */\n      paramValues[0] = \"joe's place\"; res = PQexecParams(conn,\n      \"SELECT * FROM test1 WHERE t = $1\", 1, /* one param */ NULL,\n      /* let the backend deduce param type */ paramValues, NULL, /*\n      don't need param lengths since text */ NULL, /* default to\n      all text params */ 1); /* ask for binary results */ if\n      (PQresultStatus(res) != PGRES_TUPLES_OK) { fprintf(stderr,\n      \"SELECT failed: %s\", PQerrorMessage(conn)); PQclear(res);\n      exit_nicely(conn); } show_binary_results(res); PQclear(res);\n      /* * In this second example we transmit an integer parameter\n      in binary form, * and again retrieve the results in binary\n      form. * * Although we tell PQexecParams we are letting the\n      backend deduce * parameter type, we really force the decision\n      by casting the parameter * symbol in the query text. This is\n      a good safety measure when sending * binary parameters. */ /*\n      Convert integer value \"2\" to network byte order */\n      binaryIntVal = htonl((uint32_t) 2); /* Set up parameter\n      arrays for PQexecParams */ paramValues[0] = (char *)\n      &amp;binaryIntVal; paramLengths[0] = sizeof(binaryIntVal);\n      paramFormats[0] = 1; /* binary */ res = PQexecParams(conn,\n      \"SELECT * FROM test1 WHERE i = $1::int4\", 1, /* one param */\n      NULL, /* let the backend deduce param type */ paramValues,\n      paramLengths, paramFormats, 1); /* ask for binary results */\n      if (PQresultStatus(res) != PGRES_TUPLES_OK) { fprintf(stderr,\n      \"SELECT failed: %s\", PQerrorMessage(conn)); PQclear(res);\n      exit_nicely(conn); } show_binary_results(res); PQclear(res);\n      /* close the connection to the database and cleanup */\n      PQfinish(conn); return 0; }"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/libpq.xml:0(None)
msgid "translator-credits"
msgstr ""

