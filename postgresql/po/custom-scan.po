msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/custom-scan.xml:3(title)
msgid "Writing A Custom Scan Provider"
msgstr ""

#: xml/custom-scan.xml:5(primary)
msgid "custom scan provider"
msgstr ""

#: xml/custom-scan.xml:6(secondary)
msgid "handler for"
msgstr ""

#: xml/custom-scan.xml:8(para)
msgid "<productname>PostgreSQL</productname>supports a set of experimental facilities which are intended to allow extension modules to add new scan types to the system. Unlike a <link linkend=\"fdwhandler\">foreign data wrapper</link>, which is only responsible for knowing how to scan its own foreign tables, a custom scan provider can provide an alternative method of scanning any relation in the system. Typically, the motivation for writing a custom scan provider will be to allow the use of some optimization not supported by the core system, such as caching or some form of hardware acceleration. This chapter outlines how to write a new custom scan provider."
msgstr ""

#: xml/custom-scan.xml:20(para)
msgid "Implementing a new type of custom scan is a three-step process. First, during planning, it is necessary to generate access paths representing a scan using the proposed strategy. Second, if one of those access paths is selected by the planner as the optimal strategy for scanning a particular relation, the access path must be converted to a plan. Finally, it must be possible to execute the plan and generate the same results that would have been generated for any other access path targeting the same relation."
msgstr ""

#: xml/custom-scan.xml:30(title)
msgid "Creating Custom Scan Paths"
msgstr ""

#: xml/custom-scan.xml:35(programlisting)
#, no-wrap
msgid "typedef void (*set_rel_pathlist_hook_type)\n    (PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry\n    *rte); extern PGDLLIMPORT set_rel_pathlist_hook_type\n    set_rel_pathlist_hook;"
msgstr ""

#: xml/custom-scan.xml:31(para)
msgid "A custom scan provider will typically add paths for a base relation by setting the following hook, which is called after the core code has generated what it believes to be the complete and correct set of access paths for the relation. <placeholder-1/>"
msgstr ""

#: xml/custom-scan.xml:48(programlisting)
#, no-wrap
msgid "typedef struct CustomPath { Path path; uint32\n    flags; List *custom_paths; List *custom_private; const\n    CustomPathMethods *methods; }\n    CustomPath;"
msgstr ""

#: xml/custom-scan.xml:39(para)
msgid "Although this hook function can be used to examine, modify, or remove paths generated by the core system, a custom scan provider will typically confine itself to generating <structname>CustomPath</structname>objects and adding them to <literal>rel</literal>using <function>add_path</function>. The custom scan provider is responsible for initializing the <structname>CustomPath</structname>object, which is declared like this: <placeholder-1/>"
msgstr ""

#: xml/custom-scan.xml:52(para)
msgid "<structfield>path</structfield>must be initialized as for any other path, including the row-count estimate, start and total cost, and sort ordering provided by this path. <structfield>flags</structfield>is a bit mask, which should include <literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</literal>if the custom path can support a backward scan and <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>if it can support mark and restore. Both capabilities are optional. An optional <structfield>custom_paths</structfield>is a list of <structname>Path</structname>nodes used by this custom-path node; these will be transformed into <structname>Plan</structname>nodes by planner. <structfield>custom_private</structfield>can be used to store the custom path's private data. Private data should be stored in a form that can be handled by <literal>nodeToString</literal>, so that debugging routines that attempt to print the custom path will work as designed. <structfield>methods</structfield>must point to a (usually statically allocated) object implementing the required custom path methods, of which there are currently only two, as further detailed below."
msgstr ""

#: xml/custom-scan.xml:83(programlisting)
#, no-wrap
msgid "typedef void (*set_join_pathlist_hook_type)\n    (PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *outerrel,\n    RelOptInfo *innerrel, JoinType jointype, JoinPathExtraData\n    *extra); extern PGDLLIMPORT set_join_pathlist_hook_type\n    set_join_pathlist_hook;"
msgstr ""

#: xml/custom-scan.xml:76(para)
msgid "A custom scan provider can also provide join paths. Just as for base relations, such a path must produce the same output as would normally be produced by the join it replaces. To do this, the join provider should set the following hook, and then within the hook function, create <structname>CustomPath</structname>path(s) for the join relation. <placeholder-1/>This hook will be invoked repeatedly for the same join relation, with different combinations of inner and outer relations; it is the responsibility of the hook to minimize duplicated work."
msgstr ""

#: xml/custom-scan.xml:92(title)
msgid "Custom Scan Path Callbacks"
msgstr ""

#: xml/custom-scan.xml:94(programlisting)
#, no-wrap
msgid "Plan *(*PlanCustomPath) (PlannerInfo *root,\n      RelOptInfo *rel, CustomPath *best_path, List *tlist, List\n      *clauses, List *custom_plans);"
msgstr ""

#: xml/custom-scan.xml:93(para)
msgid "<placeholder-1/>Convert a custom path to a finished plan. The return value will generally be a <literal>CustomScan</literal>object, which the callback must allocate and initialize. See <xref linkend=\"custom-scan-plan\">for more details.</xref>"
msgstr ""

#: xml/custom-scan.xml:104(programlisting)
#, no-wrap
msgid "void (*TextOutCustomPath) (StringInfo str,\n      const CustomPath *node);"
msgstr ""

#: xml/custom-scan.xml:103(para)
msgid "<placeholder-1/>Generate additional output when <function>nodeToString</function>is invoked on this custom path. This callback is optional. Since <function>nodeToString</function>will automatically dump all fields in the structure that it can see, including <structfield>custom_private</structfield>, this is only useful if the <structname>CustomPath</structname>is actually embedded in a larger struct containing additional fields."
msgstr ""

#: xml/custom-scan.xml:118(title)
msgid "Creating Custom Scan Plans"
msgstr ""

#: xml/custom-scan.xml:121(programlisting)
#, no-wrap
msgid "typedef struct CustomScan { Scan scan; uint32\n    flags; List *custom_plans; List *custom_exprs; List\n    *custom_private; List *custom_scan_tlist; Bitmapset\n    *custom_relids; const CustomScanMethods *methods; }\n    CustomScan;"
msgstr ""

#: xml/custom-scan.xml:119(para)
msgid "A custom scan is represented in a finished plan tree using the following structure: <placeholder-1/>"
msgstr ""

#: xml/custom-scan.xml:126(para)
msgid "<structfield>scan</structfield>must be initialized as for any other scan, including estimated costs, target lists, qualifications, and so on. <structfield>flags</structfield>is a bit mask with the same meaning as in <structname>CustomPath</structname>. <structfield>custom_plans</structfield>can be used to store child <structname>Plan</structname>nodes. <structfield>custom_exprs</structfield>should be used to store expression trees that will need to be fixed up by <filename>setrefs.c</filename>and <filename>subselect.c</filename>, while <structfield>custom_private</structfield>should be used to store other private data that is only used by the custom scan provider itself. <structfield>custom_scan_tlist</structfield>can be NIL when scanning a base relation, indicating that the custom scan returns scan tuples that match the base relation's row type. Otherwise it is a target list describing the actual scan tuples. <structfield>custom_scan_tlist</structfield>must be provided for joins, and could be provided for scans if the custom scan provider can compute some non-Var expressions. <structfield>custom_relids</structfield>is set by the core code to the set of relations (range table indexes) that this scan node handles; except when this scan is replacing a join, it will have only one member. <structfield>methods</structfield>must point to a (usually statically allocated) object implementing the required custom scan methods, which are further detailed below."
msgstr ""

#: xml/custom-scan.xml:158(para)
msgid "When a <structname>CustomScan</structname>scans a single relation, <structfield>scan.scanrelid</structfield>must be the range table index of the table to be scanned. When it replaces a join, <structfield>scan.scanrelid</structfield>should be zero."
msgstr ""

#: xml/custom-scan.xml:164(para)
msgid "Plan trees must be able to be duplicated using <function>copyObject</function>, so all the data stored within the <quote>custom</quote>fields must consist of nodes that that function can handle. Furthermore, custom scan providers cannot substitute a larger structure that embeds a <structname>CustomScan</structname>for the structure itself, as would be possible for a <structname>CustomPath</structname>or <structname>CustomScanState</structname>."
msgstr ""

#: xml/custom-scan.xml:175(title)
msgid "Custom Scan Plan Callbacks"
msgstr ""

#: xml/custom-scan.xml:177(programlisting)
#, no-wrap
msgid "Node *(*CreateCustomScanState) (CustomScan\n      *cscan);"
msgstr ""

#: xml/custom-scan.xml:176(para)
msgid "<placeholder-1/>Allocate a <structname>CustomScanState</structname>for this <structname>CustomScan</structname>. The actual allocation will often be larger than required for an ordinary <structname>CustomScanState</structname>, because many providers will wish to embed that as the first field of a larger structure. The value returned must have the node tag and <structfield>methods</structfield>set appropriately, but other fields should be left as zeroes at this stage; after <function>ExecInitCustomScan</function>performs basic initialization, the <function>BeginCustomScan</function>callback will be invoked to give the custom scan provider a chance to do whatever else is needed."
msgstr ""

#: xml/custom-scan.xml:194(programlisting)
#, no-wrap
msgid "void (*TextOutCustomScan) (StringInfo str,\n      const CustomScan *node);"
msgstr ""

#: xml/custom-scan.xml:193(para)
msgid "<placeholder-1/>Generate additional output when <function>nodeToString</function>is invoked on this custom plan node. This callback is optional. Since <function>nodeToString</function>will automatically dump all fields in the structure, including the substructure of the <quote>custom</quote>fields, there is usually not much need for this callback."
msgstr ""

#: xml/custom-scan.xml:206(title)
msgid "Executing Custom Scans"
msgstr ""

#: xml/custom-scan.xml:212(programlisting)
#, no-wrap
msgid "typedef struct CustomScanState { ScanState ss;\n    uint32 flags; const CustomExecMethods *methods; }\n    CustomScanState;"
msgstr ""

#: xml/custom-scan.xml:207(para)
msgid "When a <structfield>CustomScan</structfield>is executed, its execution state is represented by a <structfield>CustomScanState</structfield>, which is declared as follows: <placeholder-1/>"
msgstr ""

#: xml/custom-scan.xml:215(para)
msgid "<structfield>ss</structfield>is initialized as for any other scan state, except that if the scan is for a join rather than a base relation, <literal>ss.ss_currentRelation</literal>is left NULL. <structfield>flags</structfield>is a bit mask with the same meaning as in <structname>CustomPath</structname>and <structname>CustomScan</structname>. <structfield>methods</structfield>must point to a (usually statically allocated) object implementing the required custom scan state methods, which are further detailed below. Typically, a <structname>CustomScanState</structname>, which need not support <function>copyObject</function>, will actually be a larger structure embedding the above as its first member."
msgstr ""

#: xml/custom-scan.xml:233(title)
msgid "Custom Scan Execution Callbacks"
msgstr ""

#: xml/custom-scan.xml:235(programlisting)
#, no-wrap
msgid "void (*BeginCustomScan) (CustomScanState\n      *node, EState *estate, int eflags);"
msgstr ""

#: xml/custom-scan.xml:234(para)
msgid "<placeholder-1/>Complete initialization of the supplied <structname>CustomScanState</structname>. Standard fields have been initialized by <function>ExecInitCustomScan</function>, but any private fields should be initialized here."
msgstr ""

#: xml/custom-scan.xml:243(programlisting)
#, no-wrap
msgid "TupleTableSlot *(*ExecCustomScan)\n      (CustomScanState *node);"
msgstr ""

#: xml/custom-scan.xml:242(para)
msgid "<placeholder-1/>Fetch the next scan tuple. If any tuples remain, it should fill <literal>ps_ResultTupleSlot</literal>with the next tuple in the current scan direction, and then return the tuple slot. If not, <literal>NULL</literal>or an empty slot should be returned."
msgstr ""

#: xml/custom-scan.xml:252(programlisting)
#, no-wrap
msgid "void (*EndCustomScan) (CustomScanState\n      *node);"
msgstr ""

#: xml/custom-scan.xml:251(para)
msgid "<placeholder-1/>Clean up any private data associated with the <literal>CustomScanState</literal>. This method is required, but it does not need to do anything if there is no associated data or it will be cleaned up automatically."
msgstr ""

#: xml/custom-scan.xml:259(programlisting)
#, no-wrap
msgid "void (*ReScanCustomScan) (CustomScanState\n      *node);"
msgstr ""

#: xml/custom-scan.xml:258(para)
msgid "<placeholder-1/>Rewind the current scan to the beginning and prepare to rescan the relation."
msgstr ""

#: xml/custom-scan.xml:263(programlisting)
#, no-wrap
msgid "void (*MarkPosCustomScan) (CustomScanState\n      *node);"
msgstr ""

#: xml/custom-scan.xml:262(para)
msgid "<placeholder-1/>Save the current scan position so that it can subsequently be restored by the <function>RestrPosCustomScan</function>callback. This callback is optional, and need only be supplied if the <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>flag is set."
msgstr ""

#: xml/custom-scan.xml:271(programlisting)
#, no-wrap
msgid "void (*RestrPosCustomScan) (CustomScanState\n      *node);"
msgstr ""

#: xml/custom-scan.xml:270(para)
msgid "<placeholder-1/>Restore the previous scan position as saved by the <function>MarkPosCustomScan</function>callback. This callback is optional, and need only be supplied if the <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>flag is set."
msgstr ""

#: xml/custom-scan.xml:279(programlisting)
#, no-wrap
msgid "void (*ExplainCustomScan) (CustomScanState\n      *node, List *ancestors, ExplainState\n      *es);"
msgstr ""

#: xml/custom-scan.xml:278(para)
msgid "<placeholder-1/>Output additional information for <command>EXPLAIN</command>of a custom-scan plan node. This callback is optional. Common data stored in the <structname>ScanState</structname>, such as the target list and scan relation, will be shown even without this callback, but the callback allows the display of additional, private state."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/custom-scan.xml:0(None)
msgid "translator-credits"
msgstr ""

