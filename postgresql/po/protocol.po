msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/protocol.xml:3(title)
msgid "Frontend/Backend Protocol"
msgstr ""

#: xml/protocol.xml:5(primary)
msgid "protocol"
msgstr ""

#: xml/protocol.xml:6(secondary)
msgid "frontend-backend"
msgstr ""

#: xml/protocol.xml:8(para)
msgid "<productname>PostgreSQL</productname>uses a message-based protocol for communication between frontends and backends (clients and servers). The protocol is supported over <acronym>TCP/IP</acronym>and also over Unix-domain sockets. Port number 5432 has been registered with IANA as the customary TCP port number for servers supporting this protocol, but in practice any non-privileged port number can be used."
msgstr ""

#: xml/protocol.xml:16(para)
msgid "This document describes version 3.0 of the protocol, implemented in <productname>PostgreSQL</productname>7.4 and later. For descriptions of the earlier protocol versions, see previous releases of the <productname>PostgreSQL</productname>documentation. A single server can support multiple protocol versions. The initial startup-request message tells the server which protocol version the client is attempting to use, and then the server follows that protocol if it is able."
msgstr ""

#: xml/protocol.xml:26(para)
msgid "In order to serve multiple clients efficiently, the server launches a new <quote>backend</quote>process for each client. In the current implementation, a new child process is created immediately after an incoming connection is detected. This is transparent to the protocol, however. For purposes of the protocol, the terms <quote>backend</quote>and <quote>server</quote>are interchangeable; likewise <quote>frontend</quote>and <quote>client</quote>are interchangeable."
msgstr ""

#: xml/protocol.xml:37(title)
msgid "Overview"
msgstr ""

#: xml/protocol.xml:38(para)
msgid "The protocol has separate phases for startup and normal operation. In the startup phase, the frontend opens a connection to the server and authenticates itself to the satisfaction of the server. (This might involve a single message, or multiple messages depending on the authentication method being used.) If all goes well, the server then sends status information to the frontend, and finally enters normal operation. Except for the initial startup-request message, this part of the protocol is driven by the server."
msgstr ""

#: xml/protocol.xml:47(para)
msgid "During normal operation, the frontend sends queries and other commands to the backend, and the backend sends back query results and other responses. There are a few cases (such as <command>NOTIFY</command>) wherein the backend will send unsolicited messages, but for the most part this portion of a session is driven by frontend requests."
msgstr ""

#: xml/protocol.xml:53(para)
msgid "Termination of the session is normally by frontend choice, but can be forced by the backend in certain cases. In any case, when the backend closes the connection, it will roll back any open (incomplete) transaction before exiting."
msgstr ""

#: xml/protocol.xml:57(para)
msgid "Within normal operation, SQL commands can be executed through either of two sub-protocols. In the <quote>simple query</quote>protocol, the frontend just sends a textual query string, which is parsed and immediately executed by the backend. In the <quote>extended query</quote>protocol, processing of queries is separated into multiple steps: parsing, binding of parameter values, and execution. This offers flexibility and performance benefits, at the cost of extra complexity."
msgstr ""

#: xml/protocol.xml:66(para)
msgid "Normal operation has additional sub-protocols for special operations such as <command>COPY</command>."
msgstr ""

#: xml/protocol.xml:70(title)
msgid "Messaging Overview"
msgstr ""

#: xml/protocol.xml:71(para)
msgid "All communication is through a stream of messages. The first byte of a message identifies the message type, and the next four bytes specify the length of the rest of the message (this length count includes itself, but not the message-type byte). The remaining contents of the message are determined by the message type. For historical reasons, the very first message sent by the client (the startup message) has no initial message-type byte."
msgstr ""

#: xml/protocol.xml:79(para)
msgid "To avoid losing synchronization with the message stream, both servers and clients typically read an entire message into a buffer (using the byte count) before attempting to process its contents. This allows easy recovery if an error is detected while processing the contents. In extreme situations (such as not having enough memory to buffer the message), the receiver can use the byte count to determine how much input to skip before it resumes reading messages."
msgstr ""

#: xml/protocol.xml:88(para)
msgid "Conversely, both servers and clients must take care never to send an incomplete message. This is commonly done by marshaling the entire message in a buffer before beginning to send it. If a communications failure occurs partway through sending or receiving a message, the only sensible response is to abandon the connection, since there is little hope of recovering message-boundary synchronization."
msgstr ""

#: xml/protocol.xml:97(title)
msgid "Extended Query Overview"
msgstr ""

#: xml/protocol.xml:98(para)
msgid "In the extended-query protocol, execution of SQL commands is divided into multiple steps. The state retained between steps is represented by two types of objects: <firstterm>prepared statements</firstterm>and <firstterm>portals</firstterm>. A prepared statement represents the result of parsing and semantic analysis of a textual query string. A prepared statement is not in itself ready to execute, because it might lack specific values for <firstterm>parameters</firstterm>. A portal represents a ready-to-execute or already-partially-executed statement, with any missing parameter values filled in. (For <command>SELECT</command>statements, a portal is equivalent to an open cursor, but we choose to use a different term since cursors don't handle non- <command>SELECT</command>statements.)"
msgstr ""

#: xml/protocol.xml:113(para)
msgid "The overall execution cycle consists of a <firstterm>parse</firstterm>step, which creates a prepared statement from a textual query string; a <firstterm>bind</firstterm>step, which creates a portal given a prepared statement and values for any needed parameters; and an <firstterm>execute</firstterm>step that runs a portal's query. In the case of a query that returns rows ( <command>SELECT</command>, <command>SHOW</command>, etc), the execute step can be told to fetch only a limited number of rows, so that multiple execute steps might be needed to complete the operation."
msgstr ""

#: xml/protocol.xml:126(para)
msgid "The backend can keep track of multiple prepared statements and portals (but note that these exist only within a session, and are never shared across sessions). Existing prepared statements and portals are referenced by names assigned when they were created. In addition, an <quote>unnamed</quote>prepared statement and portal exist. Although these behave largely the same as named objects, operations on them are optimized for the case of executing a query only once and then discarding it, whereas operations on named objects are optimized on the expectation of multiple uses."
msgstr ""

#: xml/protocol.xml:139(title)
msgid "Formats and Format Codes"
msgstr ""

#: xml/protocol.xml:140(para)
msgid "Data of a particular data type might be transmitted in any of several different <firstterm>formats</firstterm>. As of <productname>PostgreSQL</productname>7.4 the only supported formats are <quote>text</quote>and <quote>binary</quote>, but the protocol makes provision for future extensions. The desired format for any value is specified by a <firstterm>format code</firstterm>. Clients can specify a format code for each transmitted parameter value and for each column of a query result. Text has format code zero, binary has format code one, and all other format codes are reserved for future definition."
msgstr ""

#: xml/protocol.xml:154(para)
msgid "The text representation of values is whatever strings are produced and accepted by the input/output conversion functions for the particular data type. In the transmitted representation, there is no trailing null character; the frontend must add one to received values if it wants to process them as C strings. (The text format does not allow embedded nulls, by the way.)"
msgstr ""

#: xml/protocol.xml:161(para)
msgid "Binary representations for integers use network byte order (most significant byte first). For other data types consult the documentation or source code to learn about the binary representation. Keep in mind that binary representations for complex data types might change across server versions; the text format is usually the more portable choice."
msgstr ""

#: xml/protocol.xml:171(title)
msgid "Message Flow"
msgstr ""

#: xml/protocol.xml:172(para)
msgid "This section describes the message flow and the semantics of each message type. (Details of the exact representation of each message appear in <xref linkend=\"protocol-message-formats\">.) There are several different sub-protocols depending on the state of the connection: start-up, query, function call, <command>COPY</command>, and termination. There are also special provisions for asynchronous operations (including notification responses and command cancellation), which can occur at any time after the start-up phase.</xref>"
msgstr ""

#: xml/protocol.xml:183(title)
msgid "Start-up"
msgstr ""

#: xml/protocol.xml:184(para)
msgid "To begin a session, a frontend opens a connection to the server and sends a startup message. This message includes the names of the user and of the database the user wants to connect to; it also identifies the particular protocol version to be used. (Optionally, the startup message can include additional settings for run-time parameters.) The server then uses this information and the contents of its configuration files (such as <filename>pg_hba.conf</filename>) to determine whether the connection is provisionally acceptable, and what additional authentication is required (if any)."
msgstr ""

#: xml/protocol.xml:195(para)
msgid "The server then sends an appropriate authentication request message, to which the frontend must reply with an appropriate authentication response message (such as a password). For all authentication methods except GSSAPI and SSPI, there is at most one request and one response. In some methods, no response at all is needed from the frontend, and so no authentication request occurs. For GSSAPI and SSPI, multiple exchanges of packets may be needed to complete the authentication."
msgstr ""

#: xml/protocol.xml:204(para)
msgid "The authentication cycle ends with the server either rejecting the connection attempt (ErrorResponse), or sending AuthenticationOk."
msgstr ""

#: xml/protocol.xml:211(term) xml/protocol.xml:369(term) xml/protocol.xml:456(term) xml/protocol.xml:758(term)
msgid "ErrorResponse"
msgstr ""

#: xml/protocol.xml:213(para)
msgid "The connection attempt has been rejected. The server then immediately closes the connection."
msgstr ""

#: xml/protocol.xml:218(term)
msgid "AuthenticationOk"
msgstr ""

#: xml/protocol.xml:220(para)
msgid "The authentication exchange is successfully completed."
msgstr ""

#: xml/protocol.xml:225(term)
msgid "AuthenticationKerberosV5"
msgstr ""

#: xml/protocol.xml:227(para)
msgid "The frontend must now take part in a Kerberos V5 authentication dialog (not described here, part of the Kerberos specification) with the server. If this is successful, the server responds with an AuthenticationOk, otherwise it responds with an ErrorResponse. This is no longer supported."
msgstr ""

#: xml/protocol.xml:236(term)
msgid "AuthenticationCleartextPassword"
msgstr ""

#: xml/protocol.xml:238(para)
msgid "The frontend must now send a PasswordMessage containing the password in clear-text form. If this is the correct password, the server responds with an AuthenticationOk, otherwise it responds with an ErrorResponse."
msgstr ""

#: xml/protocol.xml:246(term)
msgid "AuthenticationMD5Password"
msgstr ""

#: xml/protocol.xml:248(para)
msgid "The frontend must now send a PasswordMessage containing the password (with user name) encrypted via MD5, then encrypted again using the 4-byte random salt specified in the AuthenticationMD5Password message. If this is the correct password, the server responds with an AuthenticationOk, otherwise it responds with an ErrorResponse. The actual PasswordMessage can be computed in SQL as <literal>concat('md5', md5(concat(md5(concat(password, username)), random-salt)))</literal>. (Keep in mind the <function>md5()</function>function returns its result as a hex string.)"
msgstr ""

#: xml/protocol.xml:264(term)
msgid "AuthenticationSCMCredential"
msgstr ""

#: xml/protocol.xml:266(para)
msgid "This response is only possible for local Unix-domain connections on platforms that support SCM credential messages. The frontend must issue an SCM credential message and then send a single data byte. (The contents of the data byte are uninteresting; it's only used to ensure that the server waits long enough to receive the credential message.) If the credential is acceptable, the server responds with an AuthenticationOk, otherwise it responds with an ErrorResponse. (This message type is only issued by pre-9.1 servers. It may eventually be removed from the protocol specification.)"
msgstr ""

#: xml/protocol.xml:281(term)
msgid "AuthenticationGSS"
msgstr ""

#: xml/protocol.xml:283(para)
msgid "The frontend must now initiate a GSSAPI negotiation. The frontend will send a PasswordMessage with the first part of the GSSAPI data stream in response to this. If further messages are needed, the server will respond with AuthenticationGSSContinue."
msgstr ""

#: xml/protocol.xml:292(term)
msgid "AuthenticationSSPI"
msgstr ""

#: xml/protocol.xml:294(para)
msgid "The frontend must now initiate a SSPI negotiation. The frontend will send a PasswordMessage with the first part of the SSPI data stream in response to this. If further messages are needed, the server will respond with AuthenticationGSSContinue."
msgstr ""

#: xml/protocol.xml:302(term)
msgid "AuthenticationGSSContinue"
msgstr ""

#: xml/protocol.xml:304(para)
msgid "This message contains the response data from the previous step of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI or a previous AuthenticationGSSContinue). If the GSSAPI or SSPI data in this message indicates more data is needed to complete the authentication, the frontend must send that data as another PasswordMessage. If GSSAPI or SSPI authentication is completed by this message, the server will next send AuthenticationOk to indicate successful authentication or ErrorResponse to indicate failure."
msgstr ""

#: xml/protocol.xml:207(para)
msgid "The possible messages from the server in this phase are: <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:318(para)
msgid "If the frontend does not support the authentication method requested by the server, then it should immediately close the connection."
msgstr ""

#: xml/protocol.xml:321(para)
msgid "After having received AuthenticationOk, the frontend must wait for further messages from the server. In this phase a backend process is being started, and the frontend is just an interested bystander. It is still possible for the startup attempt to fail (ErrorResponse), but in the normal case the backend will send some ParameterStatus messages, BackendKeyData, and finally ReadyForQuery."
msgstr ""

#: xml/protocol.xml:328(para)
msgid "During this phase the backend will attempt to apply any additional run-time parameter settings that were given in the startup message. If successful, these values become session defaults. An error causes ErrorResponse and exit."
msgstr ""

#: xml/protocol.xml:336(term)
msgid "BackendKeyData"
msgstr ""

#: xml/protocol.xml:338(para)
msgid "This message provides secret-key data that the frontend must save if it wants to be able to issue cancel requests later. The frontend should not respond to this message, but should continue listening for a ReadyForQuery message."
msgstr ""

#: xml/protocol.xml:346(term)
msgid "ParameterStatus"
msgstr ""

#: xml/protocol.xml:348(para)
msgid "This message informs the frontend about the current (initial) setting of backend parameters, such as <xref linkend=\"guc-client-encoding\">or <xref linkend=\"guc-datestyle\">. The frontend can ignore this message, or record the settings for its future use; see <xref linkend=\"protocol-async\">for more details. The frontend should not respond to this message, but should continue listening for a ReadyForQuery message.</xref></xref></xref>"
msgstr ""

#: xml/protocol.xml:362(term) xml/protocol.xml:462(term) xml/protocol.xml:773(term)
msgid "ReadyForQuery"
msgstr ""

#: xml/protocol.xml:364(para)
msgid "Start-up is completed. The frontend can now issue commands."
msgstr ""

#: xml/protocol.xml:371(para)
msgid "Start-up failed. The connection is closed after sending this message."
msgstr ""

#: xml/protocol.xml:376(term) xml/protocol.xml:474(term) xml/protocol.xml:781(term)
msgid "NoticeResponse"
msgstr ""

#: xml/protocol.xml:378(para)
msgid "A warning message has been issued. The frontend should display the message but continue listening for ReadyForQuery or ErrorResponse."
msgstr ""

#: xml/protocol.xml:332(para)
msgid "The possible messages from the backend in this phase are: <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:384(para)
msgid "The ReadyForQuery message is the same one that the backend will issue after each command cycle. Depending on the coding needs of the frontend, it is reasonable to consider ReadyForQuery as starting a command cycle, or to consider ReadyForQuery as ending the start-up phase and each subsequent command cycle."
msgstr ""

#: xml/protocol.xml:392(title)
msgid "Simple Query"
msgstr ""

#: xml/protocol.xml:393(para)
msgid "A simple query cycle is initiated by the frontend sending a Query message to the backend. The message includes an SQL command (or commands) expressed as a text string. The backend then sends one or more response messages depending on the contents of the query command string, and finally a ReadyForQuery response message. ReadyForQuery informs the frontend that it can safely send a new command. (It is not actually necessary for the frontend to wait for ReadyForQuery before issuing another command, but the frontend must then take responsibility for figuring out what happens if the earlier command fails and already-issued later commands succeed.)"
msgstr ""

#: xml/protocol.xml:408(term)
msgid "CommandComplete"
msgstr ""

#: xml/protocol.xml:410(para)
msgid "An SQL command completed normally."
msgstr ""

#: xml/protocol.xml:414(term)
msgid "CopyInResponse"
msgstr ""

#: xml/protocol.xml:416(para)
msgid "The backend is ready to copy data from the frontend to a table; see <xref linkend=\"protocol-copy\">.</xref>"
msgstr ""

#: xml/protocol.xml:422(term)
msgid "CopyOutResponse"
msgstr ""

#: xml/protocol.xml:424(para)
msgid "The backend is ready to copy data from a table to the frontend; see <xref linkend=\"protocol-copy\">.</xref>"
msgstr ""

#: xml/protocol.xml:430(term)
msgid "RowDescription"
msgstr ""

#: xml/protocol.xml:432(para)
msgid "Indicates that rows are about to be returned in response to a <command>SELECT</command>, <command>FETCH</command>, etc query. The contents of this message describe the column layout of the rows. This will be followed by a DataRow message for each row being returned to the frontend."
msgstr ""

#: xml/protocol.xml:442(term)
msgid "DataRow"
msgstr ""

#: xml/protocol.xml:444(para)
msgid "One of the set of rows returned by a <command>SELECT</command>, <command>FETCH</command>, etc query."
msgstr ""

#: xml/protocol.xml:450(term)
msgid "EmptyQueryResponse"
msgstr ""

#: xml/protocol.xml:452(para)
msgid "An empty query string was recognized."
msgstr ""

#: xml/protocol.xml:458(para) xml/protocol.xml:760(para)
msgid "An error has occurred."
msgstr ""

#: xml/protocol.xml:464(para)
msgid "Processing of the query string is complete. A separate message is sent to indicate this because the query string might contain multiple SQL commands. (CommandComplete marks the end of processing one SQL command, not the whole string.) ReadyForQuery will always be sent, whether processing terminates successfully or with an error."
msgstr ""

#: xml/protocol.xml:476(para)
msgid "A warning message has been issued in relation to the query. Notices are in addition to other responses, i.e., the backend will continue processing the command."
msgstr ""

#: xml/protocol.xml:405(para) xml/protocol.xml:755(para)
msgid "The possible response messages from the backend are: <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:483(para)
msgid "The response to a <command>SELECT</command>query (or other queries that return row sets, such as <command>EXPLAIN</command>or <command>SHOW</command>) normally consists of RowDescription, zero or more DataRow messages, and then CommandComplete. <command>COPY</command>to or from the frontend invokes special protocol as described in <xref linkend=\"protocol-copy\">. All other query types normally produce only a CommandComplete message.</xref>"
msgstr ""

#: xml/protocol.xml:494(para)
msgid "Since a query string could contain several queries (separated by semicolons), there might be several such response sequences before the backend finishes processing the query string. ReadyForQuery is issued when the entire string has been processed and the backend is ready to accept a new query string."
msgstr ""

#: xml/protocol.xml:500(para)
msgid "If a completely empty (no contents other than whitespace) query string is received, the response is EmptyQueryResponse followed by ReadyForQuery."
msgstr ""

#: xml/protocol.xml:503(para)
msgid "In the event of an error, ErrorResponse is issued followed by ReadyForQuery. All further processing of the query string is aborted by ErrorResponse (even if more queries remained in it). Note that this might occur partway through the sequence of messages generated by an individual query."
msgstr ""

#: xml/protocol.xml:509(para)
msgid "In simple Query mode, the format of retrieved values is always text, except when the given command is a <command>FETCH</command>from a cursor declared with the <literal>BINARY</literal>option. In that case, the retrieved values are in binary format. The format codes given in the RowDescription message tell which format is being used."
msgstr ""

#: xml/protocol.xml:516(para)
msgid "A frontend must be prepared to accept ErrorResponse and NoticeResponse messages whenever it is expecting any other type of message. See also <xref linkend=\"protocol-async\">concerning messages that the backend might generate due to outside events.</xref>"
msgstr ""

#: xml/protocol.xml:521(para)
msgid "Recommended practice is to code frontends in a state-machine style that will accept any message type at any time that it could make sense, rather than wiring in assumptions about the exact sequence of messages."
msgstr ""

#: xml/protocol.xml:527(title)
msgid "Extended Query"
msgstr ""

#: xml/protocol.xml:528(para)
msgid "The extended query protocol breaks down the above-described simple query protocol into multiple steps. The results of preparatory steps can be re-used multiple times for improved efficiency. Furthermore, additional features are available, such as the possibility of supplying data values as separate parameters instead of having to insert them directly into a query string."
msgstr ""

#: xml/protocol.xml:535(para)
msgid "In the extended protocol, the frontend first sends a Parse message, which contains a textual query string, optionally some information about data types of parameter placeholders, and the name of a destination prepared-statement object (an empty string selects the unnamed prepared statement). The response is either ParseComplete or ErrorResponse. Parameter data types can be specified by OID; if not given, the parser attempts to infer the data types in the same way as it would do for untyped literal string constants."
msgstr ""

#: xml/protocol.xml:546(para)
msgid "A parameter data type can be left unspecified by setting it to zero, or by making the array of parameter type OIDs shorter than the number of parameter symbols ( <literal>$</literal><replaceable>n</replaceable>) used in the query string. Another special case is that a parameter's type can be specified as <type>void</type>(that is, the OID of the <type>void</type>pseudotype). This is meant to allow parameter symbols to be used for function parameters that are actually OUT parameters. Ordinarily there is no context in which a <type>void</type>parameter could be used, but if such a parameter symbol appears in a function's parameter list, it is effectively ignored. For example, a function call such as <literal>foo($1,$2,$3,$4)</literal>could match a function with two IN and two OUT arguments, if <literal>$3</literal>and <literal>$4</literal>are specified as having type <type>void</type>."
msgstr ""

#: xml/protocol.xml:569(para)
msgid "The query string contained in a Parse message cannot include more than one SQL statement; else a syntax error is reported. This restriction does not exist in the simple-query protocol, but it does exist in the extended protocol, because allowing prepared statements or portals to contain multiple commands would complicate the protocol unduly."
msgstr ""

#: xml/protocol.xml:577(para)
msgid "If successfully created, a named prepared-statement object lasts till the end of the current session, unless explicitly destroyed. An unnamed prepared statement lasts only until the next Parse statement specifying the unnamed statement as destination is issued. (Note that a simple Query message also destroys the unnamed statement.) Named prepared statements must be explicitly closed before they can be redefined by another Parse message, but this is not required for the unnamed statement. Named prepared statements can also be created and accessed at the SQL command level, using <command>PREPARE</command>and <command>EXECUTE</command>."
msgstr ""

#: xml/protocol.xml:589(para)
msgid "Once a prepared statement exists, it can be readied for execution using a Bind message. The Bind message gives the name of the source prepared statement (empty string denotes the unnamed prepared statement), the name of the destination portal (empty string denotes the unnamed portal), and the values to use for any parameter placeholders present in the prepared statement. The supplied parameter set must match those needed by the prepared statement. (If you declared any <type>void</type>parameters in the Parse message, pass NULL values for them in the Bind message.) Bind also specifies the format to use for any data returned by the query; the format can be specified overall, or per-column. The response is either BindComplete or ErrorResponse."
msgstr ""

#: xml/protocol.xml:603(para)
msgid "The choice between text and binary output is determined by the format codes given in Bind, regardless of the SQL command involved. The <literal>BINARY</literal>attribute in cursor declarations is irrelevant when using extended query protocol."
msgstr ""

#: xml/protocol.xml:609(para)
msgid "Query planning typically occurs when the Bind message is processed. If the prepared statement has no parameters, or is executed repeatedly, the server might save the created plan and re-use it during subsequent Bind messages for the same prepared statement. However, it will do so only if it finds that a generic plan can be created that is not much less efficient than a plan that depends on the specific parameter values supplied. This happens transparently so far as the protocol is concerned."
msgstr ""

#: xml/protocol.xml:618(para)
msgid "If successfully created, a named portal object lasts till the end of the current transaction, unless explicitly destroyed. An unnamed portal is destroyed at the end of the transaction, or as soon as the next Bind statement specifying the unnamed portal as destination is issued. (Note that a simple Query message also destroys the unnamed portal.) Named portals must be explicitly closed before they can be redefined by another Bind message, but this is not required for the unnamed portal. Named portals can also be created and accessed at the SQL command level, using <command>DECLARE CURSOR</command>and <command>FETCH</command>."
msgstr ""

#: xml/protocol.xml:630(para)
msgid "Once a portal exists, it can be executed using an Execute message. The Execute message specifies the portal name (empty string denotes the unnamed portal) and a maximum result-row count (zero meaning <quote>fetch all rows</quote>). The result-row count is only meaningful for portals containing commands that return row sets; in other cases the command is always executed to completion, and the row count is ignored. The possible responses to Execute are the same as those described above for queries issued via simple query protocol, except that Execute doesn't cause ReadyForQuery or RowDescription to be issued."
msgstr ""

#: xml/protocol.xml:642(para)
msgid "If Execute terminates before completing the execution of a portal (due to reaching a nonzero result-row count), it will send a PortalSuspended message; the appearance of this message tells the frontend that another Execute should be issued against the same portal to complete the operation. The CommandComplete message indicating completion of the source SQL command is not sent until the portal's execution is completed. Therefore, an Execute phase is always terminated by the appearance of exactly one of these messages: CommandComplete, EmptyQueryResponse (if the portal was created from an empty query string), ErrorResponse, or PortalSuspended."
msgstr ""

#: xml/protocol.xml:654(para)
msgid "At completion of each series of extended-query messages, the frontend should issue a Sync message. This parameterless message causes the backend to close the current transaction if it's not inside a <command>BEGIN</command>/ <command>COMMIT</command>transaction block ( <quote>close</quote>meaning to commit if no error, or roll back if error). Then a ReadyForQuery response is issued. The purpose of Sync is to provide a resynchronization point for error recovery. When an error is detected while processing any extended-query message, the backend issues ErrorResponse, then reads and discards messages until a Sync is reached, then issues ReadyForQuery and returns to normal message processing. (But note that no skipping occurs if an error is detected <emphasis>while</emphasis>processing Sync this ensures that there is one and only one ReadyForQuery sent for each Sync.)"
msgstr ""

#: xml/protocol.xml:673(para)
msgid "Sync does not cause a transaction block opened with <command>BEGIN</command>to be closed. It is possible to detect this situation since the ReadyForQuery message includes transaction status information."
msgstr ""

#: xml/protocol.xml:678(para)
msgid "In addition to these fundamental, required operations, there are several optional operations that can be used with extended-query protocol."
msgstr ""

#: xml/protocol.xml:681(para)
msgid "The Describe message (portal variant) specifies the name of an existing portal (or an empty string for the unnamed portal). The response is a RowDescription message describing the rows that will be returned by executing the portal; or a NoData message if the portal does not contain a query that will return rows; or ErrorResponse if there is no such portal."
msgstr ""

#: xml/protocol.xml:688(para)
msgid "The Describe message (statement variant) specifies the name of an existing prepared statement (or an empty string for the unnamed prepared statement). The response is a ParameterDescription message describing the parameters needed by the statement, followed by a RowDescription message describing the rows that will be returned when the statement is eventually executed (or a NoData message if the statement will not return rows). ErrorResponse is issued if there is no such prepared statement. Note that since Bind has not yet been issued, the formats to be used for returned columns are not yet known to the backend; the format code fields in the RowDescription message will be zeroes in this case."
msgstr ""

#: xml/protocol.xml:701(para)
msgid "In most scenarios the frontend should issue one or the other variant of Describe before issuing Execute, to ensure that it knows how to interpret the results it will get back."
msgstr ""

#: xml/protocol.xml:706(para)
msgid "The Close message closes an existing prepared statement or portal and releases resources. It is not an error to issue Close against a nonexistent statement or portal name. The response is normally CloseComplete, but could be ErrorResponse if some difficulty is encountered while releasing resources. Note that closing a prepared statement implicitly closes any open portals that were constructed from that statement."
msgstr ""

#: xml/protocol.xml:714(para)
msgid "The Flush message does not cause any specific output to be generated, but forces the backend to deliver any data pending in its output buffers. A Flush must be sent after any extended-query command except Sync, if the frontend wishes to examine the results of that command before issuing more commands. Without Flush, messages returned by the backend will be combined into the minimum possible number of packets to minimize network overhead."
msgstr ""

#: xml/protocol.xml:723(para)
msgid "The simple Query message is approximately equivalent to the series Parse, Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared statement and portal objects and no parameters. One difference is that it will accept multiple SQL statements in the query string, automatically performing the bind/describe/execute sequence for each one in succession. Another difference is that it will not return ParseComplete, BindComplete, CloseComplete, or NoData messages."
msgstr ""

#: xml/protocol.xml:735(title)
msgid "Function Call"
msgstr ""

#: xml/protocol.xml:736(para)
msgid "The Function Call sub-protocol allows the client to request a direct call of any function that exists in the database's <structname>pg_proc</structname>system catalog. The client must have execute permission for the function."
msgstr ""

#: xml/protocol.xml:742(para)
msgid "The Function Call sub-protocol is a legacy feature that is probably best avoided in new code. Similar results can be accomplished by setting up a prepared statement that does <literal>SELECT function($1, ...)</literal>. The Function Call cycle can then be replaced with Bind/Execute."
msgstr ""

#: xml/protocol.xml:749(para)
msgid "A Function Call cycle is initiated by the frontend sending a FunctionCall message to the backend. The backend then sends one or more response messages depending on the results of the function call, and finally a ReadyForQuery response message. ReadyForQuery informs the frontend that it can safely send a new query or function call."
msgstr ""

#: xml/protocol.xml:764(term)
msgid "FunctionCallResponse"
msgstr ""

#: xml/protocol.xml:766(para)
msgid "The function call was completed and returned the result given in the message. (Note that the Function Call protocol can only handle a single scalar result, not a row type or set of results.)"
msgstr ""

#: xml/protocol.xml:775(para)
msgid "Processing of the function call is complete. ReadyForQuery will always be sent, whether processing terminates successfully or with an error."
msgstr ""

#: xml/protocol.xml:783(para)
msgid "A warning message has been issued in relation to the function call. Notices are in addition to other responses, i.e., the backend will continue processing the command."
msgstr ""

#: xml/protocol.xml:792(title)
msgid "COPY Operations"
msgstr ""

#: xml/protocol.xml:793(para)
msgid "The <command>COPY</command>command allows high-speed bulk data transfer to or from the server. Copy-in and copy-out operations each switch the connection into a distinct sub-protocol, which lasts until the operation is completed."
msgstr ""

#: xml/protocol.xml:799(para)
msgid "Copy-in mode (data transfer to the server) is initiated when the backend executes a <command>COPY FROM STDIN</command>SQL statement. The backend sends a CopyInResponse message to the frontend. The frontend should then send zero or more CopyData messages, forming a stream of input data. (The message boundaries are not required to have anything to do with row boundaries, although that is often a reasonable choice.) The frontend can terminate the copy-in mode by sending either a CopyDone message (allowing successful termination) or a CopyFail message (which will cause the <command>COPY</command>SQL statement to fail with an error). The backend then reverts to the command-processing mode it was in before the <command>COPY</command>started, which will be either simple or extended query protocol. It will next send either CommandComplete (if successful) or ErrorResponse (if not)."
msgstr ""

#: xml/protocol.xml:817(para)
msgid "In the event of a backend-detected error during copy-in mode (including receipt of a CopyFail message), the backend will issue an ErrorResponse message. If the <command>COPY</command>command was issued via an extended-query message, the backend will now discard frontend messages until a Sync message is received, then it will issue ReadyForQuery and return to normal processing. If the <command>COPY</command>command was issued in a simple Query message, the rest of that message is discarded and ReadyForQuery is issued. In either case, any subsequent CopyData, CopyDone, or CopyFail messages issued by the frontend will simply be dropped."
msgstr ""

#: xml/protocol.xml:829(para)
msgid "The backend will ignore Flush and Sync messages received during copy-in mode. Receipt of any other non-copy message type constitutes an error that will abort the copy-in state as described above. (The exception for Flush and Sync is for the convenience of client libraries that always send Flush or Sync after an Execute message, without checking whether the command to be executed is a <command>COPY FROM STDIN</command>.)"
msgstr ""

#: xml/protocol.xml:837(para)
msgid "Copy-out mode (data transfer from the server) is initiated when the backend executes a <command>COPY TO STDOUT</command>SQL statement. The backend sends a CopyOutResponse message to the frontend, followed by zero or more CopyData messages (always one per row), followed by CopyDone. The backend then reverts to the command-processing mode it was in before the <command>COPY</command>started, and sends CommandComplete. The frontend cannot abort the transfer (except by closing the connection or issuing a Cancel request), but it can discard unwanted CopyData and CopyDone messages."
msgstr ""

#: xml/protocol.xml:848(para)
msgid "In the event of a backend-detected error during copy-out mode, the backend will issue an ErrorResponse message and revert to normal processing. The frontend should treat receipt of ErrorResponse as terminating the copy-out mode."
msgstr ""

#: xml/protocol.xml:853(para)
msgid "It is possible for NoticeResponse and ParameterStatus messages to be interspersed between CopyData messages; frontends must handle these cases, and should be prepared for other asynchronous message types as well (see <xref linkend=\"protocol-async\">). Otherwise, any message type other than CopyData or CopyDone may be treated as terminating copy-out mode.</xref>"
msgstr ""

#: xml/protocol.xml:860(para)
msgid "There is another Copy-related mode called copy-both, which allows high-speed bulk data transfer to <emphasis>and</emphasis>from the server. Copy-both mode is initiated when a backend in walsender mode executes a <command>START_REPLICATION</command>statement. The backend sends a CopyBothResponse message to the frontend. Both the backend and the frontend may then send CopyData messages until either end sends a CopyDone message. After the client sends a CopyDone message, the connection goes from copy-both mode to copy-out mode, and the client may not send any more CopyData messages. Similarly, when the server sends a CopyDone message, the connection goes into copy-in mode, and the server may not send any more CopyData messages. After both sides have sent a CopyDone message, the copy mode is terminated, and the backend reverts to the command-processing mode. In the event of a backend-detected error during copy-both mode, the backend will issue an ErrorResponse message, discard frontend messages until a Sync message is received, and then issue ReadyForQuery and return to normal processing. The frontend should treat receipt of ErrorResponse as terminating the copy in both directions; no CopyDone should be sent in this case. See <xref linkend=\"protocol-replication\">for more information on the subprotocol transmitted over copy-both mode.</xref>"
msgstr ""

#: xml/protocol.xml:885(para)
msgid "The CopyInResponse, CopyOutResponse and CopyBothResponse messages include fields that inform the frontend of the number of columns per row and the format codes being used for each column. (As of the present implementation, all columns in a given <command>COPY</command>operation will use the same format, but the message design does not assume this.)"
msgstr ""

#: xml/protocol.xml:894(title)
msgid "Asynchronous Operations"
msgstr ""

#: xml/protocol.xml:895(para)
msgid "There are several cases in which the backend will send messages that are not specifically prompted by the frontend's command stream. Frontends must be prepared to deal with these messages at any time, even when not engaged in a query. At minimum, one should check for these cases before beginning to read a query response."
msgstr ""

#: xml/protocol.xml:901(para)
msgid "It is possible for NoticeResponse messages to be generated due to outside activity; for example, if the database administrator commands a <quote>fast</quote>database shutdown, the backend will send a NoticeResponse indicating this fact before closing the connection. Accordingly, frontends should always be prepared to accept and display NoticeResponse messages, even when the connection is nominally idle."
msgstr ""

#: xml/protocol.xml:909(para)
msgid "ParameterStatus messages will be generated whenever the active value changes for any of the parameters the backend believes the frontend should know about. Most commonly this occurs in response to a <command>SET</command>SQL command executed by the frontend, and this case is effectively synchronous but it is also possible for parameter status changes to occur because the administrator changed a configuration file and then sent the <systemitem>SIGHUP</systemitem>signal to the server. Also, if a <command>SET</command>command is rolled back, an appropriate ParameterStatus message will be generated to report the current effective value."
msgstr ""

#: xml/protocol.xml:922(para)
msgid "At present there is a hard-wired set of parameters for which ParameterStatus will be generated: they are <varname>server_version</varname>, <varname>server_encoding</varname>, <varname>client_encoding</varname>, <varname>application_name</varname>, <varname>is_superuser</varname>, <varname>session_authorization</varname>, <varname>DateStyle</varname>, <varname>IntervalStyle</varname>, <varname>TimeZone</varname>, <varname>integer_datetimes</varname>, and <varname>standard_conforming_strings</varname>. ( <varname>server_encoding</varname>, <varname>TimeZone</varname>, and <varname>integer_datetimes</varname>were not reported by releases before 8.0; <varname>standard_conforming_strings</varname>was not reported by releases before 8.1; <varname>IntervalStyle</varname>was not reported by releases before 8.4; <varname>application_name</varname>was not reported by releases before 9.0.) Note that <varname>server_version</varname>, <varname>server_encoding</varname>and <varname>integer_datetimes</varname>are pseudo-parameters that cannot change after startup. This set might change in the future, or even become configurable. Accordingly, a frontend should simply ignore ParameterStatus for parameters that it does not understand or care about."
msgstr ""

#: xml/protocol.xml:952(para)
msgid "If a frontend issues a <command>LISTEN</command>command, then the backend will send a NotificationResponse message (not to be confused with NoticeResponse!) whenever a <command>NOTIFY</command>command is executed for the same channel name."
msgstr ""

#: xml/protocol.xml:959(para)
msgid "At present, NotificationResponse can only be sent outside a transaction, and thus it will not occur in the middle of a command-response series, though it might occur just before ReadyForQuery. It is unwise to design frontend logic that assumes that, however. Good practice is to be able to accept NotificationResponse at any point in the protocol."
msgstr ""

#: xml/protocol.xml:969(title)
msgid "Canceling Requests in Progress"
msgstr ""

#: xml/protocol.xml:970(para)
msgid "During the processing of a query, the frontend might request cancellation of the query. The cancel request is not sent directly on the open connection to the backend for reasons of implementation efficiency: we don't want to have the backend constantly checking for new input from the frontend during query processing. Cancel requests should be relatively infrequent, so we make them slightly cumbersome in order to avoid a penalty in the normal case."
msgstr ""

#: xml/protocol.xml:978(para)
msgid "To issue a cancel request, the frontend opens a new connection to the server and sends a CancelRequest message, rather than the StartupMessage message that would ordinarily be sent across a new connection. The server will process this request and then close the connection. For security reasons, no direct reply is made to the cancel request message."
msgstr ""

#: xml/protocol.xml:984(para)
msgid "A CancelRequest message will be ignored unless it contains the same key data (PID and secret key) passed to the frontend during connection start-up. If the request matches the PID and secret key for a currently executing backend, the processing of the current query is aborted. (In the existing implementation, this is done by sending a special signal to the backend process that is processing the query.)"
msgstr ""

#: xml/protocol.xml:991(para)
msgid "The cancellation signal might or might not have any effect for example, if it arrives after the backend has finished processing the query, then it will have no effect. If the cancellation is effective, it results in the current command being terminated early with an error message."
msgstr ""

#: xml/protocol.xml:996(para)
msgid "The upshot of all this is that for reasons of both security and efficiency, the frontend has no direct way to tell whether a cancel request has succeeded. It must continue to wait for the backend to respond to the query. Issuing a cancel simply improves the odds that the current query will finish soon, and improves the odds that it will fail with an error message instead of succeeding."
msgstr ""

#: xml/protocol.xml:1003(para)
msgid "Since the cancel request is sent across a new connection to the server and not across the regular frontend/backend communication link, it is possible for the cancel request to be issued by any process, not just the frontend whose query is to be canceled. This might provide additional flexibility when building multiple-process applications. It also introduces a security risk, in that unauthorized persons might try to cancel queries. The security risk is addressed by requiring a dynamically generated secret key to be supplied in cancel requests."
msgstr ""

#: xml/protocol.xml:1016(title)
msgid "Termination"
msgstr ""

#: xml/protocol.xml:1017(para)
msgid "The normal, graceful termination procedure is that the frontend sends a Terminate message and immediately closes the connection. On receipt of this message, the backend closes the connection and terminates."
msgstr ""

#: xml/protocol.xml:1021(para)
msgid "In rare cases (such as an administrator-commanded database shutdown) the backend might disconnect without any frontend request to do so. In such cases the backend will attempt to send an error or notice message giving the reason for the disconnection before it closes the connection."
msgstr ""

#: xml/protocol.xml:1026(para)
msgid "Other termination scenarios arise from various failure cases, such as core dump at one end or the other, loss of the communications link, loss of message-boundary synchronization, etc. If either frontend or backend sees an unexpected closure of the connection, it should clean up and terminate. The frontend has the option of launching a new backend by recontacting the server if it doesn't want to terminate itself. Closing the connection is also advisable if an unrecognizable message type is received, since this probably indicates loss of message-boundary sync."
msgstr ""

#: xml/protocol.xml:1036(para)
msgid "For either normal or abnormal termination, any open transaction is rolled back, not committed. One should note however that if a frontend disconnects while a non- <command>SELECT</command>query is being processed, the backend will probably finish the query before noticing the disconnection. If the query is outside any transaction block ( <command>BEGIN</command>... <command>COMMIT</command>sequence) then its results might be committed before the disconnection is recognized."
msgstr ""

#: xml/protocol.xml:1048(title)
msgid "<acronym>SSL</acronym>Session Encryption"
msgstr ""

#: xml/protocol.xml:1050(para)
msgid "If <productname>PostgreSQL</productname>was built with <acronym>SSL</acronym>support, frontend/backend communications can be encrypted using <acronym>SSL</acronym>. This provides communication security in environments where attackers might be able to capture the session traffic. For more information on encrypting <productname>PostgreSQL</productname>sessions with <acronym>SSL</acronym>, see <xref linkend=\"ssl-tcp\">.</xref>"
msgstr ""

#: xml/protocol.xml:1060(para)
msgid "To initiate an <acronym>SSL</acronym>-encrypted connection, the frontend initially sends an SSLRequest message rather than a StartupMessage. The server then responds with a single byte containing <literal>S</literal>or <literal>N</literal>, indicating that it is willing or unwilling to perform <acronym>SSL</acronym>, respectively. The frontend might close the connection at this point if it is dissatisfied with the response. To continue after <literal>S</literal>, perform an <acronym>SSL</acronym>startup handshake (not described here, part of the <acronym>SSL</acronym>specification) with the server. If this is successful, continue with sending the usual StartupMessage. In this case the StartupMessage and all subsequent data will be <acronym>SSL</acronym>-encrypted. To continue after <literal>N</literal>, send the usual StartupMessage and proceed without encryption."
msgstr ""

#: xml/protocol.xml:1081(para)
msgid "The frontend should also be prepared to handle an ErrorMessage response to SSLRequest from the server. This would only occur if the server predates the addition of <acronym>SSL</acronym>support to <productname>PostgreSQL</productname>. (Such servers are now very ancient, and likely do not exist in the wild anymore.) In this case the connection must be closed, but the frontend might choose to open a fresh connection and proceed without requesting <acronym>SSL</acronym>."
msgstr ""

#: xml/protocol.xml:1091(para)
msgid "An initial SSLRequest can also be used in a connection that is being opened to send a CancelRequest message."
msgstr ""

#: xml/protocol.xml:1093(para)
msgid "While the protocol itself does not provide a way for the server to force <acronym>SSL</acronym>encryption, the administrator can configure the server to reject unencrypted sessions as a byproduct of authentication checking."
msgstr ""

#: xml/protocol.xml:1101(title)
msgid "Streaming Replication Protocol"
msgstr ""

#: xml/protocol.xml:1102(para)
msgid "To initiate streaming replication, the frontend sends the <literal>replication</literal>parameter in the startup message. A Boolean value of <literal>true</literal>tells the backend to go into walsender mode, wherein a small set of replication commands can be issued instead of SQL statements. Only the simple query protocol can be used in walsender mode. Replication commands are logged in the server log when <xref linkend=\"guc-log-replication-commands\">is enabled. Passing <literal>database</literal>as the value instructs walsender to connect to the database specified in the <literal>dbname</literal>parameter, which will allow the connection to be used for logical replication from that database.</xref>"
msgstr ""

#: xml/protocol.xml:1124(programlisting)
#, no-wrap
msgid "psql \"dbname=postgres replication=database\" -c\n    \"IDENTIFY_SYSTEM;\""
msgstr ""

#: xml/protocol.xml:1118(para)
msgid "For the purpose of testing replication commands, you can make a replication connection via <application>psql</application>or any other <literal>libpq</literal>-using tool with a connection string including the <literal>replication</literal>option, e.g.: <placeholder-1/>However it is often more useful to use <application>pg_receivexlog</application>(for physical replication) or <application>pg_recvlogical</application>(for logical replication)."
msgstr ""

#: xml/protocol.xml:1134(term)
msgid "IDENTIFY_SYSTEM <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>"
msgstr ""

#: xml/protocol.xml:1139(para)
msgid "Requests the server to identify itself. Server replies with a result set of a single row, containing four fields:"
msgstr ""

#: xml/protocol.xml:1145(term)
msgid "systemid"
msgstr ""

#: xml/protocol.xml:1147(para)
msgid "The unique system identifier identifying the cluster. This can be used to check that the base backup used to initialize the standby came from the same cluster."
msgstr ""

#: xml/protocol.xml:1154(term)
msgid "timeline"
msgstr ""

#: xml/protocol.xml:1156(para)
msgid "Current TimelineID. Also useful to check that the standby is consistent with the master."
msgstr ""

#: xml/protocol.xml:1162(term)
msgid "xlogpos"
msgstr ""

#: xml/protocol.xml:1164(para)
msgid "Current xlog flush location. Useful to get a known location in the transaction log where streaming can start."
msgstr ""

#: xml/protocol.xml:1170(term)
msgid "dbname"
msgstr ""

#: xml/protocol.xml:1172(para)
msgid "Database connected to or NULL."
msgstr ""

#: xml/protocol.xml:1180(term)
msgid "TIMELINE_HISTORY <replaceable class=\"parameter\">tli</replaceable><indexterm><primary>TIMELINE_HISTORY</primary></indexterm>"
msgstr ""

#: xml/protocol.xml:1186(para)
msgid "Requests the server to send over the timeline history file for timeline <replaceable class=\"parameter\">tli</replaceable>. Server replies with a result set of a single row, containing two fields:"
msgstr ""

#: xml/protocol.xml:1194(term)
msgid "filename"
msgstr ""

#: xml/protocol.xml:1196(para)
msgid "Filename of the timeline history file, e.g <filename>00000002.history</filename>."
msgstr ""

#: xml/protocol.xml:1201(term)
msgid "content"
msgstr ""

#: xml/protocol.xml:1203(para)
msgid "Contents of the timeline history file."
msgstr ""

#: xml/protocol.xml:1212(term)
msgid "CREATE_REPLICATION_SLOT <replaceable class=\"parameter\">slot_name</replaceable>{ <literal>PHYSICAL</literal>| <literal>LOGICAL</literal><replaceable class=\"parameter\">output_plugin</replaceable>} <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>"
msgstr ""

#: xml/protocol.xml:1222(para)
msgid "Create a physical or logical replication slot. See <xref linkend=\"streaming-replication-slots\">for more about replication slots.</xref>"
msgstr ""

#: xml/protocol.xml:1228(replaceable) xml/protocol.xml:1547(replaceable) xml/protocol.xml:1605(replaceable)
msgid "slot_name"
msgstr ""

#: xml/protocol.xml:1232(para)
msgid "The name of the slot to create. Must be a valid replication slot name (see <xref linkend=\"streaming-replication-slots-manipulation\"> ).</xref>"
msgstr ""

#: xml/protocol.xml:1240(replaceable)
msgid "output_plugin"
msgstr ""

#: xml/protocol.xml:1244(para)
msgid "The name of the output plugin used for logical decoding (see <xref linkend=\"logicaldecoding-output-plugin\"> ).</xref>"
msgstr ""

#: xml/protocol.xml:1254(term)
msgid "START_REPLICATION [ <literal>SLOT</literal><replaceable class=\"parameter\">slot_name</replaceable>] [ <literal>PHYSICAL</literal>] <replaceable class=\"parameter\">XXX/XXX</replaceable>[ <literal>TIMELINE</literal><replaceable class=\"parameter\">tli</replaceable>] <indexterm><primary>START_REPLICATION</primary></indexterm>"
msgstr ""

#: xml/protocol.xml:1265(para)
msgid "Instructs server to start streaming WAL, starting at WAL position <replaceable class=\"parameter\">XXX/XXX</replaceable>. If <literal>TIMELINE</literal>option is specified, streaming starts on timeline <replaceable class=\"parameter\">tli</replaceable>; otherwise, the server's current timeline is selected. The server can reply with an error, e.g. if the requested section of WAL has already been recycled. On success, server responds with a CopyBothResponse message, and then starts to stream WAL to the frontend."
msgstr ""

#: xml/protocol.xml:1276(para)
msgid "If a slot's name is provided via <replaceable class=\"parameter\">slot_name</replaceable>, it will be updated as replication progresses so that the server knows which WAL segments, and if <varname>hot_standby_feedback</varname>is on which transactions, are still needed by the standby."
msgstr ""

#: xml/protocol.xml:1282(para)
msgid "If the client requests a timeline that's not the latest, but is part of the history of the server, the server will stream all the WAL on that timeline starting from the requested startpoint, up to the point where the server switched to another timeline. If the client requests streaming at exactly the end of an old timeline, the server responds immediately with CommandComplete without entering COPY mode."
msgstr ""

#: xml/protocol.xml:1290(para)
msgid "After streaming all the WAL on a timeline that is not the latest one, the server will end streaming by exiting the COPY mode. When the client acknowledges this by also exiting COPY mode, the server sends a result set with one row and two columns, indicating the next timeline in this server's history. The first column is the next timeline's ID, and the second column is the XLOG position where the switch happened. Usually, the switch position is the end of the WAL that was streamed, but there are corner cases where the server can send some WAL from the old timeline that it has not itself replayed before promoting. Finally, the server sends CommandComplete message, and is ready to accept a new command."
msgstr ""

#: xml/protocol.xml:1304(para)
msgid "WAL data is sent as a series of CopyData messages. (This allows other information to be intermixed; in particular the server can send an ErrorResponse message if it encounters a failure after beginning to stream.) The payload of each CopyData message from server to the client contains a message of one of the following formats:"
msgstr ""

#: xml/protocol.xml:1314(term)
msgid "XLogData (B)"
msgstr ""

#: xml/protocol.xml:1319(term)
msgid "Byte1('w')"
msgstr ""

#: xml/protocol.xml:1321(para)
msgid "Identifies the message as WAL data."
msgstr ""

#: xml/protocol.xml:1326(term) xml/protocol.xml:1333(term) xml/protocol.xml:1340(term) xml/protocol.xml:1381(term) xml/protocol.xml:1388(term) xml/protocol.xml:1429(term) xml/protocol.xml:1437(term) xml/protocol.xml:1444(term) xml/protocol.xml:1451(term) xml/protocol.xml:1489(term)
msgid "Int64"
msgstr ""

#: xml/protocol.xml:1328(para)
msgid "The starting point of the WAL data in this message."
msgstr ""

#: xml/protocol.xml:1335(para) xml/protocol.xml:1383(para)
msgid "The current end of WAL on the server."
msgstr ""

#: xml/protocol.xml:1342(para) xml/protocol.xml:1390(para)
msgid "The server's system clock at the time of transmission, as microseconds since midnight on 2000-01-01."
msgstr ""

#: xml/protocol.xml:1348(term) xml/protocol.xml:2162(term) xml/protocol.xml:2286(term) xml/protocol.xml:2558(term) xml/protocol.xml:2831(term) xml/protocol.xml:3083(term) xml/protocol.xml:3135(term)
msgid "Byte <replaceable>n</replaceable>"
msgstr ""

#: xml/protocol.xml:1351(para)
msgid "A section of the WAL data stream."
msgstr ""

#: xml/protocol.xml:1353(para)
msgid "A single WAL record is never split across two XLogData messages. When a WAL record crosses a WAL page boundary, and is therefore already split using continuation records, it can be split at the page boundary. In other words, the first main WAL record and its continuation records can be sent in different XLogData messages."
msgstr ""

#: xml/protocol.xml:1369(term)
msgid "Primary keepalive message (B)"
msgstr ""

#: xml/protocol.xml:1374(term)
msgid "Byte1('k')"
msgstr ""

#: xml/protocol.xml:1376(para)
msgid "Identifies the message as a sender keepalive."
msgstr ""

#: xml/protocol.xml:1396(term) xml/protocol.xml:1459(term) xml/protocol.xml:2409(term) xml/protocol.xml:2863(term) xml/protocol.xml:2932(term) xml/protocol.xml:3195(term) xml/protocol.xml:3525(term)
msgid "Byte1"
msgstr ""

#: xml/protocol.xml:1398(para)
msgid "1 means that the client should reply to this message as soon as possible, to avoid a timeout disconnect. 0 otherwise."
msgstr ""

#: xml/protocol.xml:1410(para)
msgid "The receiving process can send replies back to the sender at any time, using one of the following message formats (also in the payload of a CopyData message):"
msgstr ""

#: xml/protocol.xml:1417(term)
msgid "Standby status update (F)"
msgstr ""

#: xml/protocol.xml:1422(term)
msgid "Byte1('r')"
msgstr ""

#: xml/protocol.xml:1424(para)
msgid "Identifies the message as a receiver status update."
msgstr ""

#: xml/protocol.xml:1431(para)
msgid "The location of the last WAL byte + 1 received and written to disk in the standby."
msgstr ""

#: xml/protocol.xml:1439(para)
msgid "The location of the last WAL byte + 1 flushed to disk in the standby."
msgstr ""

#: xml/protocol.xml:1446(para)
msgid "The location of the last WAL byte + 1 applied in the standby."
msgstr ""

#: xml/protocol.xml:1453(para) xml/protocol.xml:1491(para)
msgid "The client's system clock at the time of transmission, as microseconds since midnight on 2000-01-01."
msgstr ""

#: xml/protocol.xml:1461(para)
msgid "If 1, the client requests the server to reply to this message immediately. This can be used to ping the server, to test if the connection is still healthy."
msgstr ""

#: xml/protocol.xml:1477(term)
msgid "Hot Standby feedback message (F)"
msgstr ""

#: xml/protocol.xml:1482(term)
msgid "Byte1('h')"
msgstr ""

#: xml/protocol.xml:1484(para)
msgid "Identifies the message as a Hot Standby feedback message."
msgstr ""

#: xml/protocol.xml:1497(term) xml/protocol.xml:1508(term) xml/protocol.xml:2148(term) xml/protocol.xml:2194(term) xml/protocol.xml:2200(term) xml/protocol.xml:2222(term) xml/protocol.xml:2276(term) xml/protocol.xml:2372(term) xml/protocol.xml:2379(term) xml/protocol.xml:2402(term) xml/protocol.xml:2465(term) xml/protocol.xml:2551(term) xml/protocol.xml:2609(term) xml/protocol.xml:2641(term) xml/protocol.xml:2696(term) xml/protocol.xml:2751(term) xml/protocol.xml:2804(term) xml/protocol.xml:2821(term) xml/protocol.xml:2856(term) xml/protocol.xml:2920(term) xml/protocol.xml:2966(term) xml/protocol.xml:2980(term) xml/protocol.xml:3028(term) xml/protocol.xml:3035(term) xml/protocol.xml:3073(term) xml/protocol.xml:3118(term) xml/protocol.xml:3125(term) xml/protocol.xml:3183(term) xml/protocol.xml:3229(term) xml/protocol.xml:3236(term) xml/protocol.xml:3274(term) xml/protocol.xml:3291(term) xml/protocol.xml:3313(term) xml/protocol.xml:3349(term) xml/protocol.xml:3383(term) xml/protocol.xml:3433(term) xml/protocol.xml:3488(term) xml/protocol.xml:3555(term) xml/protocol.xml:3578(term) xml/protocol.xml:3594(term) xml/protocol.xml:3609(term) xml/protocol.xml:3665(term)
msgid "Int32"
msgstr ""

#: xml/protocol.xml:1499(para)
msgid "The standby's current xmin. This may be 0, if the standby is sending notification that Hot Standby feedback will no longer be sent on this connection. Later non-zero messages may reinitiate the feedback mechanism."
msgstr ""

#: xml/protocol.xml:1510(para)
msgid "The standby's current epoch."
msgstr ""

#: xml/protocol.xml:1522(term)
msgid "START_REPLICATION <literal>SLOT</literal><replaceable class=\"parameter\">slot_name</replaceable><literal>LOGICAL</literal><replaceable class=\"parameter\">XXX/XXX</replaceable>[ ( <replaceable>option_name</replaceable>[ <replaceable>option_value</replaceable>] [, ... ] ) ]"
msgstr ""

#: xml/protocol.xml:1531(para)
msgid "Instructs server to start streaming WAL for logical replication, starting at WAL position <replaceable class=\"parameter\">XXX/XXX</replaceable>. The server can reply with an error, e.g. if the requested section of WAL has already been recycled. On success, server responds with a CopyBothResponse message, and then starts to stream WAL to the frontend."
msgstr ""

#: xml/protocol.xml:1538(para)
msgid "The messages inside the CopyBothResponse messages are of the same format documented for <literal>START_REPLICATION ... PHYSICAL</literal>."
msgstr ""

#: xml/protocol.xml:1541(para)
msgid "The output plugin associated with the selected slot is used to process the output for streaming."
msgstr ""

#: xml/protocol.xml:1546(literal)
msgid "SLOT"
msgstr ""

#: xml/protocol.xml:1551(para)
msgid "The name of the slot to stream changes from. This parameter is required, and must correspond to an existing logical replication slot created with <literal>CREATE_REPLICATION_SLOT</literal>in <literal>LOGICAL</literal>mode."
msgstr ""

#: xml/protocol.xml:1560(replaceable)
msgid "XXX/XXX"
msgstr ""

#: xml/protocol.xml:1564(para)
msgid "The WAL position to begin streaming at."
msgstr ""

#: xml/protocol.xml:1570(replaceable)
msgid "option_name"
msgstr ""

#: xml/protocol.xml:1574(para)
msgid "The name of an option passed to the slot's logical decoding plugin."
msgstr ""

#: xml/protocol.xml:1580(replaceable)
msgid "option_value"
msgstr ""

#: xml/protocol.xml:1584(para)
msgid "Optional value, in the form of a string constant, associated with the specified option."
msgstr ""

#: xml/protocol.xml:1593(term)
msgid "DROP_REPLICATION_SLOT <replaceable class=\"parameter\">slot_name</replaceable><indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>"
msgstr ""

#: xml/protocol.xml:1599(para)
msgid "Drops a replication slot, freeing any reserved server-side resources. If the slot is currently in use by an active connection, this command fails."
msgstr ""

#: xml/protocol.xml:1609(para)
msgid "The name of the slot to drop."
msgstr ""

#: xml/protocol.xml:1616(term)
msgid "BASE_BACKUP [ <literal>LABEL</literal><replaceable>'label'</replaceable>] [ <literal>PROGRESS</literal>] [ <literal>FAST</literal>] [ <literal>WAL</literal>] [ <literal>NOWAIT</literal>] [ <literal>MAX_RATE</literal><replaceable>rate</replaceable>] [ <literal>TABLESPACE_MAP</literal>] <indexterm><primary>BASE_BACKUP</primary></indexterm>"
msgstr ""

#: xml/protocol.xml:1638(literal)
msgid "LABEL"
msgstr ""

#: xml/protocol.xml:1639(replaceable)
msgid "'label'"
msgstr ""

#: xml/protocol.xml:1642(para)
msgid "Sets the label of the backup. If none is specified, a backup label of <literal>base backup</literal>will be used. The quoting rules for the label are the same as a standard SQL string with <xref linkend=\"guc-standard-conforming-strings\"> turned on.</xref>"
msgstr ""

#: xml/protocol.xml:1653(literal)
msgid "PROGRESS"
msgstr ""

#: xml/protocol.xml:1656(para)
msgid "Request information required to generate a progress report. This will send back an approximate size in the header of each tablespace, which can be used to calculate how far along the stream is done. This is calculated by enumerating all the file sizes once before the transfer is even started, and may as such have a negative impact on the performance - in particular it may take longer before the first data is streamed. Since the database files can change during the backup, the size is only approximate and may both grow and shrink between the time of approximation and the sending of the actual files."
msgstr ""

#: xml/protocol.xml:1673(literal)
msgid "FAST"
msgstr ""

#: xml/protocol.xml:1676(para)
msgid "Request a fast checkpoint."
msgstr ""

#: xml/protocol.xml:1681(literal)
msgid "WAL"
msgstr ""

#: xml/protocol.xml:1684(para)
msgid "Include the necessary WAL segments in the backup. This will include all the files between start and stop backup in the <filename>pg_xlog</filename>directory of the base directory tar file."
msgstr ""

#: xml/protocol.xml:1693(literal)
msgid "NOWAIT"
msgstr ""

#: xml/protocol.xml:1696(para)
msgid "By default, the backup will wait until the last required xlog segment has been archived, or emit a warning if log archiving is not enabled. Specifying <literal>NOWAIT</literal>disables both the waiting and the warning, leaving the client responsible for ensuring the required log is available."
msgstr ""

#: xml/protocol.xml:1707(literal)
msgid "MAX_RATE"
msgstr ""

#: xml/protocol.xml:1708(replaceable)
msgid "rate"
msgstr ""

#: xml/protocol.xml:1711(para)
msgid "Limit (throttle) the maximum amount of data transferred from server to client per unit of time. The expected unit is kilobytes per second. If this option is specified, the value must either be equal to zero or it must fall within the range from 32 kB through 1 GB (inclusive). If zero is passed or the option is not specified, no restriction is imposed on the transfer."
msgstr ""

#: xml/protocol.xml:1723(literal)
msgid "TABLESPACE_MAP"
msgstr ""

#: xml/protocol.xml:1726(para)
msgid "Include information about symbolic links present in the directory <filename>pg_tblspc</filename>in a file named <filename>tablespace_map</filename>. The tablespace map file includes each symbolic link name as it exists in the directory <filename>pg_tblspc/</filename>and the full path of that symbolic link."
msgstr ""

#: xml/protocol.xml:1630(para)
msgid "Instructs the server to start streaming a base backup. The system will automatically be put in backup mode before the backup is started, and taken out of it when the backup is complete. The following options are accepted: <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:1737(para)
msgid "When the backup is started, the server will first send two ordinary result sets, followed by one or more CopyResponse results."
msgstr ""

#: xml/protocol.xml:1740(para)
msgid "The first ordinary result set contains the starting position of the backup, in a single row with two columns. The first column contains the start position given in XLogRecPtr format, and the second column contains the corresponding timeline ID."
msgstr ""

#: xml/protocol.xml:1749(term)
msgid "spcoid"
msgstr ""

#: xml/protocol.xml:1751(para)
msgid "The oid of the tablespace, or <literal>NULL</literal>if it's the base directory."
msgstr ""

#: xml/protocol.xml:1757(term)
msgid "spclocation"
msgstr ""

#: xml/protocol.xml:1759(para)
msgid "The full path of the tablespace directory, or <literal>NULL</literal>if it's the base directory."
msgstr ""

#: xml/protocol.xml:1766(term)
msgid "size"
msgstr ""

#: xml/protocol.xml:1768(para)
msgid "The approximate size of the tablespace, if progress report has been requested; otherwise it's <literal>NULL</literal>."
msgstr ""

#: xml/protocol.xml:1745(para)
msgid "The second ordinary result set has one row for each tablespace. The fields in this row are: <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:1774(para)
msgid "After the second regular result set, one or more CopyResponse results will be sent, one for PGDATA and one for each additional tablespace other than <literal>pg_default</literal>and <literal>pg_global</literal>. The data in the CopyResponse results will be a tar format (following the <quote>ustar interchange format</quote>specified in the POSIX 1003.1-2008 standard) dump of the tablespace contents, except that the two trailing blocks of zeroes specified in the standard are omitted. After the tar data is complete, a final ordinary result set will be sent, containing the WAL end position of the backup, in the same format as the start position."
msgstr ""

#: xml/protocol.xml:1796(filename)
msgid "postmaster.pid"
msgstr ""

#: xml/protocol.xml:1801(filename)
msgid "postmaster.opts"
msgstr ""

#: xml/protocol.xml:1805(para)
msgid "various temporary files created during the operation of the PostgreSQL server"
msgstr ""

#: xml/protocol.xml:1809(para)
msgid "<filename>pg_xlog</filename>, including subdirectories. If the backup is run with WAL files included, a synthesized version of <filename>pg_xlog</filename>will be included, but it will only contain the files necessary for the backup to work, not the rest of the contents."
msgstr ""

#: xml/protocol.xml:1818(para)
msgid "<filename>pg_replslot</filename>is copied as an empty directory."
msgstr ""

#: xml/protocol.xml:1823(para)
msgid "Files other than regular files and directories, such as symbolic links and special device files, are skipped. (Symbolic links in <filename>pg_tblspc</filename>are maintained.)"
msgstr ""

#: xml/protocol.xml:1787(para)
msgid "The tar archive for the data directory and each tablespace will contain all files in the directories, regardless of whether they are <productname>PostgreSQL</productname>files or other files added to the same directory. The only excluded files are: <placeholder-1/>Owner, group and file mode are set if the underlying file system on the server supports it."
msgstr ""

#: xml/protocol.xml:1830(para)
msgid "Once all tablespaces have been sent, a final regular result set will be sent. This result set contains the end position of the backup, given in XLogRecPtr format as a single column in a single row."
msgstr ""

#: xml/protocol.xml:1131(para)
msgid "The commands accepted in walsender mode are: <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:1839(title)
msgid "Message Data Types"
msgstr ""

#: xml/protocol.xml:1844(term)
msgid "Int <replaceable>n</replaceable>( <replaceable>i</replaceable>)"
msgstr ""

#: xml/protocol.xml:1848(para)
msgid "An <replaceable>n</replaceable>-bit integer in network byte order (most significant byte first). If <replaceable>i</replaceable>is specified it is the exact value that will appear, otherwise the value is variable. Eg. Int16, Int32(42)."
msgstr ""

#: xml/protocol.xml:1857(term)
msgid "Int <replaceable>n</replaceable>[ <replaceable>k</replaceable>]"
msgstr ""

#: xml/protocol.xml:1861(para)
msgid "An array of <replaceable>k</replaceable><replaceable>n</replaceable>-bit integers, each in network byte order. The array length <replaceable>k</replaceable>is always determined by an earlier field in the message. Eg. Int16[M]."
msgstr ""

#: xml/protocol.xml:1870(term)
msgid "String( <replaceable>s</replaceable>)"
msgstr ""

#: xml/protocol.xml:1873(para)
msgid "A null-terminated string (C-style string). There is no specific length limitation on strings. If <replaceable>s</replaceable>is specified it is the exact value that will appear, otherwise the value is variable. Eg. String, String(\"user\")."
msgstr ""

#: xml/protocol.xml:1879(para)
msgid "<emphasis>There is no predefined limit</emphasis>on the length of a string that can be returned by the backend. Good coding strategy for a frontend is to use an expandable buffer so that anything that fits in memory can be accepted. If that's not feasible, read the full string and discard trailing characters that don't fit into your fixed-size buffer."
msgstr ""

#: xml/protocol.xml:1891(term)
msgid "Byte <replaceable>n</replaceable>( <replaceable>c</replaceable>)"
msgstr ""

#: xml/protocol.xml:1895(para)
msgid "Exactly <replaceable>n</replaceable>bytes. If the field width <replaceable>n</replaceable>is not a constant, it is always determinable from an earlier field in the message. If <replaceable>c</replaceable>is specified it is the exact value. Eg. Byte2, Byte1('\\n')."
msgstr ""

#: xml/protocol.xml:1840(para)
msgid "This section describes the base data types used in messages. <placeholder-1/>"
msgstr ""

#: xml/protocol.xml:1907(title)
msgid "Message Formats"
msgstr ""

#: xml/protocol.xml:1908(para)
msgid "This section describes the detailed format of each message. Each is marked to indicate that it can be sent by a frontend (F), a backend (B), or both (F B). Notice that although each message includes a byte count at the beginning, the message format is defined so that the message end can be found without reference to the byte count. This aids validity checking. (The CopyData message is an exception, because it forms part of a data stream; the contents of any individual CopyData message cannot be interpretable on their own.)"
msgstr ""

#: xml/protocol.xml:1919(term)
msgid "AuthenticationOk (B)"
msgstr ""

#: xml/protocol.xml:1924(term) xml/protocol.xml:1954(term) xml/protocol.xml:1984(term) xml/protocol.xml:2014(term) xml/protocol.xml:2051(term) xml/protocol.xml:2081(term) xml/protocol.xml:2111(term) xml/protocol.xml:2141(term)
msgid "Byte1('R')"
msgstr ""

#: xml/protocol.xml:1926(para) xml/protocol.xml:1956(para) xml/protocol.xml:1986(para) xml/protocol.xml:2016(para) xml/protocol.xml:2053(para) xml/protocol.xml:2083(para) xml/protocol.xml:2113(para) xml/protocol.xml:2143(para)
msgid "Identifies the message as an authentication request."
msgstr ""

#: xml/protocol.xml:1931(term) xml/protocol.xml:1961(term) xml/protocol.xml:1991(term) xml/protocol.xml:2058(term) xml/protocol.xml:2088(term) xml/protocol.xml:2118(term) xml/protocol.xml:2155(term) xml/protocol.xml:3635(term)
msgid "Int32(8)"
msgstr ""

#: xml/protocol.xml:1933(para) xml/protocol.xml:1963(para) xml/protocol.xml:1993(para) xml/protocol.xml:2023(para) xml/protocol.xml:2060(para) xml/protocol.xml:2090(para) xml/protocol.xml:2120(para) xml/protocol.xml:2150(para) xml/protocol.xml:2189(para) xml/protocol.xml:2224(para) xml/protocol.xml:2338(para) xml/protocol.xml:2354(para) xml/protocol.xml:2404(para) xml/protocol.xml:2444(para) xml/protocol.xml:2467(para) xml/protocol.xml:2553(para) xml/protocol.xml:2588(para) xml/protocol.xml:2611(para) xml/protocol.xml:2643(para) xml/protocol.xml:2698(para) xml/protocol.xml:2753(para) xml/protocol.xml:2806(para) xml/protocol.xml:2858(para) xml/protocol.xml:2900(para) xml/protocol.xml:2922(para) xml/protocol.xml:2968(para) xml/protocol.xml:3007(para) xml/protocol.xml:3030(para) xml/protocol.xml:3120(para) xml/protocol.xml:3163(para) xml/protocol.xml:3185(para) xml/protocol.xml:3231(para) xml/protocol.xml:3276(para) xml/protocol.xml:3315(para) xml/protocol.xml:3351(para) xml/protocol.xml:3408(para) xml/protocol.xml:3435(para) xml/protocol.xml:3467(para) xml/protocol.xml:3490(para) xml/protocol.xml:3520(para) xml/protocol.xml:3557(para) xml/protocol.xml:3637(para) xml/protocol.xml:3667(para) xml/protocol.xml:3759(para) xml/protocol.xml:3782(para)
msgid "Length of message contents in bytes, including self."
msgstr ""

#: xml/protocol.xml:1938(term)
msgid "Int32(0)"
msgstr ""

#: xml/protocol.xml:1940(para)
msgid "Specifies that the authentication was successful."
msgstr ""

#: xml/protocol.xml:1949(term)
msgid "AuthenticationKerberosV5 (B)"
msgstr ""

#: xml/protocol.xml:1968(term)
msgid "Int32(2)"
msgstr ""

#: xml/protocol.xml:1970(para)
msgid "Specifies that Kerberos V5 authentication is required."
msgstr ""

#: xml/protocol.xml:1979(term)
msgid "AuthenticationCleartextPassword (B)"
msgstr ""

#: xml/protocol.xml:1998(term)
msgid "Int32(3)"
msgstr ""

#: xml/protocol.xml:2000(para)
msgid "Specifies that a clear-text password is required."
msgstr ""

#: xml/protocol.xml:2009(term)
msgid "AuthenticationMD5Password (B)"
msgstr ""

#: xml/protocol.xml:2021(term) xml/protocol.xml:2187(term)
msgid "Int32(12)"
msgstr ""

#: xml/protocol.xml:2028(term) xml/protocol.xml:3518(term)
msgid "Int32(5)"
msgstr ""

#: xml/protocol.xml:2030(para)
msgid "Specifies that an MD5-encrypted password is required."
msgstr ""

#: xml/protocol.xml:2035(term)
msgid "Byte4"
msgstr ""

#: xml/protocol.xml:2037(para)
msgid "The salt to use when encrypting the password."
msgstr ""

#: xml/protocol.xml:2046(term)
msgid "AuthenticationSCMCredential (B)"
msgstr ""

#: xml/protocol.xml:2065(term)
msgid "Int32(6)"
msgstr ""

#: xml/protocol.xml:2067(para)
msgid "Specifies that an SCM credentials message is required."
msgstr ""

#: xml/protocol.xml:2076(term)
msgid "AuthenticationGSS (B)"
msgstr ""

#: xml/protocol.xml:2095(term)
msgid "Int32(7)"
msgstr ""

#: xml/protocol.xml:2097(para)
msgid "Specifies that GSSAPI authentication is required."
msgstr ""

#: xml/protocol.xml:2106(term)
msgid "AuthenticationSSPI (B)"
msgstr ""

#: xml/protocol.xml:2125(term)
msgid "Int32(9)"
msgstr ""

#: xml/protocol.xml:2127(para)
msgid "Specifies that SSPI authentication is required."
msgstr ""

#: xml/protocol.xml:2136(term)
msgid "AuthenticationGSSContinue (B)"
msgstr ""

#: xml/protocol.xml:2157(para)
msgid "Specifies that this message contains GSSAPI or SSPI data."
msgstr ""

#: xml/protocol.xml:2165(para)
msgid "GSSAPI or SSPI authentication data."
msgstr ""

#: xml/protocol.xml:2173(term)
msgid "BackendKeyData (B)"
msgstr ""

#: xml/protocol.xml:2178(term)
msgid "Byte1('K')"
msgstr ""

#: xml/protocol.xml:2180(para)
msgid "Identifies the message as cancellation key data. The frontend must save these values if it wishes to be able to issue CancelRequest messages later."
msgstr ""

#: xml/protocol.xml:2196(para)
msgid "The process ID of this backend."
msgstr ""

#: xml/protocol.xml:2202(para)
msgid "The secret key of this backend."
msgstr ""

#: xml/protocol.xml:2210(term)
msgid "Bind (F)"
msgstr ""

#: xml/protocol.xml:2215(term)
msgid "Byte1('B')"
msgstr ""

#: xml/protocol.xml:2217(para)
msgid "Identifies the message as a Bind command."
msgstr ""

#: xml/protocol.xml:2229(term) xml/protocol.xml:2236(term) xml/protocol.xml:2418(term) xml/protocol.xml:2472(term) xml/protocol.xml:2616(term) xml/protocol.xml:2873(term) xml/protocol.xml:2945(term) xml/protocol.xml:2973(term) xml/protocol.xml:3208(term) xml/protocol.xml:3243(term) xml/protocol.xml:3250(term) xml/protocol.xml:3320(term) xml/protocol.xml:3327(term) xml/protocol.xml:3356(term) xml/protocol.xml:3364(term) xml/protocol.xml:3440(term) xml/protocol.xml:3495(term) xml/protocol.xml:3572(term) xml/protocol.xml:3689(term) xml/protocol.xml:3736(term)
msgid "String"
msgstr ""

#: xml/protocol.xml:2231(para)
msgid "The name of the destination portal (an empty string selects the unnamed portal)."
msgstr ""

#: xml/protocol.xml:2238(para)
msgid "The name of the source prepared statement (an empty string selects the unnamed prepared statement)."
msgstr ""

#: xml/protocol.xml:2244(term) xml/protocol.xml:2265(term) xml/protocol.xml:2299(term) xml/protocol.xml:2661(term) xml/protocol.xml:2716(term) xml/protocol.xml:2771(term) xml/protocol.xml:2811(term) xml/protocol.xml:3042(term) xml/protocol.xml:3063(term) xml/protocol.xml:3096(term) xml/protocol.xml:3281(term) xml/protocol.xml:3370(term) xml/protocol.xml:3562(term) xml/protocol.xml:3586(term) xml/protocol.xml:3601(term) xml/protocol.xml:3617(term)
msgid "Int16"
msgstr ""

#: xml/protocol.xml:2246(para)
msgid "The number of parameter format codes that follow (denoted <replaceable>C</replaceable>below). This can be zero to indicate that there are no parameters or that the parameters all use the default format (text); or one, in which case the specified format code is applied to all parameters; or it can equal the actual number of parameters."
msgstr ""

#: xml/protocol.xml:2257(term) xml/protocol.xml:3055(term)
msgid "Int16[ <replaceable>C</replaceable>]"
msgstr ""

#: xml/protocol.xml:2260(para)
msgid "The parameter format codes. Each must presently be zero (text) or one (binary)."
msgstr ""

#: xml/protocol.xml:2267(para)
msgid "The number of parameter values that follow (possibly zero). This must match the number of parameters needed by the query."
msgstr ""

#: xml/protocol.xml:2278(para)
msgid "The length of the parameter value, in bytes (this count does not include itself). Can be zero. As a special case, -1 indicates a NULL parameter value. No value bytes follow in the NULL case."
msgstr ""

#: xml/protocol.xml:2289(para)
msgid "The value of the parameter, in the format indicated by the associated format code. <replaceable>n</replaceable>is the above length."
msgstr ""

#: xml/protocol.xml:2301(para)
msgid "The number of result-column format codes that follow (denoted <replaceable>R</replaceable>below). This can be zero to indicate that there are no result columns or that the result columns should all use the default format (text); or one, in which case the specified format code is applied to all result columns (if any); or it can equal the actual number of result columns of the query."
msgstr ""

#: xml/protocol.xml:2313(term)
msgid "Int16[ <replaceable>R</replaceable>]"
msgstr ""

#: xml/protocol.xml:2316(para)
msgid "The result-column format codes. Each must presently be zero (text) or one (binary)."
msgstr ""

#: xml/protocol.xml:2212(para)
msgid "<placeholder-1/>Next, the following pair of fields appear for each parameter: <placeholder-2/>After the last parameter, the following fields appear: <placeholder-3/>"
msgstr ""

#: xml/protocol.xml:2324(term)
msgid "BindComplete (B)"
msgstr ""

#: xml/protocol.xml:2329(term)
msgid "Byte1('2')"
msgstr ""

#: xml/protocol.xml:2331(para)
msgid "Identifies the message as a Bind-complete indicator."
msgstr ""

#: xml/protocol.xml:2336(term) xml/protocol.xml:2442(term) xml/protocol.xml:2586(term) xml/protocol.xml:2898(term) xml/protocol.xml:3005(term) xml/protocol.xml:3161(term) xml/protocol.xml:3406(term) xml/protocol.xml:3465(term) xml/protocol.xml:3757(term) xml/protocol.xml:3780(term)
msgid "Int32(4)"
msgstr ""

#: xml/protocol.xml:2347(term)
msgid "CancelRequest (F)"
msgstr ""

#: xml/protocol.xml:2352(term)
msgid "Int32(16)"
msgstr ""

#: xml/protocol.xml:2359(term)
msgid "Int32(80877102)"
msgstr ""

#: xml/protocol.xml:2361(para)
msgid "The cancel request code. The value is chosen to contain <literal>1234</literal>in the most significant 16 bits, and <literal>5678</literal>in the least 16 significant bits. (To avoid confusion, this code must not be the same as any protocol version number.)"
msgstr ""

#: xml/protocol.xml:2374(para)
msgid "The process ID of the target backend."
msgstr ""

#: xml/protocol.xml:2381(para)
msgid "The secret key for the target backend."
msgstr ""

#: xml/protocol.xml:2390(term)
msgid "Close (F)"
msgstr ""

#: xml/protocol.xml:2395(term) xml/protocol.xml:2458(term)
msgid "Byte1('C')"
msgstr ""

#: xml/protocol.xml:2397(para)
msgid "Identifies the message as a Close command."
msgstr ""

#: xml/protocol.xml:2411(para)
msgid "' <literal>S</literal>' to close a prepared statement; or ' <literal>P</literal>' to close a portal."
msgstr ""

#: xml/protocol.xml:2420(para)
msgid "The name of the prepared statement or portal to close (an empty string selects the unnamed prepared statement or portal)."
msgstr ""

#: xml/protocol.xml:2430(term)
msgid "CloseComplete (B)"
msgstr ""

#: xml/protocol.xml:2435(term)
msgid "Byte1('3')"
msgstr ""

#: xml/protocol.xml:2437(para)
msgid "Identifies the message as a Close-complete indicator."
msgstr ""

#: xml/protocol.xml:2453(term)
msgid "CommandComplete (B)"
msgstr ""

#: xml/protocol.xml:2460(para)
msgid "Identifies the message as a command-completed response."
msgstr ""

#: xml/protocol.xml:2474(para)
msgid "The command tag. This is usually a single word that identifies which SQL command was completed."
msgstr ""

#: xml/protocol.xml:2477(para)
msgid "For an <command>INSERT</command>command, the tag is <literal>INSERT <replaceable>oid</replaceable><replaceable>rows</replaceable></literal>, where <replaceable>rows</replaceable>is the number of rows inserted. <replaceable>oid</replaceable>is the object ID of the inserted row if <replaceable>rows</replaceable>is 1 and the target table has OIDs; otherwise <replaceable>oid</replaceable>is 0."
msgstr ""

#: xml/protocol.xml:2489(para)
msgid "For a <command>DELETE</command>command, the tag is <literal>DELETE <replaceable>rows</replaceable></literal>where <replaceable>rows</replaceable>is the number of rows deleted."
msgstr ""

#: xml/protocol.xml:2495(para)
msgid "For an <command>UPDATE</command>command, the tag is <literal>UPDATE <replaceable>rows</replaceable></literal>where <replaceable>rows</replaceable>is the number of rows updated."
msgstr ""

#: xml/protocol.xml:2501(para)
msgid "For a <command>SELECT</command>or <command>CREATE TABLE AS</command>command, the tag is <literal>SELECT <replaceable>rows</replaceable></literal>where <replaceable>rows</replaceable>is the number of rows retrieved."
msgstr ""

#: xml/protocol.xml:2509(para)
msgid "For a <command>MOVE</command>command, the tag is <literal>MOVE <replaceable>rows</replaceable></literal>where <replaceable>rows</replaceable>is the number of rows the cursor's position has been changed by."
msgstr ""

#: xml/protocol.xml:2516(para)
msgid "For a <command>FETCH</command>command, the tag is <literal>FETCH <replaceable>rows</replaceable></literal>where <replaceable>rows</replaceable>is the number of rows that have been retrieved from the cursor."
msgstr ""

#: xml/protocol.xml:2523(para)
msgid "For a <command>COPY</command>command, the tag is <literal>COPY <replaceable>rows</replaceable></literal>where <replaceable>rows</replaceable>is the number of rows copied. (Note: the row count appears only in <productname>PostgreSQL</productname>8.2 and later.)"
msgstr ""

#: xml/protocol.xml:2539(term)
msgid "CopyData (F B)"
msgstr ""

#: xml/protocol.xml:2544(term)
msgid "Byte1('d')"
msgstr ""

#: xml/protocol.xml:2546(para)
msgid "Identifies the message as <command>COPY</command>data."
msgstr ""

#: xml/protocol.xml:2561(para)
msgid "Data that forms part of a <command>COPY</command>data stream. Messages sent from the backend will always correspond to single data rows, but messages sent by frontends might divide the data stream arbitrarily."
msgstr ""

#: xml/protocol.xml:2573(term)
msgid "CopyDone (F B)"
msgstr ""

#: xml/protocol.xml:2578(term)
msgid "Byte1('c')"
msgstr ""

#: xml/protocol.xml:2580(para)
msgid "Identifies the message as a <command>COPY</command>-complete indicator."
msgstr ""

#: xml/protocol.xml:2597(term)
msgid "CopyFail (F)"
msgstr ""

#: xml/protocol.xml:2602(term)
msgid "Byte1('f')"
msgstr ""

#: xml/protocol.xml:2604(para)
msgid "Identifies the message as a <command>COPY</command>-failure indicator."
msgstr ""

#: xml/protocol.xml:2618(para)
msgid "An error message to report as the cause of failure."
msgstr ""

#: xml/protocol.xml:2627(term)
msgid "CopyInResponse (B)"
msgstr ""

#: xml/protocol.xml:2632(term)
msgid "Byte1('G')"
msgstr ""

#: xml/protocol.xml:2634(para)
msgid "Identifies the message as a Start Copy In response. The frontend must now send copy-in data (if not prepared to do so, send a CopyFail message)."
msgstr ""

#: xml/protocol.xml:2648(term) xml/protocol.xml:2703(term) xml/protocol.xml:2758(term)
msgid "Int8"
msgstr ""

#: xml/protocol.xml:2650(para) xml/protocol.xml:2705(para) xml/protocol.xml:2760(para)
msgid "0 indicates the overall <command>COPY</command>format is textual (rows separated by newlines, columns separated by separator characters, etc). 1 indicates the overall copy format is binary (similar to DataRow format). See <xref linkend=\"sql-copy\">for more information.</xref>"
msgstr ""

#: xml/protocol.xml:2663(para) xml/protocol.xml:2718(para) xml/protocol.xml:2773(para)
msgid "The number of columns in the data to be copied (denoted <replaceable>N</replaceable>below)."
msgstr ""

#: xml/protocol.xml:2669(term) xml/protocol.xml:2724(term) xml/protocol.xml:2779(term)
msgid "Int16[ <replaceable>N</replaceable>]"
msgstr ""

#: xml/protocol.xml:2672(para) xml/protocol.xml:2727(para) xml/protocol.xml:2782(para)
msgid "The format codes to be used for each column. Each must presently be zero (text) or one (binary). All must be zero if the overall copy format is textual."
msgstr ""

#: xml/protocol.xml:2683(term)
msgid "CopyOutResponse (B)"
msgstr ""

#: xml/protocol.xml:2688(term) xml/protocol.xml:2998(term)
msgid "Byte1('H')"
msgstr ""

#: xml/protocol.xml:2690(para)
msgid "Identifies the message as a Start Copy Out response. This message will be followed by copy-out data."
msgstr ""

#: xml/protocol.xml:2738(term)
msgid "CopyBothResponse (B)"
msgstr ""

#: xml/protocol.xml:2743(term)
msgid "Byte1('W')"
msgstr ""

#: xml/protocol.xml:2745(para)
msgid "Identifies the message as a Start Copy Both response. This message is used only for Streaming Replication."
msgstr ""

#: xml/protocol.xml:2793(term)
msgid "DataRow (B)"
msgstr ""

#: xml/protocol.xml:2798(term) xml/protocol.xml:2849(term)
msgid "Byte1('D')"
msgstr ""

#: xml/protocol.xml:2800(para)
msgid "Identifies the message as a data row."
msgstr ""

#: xml/protocol.xml:2813(para)
msgid "The number of column values that follow (possibly zero)."
msgstr ""

#: xml/protocol.xml:2823(para)
msgid "The length of the column value, in bytes (this count does not include itself). Can be zero. As a special case, -1 indicates a NULL column value. No value bytes follow in the NULL case."
msgstr ""

#: xml/protocol.xml:2834(para)
msgid "The value of the column, in the format indicated by the associated format code. <replaceable>n</replaceable>is the above length."
msgstr ""

#: xml/protocol.xml:2795(para)
msgid "<placeholder-1/>Next, the following pair of fields appear for each column: <placeholder-2/>"
msgstr ""

#: xml/protocol.xml:2844(term)
msgid "Describe (F)"
msgstr ""

#: xml/protocol.xml:2851(para)
msgid "Identifies the message as a Describe command."
msgstr ""

#: xml/protocol.xml:2865(para)
msgid "' <literal>S</literal>' to describe a prepared statement; or ' <literal>P</literal>' to describe a portal."
msgstr ""

#: xml/protocol.xml:2875(para)
msgid "The name of the prepared statement or portal to describe (an empty string selects the unnamed prepared statement or portal)."
msgstr ""

#: xml/protocol.xml:2885(term)
msgid "EmptyQueryResponse (B)"
msgstr ""

#: xml/protocol.xml:2890(term)
msgid "Byte1('I')"
msgstr ""

#: xml/protocol.xml:2892(para)
msgid "Identifies the message as a response to an empty query string. (This substitutes for CommandComplete.)"
msgstr ""

#: xml/protocol.xml:2909(term)
msgid "ErrorResponse (B)"
msgstr ""

#: xml/protocol.xml:2914(term) xml/protocol.xml:2959(term)
msgid "Byte1('E')"
msgstr ""

#: xml/protocol.xml:2916(para)
msgid "Identifies the message as an error."
msgstr ""

#: xml/protocol.xml:2934(para) xml/protocol.xml:3197(para)
msgid "A code identifying the field type; if zero, this is the message terminator and no string follows. The presently defined field types are listed in <xref linkend=\"protocol-error-fields\">. Since more field types might be added in future, frontends should silently ignore fields of unrecognized type.</xref>"
msgstr ""

#: xml/protocol.xml:2947(para) xml/protocol.xml:3210(para)
msgid "The field value."
msgstr ""

#: xml/protocol.xml:2911(para) xml/protocol.xml:3174(para)
msgid "<placeholder-1/>The message body consists of one or more identified fields, followed by a zero byte as a terminator. Fields can appear in any order. For each field there is the following: <placeholder-2/>"
msgstr ""

#: xml/protocol.xml:2954(term)
msgid "Execute (F)"
msgstr ""

#: xml/protocol.xml:2961(para)
msgid "Identifies the message as an Execute command."
msgstr ""

#: xml/protocol.xml:2975(para)
msgid "The name of the portal to execute (an empty string selects the unnamed portal)."
msgstr ""

#: xml/protocol.xml:2982(para)
msgid "Maximum number of rows to return, if portal contains a query that returns rows (ignored otherwise). Zero denotes <quote>no limit</quote>."
msgstr ""

#: xml/protocol.xml:2993(term)
msgid "Flush (F)"
msgstr ""

#: xml/protocol.xml:3000(para)
msgid "Identifies the message as a Flush command."
msgstr ""

#: xml/protocol.xml:3016(term)
msgid "FunctionCall (F)"
msgstr ""

#: xml/protocol.xml:3021(term)
msgid "Byte1('F')"
msgstr ""

#: xml/protocol.xml:3023(para)
msgid "Identifies the message as a function call."
msgstr ""

#: xml/protocol.xml:3037(para)
msgid "Specifies the object ID of the function to call."
msgstr ""

#: xml/protocol.xml:3044(para)
msgid "The number of argument format codes that follow (denoted <replaceable>C</replaceable>below). This can be zero to indicate that there are no arguments or that the arguments all use the default format (text); or one, in which case the specified format code is applied to all arguments; or it can equal the actual number of arguments."
msgstr ""

#: xml/protocol.xml:3058(para)
msgid "The argument format codes. Each must presently be zero (text) or one (binary)."
msgstr ""

#: xml/protocol.xml:3065(para)
msgid "Specifies the number of arguments being supplied to the function."
msgstr ""

#: xml/protocol.xml:3075(para)
msgid "The length of the argument value, in bytes (this count does not include itself). Can be zero. As a special case, -1 indicates a NULL argument value. No value bytes follow in the NULL case."
msgstr ""

#: xml/protocol.xml:3086(para)
msgid "The value of the argument, in the format indicated by the associated format code. <replaceable>n</replaceable>is the above length."
msgstr ""

#: xml/protocol.xml:3098(para)
msgid "The format code for the function result. Must presently be zero (text) or one (binary)."
msgstr ""

#: xml/protocol.xml:3018(para)
msgid "<placeholder-1/>Next, the following pair of fields appear for each argument: <placeholder-2/>After the last argument, the following field appears: <placeholder-3/>"
msgstr ""

#: xml/protocol.xml:3106(term)
msgid "FunctionCallResponse (B)"
msgstr ""

#: xml/protocol.xml:3111(term)
msgid "Byte1('V')"
msgstr ""

#: xml/protocol.xml:3113(para)
msgid "Identifies the message as a function call result."
msgstr ""

#: xml/protocol.xml:3127(para)
msgid "The length of the function result value, in bytes (this count does not include itself). Can be zero. As a special case, -1 indicates a NULL function result. No value bytes follow in the NULL case."
msgstr ""

#: xml/protocol.xml:3138(para)
msgid "The value of the function result, in the format indicated by the associated format code. <replaceable>n</replaceable>is the above length."
msgstr ""

#: xml/protocol.xml:3149(term)
msgid "NoData (B)"
msgstr ""

#: xml/protocol.xml:3154(term)
msgid "Byte1('n')"
msgstr ""

#: xml/protocol.xml:3156(para)
msgid "Identifies the message as a no-data indicator."
msgstr ""

#: xml/protocol.xml:3172(term)
msgid "NoticeResponse (B)"
msgstr ""

#: xml/protocol.xml:3177(term)
msgid "Byte1('N')"
msgstr ""

#: xml/protocol.xml:3179(para)
msgid "Identifies the message as a notice."
msgstr ""

#: xml/protocol.xml:3217(term)
msgid "NotificationResponse (B)"
msgstr ""

#: xml/protocol.xml:3222(term)
msgid "Byte1('A')"
msgstr ""

#: xml/protocol.xml:3224(para)
msgid "Identifies the message as a notification response."
msgstr ""

#: xml/protocol.xml:3238(para)
msgid "The process ID of the notifying backend process."
msgstr ""

#: xml/protocol.xml:3245(para)
msgid "The name of the channel that the notify has been raised on."
msgstr ""

#: xml/protocol.xml:3252(para)
msgid "The <quote>payload</quote>string passed from the notifying process."
msgstr ""

#: xml/protocol.xml:3262(term)
msgid "ParameterDescription (B)"
msgstr ""

#: xml/protocol.xml:3267(term)
msgid "Byte1('t')"
msgstr ""

#: xml/protocol.xml:3269(para)
msgid "Identifies the message as a parameter description."
msgstr ""

#: xml/protocol.xml:3283(para)
msgid "The number of parameters used by the statement (can be zero)."
msgstr ""

#: xml/protocol.xml:3293(para)
msgid "Specifies the object ID of the parameter data type."
msgstr ""

#: xml/protocol.xml:3264(para) xml/protocol.xml:3339(para)
msgid "<placeholder-1/>Then, for each parameter, there is the following: <placeholder-2/>"
msgstr ""

#: xml/protocol.xml:3301(term)
msgid "ParameterStatus (B)"
msgstr ""

#: xml/protocol.xml:3306(term) xml/protocol.xml:3750(term)
msgid "Byte1('S')"
msgstr ""

#: xml/protocol.xml:3308(para)
msgid "Identifies the message as a run-time parameter status report."
msgstr ""

#: xml/protocol.xml:3322(para)
msgid "The name of the run-time parameter being reported."
msgstr ""

#: xml/protocol.xml:3329(para)
msgid "The current value of the parameter."
msgstr ""

#: xml/protocol.xml:3337(term)
msgid "Parse (F)"
msgstr ""

#: xml/protocol.xml:3342(term)
msgid "Byte1('P')"
msgstr ""

#: xml/protocol.xml:3344(para)
msgid "Identifies the message as a Parse command."
msgstr ""

#: xml/protocol.xml:3358(para)
msgid "The name of the destination prepared statement (an empty string selects the unnamed prepared statement)."
msgstr ""

#: xml/protocol.xml:3366(para)
msgid "The query string to be parsed."
msgstr ""

#: xml/protocol.xml:3372(para)
msgid "The number of parameter data types specified (can be zero). Note that this is not an indication of the number of parameters that might appear in the query string, only the number that the frontend wants to prespecify types for."
msgstr ""

#: xml/protocol.xml:3385(para)
msgid "Specifies the object ID of the parameter data type. Placing a zero here is equivalent to leaving the type unspecified."
msgstr ""

#: xml/protocol.xml:3394(term)
msgid "ParseComplete (B)"
msgstr ""

#: xml/protocol.xml:3399(term)
msgid "Byte1('1')"
msgstr ""

#: xml/protocol.xml:3401(para)
msgid "Identifies the message as a Parse-complete indicator."
msgstr ""

#: xml/protocol.xml:3417(term)
msgid "PasswordMessage (F)"
msgstr ""

#: xml/protocol.xml:3422(term)
msgid "Byte1('p')"
msgstr ""

#: xml/protocol.xml:3424(para)
msgid "Identifies the message as a password response. Note that this is also used for GSSAPI and SSPI response messages (which is really a design error, since the contained data is not a null-terminated string in that case, but can be arbitrary binary data)."
msgstr ""

#: xml/protocol.xml:3442(para)
msgid "The password (encrypted, if requested)."
msgstr ""

#: xml/protocol.xml:3451(term)
msgid "PortalSuspended (B)"
msgstr ""

#: xml/protocol.xml:3456(term)
msgid "Byte1('s')"
msgstr ""

#: xml/protocol.xml:3458(para)
msgid "Identifies the message as a portal-suspended indicator. Note this only appears if an Execute message's row-count limit was reached."
msgstr ""

#: xml/protocol.xml:3476(term)
msgid "Query (F)"
msgstr ""

#: xml/protocol.xml:3481(term)
msgid "Byte1('Q')"
msgstr ""

#: xml/protocol.xml:3483(para)
msgid "Identifies the message as a simple query."
msgstr ""

#: xml/protocol.xml:3497(para)
msgid "The query string itself."
msgstr ""

#: xml/protocol.xml:3505(term)
msgid "ReadyForQuery (B)"
msgstr ""

#: xml/protocol.xml:3510(term)
msgid "Byte1('Z')"
msgstr ""

#: xml/protocol.xml:3512(para)
msgid "Identifies the message type. ReadyForQuery is sent whenever the backend is ready for a new query cycle."
msgstr ""

#: xml/protocol.xml:3527(para)
msgid "Current backend transaction status indicator. Possible values are ' <literal>I</literal>' if idle (not in a transaction block); ' <literal>T</literal>' if in a transaction block; or ' <literal>E</literal>' if in a failed transaction block (queries will be rejected until block is ended)."
msgstr ""

#: xml/protocol.xml:3543(term)
msgid "RowDescription (B)"
msgstr ""

#: xml/protocol.xml:3548(term)
msgid "Byte1('T')"
msgstr ""

#: xml/protocol.xml:3550(para)
msgid "Identifies the message as a row description."
msgstr ""

#: xml/protocol.xml:3564(para)
msgid "Specifies the number of fields in a row (can be zero)."
msgstr ""

#: xml/protocol.xml:3574(para)
msgid "The field name."
msgstr ""

#: xml/protocol.xml:3580(para)
msgid "If the field can be identified as a column of a specific table, the object ID of the table; otherwise zero."
msgstr ""

#: xml/protocol.xml:3588(para)
msgid "If the field can be identified as a column of a specific table, the attribute number of the column; otherwise zero."
msgstr ""

#: xml/protocol.xml:3596(para)
msgid "The object ID of the field's data type."
msgstr ""

#: xml/protocol.xml:3603(para)
msgid "The data type size (see <varname>pg_type.typlen</varname>). Note that negative values denote variable-width types."
msgstr ""

#: xml/protocol.xml:3611(para)
msgid "The type modifier (see <varname>pg_attribute.atttypmod</varname>). The meaning of the modifier is type-specific."
msgstr ""

#: xml/protocol.xml:3619(para)
msgid "The format code being used for the field. Currently will be zero (text) or one (binary). In a RowDescription returned from the statement variant of Describe, the format code is not yet known and will always be zero."
msgstr ""

#: xml/protocol.xml:3545(para)
msgid "<placeholder-1/>Then, for each field, there is the following: <placeholder-2/>"
msgstr ""

#: xml/protocol.xml:3630(term)
msgid "SSLRequest (F)"
msgstr ""

#: xml/protocol.xml:3642(term)
msgid "Int32(80877103)"
msgstr ""

#: xml/protocol.xml:3644(para)
msgid "The <acronym>SSL</acronym>request code. The value is chosen to contain <literal>1234</literal>in the most significant 16 bits, and <literal>5679</literal>in the least 16 significant bits. (To avoid confusion, this code must not be the same as any protocol version number.)"
msgstr ""

#: xml/protocol.xml:3660(term)
msgid "StartupMessage (F)"
msgstr ""

#: xml/protocol.xml:3672(term)
msgid "Int32(196608)"
msgstr ""

#: xml/protocol.xml:3674(para)
msgid "The protocol version number. The most significant 16 bits are the major version number (3 for the protocol described here). The least significant 16 bits are the minor version number (0 for the protocol described here)."
msgstr ""

#: xml/protocol.xml:3696(literal)
msgid "user"
msgstr ""

#: xml/protocol.xml:3699(para)
msgid "The database user name to connect as. Required; there is no default."
msgstr ""

#: xml/protocol.xml:3705(literal)
msgid "database"
msgstr ""

#: xml/protocol.xml:3708(para)
msgid "The database to connect to. Defaults to the user name."
msgstr ""

#: xml/protocol.xml:3714(literal)
msgid "options"
msgstr ""

#: xml/protocol.xml:3717(para)
msgid "Command-line arguments for the backend. (This is deprecated in favor of setting individual run-time parameters.) Spaces within this string are considered to separate arguments, unless escaped with a backslash ( <literal>\\</literal>); write <literal>\\\\</literal>to represent a literal backslash."
msgstr ""

#: xml/protocol.xml:3691(para)
msgid "The parameter name. Currently recognized names are: <placeholder-1/>In addition to the above, any run-time parameter that can be set at backend start time might be listed. Such settings will be applied during backend start (after parsing the command-line arguments if any). The values will act as session defaults."
msgstr ""

#: xml/protocol.xml:3738(para)
msgid "The parameter value."
msgstr ""

#: xml/protocol.xml:3662(para)
msgid "<placeholder-1/>The protocol version number is followed by one or more pairs of parameter name and value strings. A zero byte is required as a terminator after the last name/value pair. Parameters can appear in any order. <literal>user</literal>is required, others are optional. Each parameter is specified as: <placeholder-2/>"
msgstr ""

#: xml/protocol.xml:3745(term)
msgid "Sync (F)"
msgstr ""

#: xml/protocol.xml:3752(para)
msgid "Identifies the message as a Sync command."
msgstr ""

#: xml/protocol.xml:3768(term)
msgid "Terminate (F)"
msgstr ""

#: xml/protocol.xml:3773(term)
msgid "Byte1('X')"
msgstr ""

#: xml/protocol.xml:3775(para)
msgid "Identifies the message as a termination."
msgstr ""

#: xml/protocol.xml:3793(title)
msgid "Error and Notice Message Fields"
msgstr ""

#: xml/protocol.xml:3794(para)
msgid "This section describes the fields that can appear in ErrorResponse and NoticeResponse messages. Each field type has a single-byte identification token. Note that any given field type should appear at most once per message."
msgstr ""

#: xml/protocol.xml:3801(literal)
msgid "S"
msgstr ""

#: xml/protocol.xml:3804(para)
msgid "Severity: the field contents are <literal>ERROR</literal>, <literal>FATAL</literal>, or <literal>PANIC</literal>(in an error message), or <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>, <literal>INFO</literal>, or <literal>LOG</literal>(in a notice message), or a localized translation of one of these. Always present."
msgstr ""

#: xml/protocol.xml:3819(literal)
msgid "C"
msgstr ""

#: xml/protocol.xml:3822(para)
msgid "Code: the SQLSTATE code for the error (see <xref linkend=\"errcodes-appendix\">). Not localizable. Always present.</xref>"
msgstr ""

#: xml/protocol.xml:3829(literal)
msgid "M"
msgstr ""

#: xml/protocol.xml:3832(para)
msgid "Message: the primary human-readable error message. This should be accurate but terse (typically one line). Always present."
msgstr ""

#: xml/protocol.xml:3839(literal)
msgid "D"
msgstr ""

#: xml/protocol.xml:3842(para)
msgid "Detail: an optional secondary error message carrying more detail about the problem. Might run to multiple lines."
msgstr ""

#: xml/protocol.xml:3849(literal)
msgid "H"
msgstr ""

#: xml/protocol.xml:3852(para)
msgid "Hint: an optional suggestion what to do about the problem. This is intended to differ from Detail in that it offers advice (potentially inappropriate) rather than hard facts. Might run to multiple lines."
msgstr ""

#: xml/protocol.xml:3860(literal)
msgid "P"
msgstr ""

#: xml/protocol.xml:3863(para)
msgid "Position: the field value is a decimal ASCII integer, indicating an error cursor position as an index into the original query string. The first character has index 1, and positions are measured in characters not bytes."
msgstr ""

#: xml/protocol.xml:3872(literal)
msgid "p"
msgstr ""

#: xml/protocol.xml:3875(para)
msgid "Internal position: this is defined the same as the <literal>P</literal>field, but it is used when the cursor position refers to an internally generated command rather than the one submitted by the client. The <literal>q</literal>field will always appear when this field appears."
msgstr ""

#: xml/protocol.xml:3885(literal)
msgid "q"
msgstr ""

#: xml/protocol.xml:3888(para)
msgid "Internal query: the text of a failed internally-generated command. This could be, for example, a SQL query issued by a PL/pgSQL function."
msgstr ""

#: xml/protocol.xml:3895(literal)
msgid "W"
msgstr ""

#: xml/protocol.xml:3898(para)
msgid "Where: an indication of the context in which the error occurred. Presently this includes a call stack traceback of active procedural language functions and internally-generated queries. The trace is one entry per line, most recent first."
msgstr ""

#: xml/protocol.xml:3907(literal)
msgid "s"
msgstr ""

#: xml/protocol.xml:3910(para)
msgid "Schema name: if the error was associated with a specific database object, the name of the schema containing that object, if any."
msgstr ""

#: xml/protocol.xml:3917(literal)
msgid "t"
msgstr ""

#: xml/protocol.xml:3920(para)
msgid "Table name: if the error was associated with a specific table, the name of the table. (Refer to the schema name field for the name of the table's schema.)"
msgstr ""

#: xml/protocol.xml:3928(literal)
msgid "c"
msgstr ""

#: xml/protocol.xml:3931(para)
msgid "Column name: if the error was associated with a specific table column, the name of the column. (Refer to the schema and table name fields to identify the table.)"
msgstr ""

#: xml/protocol.xml:3939(literal)
msgid "d"
msgstr ""

#: xml/protocol.xml:3942(para)
msgid "Data type name: if the error was associated with a specific data type, the name of the data type. (Refer to the schema name field for the name of the data type's schema.)"
msgstr ""

#: xml/protocol.xml:3950(literal)
msgid "n"
msgstr ""

#: xml/protocol.xml:3953(para)
msgid "Constraint name: if the error was associated with a specific constraint, the name of the constraint. Refer to fields listed above for the associated table or domain. (For this purpose, indexes are treated as constraints, even if they weren't created with constraint syntax.)"
msgstr ""

#: xml/protocol.xml:3963(literal)
msgid "F"
msgstr ""

#: xml/protocol.xml:3966(para)
msgid "File: the file name of the source-code location where the error was reported."
msgstr ""

#: xml/protocol.xml:3972(literal)
msgid "L"
msgstr ""

#: xml/protocol.xml:3975(para)
msgid "Line: the line number of the source-code location where the error was reported."
msgstr ""

#: xml/protocol.xml:3981(literal)
msgid "R"
msgstr ""

#: xml/protocol.xml:3984(para)
msgid "Routine: the name of the source-code routine reporting the error."
msgstr ""

#: xml/protocol.xml:3990(para)
msgid "The fields for schema name, table name, column name, data type name, and constraint name are supplied only for a limited number of error types; see <xref linkend=\"errcodes-appendix\">. Frontends should not assume that the presence of any of these fields guarantees the presence of another field. Core error sources observe the interrelationships noted above, but user-defined functions may use these fields in other ways. In the same vein, clients should not assume that these fields denote contemporary objects in the current database.</xref>"
msgstr ""

#: xml/protocol.xml:4001(para)
msgid "The client is responsible for formatting displayed information to meet its needs; in particular it should break long lines as needed. Newline characters appearing in the error message fields should be treated as paragraph breaks, not line breaks."
msgstr ""

#: xml/protocol.xml:4008(title)
msgid "Summary of Changes since Protocol 2.0"
msgstr ""

#: xml/protocol.xml:4009(para)
msgid "This section provides a quick checklist of changes, for the benefit of developers trying to update existing client libraries to protocol 3.0."
msgstr ""

#: xml/protocol.xml:4012(para)
msgid "The initial startup packet uses a flexible list-of-strings format instead of a fixed format. Notice that session default values for run-time parameters can now be specified directly in the startup packet. (Actually, you could do that before using the <literal>options</literal>field, but given the limited width of <literal>options</literal>and the lack of any way to quote whitespace in the values, it wasn't a very safe technique.)"
msgstr ""

#: xml/protocol.xml:4022(para)
msgid "All messages now have a length count immediately following the message type byte (except for startup packets, which have no type byte). Also note that PasswordMessage now has a type byte."
msgstr ""

#: xml/protocol.xml:4026(para)
msgid "ErrorResponse and NoticeResponse (' <literal>E</literal>' and ' <literal>N</literal>') messages now contain multiple fields, from which the client code can assemble an error message of the desired level of verbosity. Note that individual fields will typically not end with a newline, whereas the single string sent in the older protocol always did."
msgstr ""

#: xml/protocol.xml:4033(para)
msgid "The ReadyForQuery (' <literal>Z</literal>') message includes a transaction status indicator."
msgstr ""

#: xml/protocol.xml:4036(para)
msgid "The distinction between BinaryRow and DataRow message types is gone; the single DataRow message type serves for returning data in all formats. Note that the layout of DataRow has changed to make it easier to parse. Also, the representation of binary values has changed: it is no longer directly tied to the server's internal representation."
msgstr ""

#: xml/protocol.xml:4042(para)
msgid "There is a new <quote>extended query</quote>sub-protocol, which adds the frontend message types Parse, Bind, Execute, Describe, Close, Flush, and Sync, and the backend message types ParseComplete, BindComplete, PortalSuspended, ParameterDescription, NoData, and CloseComplete. Existing clients do not have to concern themselves with this sub-protocol, but making use of it might allow improvements in performance or functionality."
msgstr ""

#: xml/protocol.xml:4050(para)
msgid "<command>COPY</command>data is now encapsulated into CopyData and CopyDone messages. There is a well-defined way to recover from errors during <command>COPY</command>. The special <quote><literal>\\.</literal></quote>last line is not needed anymore, and is not sent during <command>COPY OUT</command>. (It is still recognized as a terminator during <command>COPY IN</command>, but its use is deprecated and will eventually be removed.) Binary <command>COPY</command>is supported. The CopyInResponse and CopyOutResponse messages include fields indicating the number of columns and the format of each column."
msgstr ""

#: xml/protocol.xml:4066(para)
msgid "The layout of FunctionCall and FunctionCallResponse messages has changed. FunctionCall can now support passing NULL arguments to functions. It also can handle passing parameters and retrieving results in either text or binary format. There is no longer any reason to consider FunctionCall a potential security hole, since it does not offer direct access to internal server data representations."
msgstr ""

#: xml/protocol.xml:4073(para)
msgid "The backend sends ParameterStatus (' <literal>S</literal>') messages during connection startup for all parameters it considers interesting to the client library. Subsequently, a ParameterStatus message is sent whenever the active value changes for any of these parameters."
msgstr ""

#: xml/protocol.xml:4078(para)
msgid "The RowDescription (' <literal>T</literal>') message carries new table OID and column number fields for each column of the described row. It also shows the format code for each column."
msgstr ""

#: xml/protocol.xml:4082(para)
msgid "The CursorResponse (' <literal>P</literal>') message is no longer generated by the backend."
msgstr ""

#: xml/protocol.xml:4085(para)
msgid "The NotificationResponse (' <literal>A</literal>') message has an additional string field, which can carry a <quote>payload</quote>string passed from the <command>NOTIFY</command>event sender."
msgstr ""

#: xml/protocol.xml:4090(para)
msgid "The EmptyQueryResponse (' <literal>I</literal>') message used to include an empty string parameter; this has been removed."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/protocol.xml:0(None)
msgid "translator-credits"
msgstr ""

