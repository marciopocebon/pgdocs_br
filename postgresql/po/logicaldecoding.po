msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/logicaldecoding.xml:3(title) xml/logicaldecoding.xml:5(primary) xml/logicaldecoding.xml:140(title) xml/logicaldecoding.xml:142(primary)
msgid "Logical Decoding"
msgstr ""

#: xml/logicaldecoding.xml:7(para)
msgid "PostgreSQL provides infrastructure to stream the modifications performed via SQL to external consumers. This functionality can be used to for a variety of purposes, including replication solutions and auditing."
msgstr ""

#: xml/logicaldecoding.xml:11(para)
msgid "Changes are sent out in streams identified by logical replication slots. Each stream outputs each change exactly once."
msgstr ""

#: xml/logicaldecoding.xml:14(para)
msgid "The format in which those changes are streamed is determined by the output plugin used. An example plugin is provided in the PostgreSQL distribution. Additional plugins can be written to extend the choice of available formats without modifying any core code. Every output plugin has access to each individual new row produced by <command>INSERT</command>and the new row version created by <command>UPDATE</command>. Availability of old row versions for <command>UPDATE</command>and <command>DELETE</command>depends on the configured replica identity (see <xref linkend=\"SQL-CREATETABLE-REPLICA-IDENTITY\">).</xref>"
msgstr ""

#: xml/logicaldecoding.xml:26(para)
msgid "Changes can be consumed either using the streaming replication protocol (see <xref linkend=\"protocol-replication\">and <xref linkend=\"logicaldecoding-walsender\">), or by calling functions via SQL (see <xref linkend=\"logicaldecoding-sql\">). It is also possible to write additional methods of consuming the output of a replication slot without modifying core code (see <xref linkend=\"logicaldecoding-writer\"> ).</xref></xref></xref></xref>"
msgstr ""

#: xml/logicaldecoding.xml:37(title)
msgid "Logical Decoding Examples"
msgstr ""

#: xml/logicaldecoding.xml:38(para)
msgid "The following example demonstrates controlling logical decoding using the SQL interface."
msgstr ""

#: xml/logicaldecoding.xml:40(para)
msgid "Before you can use logical decoding, you must set <xref linkend=\"guc-wal-level\">to <literal>logical</literal>and <xref linkend=\"guc-max-replication-slots\">to at least 1. Then, you should connect to the target database (in the example below, <literal>postgres</literal>) as a superuser.</xref></xref>"
msgstr ""

#: xml/logicaldecoding.xml:48(programlisting)
#, no-wrap
msgid "postgres=# -- Create a slot named\n    'regression_slot' using the output plugin 'test_decoding'\n    postgres=# SELECT * FROM\n    pg_create_logical_replication_slot('regression_slot',\n    'test_decoding'); slot_name | xlog_position\n    -----------------+--------------- regression_slot | 0/16B1970\n    (1 row) postgres=# SELECT slot_name, plugin, slot_type,\n    database, active, restart_lsn FROM pg_replication_slots;\n    slot_name | plugin | slot_type | database | active |\n    restart_lsn\n    -----------------+---------------+-----------+----------+--------+-------------\n    regression_slot | test_decoding | logical | postgres | f |\n    0/16A4408 (1 row) postgres=# -- There are no changes to see yet\n    postgres=# SELECT * FROM\n    pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n    location | xid | data ----------+-----+------ (0 rows)\n    postgres=# CREATE TABLE data(id serial primary key, data text);\n    CREATE TABLE postgres=# -- DDL isn't replicated, so all you'll\n    see is the transaction postgres=# SELECT * FROM\n    pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n    location | xid | data -----------+-----+------------ 0/16D5D48\n    | 688 | BEGIN 688 0/16E0380 | 688 | COMMIT 688 (2 rows)\n    postgres=# -- Once changes are read, they're consumed and not\n    emitted postgres=# -- in a subsequent call: postgres=# SELECT *\n    FROM pg_logical_slot_get_changes('regression_slot', NULL,\n    NULL); location | xid | data ----------+-----+------ (0 rows)\n    postgres=# BEGIN; postgres=# INSERT INTO data(data)\n    VALUES('1'); postgres=# INSERT INTO data(data) VALUES('2');\n    postgres=# COMMIT; postgres=# SELECT * FROM\n    pg_logical_slot_get_changes('regression_slot', NULL, NULL);\n    location | xid | data\n    -----------+-----+-----------------------------------------------\n    0/16E0478 | 689 | BEGIN 689 0/16E0478 | 689 | table\n    public.data: INSERT: id[integer]:1 data[text]:'1' 0/16E0580 |\n    689 | table public.data: INSERT: id[integer]:2 data[text]:'2'\n    0/16E0650 | 689 | COMMIT 689 (4 rows) postgres=# INSERT INTO\n    data(data) VALUES('3'); postgres=# -- You can also peek ahead\n    in the change stream without consuming changes postgres=#\n    SELECT * FROM pg_logical_slot_peek_changes('regression_slot',\n    NULL, NULL); location | xid | data\n    -----------+-----+-----------------------------------------------\n    0/16E09C0 | 690 | BEGIN 690 0/16E09C0 | 690 | table\n    public.data: INSERT: id[integer]:3 data[text]:'3' 0/16E0B90 |\n    690 | COMMIT 690 (3 rows) postgres=# -- The next call to\n    pg_logical_slot_peek_changes() returns the same changes again\n    postgres=# SELECT * FROM\n    pg_logical_slot_peek_changes('regression_slot', NULL, NULL);\n    location | xid | data\n    -----------+-----+-----------------------------------------------\n    0/16E09C0 | 690 | BEGIN 690 0/16E09C0 | 690 | table\n    public.data: INSERT: id[integer]:3 data[text]:'3' 0/16E0B90 |\n    690 | COMMIT 690 (3 rows) postgres=# -- options can be passed\n    to output plugin, to influence the formatting postgres=# SELECT\n    * FROM pg_logical_slot_peek_changes('regression_slot', NULL,\n    NULL, 'include-timestamp', 'on'); location | xid | data\n    -----------+-----+-----------------------------------------------\n    0/16E09C0 | 690 | BEGIN 690 0/16E09C0 | 690 | table\n    public.data: INSERT: id[integer]:3 data[text]:'3' 0/16E0B90 |\n    690 | COMMIT 690 (at 2014-02-27 16:41:51.863092+01) (3 rows)\n    postgres=# -- Remember to destroy a slot you no longer need to\n    stop it consuming postgres=# -- server resources: postgres=#\n    SELECT pg_drop_replication_slot('regression_slot');\n    pg_drop_replication_slot ----------------------- (1\n    row)"
msgstr ""

#: xml/logicaldecoding.xml:112(para)
msgid "The following example shows how logical decoding is controlled over the streaming replication protocol, using the program <xref linkend=\"app-pgrecvlogical\">included in the PostgreSQL distribution. This requires that client authentication is set up to allow replication connections (see <xref linkend=\"streaming-replication-authentication\">) and that <varname>max_wal_senders</varname>is set sufficiently high to an additional connection.</xref></xref>"
msgstr ""

#: xml/logicaldecoding.xml:122(programlisting)
#, no-wrap
msgid "$ pg_recvlogical -d postgres --slot test\n    --create-slot $ pg_recvlogical -d postgres --slot test --start\n    -f - \n    <keycombo action=\"simul\">\n      <keycap>Control</keycap>\n      <keycap>Z</keycap>\n    </keycombo>$ psql -d postgres -c \"INSERT INTO data(data)\n    VALUES('4');\" $ fg BEGIN 693 table public.data: INSERT:\n    id[integer]:4 data[text]:'4' COMMIT 693 \n    <keycombo action=\"simul\">\n      <keycap>Control</keycap>\n      <keycap>C</keycap>\n    </keycombo>$ pg_recvlogical -d postgres --slot test\n    --drop-slot"
msgstr ""

#: xml/logicaldecoding.xml:138(title)
msgid "Logical Decoding Concepts"
msgstr ""

#: xml/logicaldecoding.xml:144(para)
msgid "Logical decoding is the process of extracting all persistent changes to a database's tables into a coherent, easy to understand format which can be interpreted without detailed knowledge of the database's internal state."
msgstr ""

#: xml/logicaldecoding.xml:148(para)
msgid "In <productname>PostgreSQL</productname>, logical decoding is implemented by decoding the contents of the <link linkend=\"wal\">write-ahead log</link>, which describe changes on a storage level, into an application-specific form such as a stream of tuples or SQL statements."
msgstr ""

#: xml/logicaldecoding.xml:156(title)
msgid "Replication Slots"
msgstr ""

#: xml/logicaldecoding.xml:158(primary)
msgid "replication slot"
msgstr ""

#: xml/logicaldecoding.xml:159(secondary)
msgid "logical replication"
msgstr ""

#: xml/logicaldecoding.xml:161(para)
msgid "In the context of logical replication, a slot represents a stream of changes that can be replayed to a client in the order they were made on the origin server. Each slot streams a sequence of changes from a single database, sending each change exactly once (except when peeking forward in the stream)."
msgstr ""

#: xml/logicaldecoding.xml:168(para)
msgid "<productname>PostgreSQL</productname>also has streaming replication slots (see <xref linkend=\"streaming-replication\">), but they are used somewhat differently there.</xref>"
msgstr ""

#: xml/logicaldecoding.xml:174(para)
msgid "A replication slot has an identifier that is unique across all databases in a <productname>PostgreSQL</productname>cluster. Slots persist independently of the connection using them and are crash-safe."
msgstr ""

#: xml/logicaldecoding.xml:179(para)
msgid "Multiple independent slots may exist for a single database. Each slot has its own state, allowing different consumers to receive changes from different points in the database change stream. For most applications, a separate slot will be required for each consumer."
msgstr ""

#: xml/logicaldecoding.xml:184(para)
msgid "A logical replication slot knows nothing about the state of the receiver(s). It's even possible to have multiple different receivers using the same slot at different times; they'll just get the changes following on from when the last receiver stopped consuming them. Only one receiver may consume changes from a slot at any given time."
msgstr ""

#: xml/logicaldecoding.xml:191(para)
msgid "Replication slots persist across crashes and know nothing about the state of their consumer(s). They will prevent removal of required resources even when there is no connection using them. This consumes storage because neither required WAL nor required rows from the system catalogs can be removed by <command>VACUUM</command>as long as they are required by a replication slot. So if a slot is no longer required it should be dropped."
msgstr ""

#: xml/logicaldecoding.xml:203(title)
msgid "Output Plugins"
msgstr ""

#: xml/logicaldecoding.xml:204(para)
msgid "Output plugins transform the data from the write-ahead log's internal representation into the format the consumer of a replication slot desires."
msgstr ""

#: xml/logicaldecoding.xml:209(title)
msgid "Exported Snapshots"
msgstr ""

#: xml/logicaldecoding.xml:210(para)
msgid "When a new replication slot is created using the streaming replication interface, a snapshot is exported (see <xref linkend=\"functions-snapshot-synchronization\">), which will show exactly the state of the database after which all changes will be included in the change stream. This can be used to create a new replica by using <link linkend=\"sql-set-transaction\"><literal>SET TRANSACTION SNAPSHOT</literal></link>to read the state of the database at the moment the slot was created. This transaction can then be used to dump the database's state at that point in time, which afterwards can be updated using the slot's contents without losing any changes.</xref>"
msgstr ""

#: xml/logicaldecoding.xml:226(title)
msgid "Streaming Replication Protocol Interface"
msgstr ""

#: xml/logicaldecoding.xml:232(replaceable) xml/logicaldecoding.xml:239(replaceable) xml/logicaldecoding.xml:245(replaceable)
msgid "slot_name"
msgstr ""

#: xml/logicaldecoding.xml:233(replaceable) xml/logicaldecoding.xml:246(replaceable)
msgid "options"
msgstr ""

#: xml/logicaldecoding.xml:231(literal)
msgid "CREATE_REPLICATION_SLOT <placeholder-1/>LOGICAL <placeholder-2/>"
msgstr ""

#: xml/logicaldecoding.xml:238(literal)
msgid "DROP_REPLICATION_SLOT <placeholder-1/>"
msgstr ""

#: xml/logicaldecoding.xml:244(literal)
msgid "START_REPLICATION SLOT <placeholder-1/>LOGICAL <placeholder-2/>"
msgstr ""

#: xml/logicaldecoding.xml:227(para)
msgid "The commands <placeholder-1/>are used to create, drop, and stream changes from a replication slot, respectively. These commands are only available over a replication connection; they cannot be used via SQL. See <xref linkend=\"protocol-replication\">for details on these commands.</xref>"
msgstr ""

#: xml/logicaldecoding.xml:255(para)
msgid "The command <xref linkend=\"app-pgrecvlogical\">can be used to control logical decoding over a streaming replication connection. (It uses these commands internally.)</xref>"
msgstr ""

#: xml/logicaldecoding.xml:261(title)
msgid "Logical Decoding <acronym>SQL</acronym>Interface"
msgstr ""

#: xml/logicaldecoding.xml:263(para)
msgid "See <xref linkend=\"functions-replication\">for detailed documentation on the SQL-level API for interacting with logical decoding.</xref>"
msgstr ""

#: xml/logicaldecoding.xml:267(para)
msgid "Synchronous replication (see <xref linkend=\"synchronous-replication\">) is only supported on replication slots used over the streaming replication interface. The function interface and additional, non-core interfaces do not support synchronous replication.</xref>"
msgstr ""

#: xml/logicaldecoding.xml:275(title)
msgid "System Catalogs Related to Logical Decoding"
msgstr ""

#: xml/logicaldecoding.xml:276(para)
msgid "The <link linkend=\"catalog-pg-replication-slots\"><structname>pg_replication_slots</structname></link>view and the <link linkend=\"monitoring-stats-views-table\"><structname>pg_stat_replication</structname></link>view provide information about the current state of replication slots and streaming replication connections respectively. These views apply to both physical and logical replication."
msgstr ""

#: xml/logicaldecoding.xml:288(title)
msgid "Logical Decoding Output Plugins"
msgstr ""

#: xml/logicaldecoding.xml:289(para)
msgid "An example output plugin can be found in the <link linkend=\"test-decoding\"><filename>contrib/test_decoding</filename></link>subdirectory of the PostgreSQL source tree."
msgstr ""

#: xml/logicaldecoding.xml:294(title)
msgid "Initialization Function"
msgstr ""

#: xml/logicaldecoding.xml:296(primary)
msgid "_PG_output_plugin_init"
msgstr ""

#: xml/logicaldecoding.xml:307(programlisting)
#, no-wrap
msgid "typedef struct OutputPluginCallbacks {\n      LogicalDecodeStartupCB startup_cb; LogicalDecodeBeginCB\n      begin_cb; LogicalDecodeChangeCB change_cb;\n      LogicalDecodeCommitCB commit_cb;\n      LogicalDecodeFilterByOriginCB filter_by_origin_cb;\n      LogicalDecodeShutdownCB shutdown_cb; } OutputPluginCallbacks;\n      typedef void (*LogicalOutputPluginInit)(struct\n      OutputPluginCallbacks *cb);"
msgstr ""

#: xml/logicaldecoding.xml:298(para)
msgid "An output plugin is loaded by dynamically loading a shared library with the output plugin's name as the library base name. The normal library search path is used to locate the library. To provide the required output plugin callbacks and to indicate that the library is actually an output plugin it needs to provide a function named <function>_PG_output_plugin_init</function>. This function is passed a struct that needs to be filled with the callback function pointers for individual actions. <placeholder-1/>The <function>begin_cb</function>, <function>change_cb</function>and <function>commit_cb</function>callbacks are required, while <function>startup_cb</function>, <function>filter_by_origin_cb</function>and <function>shutdown_cb</function>are optional."
msgstr ""

#: xml/logicaldecoding.xml:323(title)
msgid "Capabilities"
msgstr ""

#: xml/logicaldecoding.xml:332(programlisting)
#, no-wrap
msgid "ALTER TABLE user_catalog_table SET\n      (user_catalog_table = true); CREATE TABLE\n      another_catalog_table(data text) WITH (user_catalog_table =\n      true);"
msgstr ""

#: xml/logicaldecoding.xml:324(para)
msgid "To decode, format and output changes, output plugins can use most of the backend's normal infrastructure, including calling output functions. Read only access to relations is permitted as long as only relations are accessed that either have been created by <command>initdb</command>in the <literal>pg_catalog</literal>schema, or have been marked as user provided catalog tables using <placeholder-1/>Any actions leading to transaction ID assignment are prohibited. That, among others, includes writing to tables, performing DDL changes, and calling <literal>txid_current()</literal>."
msgstr ""

#: xml/logicaldecoding.xml:341(title)
msgid "Output Modes"
msgstr ""

#: xml/logicaldecoding.xml:342(para)
msgid "Output plugin callbacks can pass data to the consumer in nearly arbitrary formats. For some use cases, like viewing the changes via SQL, returning data in a data type that can contain arbitrary data (e.g., <type>bytea</type>) is cumbersome. If the output plugin only outputs textual data in the server's encoding, it can declare that by setting <literal>OutputPluginOptions.output_mode</literal>to <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>instead of <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>in the <link linkend=\"logicaldecoding-output-plugin-startup\">startup callback</link>. In that case, all the data has to be in the server's encoding so that a <type>text</type>datum can contain it. This is checked in assertion-enabled builds."
msgstr ""

#: xml/logicaldecoding.xml:359(title)
msgid "Output Plugin Callbacks"
msgstr ""

#: xml/logicaldecoding.xml:360(para)
msgid "An output plugin gets notified about changes that are happening via various callbacks it needs to provide."
msgstr ""

#: xml/logicaldecoding.xml:362(para)
msgid "Concurrent transactions are decoded in commit order, and only changes belonging to a specific transaction are decoded between the <literal>begin</literal>and <literal>commit</literal>callbacks. Transactions that were rolled back explicitly or implicitly never get decoded. Successful savepoints are folded into the transaction containing them in the order they were executed within that transaction."
msgstr ""

#: xml/logicaldecoding.xml:372(para)
msgid "Only transactions that have already safely been flushed to disk will be decoded. That can lead to a <command>COMMIT</command>not immediately being decoded in a directly following <literal>pg_logical_slot_get_changes()</literal>when <varname>synchronous_commit</varname>is set to <literal>off</literal>."
msgstr ""

#: xml/logicaldecoding.xml:381(title)
msgid "Startup Callback"
msgstr ""

#: xml/logicaldecoding.xml:387(programlisting)
#, no-wrap
msgid "typedef void (*LogicalDecodeStartupCB) (\n        struct LogicalDecodingContext *ctx, OutputPluginOptions\n        *options, bool is_init );"
msgstr ""

#: xml/logicaldecoding.xml:394(programlisting)
#, no-wrap
msgid "typedef struct OutputPluginOptions {\n        OutputPluginOutputType output_type; }\n        OutputPluginOptions;"
msgstr ""

#: xml/logicaldecoding.xml:382(para)
msgid "The optional <function>startup_cb</function>callback is called whenever a replication slot is created or asked to stream changes, independent of the number of changes that are ready to be put out. <placeholder-1/>The <literal>is_init</literal>parameter will be true when the replication slot is being created and false otherwise. <parameter>options</parameter>points to a struct of options that output plugins can set: <placeholder-2/><literal>output_type</literal>has to either be set to <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>or <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. See also <xref linkend=\"logicaldecoding-output-mode\">.</xref>"
msgstr ""

#: xml/logicaldecoding.xml:401(para)
msgid "The startup callback should validate the options present in <literal>ctx-output_plugin_options</literal>. If the output plugin needs to have a state, it can use <literal>ctx-output_plugin_private</literal>to store it."
msgstr ""

#: xml/logicaldecoding.xml:409(title)
msgid "Shutdown Callback"
msgstr ""

#: xml/logicaldecoding.xml:416(programlisting)
#, no-wrap
msgid "typedef void (*LogicalDecodeShutdownCB) (\n        struct LogicalDecodingContext *ctx\n        );"
msgstr ""

#: xml/logicaldecoding.xml:410(para)
msgid "The optional <function>shutdown_cb</function>callback is called whenever a formerly active replication slot is not used anymore and can be used to deallocate resources private to the output plugin. The slot isn't necessarily being dropped, streaming is just being stopped. <placeholder-1/>"
msgstr ""

#: xml/logicaldecoding.xml:421(title)
msgid "Transaction Begin Callback"
msgstr ""

#: xml/logicaldecoding.xml:426(programlisting)
#, no-wrap
msgid "typedef void (*LogicalDecodeBeginCB) (\n        struct LogicalDecodingContext *, ReorderBufferTXN *txn\n        );"
msgstr ""

#: xml/logicaldecoding.xml:422(para)
msgid "The required <function>begin_cb</function>callback is called whenever a start of a committed transaction has been decoded. Aborted transactions and their contents never get decoded. <placeholder-1/>The <parameter>txn</parameter>parameter contains meta information about the transaction, like the time stamp at which it has been committed and its XID."
msgstr ""

#: xml/logicaldecoding.xml:434(title)
msgid "Transaction End Callback"
msgstr ""

#: xml/logicaldecoding.xml:441(programlisting)
#, no-wrap
msgid "typedef void (*LogicalDecodeCommitCB) (\n        struct LogicalDecodingContext *, ReorderBufferTXN *txn\n        );"
msgstr ""

#: xml/logicaldecoding.xml:435(para)
msgid "The required <function>commit_cb</function>callback is called whenever a transaction commit has been decoded. The <function>change_cb</function>callbacks for all modified rows will have been called before this, if there have been any modified rows. <placeholder-1/>"
msgstr ""

#: xml/logicaldecoding.xml:446(title)
msgid "Change Callback"
msgstr ""

#: xml/logicaldecoding.xml:456(programlisting)
#, no-wrap
msgid "typedef void (*LogicalDecodeChangeCB) (\n        struct LogicalDecodingContext *ctx, ReorderBufferTXN *txn,\n        Relation relation, ReorderBufferChange *change\n        );"
msgstr ""

#: xml/logicaldecoding.xml:447(para)
msgid "The required <function>change_cb</function>callback is called for every individual row modification inside a transaction, may it be an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>. Even if the original command modified several rows at once the callback will be called individually for each row. <placeholder-1/>The <parameter>ctx</parameter>and <parameter>txn</parameter>parameters have the same contents as for the <function>begin_cb</function>and <function>commit_cb</function>callbacks, but additionally the relation descriptor <parameter>relation</parameter>points to the relation the row belongs to and a struct <parameter>change</parameter>describing the row modification are passed in."
msgstr ""

#: xml/logicaldecoding.xml:471(para)
msgid "Only changes in user defined tables that are not unlogged (see <xref linkend=\"SQL-CREATETABLE-UNLOGGED\">) and not temporary (see <xref linkend=\"SQL-CREATETABLE-TEMPORARY\">) can be extracted using logical decoding.</xref></xref>"
msgstr ""

#: xml/logicaldecoding.xml:480(title)
msgid "Origin Filter Callback"
msgstr ""

#: xml/logicaldecoding.xml:486(programlisting)
#, no-wrap
msgid "typedef bool (*LogicalDecodeChangeCB) (\n        struct LogicalDecodingContext *ctx, RepNodeId origin_id\n        );"
msgstr ""

#: xml/logicaldecoding.xml:481(para)
msgid "The optional <function>filter_by_origin_cb</function>callback is called to determine whether data that has been replayed from <parameter>origin_id</parameter>is of interest to the output plugin. <placeholder-1/>The <parameter>ctx</parameter>parameter has the same contents as for the other callbacks. No information but the origin is available. To signal that changes originating on the passed in node are irrelevant, return true, causing them to be filtered away; false otherwise. The other callbacks will not be called for transactions and changes that have been filtered away."
msgstr ""

#: xml/logicaldecoding.xml:496(para)
msgid "This is useful when implementing cascading or multidirectional replication solutions. Filtering by the origin allows to prevent replicating the same changes back and forth in such setups. While transactions and changes also carry information about the origin, filtering via this callback is noticeably more efficient."
msgstr ""

#: xml/logicaldecoding.xml:505(title)
msgid "Functions for Producing Output"
msgstr ""

#: xml/logicaldecoding.xml:506(para)
msgid "To actually produce output, output plugins can write data to the <literal>StringInfo</literal>output buffer in <literal>ctx-out</literal>when inside the <function>begin_cb</function>, <function>commit_cb</function>, or <function>change_cb</function>callbacks. Before writing to the output buffer, <function>OutputPluginPrepareWrite(ctx, last_write)</function>has to be called, and after finishing writing to the buffer, <function>OutputPluginWrite(ctx, last_write)</function>has to be called to perform the write. The <parameter>last_write</parameter>indicates whether a particular write was the callback's last write."
msgstr ""

#: xml/logicaldecoding.xml:523(programlisting)
#, no-wrap
msgid "OutputPluginPrepareWrite(ctx, true);\n      appendStringInfo(ctx-&gt;out, \"BEGIN %u\", txn-&gt;xid);\n      OutputPluginWrite(ctx, true);"
msgstr ""

#: xml/logicaldecoding.xml:521(para)
msgid "The following example shows how to output data to the consumer of an output plugin: <placeholder-1/>"
msgstr ""

#: xml/logicaldecoding.xml:529(title)
msgid "Logical Decoding Output Writers"
msgstr ""

#: xml/logicaldecoding.xml:530(para)
msgid "It is possible to add more output methods for logical decoding. For details, see <filename> src/backend/replication/logical/logicalfuncs.c</filename>. Essentially, three functions need to be provided: one to read WAL, one to prepare writing output, and one to write the output (see <xref linkend=\"logicaldecoding-output-plugin-output\"> ).</xref>"
msgstr ""

#: xml/logicaldecoding.xml:541(title)
msgid "Synchronous Replication Support for Logical Decoding"
msgstr ""

#: xml/logicaldecoding.xml:543(para)
msgid "Logical decoding can be used to build <link linkend=\"synchronous-replication\">synchronous replication</link>solutions with the same user interface as synchronous replication for <link linkend=\"streaming-replication\">streaming replication</link>. To do this, the streaming replication interface (see <xref linkend=\"logicaldecoding-walsender\">) must be used to stream out data. Clients have to send <literal>Standby status update (F)</literal>(see <xref linkend=\"protocol-replication\">) messages, just like streaming replication clients do.</xref></xref>"
msgstr ""

#: xml/logicaldecoding.xml:556(para)
msgid "A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, <parameter>synchronous_standby_names</parameter>currently is server wide, this means this technique will not work properly if more than one database is actively used."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/logicaldecoding.xml:0(None)
msgid "translator-credits"
msgstr ""

