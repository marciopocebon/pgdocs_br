msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/seg.xml:3(title) xml/seg.xml:5(primary) xml/seg.xml:148(type)
msgid "seg"
msgstr ""

#: xml/seg.xml:7(para)
msgid "This module implements a data type <type>seg</type>for representing line segments, or floating point intervals. <type>seg</type>can represent uncertainty in the interval endpoints, making it especially useful for representing laboratory measurements."
msgstr ""

#: xml/seg.xml:14(title)
msgid "Rationale"
msgstr ""

#: xml/seg.xml:15(para)
msgid "The geometry of measurements is usually more complex than that of a point in a numeric continuum. A measurement is usually a segment of that continuum with somewhat fuzzy limits. The measurements come out as intervals because of uncertainty and randomness, as well as because the value being measured may naturally be an interval indicating some condition, such as the temperature range of stability of a protein."
msgstr ""

#: xml/seg.xml:22(para)
msgid "Using just common sense, it appears more convenient to store such data as intervals, rather than pairs of numbers. In practice, it even turns out more efficient in most applications."
msgstr ""

#: xml/seg.xml:26(para)
msgid "Further along the line of common sense, the fuzziness of the limits suggests that the use of traditional numeric data types leads to a certain loss of information. Consider this: your instrument reads 6.50, and you input this reading into the database. What do you get when you fetch it? Watch: <screen>test=&gt; select 6.50 :: float8 as \"pH\"; pH --- 6.5 (1\n    row)</screen>In the world of measurements, 6.50 is not the same as 6.5. It may sometimes be critically different. The experimenters usually write down (and publish) the digits they trust. 6.50 is actually a fuzzy interval contained within a bigger and even fuzzier interval, 6.5, with their center points being (probably) the only common feature they share. We definitely do not want such different data items to appear the same."
msgstr ""

#: xml/seg.xml:40(para)
msgid "Conclusion? It is nice to have a special data type that can record the limits of an interval with arbitrarily variable precision. Variable in the sense that each data element records its own precision."
msgstr ""

#: xml/seg.xml:44(para)
msgid "Check this out: <screen>test=&gt; select '6.25 .. 6.50'::seg as \"pH\"; pH\n    ------------ 6.25 .. 6.50 (1 row)</screen>"
msgstr ""

#: xml/seg.xml:49(title)
msgid "Syntax"
msgstr ""

#: xml/seg.xml:50(para)
msgid "The external representation of an interval is formed using one or two floating-point numbers joined by the range operator ( <literal>..</literal>or <literal>...</literal>). Alternatively, it can be specified as a center point plus or minus a deviation. Optional certainty indicators ( <literal/>, <literal/>or <literal>~</literal>) can be stored as well. (Certainty indicators are ignored by all the built-in operators, however.) <xref linkend=\"seg-repr-table\">gives an overview of allowed representations; <xref linkend=\"seg-input-examples\">shows some examples.</xref></xref>"
msgstr ""

#: xml/seg.xml:66(para)
msgid "In <xref linkend=\"seg-repr-table\">, <replaceable>x</replaceable>, <replaceable>y</replaceable>, and <replaceable>delta</replaceable>denote floating-point numbers. <replaceable>x</replaceable>and <replaceable>y</replaceable>, but not <replaceable>delta</replaceable>, can be preceded by a certainty indicator.</xref>"
msgstr ""

#: xml/seg.xml:76(title)
msgid "<type>seg</type>External Representations"
msgstr ""

#: xml/seg.xml:83(replaceable) xml/seg.xml:91(replaceable) xml/seg.xml:95(replaceable) xml/seg.xml:101(replaceable) xml/seg.xml:105(replaceable) xml/seg.xml:107(replaceable) xml/seg.xml:113(replaceable) xml/seg.xml:116(replaceable) xml/seg.xml:121(replaceable) xml/seg.xml:124(replaceable)
msgid "x"
msgstr ""

#: xml/seg.xml:86(entry)
msgid "Single value (zero-length interval)"
msgstr ""

#: xml/seg.xml:92(replaceable) xml/seg.xml:96(replaceable)
msgid "y"
msgstr ""

#: xml/seg.xml:90(literal)
msgid "<placeholder-1/>.. <placeholder-2/>"
msgstr ""

#: xml/seg.xml:94(entry)
msgid "Interval from <placeholder-1/>to <placeholder-2/>"
msgstr ""

#: xml/seg.xml:102(replaceable) xml/seg.xml:106(replaceable) xml/seg.xml:108(replaceable)
msgid "delta"
msgstr ""

#: xml/seg.xml:100(literal)
msgid "<placeholder-1/>(+-) <placeholder-2/>"
msgstr ""

#: xml/seg.xml:104(entry)
msgid "Interval from <placeholder-1/>- <placeholder-2/>to <placeholder-3/>+ <placeholder-4/>"
msgstr ""

#: xml/seg.xml:112(literal)
msgid "<placeholder-1/>.."
msgstr ""

#: xml/seg.xml:115(entry)
msgid "Open interval with lower bound <placeholder-1/>"
msgstr ""

#: xml/seg.xml:120(literal)
msgid ".. <placeholder-1/>"
msgstr ""

#: xml/seg.xml:123(entry)
msgid "Open interval with upper bound <placeholder-1/>"
msgstr ""

#: xml/seg.xml:130(title)
msgid "Examples of Valid <type>seg</type>Input"
msgstr ""

#: xml/seg.xml:136(literal) xml/seg.xml:153(literal) xml/seg.xml:161(literal)
msgid "5.0"
msgstr ""

#: xml/seg.xml:138(entry)
msgid "Creates a zero-length segment (a point, if you will)"
msgstr ""

#: xml/seg.xml:143(literal)
msgid "~5.0"
msgstr ""

#: xml/seg.xml:146(literal) xml/seg.xml:147(literal)
msgid "~"
msgstr ""

#: xml/seg.xml:145(entry)
msgid "Creates a zero-length segment and records <placeholder-1/>in the data. <placeholder-2/>is ignored by <placeholder-3/>operations, but is preserved as a comment."
msgstr ""

#: xml/seg.xml:155(entry) xml/seg.xml:163(entry)
msgid "Creates a point at 5.0. <literal/>is ignored but is preserved as a comment."
msgstr ""

#: xml/seg.xml:169(literal)
msgid "5(+-)0.3"
msgstr ""

#: xml/seg.xml:172(literal)
msgid "4.7 .. 5.3"
msgstr ""

#: xml/seg.xml:173(literal)
msgid "(+-)"
msgstr ""

#: xml/seg.xml:171(entry)
msgid "Creates an interval <placeholder-1/>. Note that the <placeholder-2/>notation isn't preserved."
msgstr ""

#: xml/seg.xml:178(literal)
msgid "50 .."
msgstr ""

#: xml/seg.xml:180(entry)
msgid "Everything that is greater than or equal to 50"
msgstr ""

#: xml/seg.xml:185(literal)
msgid ".. 0"
msgstr ""

#: xml/seg.xml:187(entry)
msgid "Everything that is less than or equal to 0"
msgstr ""

#: xml/seg.xml:192(literal)
msgid "1.5e-2 .. 2E-2"
msgstr ""

#: xml/seg.xml:195(literal)
msgid "0.015 .. 0.02"
msgstr ""

#: xml/seg.xml:194(entry)
msgid "Creates an interval <placeholder-1/>"
msgstr ""

#: xml/seg.xml:199(literal)
msgid "1 ... 2"
msgstr ""

#: xml/seg.xml:202(literal)
msgid "1...2"
msgstr ""

#: xml/seg.xml:203(literal)
msgid "1 .. 2"
msgstr ""

#: xml/seg.xml:204(literal)
msgid "1..2"
msgstr ""

#: xml/seg.xml:201(entry)
msgid "The same as <placeholder-1/>, or <placeholder-2/>, or <placeholder-3/>(spaces around the range operator are ignored)"
msgstr ""

#: xml/seg.xml:210(para)
msgid "Because <literal>...</literal>is widely used in data sources, it is allowed as an alternative spelling of <literal>..</literal>. Unfortunately, this creates a parsing ambiguity: it is not clear whether the upper bound in <literal>0...23</literal>is meant to be <literal>23</literal>or <literal>0.23</literal>. This is resolved by requiring at least one digit before the decimal point in all numbers in <type>seg</type>input."
msgstr ""

#: xml/seg.xml:220(para)
msgid "As a sanity check, <type>seg</type>rejects intervals with the lower bound greater than the upper, for example <literal>5 .. 2</literal>."
msgstr ""

#: xml/seg.xml:226(title)
msgid "Precision"
msgstr ""

#: xml/seg.xml:227(para)
msgid "<type>seg</type>values are stored internally as pairs of 32-bit floating point numbers. This means that numbers with more than 7 significant digits will be truncated."
msgstr ""

#: xml/seg.xml:231(para)
msgid "Numbers with 7 or fewer significant digits retain their original precision. That is, if your query returns 0.00, you will be sure that the trailing zeroes are not the artifacts of formatting: they reflect the precision of the original data. The number of leading zeroes does not affect precision: the value 0.0067 is considered to have just 2 significant digits."
msgstr ""

#: xml/seg.xml:240(title)
msgid "Usage"
msgstr ""

#: xml/seg.xml:241(para)
msgid "The <filename>seg</filename>module includes a GiST index operator class for <type>seg</type>values. The operators supported by the GiST operator class are shown in <xref linkend=\"seg-gist-operators\">.</xref>"
msgstr ""

#: xml/seg.xml:248(title)
msgid "Seg GiST Operators"
msgstr ""

#: xml/seg.xml:252(entry)
msgid "Operator"
msgstr ""

#: xml/seg.xml:253(entry)
msgid "Description"
msgstr ""

#: xml/seg.xml:259(literal) xml/seg.xml:267(literal) xml/seg.xml:275(literal) xml/seg.xml:284(literal) xml/seg.xml:300(literal)
msgid "[a, b] [c, d]"
msgstr ""

#: xml/seg.xml:261(entry)
msgid "[a, b] is entirely to the left of [c, d]. That is, [a, b] [c, d] is true if b c and false otherwise."
msgstr ""

#: xml/seg.xml:269(entry)
msgid "[a, b] is entirely to the right of [c, d]. That is, [a, b] [c, d] is true if a d and false otherwise."
msgstr ""

#: xml/seg.xml:279(quote)
msgid "does not extend to right of"
msgstr ""

#: xml/seg.xml:277(entry)
msgid "Overlaps or is left of This might be better read as <placeholder-1/>. It is true when b = d."
msgstr ""

#: xml/seg.xml:288(quote)
msgid "does not extend to left of"
msgstr ""

#: xml/seg.xml:286(entry)
msgid "Overlaps or is right of This might be better read as <placeholder-1/>. It is true when a = c."
msgstr ""

#: xml/seg.xml:293(literal)
msgid "[a, b] = [c, d]"
msgstr ""

#: xml/seg.xml:295(entry)
msgid "Same as The segments [a, b] and [c, d] are identical, that is, a = c and b = d."
msgstr ""

#: xml/seg.xml:302(entry)
msgid "The segments [a, b] and [c, d] overlap."
msgstr ""

#: xml/seg.xml:306(literal) xml/seg.xml:313(literal)
msgid "[a, b] @ [c, d]"
msgstr ""

#: xml/seg.xml:308(entry)
msgid "The segment [a, b] contains the segment [c, d], that is, a = c and b = d."
msgstr ""

#: xml/seg.xml:315(entry)
msgid "The segment [a, b] is contained in [c, d], that is, a = c and b = d."
msgstr ""

#: xml/seg.xml:321(para)
msgid "(Before PostgreSQL 8.2, the containment operators <literal>@</literal>and <literal>@</literal>were respectively called <literal>@</literal>and <literal>~</literal>. These names are still available, but are deprecated and will eventually be retired. Notice that the old names are reversed from the convention formerly followed by the core geometric data types!)"
msgstr ""

#: xml/seg.xml:329(para)
msgid "The standard B-tree operators are also provided, for example <informaltable><tgroup cols=\"2\"><thead><row><entry>Operator</entry><entry>Description</entry></row></thead><tbody><row><entry><literal>[a, b] [c, d]</literal></entry><entry>Less than</entry></row><row><entry><literal>[a, b] [c, d]</literal></entry><entry>Greater than</entry></row></tbody></tgroup></informaltable>These operators do not make a lot of sense for any practical purpose but sorting. These operators first compare (a) to (c), and if these are equal, compare (b) to (d). That results in reasonably good sorting in most cases, which is useful if you want to use ORDER BY with this type."
msgstr ""

#: xml/seg.xml:361(title)
msgid "Notes"
msgstr ""

#: xml/seg.xml:362(para)
msgid "For examples of usage, see the regression test <filename>sql/seg.sql</filename>."
msgstr ""

#: xml/seg.xml:364(para)
msgid "The mechanism that converts <literal>(+-)</literal>to regular ranges isn't completely accurate in determining the number of significant digits for the boundaries. For example, it adds an extra digit to the lower boundary if the resulting interval includes a power of ten: <screen>postgres=&gt; select '10(+-)1'::seg as seg; seg\n    --------- 9.0 .. 11 -- should be: 9 .. 11</screen>"
msgstr ""

#: xml/seg.xml:372(para)
msgid "The performance of an R-tree index can largely depend on the initial order of input values. It may be very helpful to sort the input table on the <type>seg</type>column; see the script <filename>sort-segments.pl</filename>for an example."
msgstr ""

#: xml/seg.xml:379(title)
msgid "Credits"
msgstr ""

#: xml/seg.xml:380(para)
msgid "Original author: Gene Selkov, Jr. <email>selkovjr@mcs.anl.gov</email>, Mathematics and Computer Science Division, Argonne National Laboratory."
msgstr ""

#: xml/seg.xml:383(para)
msgid "My thanks are primarily to Prof. Joe Hellerstein ( <ulink url=\"http://db.cs.berkeley.edu/jmh/\"/>) for elucidating the gist of the GiST ( <ulink url=\"http://gist.cs.berkeley.edu/\"/>). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/seg.xml:0(None)
msgid "translator-credits"
msgstr ""

