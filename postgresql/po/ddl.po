msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/ddl.xml:3(title)
msgid "Data Definition"
msgstr ""

#: xml/ddl.xml:4(para)
msgid "This chapter covers how one creates the database structures that will hold one's data. In a relational database, the raw data is stored in tables, so the majority of this chapter is devoted to explaining how tables are created and modified and what features are available to control what data is stored in the tables. Subsequently, we discuss how tables can be organized into schemas, and how privileges can be assigned to tables. Finally, we will briefly look at other features that affect the data storage, such as inheritance, views, functions, and triggers."
msgstr ""

#: xml/ddl.xml:15(title)
msgid "Table Basics"
msgstr ""

#: xml/ddl.xml:17(primary) xml/ddl.xml:66(primary) xml/ddl.xml:107(primary) xml/ddl.xml:834(primary) xml/ddl.xml:1039(primary) xml/ddl.xml:1806(primary) xml/ddl.xml:2074(primary)
msgid "table"
msgstr ""

#: xml/ddl.xml:20(primary)
msgid "row"
msgstr ""

#: xml/ddl.xml:23(primary) xml/ddl.xml:660(primary) xml/ddl.xml:880(primary) xml/ddl.xml:914(primary) xml/ddl.xml:1029(primary)
msgid "column"
msgstr ""

#: xml/ddl.xml:25(para)
msgid "A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in <xref linkend=\"queries\">. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</xref>"
msgstr ""

#: xml/ddl.xml:39(para)
msgid "Each column has a data type. The data type constrains the set of possible values that can be assigned to a column and assigns semantics to the data stored in the column so that it can be used for computations. For instance, a column declared to be of a numerical type will not accept arbitrary text strings, and the data stored in such a column can be used for mathematical computations. By contrast, a column declared to be of a character string type will accept almost any kind of data but it does not lend itself to mathematical calculations, although other operations such as string concatenation are available."
msgstr ""

#: xml/ddl.xml:50(para)
msgid "<productname>PostgreSQL</productname>includes a sizable set of built-in data types that fit many applications. Users can also define their own data types. Most built-in data types have obvious names and semantics, so we defer a detailed explanation to <xref linkend=\"datatype\">. Some of the frequently used data types are <type>integer</type>for whole numbers, <type>numeric</type>for possibly fractional numbers, <type>text</type>for character strings, <type>date</type>for dates, <type>time</type>for time-of-day values, and <type>timestamp</type>for values containing both date and time.</xref>"
msgstr ""

#: xml/ddl.xml:67(secondary) xml/ddl.xml:1492(secondary)
msgid "creating"
msgstr ""

#: xml/ddl.xml:73(programlisting)
#, no-wrap
msgid "CREATE TABLE my_first_table ( first_column\n    text, second_column integer );"
msgstr ""

#: xml/ddl.xml:69(para)
msgid "To create a table, you use the aptly named <xref linkend=\"sql-createtable\">command. In this command you specify at least a name for the new table, the names of the columns and the data type of each column. For example: <placeholder-1/>This creates a table named <literal>my_first_table</literal>with two columns. The first column is named <literal>first_column</literal>and has a data type of <type>text</type>; the second column has the name <literal>second_column</literal>and the type <type>integer</type>. The table and column names follow the identifier syntax explained in <xref linkend=\"sql-syntax-identifiers\">. The type names are usually also identifiers, but there are some exceptions. Note that the column list is comma-separated and surrounded by parentheses.</xref></xref>"
msgstr ""

#: xml/ddl.xml:91(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n    name text, price numeric );"
msgstr ""

#: xml/ddl.xml:87(para)
msgid "Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example: <placeholder-1/>(The <type>numeric</type>type can store fractional components, as would be typical of monetary amounts.)"
msgstr ""

#: xml/ddl.xml:96(para)
msgid "When you create many interrelated tables it is wise to choose a consistent naming pattern for the tables and columns. For instance, there is a choice of using singular or plural nouns for table names, both of which are favored by some theorist or other."
msgstr ""

#: xml/ddl.xml:102(para)
msgid "There is a limit on how many columns a table can contain. Depending on the column types, it is between 250 and 1600. However, defining a table with anywhere near this many columns is highly unusual and often a questionable design."
msgstr ""

#: xml/ddl.xml:108(secondary) xml/ddl.xml:915(secondary) xml/ddl.xml:957(secondary) xml/ddl.xml:1534(secondary)
msgid "removing"
msgstr ""

#: xml/ddl.xml:113(programlisting)
#, no-wrap
msgid "DROP TABLE my_first_table; DROP TABLE\n    products;"
msgstr ""

#: xml/ddl.xml:110(para)
msgid "If you no longer need a table, you can remove it using the <xref linkend=\"sql-droptable\">command. For example: <placeholder-1/>Attempting to drop a table that does not exist is an error. Nevertheless, it is common in SQL script files to unconditionally try to drop each table before creating it, ignoring any error messages, so that the script works whether or not the table exists. (If you like, you can use the <literal>DROP TABLE IF EXISTS</literal>variant to avoid the error messages, but this is not standard SQL.)</xref>"
msgstr ""

#: xml/ddl.xml:121(para)
msgid "If you need to modify a table that already exists, see <xref linkend=\"ddl-alter\">later in this chapter.</xref>"
msgstr ""

#: xml/ddl.xml:123(para)
msgid "With the tools discussed so far you can create fully functional tables. The remainder of this chapter is concerned with adding features to the table definition to ensure data integrity, security, or convenience. If you are eager to fill your tables with data now you can skip ahead to <xref linkend=\"dml\">and read the rest of this chapter later.</xref>"
msgstr ""

#: xml/ddl.xml:132(title)
msgid "Default Values"
msgstr ""

#: xml/ddl.xml:134(primary) xml/ddl.xml:986(primary)
msgid "default value"
msgstr ""

#: xml/ddl.xml:136(para)
msgid "A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in <xref linkend=\"dml\">.)</xref>"
msgstr ""

#: xml/ddl.xml:144(para)
msgid "<indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>If no default value is declared explicitly, the default value is the null value. This usually makes sense because a null value can be considered to represent unknown data."
msgstr ""

#: xml/ddl.xml:154(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n    name text, price numeric \n    <emphasis>DEFAULT 9.99</emphasis>);"
msgstr ""

#: xml/ddl.xml:152(para)
msgid "In a table definition, default values are listed after the column data type. For example: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:168(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer \n    <emphasis>DEFAULT\n    nextval('products_product_no_seq')</emphasis>, ...\n    );"
msgstr ""

#: xml/ddl.xml:177(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no \n    <emphasis>SERIAL</emphasis>, ... );"
msgstr ""

#: xml/ddl.xml:157(para)
msgid "The default value can be an expression, which will be evaluated whenever the default value is inserted ( <emphasis>not</emphasis>when the table is created). A common example is for a <type>timestamp</type>column to have a default of <literal>CURRENT_TIMESTAMP</literal>, so that it gets set to the time of row insertion. Another common example is generating a <quote>serial number</quote>for each row. In <productname>PostgreSQL</productname>this is typically done by something like: <placeholder-1/>where the <literal>nextval()</literal>function supplies successive values from a <firstterm>sequence object</firstterm>(see <xref linkend=\"functions-sequence\">). This arrangement is sufficiently common that there's a special shorthand for it: <placeholder-2/>The <literal>SERIAL</literal>shorthand is discussed further in <xref linkend=\"datatype-serial\">.</xref></xref>"
msgstr ""

#: xml/ddl.xml:183(title)
msgid "Constraints"
msgstr ""

#: xml/ddl.xml:185(primary) xml/ddl.xml:208(primary) xml/ddl.xml:228(primary) xml/ddl.xml:303(primary) xml/ddl.xml:357(primary) xml/ddl.xml:412(primary) xml/ddl.xml:458(primary) xml/ddl.xml:631(primary) xml/ddl.xml:935(primary) xml/ddl.xml:956(primary)
msgid "constraint"
msgstr ""

#: xml/ddl.xml:187(para)
msgid "Data types are a way to limit the kind of data that can be stored in a table. For many applications, however, the constraint they provide is too coarse. For example, a column containing a product price should probably only accept positive values. But there is no standard data type that accepts only positive numbers. Another issue is that you might want to constrain column data with respect to other columns or rows. For example, in a table containing product information, there should be only one row for each product number."
msgstr ""

#: xml/ddl.xml:196(para)
msgid "To that end, SQL allows you to define constraints on columns and tables. Constraints give you as much control over the data in your tables as you wish. If a user attempts to store data in a column that would violate a constraint, an error is raised. This applies even if the value came from the default value definition."
msgstr ""

#: xml/ddl.xml:203(title)
msgid "Check Constraints"
msgstr ""

#: xml/ddl.xml:205(primary)
msgid "check constraint"
msgstr ""

#: xml/ddl.xml:209(secondary)
msgid "check"
msgstr ""

#: xml/ddl.xml:215(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric \n      <emphasis>CHECK (price\n      0)</emphasis>);"
msgstr ""

#: xml/ddl.xml:211(para)
msgid "A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:219(para)
msgid "As you see, the constraint definition comes after the data type, just like default value definitions. Default values and constraints can be listed in any order. A check constraint consists of the key word <literal>CHECK</literal>followed by an expression in parentheses. The check constraint expression should involve the column thus constrained, otherwise the constraint would not make too much sense."
msgstr ""

#: xml/ddl.xml:229(secondary) xml/ddl.xml:1503(primary) xml/ddl.xml:1584(primary)
msgid "name"
msgstr ""

#: xml/ddl.xml:234(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric \n      <emphasis>CONSTRAINT positive_price</emphasis>CHECK (price 0)\n      );"
msgstr ""

#: xml/ddl.xml:231(para)
msgid "You can also give the constraint a separate name. This clarifies error messages and allows you to refer to the constraint when you need to change it. The syntax is: <placeholder-1/>So, to specify a named constraint, use the key word <literal>CONSTRAINT</literal>followed by an identifier followed by the constraint definition. (If you don't specify a constraint name in this way, the system chooses a name for you.)"
msgstr ""

#: xml/ddl.xml:247(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric CHECK (price 0), discounted_price\n      numeric CHECK (discounted_price 0), \n      <emphasis>CHECK (price\n      discounted_price)</emphasis>);"
msgstr ""

#: xml/ddl.xml:243(para)
msgid "A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:252(para)
msgid "The first two constraints should look familiar. The third one uses a new syntax. It is not attached to a particular column, instead it appears as a separate item in the comma-separated column list. Column definitions and these constraint definitions can be listed in mixed order."
msgstr ""

#: xml/ddl.xml:268(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric, CHECK (price 0), discounted_price\n      numeric, CHECK (discounted_price 0), CHECK (price\n      discounted_price) );"
msgstr ""

#: xml/ddl.xml:272(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric CHECK (price 0), discounted_price\n      numeric, CHECK (discounted_price 0 AND price\n      discounted_price) );"
msgstr ""

#: xml/ddl.xml:257(para)
msgid "We say that the first two constraints are column constraints, whereas the third one is a table constraint because it is written separately from any one column definition. Column constraints can also be written as table constraints, while the reverse is not necessarily possible, since a column constraint is supposed to refer to only the column it is attached to. ( <productname>PostgreSQL</productname>doesn't enforce that rule, but you should follow it if you want your table definitions to work with other database systems.) The above example could also be written as: <placeholder-1/>or even: <placeholder-2/>It's a matter of taste."
msgstr ""

#: xml/ddl.xml:279(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric, CHECK (price 0), discounted_price\n      numeric, CHECK (discounted_price 0), \n      <emphasis>CONSTRAINT valid_discount</emphasis>CHECK (price\n      discounted_price) );"
msgstr ""

#: xml/ddl.xml:277(para)
msgid "Names can be assigned to table constraints in the same way as column constraints: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:285(primary) xml/ddl.xml:390(primary)
msgid "null value"
msgstr ""

#: xml/ddl.xml:286(secondary)
msgid "with check constraints"
msgstr ""

#: xml/ddl.xml:289(para)
msgid "It should be noted that a check constraint is satisfied if the check expression evaluates to true or the null value. Since most expressions will evaluate to the null value if any operand is null, they will not prevent null values in the constrained columns. To ensure that a column does not contain null values, the not-null constraint described in the next section can be used."
msgstr ""

#: xml/ddl.xml:298(title)
msgid "Not-Null Constraints"
msgstr ""

#: xml/ddl.xml:300(primary)
msgid "not-null constraint"
msgstr ""

#: xml/ddl.xml:304(secondary)
msgid "NOT NULL"
msgstr ""

#: xml/ddl.xml:308(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer \n      <emphasis>NOT NULL</emphasis>, name text \n      <emphasis>NOT NULL</emphasis>, price numeric\n      );"
msgstr ""

#: xml/ddl.xml:306(para)
msgid "A not-null constraint simply specifies that a column must not assume the null value. A syntax example: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:312(para)
msgid "A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint <literal>CHECK ( <replaceable>column_name</replaceable>IS NOT NULL)</literal>, but in <productname>PostgreSQL</productname>creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way."
msgstr ""

#: xml/ddl.xml:324(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer\n      NOT NULL, name text NOT NULL, price numeric NOT NULL CHECK\n      (price 0) );"
msgstr ""

#: xml/ddl.xml:322(para)
msgid "Of course, a column can have more than one constraint. Just write the constraints one after another: <placeholder-1/>The order doesn't matter. It does not necessarily determine in which order the constraints are checked."
msgstr ""

#: xml/ddl.xml:342(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer\n      NULL, name text NULL, price numeric NULL\n      );"
msgstr ""

#: xml/ddl.xml:329(para)
msgid "The <literal>NOT NULL</literal>constraint has an inverse: the <literal>NULL</literal>constraint. This does not mean that the column must be null, which would surely be useless. Instead, this simply selects the default behavior that the column might be null. The <literal>NULL</literal>constraint is not present in the SQL standard and should not be used in portable applications. (It was only added to <productname>PostgreSQL</productname>to be compatible with some other database systems.) Some users, however, like it because it makes it easy to toggle the constraint in a script file. For example, you could start with: <placeholder-1/>and then insert the <literal>NOT</literal>key word where desired."
msgstr ""

#: xml/ddl.xml:347(para)
msgid "In most database designs the majority of columns should be marked not null."
msgstr ""

#: xml/ddl.xml:352(title)
msgid "Unique Constraints"
msgstr ""

#: xml/ddl.xml:354(primary)
msgid "unique constraint"
msgstr ""

#: xml/ddl.xml:358(secondary)
msgid "unique"
msgstr ""

#: xml/ddl.xml:363(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer \n      <emphasis>UNIQUE</emphasis>, name text, price numeric\n      );"
msgstr ""

#: xml/ddl.xml:366(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer,\n      name text, price numeric, \n      <emphasis>UNIQUE\n      (product_no)</emphasis>);"
msgstr ""

#: xml/ddl.xml:360(para)
msgid "Unique constraints ensure that the data contained in a column or a group of columns is unique with respect to all the rows in the table. The syntax is: <placeholder-1/>when written as a column constraint, and: <placeholder-2/>when written as a table constraint."
msgstr ""

#: xml/ddl.xml:373(programlisting)
#, no-wrap
msgid "CREATE TABLE example ( a integer, b integer,\n      c integer, \n      <emphasis>UNIQUE (a, c)</emphasis>);"
msgstr ""

#: xml/ddl.xml:371(para)
msgid "If a unique constraint refers to a group of columns, the columns are listed separated by commas: <placeholder-1/>This specifies that the combination of values in the indicated columns is unique across the whole table, though any one of the columns need not be (and ordinarily isn't) unique."
msgstr ""

#: xml/ddl.xml:381(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer \n      <emphasis>CONSTRAINT must_be_different</emphasis>UNIQUE, name\n      text, price numeric );"
msgstr ""

#: xml/ddl.xml:379(para)
msgid "You can assign your own name for a unique constraint, in the usual way: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:384(para)
msgid "Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns used in the constraint. A uniqueness constraint on only some rows can be enforced by creating a <link linkend=\"indexes-partial\">partial index</link>."
msgstr ""

#: xml/ddl.xml:391(secondary)
msgid "with unique constraints"
msgstr ""

#: xml/ddl.xml:394(para)
msgid "In general, a unique constraint is violated when there is more than one row in the table where the values of all of the columns included in the constraint are equal. However, two null values are not considered equal in this comparison. That means even in the presence of a unique constraint it is possible to store duplicate rows that contain a null value in at least one of the constrained columns. This behavior conforms to the SQL standard, but we have heard that other SQL databases might not follow this rule. So be careful when developing applications that are intended to be portable."
msgstr ""

#: xml/ddl.xml:407(title)
msgid "Primary Keys"
msgstr ""

#: xml/ddl.xml:409(primary) xml/ddl.xml:413(secondary)
msgid "primary key"
msgstr ""

#: xml/ddl.xml:419(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer\n      UNIQUE NOT NULL, name text, price numeric );"
msgstr ""

#: xml/ddl.xml:421(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer \n      <emphasis>PRIMARY KEY</emphasis>, name text, price numeric\n      );"
msgstr ""

#: xml/ddl.xml:415(para)
msgid "Technically, a primary key constraint is simply a combination of a unique constraint and a not-null constraint. So, the following two table definitions accept the same data: <placeholder-1/><placeholder-2/>"
msgstr ""

#: xml/ddl.xml:426(programlisting)
#, no-wrap
msgid "CREATE TABLE example ( a integer, b integer,\n      c integer, \n      <emphasis>PRIMARY KEY (a,\n      c)</emphasis>);"
msgstr ""

#: xml/ddl.xml:424(para)
msgid "Primary keys can also constrain more than one column; the syntax is similar to unique constraints: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:430(para)
msgid "A primary key indicates that a column or group of columns can be used as a unique identifier for rows in the table. (This is a direct consequence of the definition of a primary key. Note that a unique constraint does not, by itself, provide a unique identifier because it does not exclude null values.) This is useful both for documentation purposes and for client applications. For example, a GUI application that allows modifying row values probably needs to know the primary key of a table to be able to identify rows uniquely."
msgstr ""

#: xml/ddl.xml:440(para)
msgid "Adding a primary key will automatically create a unique B-tree index on the column or group of columns used in the primary key."
msgstr ""

#: xml/ddl.xml:443(para)
msgid "A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by <productname>PostgreSQL</productname>, but it is usually best to follow it."
msgstr ""

#: xml/ddl.xml:453(title)
msgid "Foreign Keys"
msgstr ""

#: xml/ddl.xml:455(primary) xml/ddl.xml:459(secondary)
msgid "foreign key"
msgstr ""

#: xml/ddl.xml:462(primary)
msgid "referential integrity"
msgstr ""

#: xml/ddl.xml:464(para)
msgid "A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the <firstterm>referential integrity</firstterm>between two related tables."
msgstr ""

#: xml/ddl.xml:472(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer\n      PRIMARY KEY, name text, price numeric\n      );"
msgstr ""

#: xml/ddl.xml:479(programlisting)
#, no-wrap
msgid "CREATE TABLE orders ( order_id integer\n      PRIMARY KEY, product_no integer \n      <emphasis>REFERENCES products (product_no)</emphasis>,\n      quantity integer );"
msgstr ""

#: xml/ddl.xml:470(para)
msgid "Say you have the product table that we have used several times already: <placeholder-1/>Let's also assume you have a table storing orders of those products. We want to ensure that the orders table only contains orders of products that actually exist. So we define a foreign key constraint in the orders table that references the products table: <placeholder-2/>Now it is impossible to create orders with non-NULL <structfield>product_no</structfield>entries that do not appear in the products table."
msgstr ""

#: xml/ddl.xml:486(para)
msgid "We say that in this situation the orders table is the <firstterm>referencing</firstterm>table and the products table is the <firstterm>referenced</firstterm>table. Similarly, there are referencing and referenced columns."
msgstr ""

#: xml/ddl.xml:492(programlisting)
#, no-wrap
msgid "CREATE TABLE orders ( order_id integer\n      PRIMARY KEY, product_no integer \n      <emphasis>REFERENCES products</emphasis>, quantity integer\n      );"
msgstr ""

#: xml/ddl.xml:491(para)
msgid "You can also shorten the above command to: <placeholder-1/>because in absence of a column list the primary key of the referenced table is used as the referenced column(s)."
msgstr ""

#: xml/ddl.xml:501(programlisting)
#, no-wrap
msgid "CREATE TABLE t1 ( a integer PRIMARY KEY, b\n      integer, c integer, \n      <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1,\n      c2)</emphasis>);"
msgstr ""

#: xml/ddl.xml:498(para)
msgid "A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example: <placeholder-1/>Of course, the number and type of the constrained columns need to match the number and type of the referenced columns."
msgstr ""

#: xml/ddl.xml:507(para)
msgid "You can assign your own name for a foreign key constraint, in the usual way."
msgstr ""

#: xml/ddl.xml:515(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer\n      PRIMARY KEY, name text, price numeric ); CREATE TABLE orders\n      ( order_id integer PRIMARY KEY, shipping_address text, ... );\n      CREATE TABLE order_items ( product_no integer REFERENCES\n      products, order_id integer REFERENCES orders, quantity\n      integer, PRIMARY KEY (product_no, order_id)\n      );"
msgstr ""

#: xml/ddl.xml:509(para)
msgid "A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure: <placeholder-1/>Notice that the primary key overlaps with the foreign keys in the last table."
msgstr ""

#: xml/ddl.xml:524(primary) xml/ddl.xml:1981(literal) xml/ddl.xml:2694(primary)
msgid "CASCADE"
msgstr ""

#: xml/ddl.xml:525(secondary) xml/ddl.xml:529(secondary)
msgid "foreign key action"
msgstr ""

#: xml/ddl.xml:528(primary) xml/ddl.xml:2698(primary)
msgid "RESTRICT"
msgstr ""

#: xml/ddl.xml:538(para)
msgid "Disallow deleting a referenced product"
msgstr ""

#: xml/ddl.xml:541(para)
msgid "Delete the orders as well"
msgstr ""

#: xml/ddl.xml:544(para)
msgid "Something else?"
msgstr ""

#: xml/ddl.xml:531(para)
msgid "We know that the foreign keys disallow creation of orders that do not relate to any products. But what if a product is removed after an order is created that references it? SQL allows you to handle that as well. Intuitively, we have a few options: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:553(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( product_no integer\n      PRIMARY KEY, name text, price numeric ); CREATE TABLE orders\n      ( order_id integer PRIMARY KEY, shipping_address text, ... );\n      CREATE TABLE order_items ( product_no integer REFERENCES\n      products \n      <emphasis>ON DELETE RESTRICT</emphasis>, order_id integer\n      REFERENCES orders \n      <emphasis>ON DELETE CASCADE</emphasis>, quantity integer,\n      PRIMARY KEY (product_no, order_id) );"
msgstr ""

#: xml/ddl.xml:547(para)
msgid "To illustrate this, let's implement the following policy on the many-to-many relationship example above: when someone wants to remove a product that is still referenced by an order (via <literal>order_items</literal>), we disallow it. If someone removes an order, the order items are removed as well: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:562(para)
msgid "Restricting and cascading deletes are the two most common options. <literal>RESTRICT</literal>prevents deletion of a referenced row. <literal>NO ACTION</literal>means that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is that <literal>NO ACTION</literal>allows the check to be deferred until later in the transaction, whereas <literal>RESTRICT</literal>does not.) <literal>CASCADE</literal>specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. There are two other options: <literal>SET NULL</literal>and <literal>SET DEFAULT</literal>. These cause the referencing column(s) in the referencing row(s) to be set to nulls or their default values, respectively, when the referenced row is deleted. Note that these do not excuse you from observing any constraints. For example, if an action specifies <literal>SET DEFAULT</literal>but the default value would not satisfy the foreign key constraint, the operation will fail."
msgstr ""

#: xml/ddl.xml:586(para)
msgid "Analogous to <literal>ON DELETE</literal>there is also <literal>ON UPDATE</literal>which is invoked when a referenced column is changed (updated). The possible actions are the same. In this case, <literal>CASCADE</literal>means that the updated values of the referenced column(s) should be copied into the referencing row(s)."
msgstr ""

#: xml/ddl.xml:594(para)
msgid "Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If <literal>MATCH FULL</literal>is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a <literal>MATCH FULL</literal>constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as <literal>NOT NULL</literal>."
msgstr ""

#: xml/ddl.xml:605(para)
msgid "A foreign key must reference columns that either are a primary key or form a unique constraint. This means that the referenced columns always have an index (the one underlying the primary key or unique constraint); so checks on whether a referencing row has a match will be efficient. Since a <command>DELETE</command>of a row from the referenced table or an <command>UPDATE</command>of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, declaration of a foreign key constraint does not automatically create an index on the referencing columns."
msgstr ""

#: xml/ddl.xml:619(para)
msgid "More information about updating and deleting data is in <xref linkend=\"dml\">. Also see the description of foreign key constraint syntax in the reference documentation for <xref linkend=\"sql-createtable\">.</xref></xref>"
msgstr ""

#: xml/ddl.xml:626(title)
msgid "Exclusion Constraints"
msgstr ""

#: xml/ddl.xml:628(primary)
msgid "exclusion constraint"
msgstr ""

#: xml/ddl.xml:632(secondary)
msgid "exclusion"
msgstr ""

#: xml/ddl.xml:638(programlisting)
#, no-wrap
msgid "CREATE TABLE circles ( c circle, EXCLUDE\n      USING gist (c WITH ) );"
msgstr ""

#: xml/ddl.xml:634(para)
msgid "Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, at least one of these operator comparisons will return false or null. The syntax is: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:640(para)
msgid "See also <link linkend=\"SQL-CREATETABLE-EXCLUDE\"><command>CREATE TABLE ... CONSTRAINT ... EXCLUDE</command></link>for details."
msgstr ""

#: xml/ddl.xml:644(para)
msgid "Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration."
msgstr ""

#: xml/ddl.xml:650(title)
msgid "System Columns"
msgstr ""

#: xml/ddl.xml:651(para)
msgid "Every table has several <firstterm>system columns</firstterm>that are implicitly defined by the system. Therefore, these names cannot be used as names of user-defined columns. (Note that these restrictions are separate from whether the name is a key word or not; quoting a name will not allow you to escape these restrictions.) You do not really need to be concerned about these columns; just know they exist."
msgstr ""

#: xml/ddl.xml:661(secondary)
msgid "system column"
msgstr ""

#: xml/ddl.xml:666(structfield)
msgid "oid"
msgstr ""

#: xml/ddl.xml:669(para)
msgid "<indexterm><primary>OID</primary><secondary>column</secondary></indexterm>The object identifier (object ID) of a row. This column is only present if the table was created using <literal>WITH OIDS</literal>, or if the <xref linkend=\"guc-default-with-oids\">configuration variable was set at the time. This column is of type <type>oid</type>(same name as the column); see <xref linkend=\"datatype-oid\">for more information about the type.</xref></xref>"
msgstr ""

#: xml/ddl.xml:686(structfield) xml/ddl.xml:690(primary)
msgid "tableoid"
msgstr ""

#: xml/ddl.xml:692(para)
msgid "The OID of the table containing this row. This column is particularly handy for queries that select from inheritance hierarchies (see <xref linkend=\"ddl-inherit\">), since without it, it's difficult to tell which individual table a row came from. The <structfield>tableoid</structfield>can be joined against the <structfield>oid</structfield>column of <structname>pg_class</structname>to obtain the table name.</xref>"
msgstr ""

#: xml/ddl.xml:707(structfield) xml/ddl.xml:711(primary)
msgid "xmin"
msgstr ""

#: xml/ddl.xml:713(para)
msgid "The identity (transaction ID) of the inserting transaction for this row version. (A row version is an individual state of a row; each update of a row creates a new row version for the same logical row.)"
msgstr ""

#: xml/ddl.xml:721(structfield) xml/ddl.xml:725(primary)
msgid "cmin"
msgstr ""

#: xml/ddl.xml:727(para)
msgid "The command identifier (starting at zero) within the inserting transaction."
msgstr ""

#: xml/ddl.xml:733(structfield) xml/ddl.xml:737(primary)
msgid "xmax"
msgstr ""

#: xml/ddl.xml:739(para)
msgid "The identity (transaction ID) of the deleting transaction, or zero for an undeleted row version. It is possible for this column to be nonzero in a visible row version. That usually indicates that the deleting transaction hasn't committed yet, or that an attempted deletion was rolled back."
msgstr ""

#: xml/ddl.xml:749(structfield) xml/ddl.xml:753(primary)
msgid "cmax"
msgstr ""

#: xml/ddl.xml:755(para)
msgid "The command identifier within the deleting transaction, or zero."
msgstr ""

#: xml/ddl.xml:761(structfield) xml/ddl.xml:765(primary)
msgid "ctid"
msgstr ""

#: xml/ddl.xml:767(para)
msgid "The physical location of the row version within its table. Note that although the <structfield>ctid</structfield>can be used to locate the row version very quickly, a row's <structfield>ctid</structfield>will change if it is updated or moved by <command>VACUUM FULL</command>. Therefore <structfield>ctid</structfield>is useless as a long-term row identifier. The OID, or even better a user-defined serial number, should be used to identify logical rows."
msgstr ""

#: xml/ddl.xml:791(para)
msgid "A unique constraint should be created on the OID column of each table for which the OID will be used to identify rows. When such a unique constraint (or unique index) exists, the system takes care not to generate an OID matching an already-existing row. (Of course, this is only possible if the table contains fewer than 2 <superscript>32</superscript>(4 billion) rows, and in practice the table size had better be much less than that, or performance might suffer.)"
msgstr ""

#: xml/ddl.xml:802(para)
msgid "OIDs should never be assumed to be unique across tables; use the combination of <structfield>tableoid</structfield>and row OID if you need a database-wide identifier."
msgstr ""

#: xml/ddl.xml:808(para)
msgid "Of course, the tables in question must be created <literal>WITH OIDS</literal>. As of <productname>PostgreSQL</productname>8.1, <literal>WITHOUT OIDS</literal>is the default."
msgstr ""

#: xml/ddl.xml:781(para)
msgid "OIDs are 32-bit quantities and are assigned from a single cluster-wide counter. In a large or long-lived database, it is possible for the counter to wrap around. Hence, it is bad practice to assume that OIDs are unique, unless you take steps to ensure that this is the case. If you need to identify the rows in a table, using a sequence generator is strongly recommended. However, OIDs can be used as well, provided that a few additional precautions are taken: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:814(para)
msgid "Transaction identifiers are also 32-bit quantities. In a long-lived database it is possible for transaction IDs to wrap around. This is not a fatal problem given appropriate maintenance procedures; see <xref linkend=\"maintenance\">for details. It is unwise, however, to depend on the uniqueness of transaction IDs over the long term (more than one billion transactions).</xref>"
msgstr ""

#: xml/ddl.xml:821(para)
msgid "Command identifiers are also 32-bit quantities. This creates a hard limit of 2 <superscript>32</superscript>(4 billion) <acronym>SQL</acronym>commands within a single transaction. In practice this limit is not a problem note that the limit is on the number of <acronym>SQL</acronym>commands, not the number of rows processed. Also, only commands that actually modify the database contents will consume a command identifier."
msgstr ""

#: xml/ddl.xml:832(title)
msgid "Modifying Tables"
msgstr ""

#: xml/ddl.xml:835(secondary)
msgid "modifying"
msgstr ""

#: xml/ddl.xml:837(para)
msgid "When you create a table and you realize that you made a mistake, or the requirements of the application change, you can drop the table and create it again. But this is not a convenient option if the table is already filled with data, or if the table is referenced by other database objects (for instance a foreign key constraint). Therefore <productname>PostgreSQL</productname>provides a family of commands to make modifications to existing tables. Note that this is conceptually distinct from altering the data contained in the table: here we are interested in altering the definition, or structure, of the table."
msgstr ""

#: xml/ddl.xml:851(para)
msgid "Add columns"
msgstr ""

#: xml/ddl.xml:854(para)
msgid "Remove columns"
msgstr ""

#: xml/ddl.xml:857(para)
msgid "Add constraints"
msgstr ""

#: xml/ddl.xml:860(para)
msgid "Remove constraints"
msgstr ""

#: xml/ddl.xml:863(para)
msgid "Change default values"
msgstr ""

#: xml/ddl.xml:866(para)
msgid "Change column data types"
msgstr ""

#: xml/ddl.xml:869(para)
msgid "Rename columns"
msgstr ""

#: xml/ddl.xml:872(para)
msgid "Rename tables"
msgstr ""

#: xml/ddl.xml:848(para)
msgid "You can: <placeholder-1/>All these actions are performed using the <xref linkend=\"sql-altertable\">command, whose reference page contains details beyond those given here.</xref>"
msgstr ""

#: xml/ddl.xml:878(title)
msgid "Adding a Column"
msgstr ""

#: xml/ddl.xml:881(secondary) xml/ddl.xml:936(secondary)
msgid "adding"
msgstr ""

#: xml/ddl.xml:884(programlisting)
#, no-wrap
msgid "ALTER TABLE products ADD COLUMN description\n      text;"
msgstr ""

#: xml/ddl.xml:883(para)
msgid "To add a column, use a command like: <placeholder-1/>The new column is initially filled with whatever default value is given (null if you don't specify a <literal>DEFAULT</literal>clause)."
msgstr ""

#: xml/ddl.xml:890(programlisting)
#, no-wrap
msgid "ALTER TABLE products ADD COLUMN description\n      text CHECK (description '');"
msgstr ""

#: xml/ddl.xml:888(para)
msgid "You can also define constraints on the column at the same time, using the usual syntax: <placeholder-1/>In fact all the options that can be applied to a column description in <command>CREATE TABLE</command>can be used here. Keep in mind however that the default value must satisfy the given constraints, or the <literal>ADD</literal>will fail. Alternatively, you can add constraints later (see below) after you've filled in the new column correctly."
msgstr ""

#: xml/ddl.xml:900(para)
msgid "Adding a column with a default requires updating each row of the table (to store the new column value). However, if no default is specified, <productname>PostgreSQL</productname>is able to avoid the physical update. So if you intend to fill the column with mostly nondefault values, it's best to add the column with no default, insert the correct values using <command>UPDATE</command>, and then add any desired default as described below."
msgstr ""

#: xml/ddl.xml:912(title)
msgid "Removing a Column"
msgstr ""

#: xml/ddl.xml:918(programlisting)
#, no-wrap
msgid "ALTER TABLE products DROP COLUMN\n      description;"
msgstr ""

#: xml/ddl.xml:927(programlisting)
#, no-wrap
msgid "ALTER TABLE products DROP COLUMN description\n      CASCADE;"
msgstr ""

#: xml/ddl.xml:917(para)
msgid "To remove a column, use a command like: <placeholder-1/>Whatever data was in the column disappears. Table constraints involving the column are dropped, too. However, if the column is referenced by a foreign key constraint of another table, <productname>PostgreSQL</productname>will not silently drop that constraint. You can authorize dropping everything that depends on the column by adding <literal>CASCADE</literal>: <placeholder-2/>See <xref linkend=\"ddl-depend\">for a description of the general mechanism behind this.</xref>"
msgstr ""

#: xml/ddl.xml:933(title)
msgid "Adding a Constraint"
msgstr ""

#: xml/ddl.xml:940(programlisting)
#, no-wrap
msgid "ALTER TABLE products ADD CHECK (name '');\n      ALTER TABLE products ADD CONSTRAINT some_name UNIQUE\n      (product_no); ALTER TABLE products ADD FOREIGN KEY\n      (product_group_id) REFERENCES\n      product_groups;"
msgstr ""

#: xml/ddl.xml:947(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN product_no\n      SET NOT NULL;"
msgstr ""

#: xml/ddl.xml:938(para)
msgid "To add a constraint, the table constraint syntax is used. For example: <placeholder-1/>To add a not-null constraint, which cannot be written as a table constraint, use this syntax: <placeholder-2/>"
msgstr ""

#: xml/ddl.xml:949(para)
msgid "The constraint will be checked immediately, so the table data must satisfy the constraint before it can be added."
msgstr ""

#: xml/ddl.xml:954(title)
msgid "Removing a Constraint"
msgstr ""

#: xml/ddl.xml:967(programlisting)
#, no-wrap
msgid "ALTER TABLE products DROP CONSTRAINT\n      some_name;"
msgstr ""

#: xml/ddl.xml:959(para)
msgid "To remove a constraint you need to know its name. If you gave it a name then that's easy. Otherwise the system assigned a generated name, which you need to find out. The <application>psql</application>command <literal>\\d <replaceable>tablename</replaceable></literal>can be helpful here; other interfaces might also provide a way to inspect table details. Then the command is: <placeholder-1/>(If you are dealing with a generated constraint name like <literal>$2</literal>, don't forget that you'll need to double-quote it to make it a valid identifier.)"
msgstr ""

#: xml/ddl.xml:972(para)
msgid "As with dropping a column, you need to add <literal>CASCADE</literal>if you want to drop a constraint that something else depends on. An example is that a foreign key constraint depends on a unique or primary key constraint on the referenced column(s)."
msgstr ""

#: xml/ddl.xml:979(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN product_no\n      DROP NOT NULL;"
msgstr ""

#: xml/ddl.xml:977(para)
msgid "This works the same for all constraint types except not-null constraints. To drop a not null constraint use: <placeholder-1/>(Recall that not-null constraints do not have names.)"
msgstr ""

#: xml/ddl.xml:984(title)
msgid "Changing a Column's Default Value"
msgstr ""

#: xml/ddl.xml:987(secondary) xml/ddl.xml:1006(secondary)
msgid "changing"
msgstr ""

#: xml/ddl.xml:990(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN price SET\n      DEFAULT 7.77;"
msgstr ""

#: xml/ddl.xml:989(para)
msgid "To set a new default for a column, use a command like: <placeholder-1/>Note that this doesn't affect any existing rows in the table, it just changes the default for future <command>INSERT</command>commands."
msgstr ""

#: xml/ddl.xml:996(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN price DROP\n      DEFAULT;"
msgstr ""

#: xml/ddl.xml:995(para)
msgid "To remove any default value, use: <placeholder-1/>This is effectively the same as setting the default to null. As a consequence, it is not an error to drop a default where one hadn't been defined, because the default is implicitly the null value."
msgstr ""

#: xml/ddl.xml:1003(title)
msgid "Changing a Column's Data Type"
msgstr ""

#: xml/ddl.xml:1005(primary)
msgid "column data type"
msgstr ""

#: xml/ddl.xml:1010(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN price TYPE\n      numeric(10,2);"
msgstr ""

#: xml/ddl.xml:1008(para)
msgid "To convert a column to a different data type, use a command like: <placeholder-1/>This will succeed only if each existing entry in the column can be converted to the new type by an implicit cast. If a more complex conversion is needed, you can add a <literal>USING</literal>clause that specifies how to compute the new values from the old."
msgstr ""

#: xml/ddl.xml:1017(para)
msgid "<productname>PostgreSQL</productname>will attempt to convert the column's default value (if any) to the new type, as well as any constraints that involve the column. But these conversions might fail, or might produce surprising results. It's often best to drop any constraints on the column before altering its type, and then add back suitably modified constraints afterwards."
msgstr ""

#: xml/ddl.xml:1027(title)
msgid "Renaming a Column"
msgstr ""

#: xml/ddl.xml:1030(secondary) xml/ddl.xml:1040(secondary)
msgid "renaming"
msgstr ""

#: xml/ddl.xml:1033(programlisting)
#, no-wrap
msgid "ALTER TABLE products RENAME COLUMN product_no\n      TO product_number;"
msgstr ""

#: xml/ddl.xml:1032(para)
msgid "To rename a column: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:1037(title)
msgid "Renaming a Table"
msgstr ""

#: xml/ddl.xml:1043(programlisting)
#, no-wrap
msgid "ALTER TABLE products RENAME TO\n      items;"
msgstr ""

#: xml/ddl.xml:1042(para)
msgid "To rename a table: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:1048(title)
msgid "Privileges"
msgstr ""

#: xml/ddl.xml:1050(primary) xml/ddl.xml:1054(see) xml/ddl.xml:1672(primary)
msgid "privilege"
msgstr ""

#: xml/ddl.xml:1053(primary)
msgid "permission"
msgstr ""

#: xml/ddl.xml:1057(primary)
msgid "owner"
msgstr ""

#: xml/ddl.xml:1060(primary)
msgid "GRANT"
msgstr ""

#: xml/ddl.xml:1063(primary)
msgid "REVOKE"
msgstr ""

#: xml/ddl.xml:1065(para)
msgid "When an object is created, it is assigned an owner. The owner is normally the role that executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can do anything with the object. To allow other roles to use it, <firstterm>privileges</firstterm>must be granted."
msgstr ""

#: xml/ddl.xml:1071(para)
msgid "There are different kinds of privileges: <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>, <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>, and <literal>USAGE</literal>. The privileges applicable to a particular object vary depending on the object's type (table, function, etc). For complete information on the different types of privileges supported by <productname>PostgreSQL</productname>, refer to the <xref linkend=\"sql-grant\">reference page. The following sections and chapters will also show you how those privileges are used.</xref>"
msgstr ""

#: xml/ddl.xml:1091(para)
msgid "The right to modify or destroy an object is always the privilege of the owner only."
msgstr ""

#: xml/ddl.xml:1093(para)
msgid "An object can be assigned to a new owner with an <command>ALTER</command>command of the appropriate kind for the object, e.g. <xref linkend=\"sql-altertable\">. Superusers can always do this; ordinary roles can only do it if they are both the current owner of the object (or a member of the owning role) and a member of the new owning role.</xref>"
msgstr ""

#: xml/ddl.xml:1105(programlisting)
#, no-wrap
msgid "GRANT UPDATE ON accounts TO\n    joe;"
msgstr ""

#: xml/ddl.xml:1100(para)
msgid "To assign privileges, the <command>GRANT</command>command is used. For example, if <literal>joe</literal>is an existing user, and <literal>accounts</literal>is an existing table, the privilege to update the table can be granted with: <placeholder-1/>Writing <literal>ALL</literal>in place of a specific privilege grants all privileges that are relevant for the object type."
msgstr ""

#: xml/ddl.xml:1109(para)
msgid "The special <quote>user</quote>name <literal>PUBLIC</literal>can be used to grant a privilege to every user on the system. Also, <quote>group</quote>roles can be set up to help manage privileges when there are many users of a database for details see <xref linkend=\"user-manag\">.</xref>"
msgstr ""

#: xml/ddl.xml:1119(programlisting)
#, no-wrap
msgid "REVOKE ALL ON accounts FROM\n    PUBLIC;"
msgstr ""

#: xml/ddl.xml:1117(para)
msgid "To revoke a privilege, use the fittingly named <command>REVOKE</command>command: <placeholder-1/>The special privileges of the object owner (i.e., the right to do <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, etc.) are always implicit in being the owner, and cannot be granted or revoked. But the object owner can choose to revoke his own ordinary privileges, for example to make a table read-only for himself as well as others."
msgstr ""

#: xml/ddl.xml:1129(para)
msgid "Ordinarily, only the object's owner (or a superuser) can grant or revoke privileges on an object. However, it is possible to grant a privilege <quote>with grant option</quote>, which gives the recipient the right to grant it in turn to others. If the grant option is subsequently revoked then all who received the privilege from that recipient (directly or through a chain of grants) will lose the privilege. For details see the <xref linkend=\"sql-grant\">and <xref linkend=\"sql-revoke\">reference pages.</xref></xref>"
msgstr ""

#: xml/ddl.xml:1142(title)
msgid "Row Security Policies"
msgstr ""

#: xml/ddl.xml:1144(primary)
msgid "row-level security"
msgstr ""

#: xml/ddl.xml:1147(primary)
msgid "policy"
msgstr ""

#: xml/ddl.xml:1149(para)
msgid "In addition to the SQL-standard <link linkend=\"ddl-priv\">privilege system</link>available through <xref linkend=\"sql-grant\">, tables can have <firstterm>row security policies</firstterm>that restrict, on a per-user basis, which rows can be returned by normal queries or inserted, updated, or deleted by data modification commands. This feature is also known as <firstterm>Row-Level Security</firstterm>. By default, tables do not have any policies, so that if a user has access privileges to a table according to the SQL privilege system, all rows within it are equally available for querying or updating.</xref>"
msgstr ""

#: xml/ddl.xml:1162(para)
msgid "When row security is enabled on a table (with <link linkend=\"sql-altertable\">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</link>), all normal access to the table for selecting rows or modifying rows must be allowed by a row security policy. (However, the table's owner is typically not subject to row security policies.) If no policy exists for the table, a default-deny policy is used, meaning that no rows are visible or can be modified. Operations that apply to the whole table, such as <command>TRUNCATE</command>and <literal>REFERENCES</literal>, are not subject to row security."
msgstr ""

#: xml/ddl.xml:1174(para)
msgid "Row security policies can be specific to commands, or to roles, or to both. A policy can be specified to apply to <literal>ALL</literal>commands, or to <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, or <literal>DELETE</literal>. Multiple roles can be assigned to a given policy, and normal role membership and inheritance rules apply."
msgstr ""

#: xml/ddl.xml:1183(para)
msgid "To specify which rows are visible or modifiable according to a policy, an expression is required that returns a Boolean result. This expression will be evaluated for each row prior to any conditions or functions coming from the user's query. (The only exceptions to this rule are <literal>leakproof</literal>functions, which are guaranteed to not leak information; the optimizer may choose to apply such functions ahead of the row-security check.) Rows for which the expression does not return <literal>true</literal>will not be processed. Separate expressions may be specified to provide independent control over the rows which are visible and the rows which are allowed to be modified. Policy expressions are run as part of the query and with the privileges of the user running the query, although security-definer functions can be used to access data not available to the calling user."
msgstr ""

#: xml/ddl.xml:1199(para)
msgid "Superusers and roles with the <literal>BYPASSRLS</literal>attribute always bypass the row security system when accessing a table. Table owners normally bypass row security as well, though a table owner can choose to be subject to row security with <link linkend=\"sql-altertable\">ALTER TABLE ... FORCE ROW LEVEL SECURITY</link>."
msgstr ""

#: xml/ddl.xml:1206(para)
msgid "Enabling and disabling row security, as well as adding policies to a table, is always the privilege of the table owner only."
msgstr ""

#: xml/ddl.xml:1209(para)
msgid "Policies are created using the <xref linkend=\"sql-createpolicy\">command, altered using the <xref linkend=\"sql-alterpolicy\">command, and dropped using the <xref linkend=\"sql-droppolicy\">command. To enable and disable row security for a given table, use the <xref linkend=\"sql-altertable\"> command.</xref></xref></xref></xref>"
msgstr ""

#: xml/ddl.xml:1216(para)
msgid "Each policy has a name and multiple policies can be defined for a table. As policies are table-specific, each policy for a table must have a unique name. Different tables may have policies with the same name."
msgstr ""

#: xml/ddl.xml:1220(para)
msgid "When multiple policies apply to a given query, they are combined using <literal>OR</literal>, so that a row is accessible if any policy allows it. This is similar to the rule that a given role has the privileges of all roles that they are a member of."
msgstr ""

#: xml/ddl.xml:1226(para)
msgid "As a simple example, here is how to create a policy on the <literal>account</literal>relation to allow only members of the <literal>managers</literal>role to access rows, and only rows of their accounts:"
msgstr ""

#: xml/ddl.xml:1232(programlisting)
#, no-wrap
msgid "CREATE TABLE accounts (manager text, company\n    text, contact_email text); ALTER TABLE accounts ENABLE ROW\n    LEVEL SECURITY; CREATE POLICY account_managers ON accounts TO\n    managers USING (manager = current_user);"
msgstr ""

#: xml/ddl.xml:1236(para)
msgid "If no role is specified, or the special user name <literal>PUBLIC</literal>is used, then the policy applies to all users on the system. To allow all users to access their own row in a <literal>users</literal>table, a simple policy can be used:"
msgstr ""

#: xml/ddl.xml:1242(programlisting)
#, no-wrap
msgid "CREATE POLICY user_policy ON users USING (user\n    = current_user);"
msgstr ""

#: xml/ddl.xml:1244(para)
msgid "To use a different policy for rows that are being added to the table compared to those rows that are visible, the <literal>WITH CHECK</literal>clause can be used. This policy would allow all users to view all rows in the <literal>users</literal>table, but only modify their own:"
msgstr ""

#: xml/ddl.xml:1250(programlisting)
#, no-wrap
msgid "CREATE POLICY user_policy ON users USING (true)\n    WITH CHECK (user = current_user);"
msgstr ""

#: xml/ddl.xml:1252(para)
msgid "Row security can also be disabled with the <command>ALTER TABLE</command>command. Disabling row security does not remove any policies that are defined on the table; they are simply ignored. Then all rows in the table are visible and modifiable, subject to the standard SQL privileges system."
msgstr ""

#: xml/ddl.xml:1258(para)
msgid "Below is a larger example of how this feature can be used in production environments. The table <literal>passwd</literal>emulates a Unix password file:"
msgstr ""

#: xml/ddl.xml:1261(programlisting)
#, no-wrap
msgid "-- Simple passwd-file based example CREATE\n    TABLE passwd ( username text UNIQUE NOT NULL, pwhash text, uid\n    int PRIMARY KEY, gid int NOT NULL, real_name text NOT NULL,\n    home_phone text, extra_info text, home_dir text NOT NULL, shell\n    text NOT NULL ); CREATE ROLE admin; -- Administrator CREATE\n    ROLE bob; -- Normal user CREATE ROLE alice; -- Normal user --\n    Populate the table INSERT INTO passwd VALUES\n    ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');\n    INSERT INTO passwd VALUES\n    ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');\n    INSERT INTO passwd VALUES\n    ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');\n    -- Be sure to enable row level security on the table ALTER\n    TABLE passwd ENABLE ROW LEVEL SECURITY; -- Create policies --\n    Administrator can see all rows and add any rows CREATE POLICY\n    admin_all ON passwd TO admin USING (true) WITH CHECK (true); --\n    Normal users can view all rows CREATE POLICY all_view ON passwd\n    FOR SELECT USING (true); -- Normal users can update their own\n    records, but -- limit which shells a normal user is allowed to\n    set CREATE POLICY user_mod ON passwd FOR UPDATE USING\n    (current_user = username) WITH CHECK ( current_user = username\n    AND shell IN\n    ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh') );\n    -- Allow admin all normal rights GRANT SELECT, INSERT, UPDATE,\n    DELETE ON passwd TO admin; -- Users only get select access on\n    public columns GRANT SELECT (username, uid, gid, real_name,\n    home_phone, extra_info, home_dir, shell) ON passwd TO public;\n    -- Allow users to update certain columns GRANT UPDATE (pwhash,\n    real_name, home_phone, extra_info, shell) ON passwd TO\n    public;"
msgstr ""

#: xml/ddl.xml:1291(para)
msgid "As with any security settings, it's important to test and ensure that the system is behaving as expected. Using the example above, this demonstrates that the permission system is working properly."
msgstr ""

#: xml/ddl.xml:1295(programlisting)
#, no-wrap
msgid "-- admin can view all rows and fields postgres=\n    set role admin; SET postgres= table passwd; username | pwhash |\n    uid | gid | real_name | home_phone | extra_info | home_dir |\n    shell\n    ----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------\n    admin | xxx | 0 | 0 | Admin | 111-222-3333 | | /root |\n    /bin/dash bob | xxx | 1 | 1 | Bob | 123-456-7890 | | /home/bob\n    | /bin/zsh alice | xxx | 2 | 1 | Alice | 098-765-4321 | |\n    /home/alice | /bin/zsh (3 rows) -- Test what Alice is able to\n    do postgres= set role alice; SET postgres= table passwd; ERROR:\n    permission denied for relation passwd postgres= select\n    username,real_name,home_phone,extra_info,home_dir,shell from\n    passwd; username | real_name | home_phone | extra_info |\n    home_dir | shell\n    ----------+-----------+--------------+------------+-------------+-----------\n    admin | Admin | 111-222-3333 | | /root | /bin/dash bob | Bob |\n    123-456-7890 | | /home/bob | /bin/zsh alice | Alice |\n    098-765-4321 | | /home/alice | /bin/zsh (3 rows) postgres=\n    update passwd set username = 'joe'; ERROR: permission denied\n    for relation passwd -- Alice is allowed to change her own\n    real_name, but no others postgres= update passwd set real_name\n    = 'Alice Doe'; UPDATE 1 postgres= update passwd set real_name =\n    'John Doe' where username = 'admin'; UPDATE 0 postgres= update\n    passwd set shell = '/bin/xx'; ERROR: new row violates WITH\n    CHECK OPTION for \"passwd\" postgres= delete from passwd; ERROR:\n    permission denied for relation passwd postgres= insert into\n    passwd (username) values ('xxx'); ERROR: permission denied for\n    relation passwd -- Alice can change her own password; RLS\n    silently prevents updating other rows postgres= update passwd\n    set pwhash = 'abc'; UPDATE 1"
msgstr ""

#: xml/ddl.xml:1325(para)
msgid "Referential integrity checks, such as unique or primary key constraints and foreign key references, always bypass row security to ensure that data integrity is maintained. Care must be taken when developing schemas and row level policies to avoid <quote>covert channel</quote>leaks of information through such referential integrity checks."
msgstr ""

#: xml/ddl.xml:1332(para)
msgid "In some contexts it is important to be sure that row security is not being applied. For example, when taking a backup, it could be disastrous if row security silently caused some rows to be omitted from the backup. In such a situation, you can set the <xref linkend=\"guc-row-security\">configuration parameter to <literal>off</literal>. This does not in itself bypass row security; what it does is throw an error if any query's results would get filtered by a policy. The reason for the error can then be investigated and fixed.</xref>"
msgstr ""

#: xml/ddl.xml:1342(para)
msgid "In the examples above, the policy expressions consider only the current values in the row to be accessed or updated. This is the simplest and best-performing case; when possible, it's best to design row security applications to work this way. If it is necessary to consult other rows or other tables to make a policy decision, that can be accomplished using sub- <command>SELECT</command>s, or functions that contain <command>SELECT</command>s, in the policy expressions. Be aware however that such accesses can create race conditions that could allow information leakage if care is not taken. As an example, consider the following table design:"
msgstr ""

#: xml/ddl.xml:1353(programlisting)
#, no-wrap
msgid "-- definition of privilege groups CREATE TABLE\n    groups (group_id int PRIMARY KEY, group_name text NOT NULL);\n    INSERT INTO groups VALUES (1, 'low'), (2, 'medium'), (5,\n    'high'); GRANT ALL ON groups TO alice; -- alice is the\n    administrator GRANT SELECT ON groups TO public; -- definition\n    of users' privilege levels CREATE TABLE users (user_name text\n    PRIMARY KEY, group_id int NOT NULL REFERENCES groups); INSERT\n    INTO users VALUES ('alice', 5), ('bob', 2), ('mallory', 2);\n    GRANT ALL ON users TO alice; GRANT SELECT ON users TO public;\n    -- table holding the information to be protected CREATE TABLE\n    information (info text, group_id int NOT NULL REFERENCES\n    groups); INSERT INTO information VALUES ('barely secret', 1),\n    ('slightly secret', 2), ('very secret', 5); ALTER TABLE\n    information ENABLE ROW LEVEL SECURITY; -- a row should be\n    visible to/updatable by users whose security group_id is --\n    greater than or equal to the row's group_id CREATE POLICY fp_s\n    ON information FOR SELECT USING (group_id = (SELECT group_id\n    FROM users WHERE user_name = current_user)); CREATE POLICY fp_u\n    ON information FOR UPDATE USING (group_id = (SELECT group_id\n    FROM users WHERE user_name = current_user)); -- we rely only on\n    RLS to protect the information table GRANT ALL ON information\n    TO public;"
msgstr ""

#: xml/ddl.xml:1375(para)
msgid "Now suppose that <literal>alice</literal>wishes to change the <quote>slightly secret</quote>information, but decides that <literal>mallory</literal>should not be trusted with the new content of that row, so she does:"
msgstr ""

#: xml/ddl.xml:1380(programlisting)
#, no-wrap
msgid "BEGIN; UPDATE users SET group_id = 1 WHERE\n    user_name = 'mallory'; UPDATE information SET info = 'secret\n    from mallory' WHERE group_id = 2; COMMIT;"
msgstr ""

#: xml/ddl.xml:1388(programlisting)
#, no-wrap
msgid "SELECT * FROM information WHERE group_id = 2\n    FOR UPDATE;"
msgstr ""

#: xml/ddl.xml:1383(para)
msgid "That looks safe; there is no window wherein <literal>mallory</literal>should be able to see the <quote>secret from mallory</quote>string. However, there is a race condition here. If <literal>mallory</literal>is concurrently doing, say, <placeholder-1/>and her transaction is in <literal>READ COMMITTED</literal>mode, it is possible for her to see <quote>secret from mallory</quote>. That happens if her transaction reaches the <structname>information</structname>row just after <literal>alice</literal>'s does. It blocks waiting for <literal>alice</literal>'s transaction to commit, then fetches the updated row contents thanks to the <literal>FOR UPDATE</literal>clause. However, it does <emphasis>not</emphasis>fetch an updated row for the implicit <command>SELECT</command>from <structname>users</structname>, because that sub- <command>SELECT</command>did not have <literal>FOR UPDATE</literal>; instead the <structname>users</structname>row is read with the snapshot taken at the start of the query. Therefore, the policy expression tests the old value of <literal>mallory</literal>'s privilege level and allows her to see the updated row."
msgstr ""

#: xml/ddl.xml:1409(para)
msgid "There are several ways around this problem. One simple answer is to use <literal>SELECT ... FOR SHARE</literal>in sub- <command>SELECT</command>s in row security policies. However, that requires granting <literal>UPDATE</literal>privilege on the referenced table (here <structname>users</structname>) to the affected users, which might be undesirable. (But another row security policy could be applied to prevent them from actually exercising that privilege; or the sub- <command>SELECT</command>could be embedded into a security definer function.) Also, heavy concurrent use of row share locks on the referenced table could pose a performance problem, especially if updates of it are frequent. Another solution, practical if updates of the referenced table are infrequent, is to take an exclusive lock on the referenced table when updating it, so that no concurrent transactions could be examining old row values. Or one could just wait for all concurrent transactions to end after committing an update of the referenced table and before making changes that rely on the new security situation."
msgstr ""

#: xml/ddl.xml:1431(para)
msgid "For additional details see <xref linkend=\"sql-createpolicy\">and <xref linkend=\"sql-altertable\">.</xref></xref>"
msgstr ""

#: xml/ddl.xml:1436(title)
msgid "Schemas"
msgstr ""

#: xml/ddl.xml:1438(primary) xml/ddl.xml:1491(primary) xml/ddl.xml:1533(primary) xml/ddl.xml:1562(primary) xml/ddl.xml:1599(primary) xml/ddl.xml:1705(secondary)
msgid "schema"
msgstr ""

#: xml/ddl.xml:1440(para)
msgid "A <productname>PostgreSQL</productname>database cluster contains one or more named databases. Users and groups of users are shared across the entire cluster, but no other data is shared across databases. Any given client connection to the server can access only the data in a single database, the one specified in the connection request."
msgstr ""

#: xml/ddl.xml:1448(para)
msgid "Users of a cluster do not necessarily have the privilege to access every database in the cluster. Sharing of user names means that there cannot be different users named, say, <literal>joe</literal>in two databases in the same cluster; but the system can be configured to allow <literal>joe</literal>access to only some of the databases."
msgstr ""

#: xml/ddl.xml:1457(para)
msgid "A database contains one or more named <firstterm>schemas</firstterm>, which in turn contain tables. Schemas also contain other kinds of named objects, including data types, functions, and operators. The same object name can be used in different schemas without conflict; for example, both <literal>schema1</literal>and <literal>myschema</literal>can contain tables named <literal>mytable</literal>. Unlike databases, schemas are not rigidly separated: a user can access objects in any of the schemas in the database he is connected to, if he has privileges to do so."
msgstr ""

#: xml/ddl.xml:1473(para)
msgid "To allow many users to use one database without interfering with each other."
msgstr ""

#: xml/ddl.xml:1477(para)
msgid "To organize database objects into logical groups to make them more manageable."
msgstr ""

#: xml/ddl.xml:1481(para)
msgid "Third-party applications can be put into separate schemas so they do not collide with the names of other objects."
msgstr ""

#: xml/ddl.xml:1469(para)
msgid "There are several reasons why one might want to use schemas: <placeholder-1/>Schemas are analogous to directories at the operating system level, except that schemas cannot be nested."
msgstr ""

#: xml/ddl.xml:1489(title)
msgid "Creating a Schema"
msgstr ""

#: xml/ddl.xml:1497(programlisting)
#, no-wrap
msgid "CREATE SCHEMA\n      myschema;"
msgstr ""

#: xml/ddl.xml:1494(para)
msgid "To create a schema, use the <xref linkend=\"sql-createschema\">command. Give the schema a name of your choice. For example: <placeholder-1/></xref>"
msgstr ""

#: xml/ddl.xml:1500(primary)
msgid "qualified name"
msgstr ""

#: xml/ddl.xml:1504(secondary)
msgid "qualified"
msgstr ""

#: xml/ddl.xml:1506(para)
msgid "To create or access objects in a schema, write a <firstterm>qualified name</firstterm>consisting of the schema name and table name separated by a dot: <synopsis>\n        <replaceable>schema</replaceable>\n        <literal>.</literal>\n        <replaceable>table</replaceable>\n      </synopsis>This works anywhere a table name is expected, including the table modification commands and the data access commands discussed in the following chapters. (For brevity we will speak of tables only, but the same ideas apply to other kinds of named objects, such as types and functions.)"
msgstr ""

#: xml/ddl.xml:1518(para)
msgid "Actually, the even more general syntax <synopsis>\n        <replaceable>database</replaceable>\n        <literal>.</literal>\n        <replaceable>schema</replaceable>\n        <literal>.</literal>\n        <replaceable>table</replaceable>\n      </synopsis>can be used too, but at present this is just for <foreignphrase>pro forma</foreignphrase>compliance with the SQL standard. If you write a database name, it must be the same as the database you are connected to."
msgstr ""

#: xml/ddl.xml:1530(programlisting)
#, no-wrap
msgid "CREATE TABLE myschema.mytable ( ...\n      );"
msgstr ""

#: xml/ddl.xml:1529(para)
msgid "So to create a table in the new schema, use: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:1538(programlisting)
#, no-wrap
msgid "DROP SCHEMA myschema;"
msgstr ""

#: xml/ddl.xml:1540(programlisting)
#, no-wrap
msgid "DROP SCHEMA myschema\n      CASCADE;"
msgstr ""

#: xml/ddl.xml:1536(para)
msgid "To drop a schema if it's empty (all objects in it have been dropped), use: <placeholder-1/>To drop a schema including all contained objects, use: <placeholder-2/>See <xref linkend=\"ddl-depend\">for a description of the general mechanism behind this.</xref>"
msgstr ""

#: xml/ddl.xml:1548(programlisting)
#, no-wrap
msgid "CREATE SCHEMA \n      <replaceable>schemaname</replaceable>AUTHORIZATION \n      <replaceable>username</replaceable>;"
msgstr ""

#: xml/ddl.xml:1544(para)
msgid "Often you will want to create a schema owned by someone else (since this is one of the ways to restrict the activities of your users to well-defined namespaces). The syntax for that is: <placeholder-1/>You can even omit the schema name, in which case the schema name will be the same as the user name. See <xref linkend=\"ddl-schemas-patterns\">for how this can be useful.</xref>"
msgstr ""

#: xml/ddl.xml:1555(para)
msgid "Schema names beginning with <literal>pg_</literal>are reserved for system purposes and cannot be created by users."
msgstr ""

#: xml/ddl.xml:1560(title)
msgid "The Public Schema"
msgstr ""

#: xml/ddl.xml:1563(secondary)
msgid "public"
msgstr ""

#: xml/ddl.xml:1570(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( ...\n      );"
msgstr ""

#: xml/ddl.xml:1572(programlisting)
#, no-wrap
msgid "CREATE TABLE public.products ( ...\n      );"
msgstr ""

#: xml/ddl.xml:1565(para)
msgid "In the previous sections we created tables without specifying any schema names. By default such tables (and other objects) are automatically put into a schema named <quote>public</quote>. Every new database contains such a schema. Thus, the following are equivalent: <placeholder-1/>and: <placeholder-2/>"
msgstr ""

#: xml/ddl.xml:1576(title)
msgid "The Schema Search Path"
msgstr ""

#: xml/ddl.xml:1578(primary)
msgid "search path"
msgstr ""

#: xml/ddl.xml:1581(primary)
msgid "unqualified name"
msgstr ""

#: xml/ddl.xml:1585(secondary)
msgid "unqualified"
msgstr ""

#: xml/ddl.xml:1587(para)
msgid "Qualified names are tedious to write, and it's often best not to wire a particular schema name into applications anyway. Therefore tables are often referred to by <firstterm>unqualified names</firstterm>, which consist of just the table name. The system determines which table is meant by following a <firstterm>search path</firstterm>, which is a list of schemas to look in. The first matching table in the search path is taken to be the one wanted. If there is no match in the search path, an error is reported, even if matching table names exist in other schemas in the database."
msgstr ""

#: xml/ddl.xml:1600(secondary)
msgid "current"
msgstr ""

#: xml/ddl.xml:1602(para)
msgid "The first schema named in the search path is called the current schema. Aside from being the first schema searched, it is also the schema in which new tables will be created if the <command>CREATE TABLE</command>command does not specify a schema name."
msgstr ""

#: xml/ddl.xml:1610(varname)
msgid "search_path"
msgstr ""

#: xml/ddl.xml:1609(primary)
msgid "<placeholder-1/>configuration parameter"
msgstr ""

#: xml/ddl.xml:1615(programlisting)
#, no-wrap
msgid "SHOW search_path;"
msgstr ""

#: xml/ddl.xml:1613(para)
msgid "To show the current search path, use the following command: <placeholder-1/>In the default setup this returns: <screen>search_path -------------- \"$user\",\n      public</screen>The first element specifies that a schema with the same name as the current user is to be searched. If no such schema exists, the entry is ignored. The second element refers to the public schema that we have seen already."
msgstr ""

#: xml/ddl.xml:1622(para)
msgid "The first schema in the search path that exists is the default location for creating new objects. That is the reason that by default objects are created in the public schema. When objects are referenced in any other context without schema qualification (table modification, data modification, or query commands) the search path is traversed until a matching object is found. Therefore, in the default configuration, any unqualified access again can only refer to the public schema."
msgstr ""

#: xml/ddl.xml:1632(programlisting)
#, no-wrap
msgid "SET search_path TO\n      myschema,public;"
msgstr ""

#: xml/ddl.xml:1637(programlisting)
#, no-wrap
msgid "DROP TABLE mytable;"
msgstr ""

#: xml/ddl.xml:1631(para)
msgid "To put our new schema in the path, we use: <placeholder-1/>(We omit the <literal>$user</literal>here because we have no immediate need for it.) And then we can access the table without schema qualification: <placeholder-2/>Also, since <literal>myschema</literal>is the first element in the path, new objects would by default be created in it."
msgstr ""

#: xml/ddl.xml:1642(programlisting)
#, no-wrap
msgid "SET search_path TO\n      myschema;"
msgstr ""

#: xml/ddl.xml:1641(para)
msgid "We could also have written: <placeholder-1/>Then we no longer have access to the public schema without explicit qualification. There is nothing special about the public schema except that it exists by default. It can be dropped, too."
msgstr ""

#: xml/ddl.xml:1647(para)
msgid "See also <xref linkend=\"functions-info\">for other ways to manipulate the schema search path.</xref>"
msgstr ""

#: xml/ddl.xml:1664(programlisting)
#, no-wrap
msgid "SELECT 3 OPERATOR(pg_catalog.+)\n      4;"
msgstr ""

#: xml/ddl.xml:1650(para)
msgid "The search path works in the same way for data type names, function names, and operator names as it does for table names. Data type and function names can be qualified in exactly the same way as table names. If you need to write a qualified operator name in an expression, there is a special provision: you must write <synopsis>\n        <literal>OPERATOR(</literal>\n        <replaceable>schema</replaceable>\n        <literal>.</literal>\n        <replaceable>operator</replaceable>\n        <literal>)</literal>\n      </synopsis>This is needed to avoid syntactic ambiguity. An example is: <placeholder-1/>In practice one usually relies on the search path for operators, so as not to have to write anything so ugly as that."
msgstr ""

#: xml/ddl.xml:1670(title)
msgid "Schemas and Privileges"
msgstr ""

#: xml/ddl.xml:1673(secondary)
msgid "for schemas"
msgstr ""

#: xml/ddl.xml:1675(para)
msgid "By default, users cannot access any objects in schemas they do not own. To allow that, the owner of the schema must grant the <literal>USAGE</literal>privilege on the schema. To allow users to make use of the objects in the schema, additional privileges might need to be granted, as appropriate for the object."
msgstr ""

#: xml/ddl.xml:1692(programlisting)
#, no-wrap
msgid "REVOKE CREATE ON SCHEMA public FROM\n      PUBLIC;"
msgstr ""

#: xml/ddl.xml:1682(para)
msgid "A user can also be allowed to create objects in someone else's schema. To allow that, the <literal>CREATE</literal>privilege on the schema needs to be granted. Note that by default, everyone has <literal>CREATE</literal>and <literal>USAGE</literal>privileges on the schema <literal>public</literal>. This allows all users that are able to connect to a given database to create objects in its <literal>public</literal>schema. If you do not want to allow that, you can revoke that privilege: <placeholder-1/>(The first <quote>public</quote>is the schema, the second <quote>public</quote>means <quote>every user</quote>. In the first sense it is an identifier, in the second sense it is a key word, hence the different capitalization; recall the guidelines from <xref linkend=\"sql-syntax-identifiers\">.)</xref>"
msgstr ""

#: xml/ddl.xml:1702(title)
msgid "The System Catalog Schema"
msgstr ""

#: xml/ddl.xml:1704(primary)
msgid "system catalog"
msgstr ""

#: xml/ddl.xml:1707(para)
msgid "In addition to <literal>public</literal>and user-created schemas, each database contains a <literal>pg_catalog</literal>schema, which contains the system tables and all the built-in data types, functions, and operators. <literal>pg_catalog</literal>is always effectively part of the search path. If it is not named explicitly in the path then it is implicitly searched <emphasis>before</emphasis>searching the path's schemas. This ensures that built-in names will always be findable. However, you can explicitly place <literal>pg_catalog</literal>at the end of your search path if you prefer to have user-defined names override built-in names."
msgstr ""

#: xml/ddl.xml:1722(para)
msgid "Since system table names begin with <literal>pg_</literal>, it is best to avoid such names to ensure that you won't suffer a conflict if some future version defines a system table named the same as your table. (With the default search path, an unqualified reference to your table name would then be resolved as the system table instead.) System tables will continue to follow the convention of having names beginning with <literal>pg_</literal>, so that they will not conflict with unqualified user-table names so long as users avoid the <literal>pg_</literal>prefix."
msgstr ""

#: xml/ddl.xml:1735(title)
msgid "Usage Patterns"
msgstr ""

#: xml/ddl.xml:1741(para)
msgid "If you do not create any schemas then all users access the public schema implicitly. This simulates the situation where schemas are not available at all. This setup is mainly recommended when there is only a single user or a few cooperating users in a database. This setup also allows smooth transition from the non-schema-aware world."
msgstr ""

#: xml/ddl.xml:1750(para)
msgid "You can create a schema for each user with the same name as that user. Recall that the default search path starts with <literal>$user</literal>, which resolves to the user name. Therefore, if each user has a separate schema, they access their own schemas by default."
msgstr ""

#: xml/ddl.xml:1756(para)
msgid "If you use this setup then you might also want to revoke access to the public schema (or drop it altogether), so users are truly constrained to their own schemas."
msgstr ""

#: xml/ddl.xml:1762(para)
msgid "To install shared applications (tables to be used by everyone, additional functions provided by third parties, etc.), put them into separate schemas. Remember to grant appropriate privileges to allow the other users to access them. Users can then refer to these additional objects by qualifying the names with a schema name, or they can put the additional schemas into their search path, as they choose."
msgstr ""

#: xml/ddl.xml:1736(para)
msgid "Schemas can be used to organize your data in many ways. There are a few usage patterns that are recommended and are easily supported by the default configuration: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:1774(title)
msgid "Portability"
msgstr ""

#: xml/ddl.xml:1775(para)
msgid "In the SQL standard, the notion of objects in the same schema being owned by different users does not exist. Moreover, some implementations do not allow you to create schemas that have a different name than their owner. In fact, the concepts of schema and user are nearly equivalent in a database system that implements only the basic schema support specified in the standard. Therefore, many users consider qualified names to really consist of <literal><replaceable>username</replaceable>. <replaceable>tablename</replaceable></literal>. This is how <productname>PostgreSQL</productname>will effectively behave if you create a per-user schema for every user."
msgstr ""

#: xml/ddl.xml:1788(para)
msgid "Also, there is no concept of a <literal>public</literal>schema in the SQL standard. For maximum conformance to the standard, you should not use (perhaps even remove) the <literal>public</literal>schema."
msgstr ""

#: xml/ddl.xml:1793(para)
msgid "Of course, some SQL database systems might not implement schemas at all, or provide namespace support by allowing (possibly limited) cross-database access. If you need to work with those systems, then maximum portability would be achieved by not using schemas at all."
msgstr ""

#: xml/ddl.xml:1801(title)
msgid "Inheritance"
msgstr ""

#: xml/ddl.xml:1803(primary) xml/ddl.xml:1807(secondary)
msgid "inheritance"
msgstr ""

#: xml/ddl.xml:1809(para)
msgid "<productname>PostgreSQL</productname>implements table inheritance, which can be a useful tool for database designers. (SQL:1999 and later define a type inheritance feature, which differs in many respects from the features described here.)"
msgstr ""

#: xml/ddl.xml:1827(programlisting)
#, no-wrap
msgid "CREATE TABLE cities ( name text, population\n    float, altitude int -- in feet ); CREATE TABLE capitals ( state\n    char(2) ) INHERITS (cities);"
msgstr ""

#: xml/ddl.xml:1815(para)
msgid "Let's start with an example: suppose we are trying to build a data model for cities. Each state has many cities, but only one capital. We want to be able to quickly retrieve the capital city for any particular state. This can be done by creating two tables, one for state capitals and one for cities that are not capitals. However, what happens when we want to ask for data about a city, regardless of whether it is a capital or not? The inheritance feature can help to resolve this problem. We define the <structname>capitals</structname>table so that it inherits from <structname>cities</structname>: <placeholder-1/>In this case, the <structname>capitals</structname>table <firstterm>inherits</firstterm>all the columns of its parent table, <structname>cities</structname>. State capitals also have an extra column, <structfield>state</structfield>, that shows their state."
msgstr ""

#: xml/ddl.xml:1845(programlisting)
#, no-wrap
msgid "SELECT name, altitude FROM cities WHERE\n    altitude 500;"
msgstr ""

#: xml/ddl.xml:1849(programlisting)
#, no-wrap
msgid "name | altitude -----------+---------- Las\n    Vegas | 2174 Mariposa | 1953 Madison |\n    845"
msgstr ""

#: xml/ddl.xml:1837(para)
msgid "In <productname>PostgreSQL</productname>, a table can inherit from zero or more other tables, and a query can reference either all rows of a table or all rows of a table plus all of its descendant tables. The latter behavior is the default. For example, the following query finds the names of all cities, including state capitals, that are located at an altitude over 500 feet: <placeholder-1/>Given the sample data from the <productname>PostgreSQL</productname>tutorial (see <xref linkend=\"tutorial-sql-intro\">), this returns: <placeholder-2/></xref>"
msgstr ""

#: xml/ddl.xml:1855(programlisting)
#, no-wrap
msgid "SELECT name, altitude FROM ONLY cities WHERE\n    altitude 500; name | altitude -----------+---------- Las Vegas\n    | 2174 Mariposa | 1953"
msgstr ""

#: xml/ddl.xml:1852(para)
msgid "On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:1858(para)
msgid "Here the <literal>ONLY</literal>keyword indicates that the query should apply only to <structname>cities</structname>, and not any tables below <structname>cities</structname>in the inheritance hierarchy. Many of the commands that we have already discussed <command>SELECT</command>, <command>UPDATE</command>and <command>DELETE</command>support the <literal>ONLY</literal>keyword."
msgstr ""

#: xml/ddl.xml:1871(programlisting)
#, no-wrap
msgid "SELECT name, altitude FROM cities* WHERE\n    altitude 500;"
msgstr ""

#: xml/ddl.xml:1868(para)
msgid "You can also write the table name with a trailing <literal>*</literal>to explicitly specify that descendant tables are included: <placeholder-1/>Writing <literal>*</literal>is not necessary, since this behavior is the default (unless you have changed the setting of the <xref linkend=\"guc-sql-inheritance\">configuration option). However writing <literal>*</literal>might be useful to emphasize that additional tables will be searched.</xref>"
msgstr ""

#: xml/ddl.xml:1884(programlisting)
#, no-wrap
msgid "SELECT c.tableoid, c.name, c.altitude FROM\n    cities c WHERE c.altitude 500;"
msgstr ""

#: xml/ddl.xml:1886(programlisting)
#, no-wrap
msgid "tableoid | name | altitude\n    ----------+-----------+---------- 139793 | Las Vegas | 2174\n    139793 | Mariposa | 1953 139798 | Madison |\n    845"
msgstr ""

#: xml/ddl.xml:1894(programlisting)
#, no-wrap
msgid "SELECT p.relname, c.name, c.altitude FROM\n    cities c, pg_class p WHERE c.altitude 500 AND c.tableoid =\n    p.oid;"
msgstr ""

#: xml/ddl.xml:1897(programlisting)
#, no-wrap
msgid "relname | name | altitude\n    ----------+-----------+---------- cities | Las Vegas | 2174\n    cities | Mariposa | 1953 capitals | Madison |\n    845"
msgstr ""

#: xml/ddl.xml:1879(para)
msgid "In some cases you might wish to know which table a particular row originated from. There is a system column called <structfield>tableoid</structfield>in each table which can tell you the originating table: <placeholder-1/>which returns: <placeholder-2/>(If you try to reproduce this example, you will probably get different numeric OIDs.) By doing a join with <structname>pg_class</structname>you can see the actual table names: <placeholder-3/>which returns: <placeholder-4/>"
msgstr ""

#: xml/ddl.xml:1904(programlisting)
#, no-wrap
msgid "SELECT c.tableoid::regclass, c.name, c.altitude\n    FROM cities c WHERE c.altitude 500;"
msgstr ""

#: xml/ddl.xml:1901(para)
msgid "Another way to get the same effect is to use the <type>regclass</type>pseudo-type, which will print the table OID symbolically: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:1911(programlisting)
#, no-wrap
msgid "INSERT INTO cities (name, population, altitude,\n    state) VALUES ('Albany', NULL, NULL, 'NY');"
msgstr ""

#: xml/ddl.xml:1906(para)
msgid "Inheritance does not automatically propagate data from <command>INSERT</command>or <command>COPY</command>commands to other tables in the inheritance hierarchy. In our example, the following <command>INSERT</command>statement will fail: <placeholder-1/>We might hope that the data would somehow be routed to the <structname>capitals</structname>table, but this does not happen: <command>INSERT</command>always inserts into exactly the table specified. In some cases it is possible to redirect the insertion using a rule (see <xref linkend=\"rules\">). However that does not help for the above case because the <structname>cities</structname>table does not contain the column <structfield>state</structfield>, and so the command will be rejected before the rule can be applied.</xref>"
msgstr ""

#: xml/ddl.xml:1925(para)
msgid "All check constraints and not-null constraints on a parent table are automatically inherited by its children. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited."
msgstr ""

#: xml/ddl.xml:1929(para)
msgid "A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are <quote>merged</quote>so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. The merged column will have copies of all the check constraints coming from any one of the column definitions it came from, and will be marked not-null if any of them are."
msgstr ""

#: xml/ddl.xml:1941(para)
msgid "Table inheritance is typically established when the child table is created, using the <literal>INHERITS</literal>clause of the <xref linkend=\"sql-createtable\">statement. Alternatively, a table which is already defined in a compatible way can have a new parent relationship added, using the <literal>INHERIT</literal>variant of <xref linkend=\"sql-altertable\">. To do this the new child table must already include columns with the same names and types as the columns of the parent. It must also include check constraints with the same names and check expressions as those of the parent. Similarly an inheritance link can be removed from a child using the <literal>NO INHERIT</literal>variant of <command>ALTER TABLE</command>. Dynamically adding and removing inheritance links like this can be useful when the inheritance relationship is being used for table partitioning (see <xref linkend=\"ddl-partitioning\">).</xref></xref></xref>"
msgstr ""

#: xml/ddl.xml:1959(para)
msgid "One convenient way to create a compatible table that will later be made a new child is to use the <literal>LIKE</literal>clause in <command>CREATE TABLE</command>. This creates a new table with the same columns as the source table. If there are any <literal>CHECK</literal>constraints defined on the source table, the <literal>INCLUDING CONSTRAINTS</literal>option to <literal>LIKE</literal>should be specified, as the new child must have constraints matching the parent to be considered compatible."
msgstr ""

#: xml/ddl.xml:1970(para)
msgid "A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the <literal>CASCADE</literal>option."
msgstr ""

#: xml/ddl.xml:1982(command)
msgid "ALTER TABLE"
msgstr ""

#: xml/ddl.xml:1984(command)
msgid "CREATE TABLE"
msgstr ""

#: xml/ddl.xml:1977(xref)
msgid "will propagate any changes in column data definitions and check constraints down the inheritance hierarchy. Again, dropping columns that are depended on by other tables is only possible when using the <placeholder-1/>option. <placeholder-2/>follows the same rules for duplicate column merging and rejection that apply during <placeholder-3/>."
msgstr ""

#: xml/ddl.xml:1986(para)
msgid "Note how table access permissions are handled. Querying a parent table can automatically access data in child tables without further access privilege checking. This preserves the appearance that the data is (also) in the parent table. Accessing the child tables directly is, however, not automatically allowed and would require further privileges to be granted."
msgstr ""

#: xml/ddl.xml:1993(para)
msgid "Foreign tables (see <xref linkend=\"ddl-foreign-data\">) can also be part of inheritance hierarchies, either as parent or child tables, just as regular tables can be. If a foreign table is part of an inheritance hierarchy then any operations not supported by the foreign table are not supported on the whole hierarchy either.</xref>"
msgstr ""

#: xml/ddl.xml:2001(title) xml/ddl.xml:2531(title)
msgid "Caveats"
msgstr ""

#: xml/ddl.xml:2002(para)
msgid "Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, most variants of <literal>ALTER TABLE</literal>, but not <literal>INSERT</literal>or <literal>ALTER TABLE ... RENAME</literal>) typically default to including child tables and support the <literal>ONLY</literal>notation to exclude them. Commands that do database maintenance and tuning (e.g., <literal>REINDEX</literal>, <literal>VACUUM</literal>) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page ( <xref linkend=\"sql-commands\">).</xref>"
msgstr ""

#: xml/ddl.xml:2028(para)
msgid "If we declared <structname>cities</structname>. <structfield>name</structfield>to be <literal>UNIQUE</literal>or a <literal>PRIMARY KEY</literal>, this would not stop the <structname>capitals</structname>table from having rows with names duplicating rows in <structname>cities</structname>. And those duplicate rows would by default show up in queries from <structname>cities</structname>. In fact, by default <structname>capitals</structname>would have no unique constraint at all, and so could contain multiple rows with the same name. You could add a unique constraint to <structname>capitals</structname>, but this would not prevent duplication compared to <structname>cities</structname>."
msgstr ""

#: xml/ddl.xml:2046(para)
msgid "Similarly, if we were to specify that <structname>cities</structname>. <structfield>name</structfield><literal>REFERENCES</literal>some other table, this constraint would not automatically propagate to <structname>capitals</structname>. In this case you could work around it by manually adding the same <literal>REFERENCES</literal>constraint to <structname>capitals</structname>."
msgstr ""

#: xml/ddl.xml:2057(para)
msgid "Specifying that another table's column <literal>REFERENCES cities(name)</literal>would allow the other table to contain city names, but not capital names. There is no good workaround for this case."
msgstr ""

#: xml/ddl.xml:2020(para)
msgid "A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example: <placeholder-1/>These deficiencies will probably be fixed in some future release, but in the meantime considerable care is needed in deciding whether inheritance is useful for your application."
msgstr ""

#: xml/ddl.xml:2069(title)
msgid "Partitioning"
msgstr ""

#: xml/ddl.xml:2071(primary) xml/ddl.xml:2075(secondary)
msgid "partitioning"
msgstr ""

#: xml/ddl.xml:2077(para)
msgid "<productname>PostgreSQL</productname>supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design."
msgstr ""

#: xml/ddl.xml:2082(title)
msgid "Overview"
msgstr ""

#: xml/ddl.xml:2088(para)
msgid "Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory."
msgstr ""

#: xml/ddl.xml:2097(para)
msgid "When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table."
msgstr ""

#: xml/ddl.xml:2104(para)
msgid "Bulk loads and deletes can be accomplished by adding or removing partitions, if that requirement is planned into the partitioning design. <command>ALTER TABLE NO INHERIT</command>and <command>DROP TABLE</command>are both far faster than a bulk operation. These commands also entirely avoid the <command>VACUUM</command>overhead caused by a bulk <command>DELETE</command>."
msgstr ""

#: xml/ddl.xml:2114(para)
msgid "Seldom-used data can be migrated to cheaper and slower storage media."
msgstr ""

#: xml/ddl.xml:2083(para)
msgid "Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits: <placeholder-1/>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server."
msgstr ""

#: xml/ddl.xml:2123(para)
msgid "Currently, <productname>PostgreSQL</productname>supports partitioning via table inheritance. Each partition must be created as a child table of a single parent table. The parent table itself is normally empty; it exists just to represent the entire data set. You should be familiar with inheritance (see <xref linkend=\"ddl-inherit\">) before attempting to set up partitioning.</xref>"
msgstr ""

#: xml/ddl.xml:2136(term)
msgid "Range Partitioning"
msgstr ""

#: xml/ddl.xml:2138(para)
msgid "The table is partitioned into <quote>ranges</quote>defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example one might partition by date ranges, or by ranges of identifiers for particular business objects."
msgstr ""

#: xml/ddl.xml:2147(term)
msgid "List Partitioning"
msgstr ""

#: xml/ddl.xml:2149(para)
msgid "The table is partitioned by explicitly listing which key values appear in each partition."
msgstr ""

#: xml/ddl.xml:2131(para)
msgid "The following forms of partitioning can be implemented in <productname>PostgreSQL</productname>: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:2156(title)
msgid "Implementing Partitioning"
msgstr ""

#: xml/ddl.xml:2160(para)
msgid "Create the <quote>master</quote>table, from which all of the partitions will inherit."
msgstr ""

#: xml/ddl.xml:2163(para)
msgid "This table will contain no data. Do not define any check constraints on this table, unless you intend them to be applied equally to all partitions. There is no point in defining any indexes or unique constraints on it, either."
msgstr ""

#: xml/ddl.xml:2170(para)
msgid "Create several <quote>child</quote>tables that each inherit from the master table. Normally, these tables will not add any columns to the set inherited from the master."
msgstr ""

#: xml/ddl.xml:2174(para)
msgid "We will refer to the child tables as partitions, though they are in every way normal <productname>PostgreSQL</productname>tables (or, possibly, foreign tables)."
msgstr ""

#: xml/ddl.xml:2180(para)
msgid "Add table constraints to the partition tables to define the allowed key values in each partition."
msgstr ""

#: xml/ddl.xml:2183(programlisting)
#, no-wrap
msgid "CHECK ( x = 1 ) CHECK ( county IN (\n          'Oxfordshire', 'Buckinghamshire', 'Warwickshire' )) CHECK\n          ( outletID = 100 AND outletID 200\n          )"
msgstr ""

#: xml/ddl.xml:2190(programlisting)
#, no-wrap
msgid "CHECK ( outletID BETWEEN 100 AND 200 )\n          CHECK ( outletID BETWEEN 200 AND 300\n          )"
msgstr ""

#: xml/ddl.xml:2182(para)
msgid "Typical examples would be: <placeholder-1/>Ensure that the constraints guarantee that there is no overlap between the key values permitted in different partitions. A common mistake is to set up range constraints like: <placeholder-2/>This is wrong since it is not clear which partition the key value 200 belongs in."
msgstr ""

#: xml/ddl.xml:2194(para)
msgid "Note that there is no difference in syntax between range and list partitioning; those terms are descriptive only."
msgstr ""

#: xml/ddl.xml:2199(para)
msgid "For each partition, create an index on the key column(s), as well as any other indexes you might want. (The key index is not strictly necessary, but in most scenarios it is helpful. If you intend the key values to be unique then you should always create a unique or primary-key constraint for each partition.)"
msgstr ""

#: xml/ddl.xml:2207(para)
msgid "Optionally, define a trigger or rule to redirect data inserted into the master table to the appropriate partition."
msgstr ""

#: xml/ddl.xml:2212(para)
msgid "Ensure that the <xref linkend=\"guc-constraint-exclusion\">configuration parameter is not disabled in <filename>postgresql.conf</filename>. If it is, queries will not be optimized as desired.</xref>"
msgstr ""

#: xml/ddl.xml:2157(para)
msgid "To set up a partitioned table, do the following: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:2223(programlisting)
#, no-wrap
msgid "CREATE TABLE measurement ( city_id int not\n      null, logdate date not null, peaktemp int, unitsales int\n      );"
msgstr ""

#: xml/ddl.xml:2219(para)
msgid "For example, suppose we are constructing a database for a large ice cream company. The company measures peak temperatures every day as well as ice cream sales in each region. Conceptually, we want a table like: <placeholder-1/>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data."
msgstr ""

#: xml/ddl.xml:2232(para)
msgid "In this situation we can use partitioning to help us meet all of our different requirements for the measurements table. Following the steps outlined above, partitioning can be set up as follows:"
msgstr ""

#: xml/ddl.xml:2239(para)
msgid "The master table is the <structname>measurement</structname>table, declared exactly as above."
msgstr ""

#: xml/ddl.xml:2246(programlisting)
#, no-wrap
msgid "CREATE TABLE measurement_y2006m02 ( )\n            INHERITS (measurement); CREATE TABLE\n            measurement_y2006m03 ( ) INHERITS (measurement); ...\n            CREATE TABLE measurement_y2007m11 ( ) INHERITS\n            (measurement); CREATE TABLE measurement_y2007m12 ( )\n            INHERITS (measurement); CREATE TABLE\n            measurement_y2008m01 ( ) INHERITS\n            (measurement);"
msgstr ""

#: xml/ddl.xml:2244(para)
msgid "Next we create one partition for each active month: <placeholder-1/>Each of the partitions are complete tables in their own right, but they inherit their definitions from the <structname>measurement</structname>table."
msgstr ""

#: xml/ddl.xml:2257(para)
msgid "This solves one of our problems: deleting old data. Each month, all we will need to do is perform a <command>DROP TABLE</command>on the oldest child table and create a new child table for the new month's data."
msgstr ""

#: xml/ddl.xml:2268(programlisting)
#, no-wrap
msgid "CREATE TABLE measurement_y2006m02 (\n            CHECK ( logdate = DATE '2006-02-01' AND logdate DATE\n            '2006-03-01' ) ) INHERITS (measurement); CREATE TABLE\n            measurement_y2006m03 ( CHECK ( logdate = DATE\n            '2006-03-01' AND logdate DATE '2006-04-01' ) ) INHERITS\n            (measurement); ... CREATE TABLE measurement_y2007m11 (\n            CHECK ( logdate = DATE '2007-11-01' AND logdate DATE\n            '2007-12-01' ) ) INHERITS (measurement); CREATE TABLE\n            measurement_y2007m12 ( CHECK ( logdate = DATE\n            '2007-12-01' AND logdate DATE '2008-01-01' ) ) INHERITS\n            (measurement); CREATE TABLE measurement_y2008m01 (\n            CHECK ( logdate = DATE '2008-01-01' AND logdate DATE\n            '2008-02-01' ) ) INHERITS\n            (measurement);"
msgstr ""

#: xml/ddl.xml:2264(para)
msgid "We must provide non-overlapping table constraints. Rather than just creating the partition tables as above, the table creation script should really be: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:2285(programlisting)
#, no-wrap
msgid "CREATE INDEX\n            measurement_y2006m02_logdate ON measurement_y2006m02\n            (logdate); CREATE INDEX measurement_y2006m03_logdate ON\n            measurement_y2006m03 (logdate); ... CREATE INDEX\n            measurement_y2007m11_logdate ON measurement_y2007m11\n            (logdate); CREATE INDEX measurement_y2007m12_logdate ON\n            measurement_y2007m12 (logdate); CREATE INDEX\n            measurement_y2008m01_logdate ON measurement_y2008m01\n            (logdate);"
msgstr ""

#: xml/ddl.xml:2284(para)
msgid "We probably need indexes on the key columns too: <placeholder-1/>We choose not to add further indexes at this time."
msgstr ""

#: xml/ddl.xml:2304(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n            measurement_insert_trigger() RETURNS TRIGGER AS $$\n            BEGIN INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n            RETURN NULL; END; $$ LANGUAGE\n            plpgsql;"
msgstr ""

#: xml/ddl.xml:2310(programlisting)
#, no-wrap
msgid "CREATE TRIGGER\n            insert_measurement_trigger BEFORE INSERT ON measurement\n            FOR EACH ROW EXECUTE PROCEDURE\n            measurement_insert_trigger();"
msgstr ""

#: xml/ddl.xml:2297(para)
msgid "We want our application to be able to say <literal>INSERT INTO measurement ...</literal>and have the data be redirected into the appropriate partition table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest partition, we can use a very simple trigger function: <placeholder-1/>After creating the function, we create a trigger which calls the trigger function: <placeholder-2/>We must redefine the trigger function each month so that it always points to the current partition. The trigger definition does not need to be updated, however."
msgstr ""

#: xml/ddl.xml:2321(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n            measurement_insert_trigger() RETURNS TRIGGER AS $$\n            BEGIN IF ( NEW.logdate = DATE '2006-02-01' AND\n            NEW.logdate DATE '2006-03-01' ) THEN INSERT INTO\n            measurement_y2006m02 VALUES (NEW.*); ELSIF (\n            NEW.logdate = DATE '2006-03-01' AND NEW.logdate DATE\n            '2006-04-01' ) THEN INSERT INTO measurement_y2006m03\n            VALUES (NEW.*); ... ELSIF ( NEW.logdate = DATE\n            '2008-01-01' AND NEW.logdate DATE '2008-02-01' ) THEN\n            INSERT INTO measurement_y2008m01 VALUES (NEW.*); ELSE\n            RAISE EXCEPTION 'Date out of range. Fix the\n            measurement_insert_trigger() function!'; END IF; RETURN\n            NULL; END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/ddl.xml:2317(para)
msgid "We might want to insert data and have the server automatically locate the partition into which the row should be added. We could do this with a more complex trigger function, for example: <placeholder-1/>The trigger definition is the same as before. Note that each <literal>IF</literal>test must exactly match the <literal>CHECK</literal>constraint for its partition."
msgstr ""

#: xml/ddl.xml:2339(para)
msgid "While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed."
msgstr ""

#: xml/ddl.xml:2344(para)
msgid "In practice it might be best to check the newest partition first, if most inserts go into that partition. For simplicity we have shown the trigger's tests in the same order as in other parts of this example."
msgstr ""

#: xml/ddl.xml:2353(para)
msgid "As we can see, a complex partitioning scheme could require a substantial amount of DDL. In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically."
msgstr ""

#: xml/ddl.xml:2360(title)
msgid "Managing Partitions"
msgstr ""

#: xml/ddl.xml:2361(para)
msgid "Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around."
msgstr ""

#: xml/ddl.xml:2372(programlisting)
#, no-wrap
msgid "DROP TABLE\n      measurement_y2006m02;"
msgstr ""

#: xml/ddl.xml:2370(para)
msgid "The simplest option for removing old data is simply to drop the partition that is no longer necessary: <placeholder-1/>This can very quickly delete millions of records because it doesn't have to individually delete every record."
msgstr ""

#: xml/ddl.xml:2379(programlisting)
#, no-wrap
msgid "ALTER TABLE measurement_y2006m02 NO INHERIT\n      measurement;"
msgstr ""

#: xml/ddl.xml:2376(para)
msgid "Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right: <placeholder-1/>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using <command>COPY</command>, <application>pg_dump</application>, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports."
msgstr ""

#: xml/ddl.xml:2392(programlisting)
#, no-wrap
msgid "CREATE TABLE measurement_y2008m02 ( CHECK (\n      logdate = DATE '2008-02-01' AND logdate DATE '2008-03-01' ) )\n      INHERITS (measurement);"
msgstr ""

#: xml/ddl.xml:2399(programlisting)
#, no-wrap
msgid "CREATE TABLE measurement_y2008m02 (LIKE\n      measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS); ALTER\n      TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02 CHECK (\n      logdate = DATE '2008-02-01' AND logdate DATE '2008-03-01' );\n      \\copy measurement_y2008m02 from 'measurement_y2008m02' --\n      possibly some other data preparation work ALTER TABLE\n      measurement_y2008m02 INHERIT\n      measurement;"
msgstr ""

#: xml/ddl.xml:2389(para)
msgid "Similarly we can add a new partition to handle new data. We can create an empty partition in the partitioned table just as the original partitions were created above: <placeholder-1/>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table: <placeholder-2/>"
msgstr ""

#: xml/ddl.xml:2409(title)
msgid "Partitioning and Constraint Exclusion"
msgstr ""

#: xml/ddl.xml:2411(primary)
msgid "constraint exclusion"
msgstr ""

#: xml/ddl.xml:2418(programlisting)
#, no-wrap
msgid "SET constraint_exclusion = on; SELECT\n      count(*) FROM measurement WHERE logdate = DATE\n      '2008-01-01';"
msgstr ""

#: xml/ddl.xml:2413(para)
msgid "<firstterm>Constraint exclusion</firstterm>is a query optimization technique that improves performance for partitioned tables defined in the fashion described above. As an example: <placeholder-1/>Without constraint exclusion, the above query would scan each of the partitions of the <structname>measurement</structname>table. With constraint exclusion enabled, the planner will examine the constraints of each partition and try to prove that the partition need not be scanned because it could not contain any rows meeting the query's <literal>WHERE</literal>clause. When the planner can prove this, it excludes the partition from the query plan."
msgstr ""

#: xml/ddl.xml:2435(programlisting)
#, no-wrap
msgid "SET constraint_exclusion = off; EXPLAIN\n      SELECT count(*) FROM measurement WHERE logdate = DATE\n      '2008-01-01'; QUERY PLAN\n      -----------------------------------------------------------------------------------------------\n      Aggregate (cost=158.66..158.68 rows=1 width=0) - Append\n      (cost=0.00..151.88 rows=2715 width=0) - Seq Scan on\n      measurement (cost=0.00..30.38 rows=543 width=0) Filter:\n      (logdate = '2008-01-01'::date) - Seq Scan on\n      measurement_y2006m02 measurement (cost=0.00..30.38 rows=543\n      width=0) Filter: (logdate = '2008-01-01'::date) - Seq Scan on\n      measurement_y2006m03 measurement (cost=0.00..30.38 rows=543\n      width=0) Filter: (logdate = '2008-01-01'::date) ... - Seq\n      Scan on measurement_y2007m12 measurement (cost=0.00..30.38\n      rows=543 width=0) Filter: (logdate = '2008-01-01'::date) -\n      Seq Scan on measurement_y2008m01 measurement\n      (cost=0.00..30.38 rows=543 width=0) Filter: (logdate =\n      '2008-01-01'::date)"
msgstr ""

#: xml/ddl.xml:2457(programlisting)
#, no-wrap
msgid "SET constraint_exclusion = on; EXPLAIN SELECT\n      count(*) FROM measurement WHERE logdate = DATE '2008-01-01';\n      QUERY PLAN\n      -----------------------------------------------------------------------------------------------\n      Aggregate (cost=63.47..63.48 rows=1 width=0) - Append\n      (cost=0.00..60.75 rows=1086 width=0) - Seq Scan on\n      measurement (cost=0.00..30.38 rows=543 width=0) Filter:\n      (logdate = '2008-01-01'::date) - Seq Scan on\n      measurement_y2008m01 measurement (cost=0.00..30.38 rows=543\n      width=0) Filter: (logdate =\n      '2008-01-01'::date)"
msgstr ""

#: xml/ddl.xml:2429(para)
msgid "You can use the <command>EXPLAIN</command>command to show the difference between a plan with <varname>constraint_exclusion</varname>on and a plan with it off. A typical unoptimized plan for this type of table setup is: <placeholder-1/>Some or all of the partitions might use index scans instead of full-table sequential scans, but the point here is that there is no need to scan the older partitions at all to answer this query. When we enable constraint exclusion, we get a significantly cheaper plan that will deliver the same answer: <placeholder-2/>"
msgstr ""

#: xml/ddl.xml:2468(para)
msgid "Note that constraint exclusion is driven only by <literal>CHECK</literal>constraints, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former."
msgstr ""

#: xml/ddl.xml:2476(para)
msgid "The default (and recommended) setting of <xref linkend=\"guc-constraint-exclusion\">is actually neither <literal>on</literal>nor <literal>off</literal>, but an intermediate setting called <literal>partition</literal>, which causes the technique to be applied only to queries that are likely to be working on partitioned tables. The <literal>on</literal>setting causes the planner to examine <literal>CHECK</literal>constraints in all queries, even simple ones that are unlikely to benefit.</xref>"
msgstr ""

#: xml/ddl.xml:2488(title)
msgid "Alternative Partitioning Methods"
msgstr ""

#: xml/ddl.xml:2492(programlisting)
#, no-wrap
msgid "CREATE RULE measurement_insert_y2006m02 AS ON\n      INSERT TO measurement WHERE ( logdate = DATE '2006-02-01' AND\n      logdate DATE '2006-03-01' ) DO INSTEAD INSERT INTO\n      measurement_y2006m02 VALUES (NEW.*); ... CREATE RULE\n      measurement_insert_y2008m01 AS ON INSERT TO measurement WHERE\n      ( logdate = DATE '2008-01-01' AND logdate DATE '2008-02-01' )\n      DO INSTEAD INSERT INTO measurement_y2008m01 VALUES\n      (NEW.*);"
msgstr ""

#: xml/ddl.xml:2489(para)
msgid "A different approach to redirecting inserts into the appropriate partition table is to set up rules, instead of a trigger, on the master table. For example: <placeholder-1/>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance."
msgstr ""

#: xml/ddl.xml:2505(para)
msgid "Be aware that <command>COPY</command>ignores rules. If you want to use <command>COPY</command>to insert data, you'll need to copy into the correct partition table rather than into the master. <command>COPY</command>does fire triggers, so you can use it normally if you use the trigger approach."
msgstr ""

#: xml/ddl.xml:2512(para)
msgid "Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead."
msgstr ""

#: xml/ddl.xml:2519(programlisting)
#, no-wrap
msgid "CREATE VIEW measurement AS SELECT * FROM\n      measurement_y2006m02 UNION ALL SELECT * FROM\n      measurement_y2006m03 ... UNION ALL SELECT * FROM\n      measurement_y2007m11 UNION ALL SELECT * FROM\n      measurement_y2007m12 UNION ALL SELECT * FROM\n      measurement_y2008m01;"
msgstr ""

#: xml/ddl.xml:2516(para)
msgid "Partitioning can also be arranged using a <literal>UNION ALL</literal>view, instead of table inheritance. For example, <placeholder-1/>However, the need to recreate the view adds an extra step to adding and dropping individual partitions of the data set. In practice this method has little to recommend it compared to using inheritance."
msgstr ""

#: xml/ddl.xml:2535(para)
msgid "There is no automatic way to verify that all of the <literal>CHECK</literal>constraints are mutually exclusive. It is safer to create code that generates partitions and creates and/or modifies associated objects than to write each by hand."
msgstr ""

#: xml/ddl.xml:2543(para)
msgid "The schemes shown here assume that the partition key column(s) of a row never change, or at least do not change enough to require it to move to another partition. An <command>UPDATE</command>that attempts to do that will fail because of the <literal>CHECK</literal>constraints. If you need to handle such cases, you can put suitable update triggers on the partition tables, but it makes management of the structure much more complicated."
msgstr ""

#: xml/ddl.xml:2560(programlisting)
#, no-wrap
msgid "ANALYZE measurement;"
msgstr ""

#: xml/ddl.xml:2555(para)
msgid "If you are using manual <command>VACUUM</command>or <command>ANALYZE</command>commands, don't forget that you need to run them on each partition individually. A command like: <placeholder-1/>will only process the master table."
msgstr ""

#: xml/ddl.xml:2564(para)
msgid "<command>INSERT</command>statements with <literal>ON CONFLICT</literal>clauses are unlikely to work as expected, as the <literal>ON CONFLICT</literal>action is only taken in case of unique violations on the specified target relation, not its child relations."
msgstr ""

#: xml/ddl.xml:2532(para)
msgid "The following caveats apply to partitioned tables: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:2576(para)
msgid "Constraint exclusion only works when the query's <literal>WHERE</literal>clause contains constants (or externally supplied parameters). For example, a comparison against a non-immutable function such as <function>CURRENT_TIMESTAMP</function>cannot be optimized, since the planner cannot know which partition the function value might fall into at run time."
msgstr ""

#: xml/ddl.xml:2585(para)
msgid "Keep the partitioning constraints simple, else the planner may not be able to prove that partitions don't need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators."
msgstr ""

#: xml/ddl.xml:2596(para)
msgid "All constraints on all partitions of the master table are examined during constraint exclusion, so large numbers of partitions are likely to increase query planning time considerably. Partitioning using these techniques will work well with up to perhaps a hundred partitions; don't try to use many thousands of partitions."
msgstr ""

#: xml/ddl.xml:2573(para)
msgid "The following caveats apply to constraint exclusion: <placeholder-1/>"
msgstr ""

#: xml/ddl.xml:2608(title)
msgid "Foreign Data"
msgstr ""

#: xml/ddl.xml:2610(primary)
msgid "foreign data"
msgstr ""

#: xml/ddl.xml:2613(primary)
msgid "foreign table"
msgstr ""

#: xml/ddl.xml:2616(primary)
msgid "user mapping"
msgstr ""

#: xml/ddl.xml:2618(para)
msgid "<productname>PostgreSQL</productname>implements portions of the SQL/MED specification, allowing you to access data that resides outside PostgreSQL using regular SQL queries. Such data is referred to as <firstterm>foreign data</firstterm>. (Note that this usage is not to be confused with foreign keys, which are a type of constraint within the database.)"
msgstr ""

#: xml/ddl.xml:2626(para)
msgid "Foreign data is accessed with help from a <firstterm>foreign data wrapper</firstterm>. A foreign data wrapper is a library that can communicate with an external data source, hiding the details of connecting to the data source and obtaining data from it. There are some foreign data wrappers available as <filename>contrib</filename>modules; see <xref linkend=\"contrib\">. Other kinds of foreign data wrappers might be found as third party products. If none of the existing foreign data wrappers suit your needs, you can write your own; see <xref linkend=\"fdwhandler\">.</xref></xref>"
msgstr ""

#: xml/ddl.xml:2638(para)
msgid "To access foreign data, you need to create a <firstterm>foreign server</firstterm>object, which defines how to connect to a particular external data source according to the set of options used by its supporting foreign data wrapper. Then you need to create one or more <firstterm>foreign tables</firstterm>, which define the structure of the remote data. A foreign table can be used in queries just like a normal table, but a foreign table has no storage in the PostgreSQL server. Whenever it is used, <productname>PostgreSQL</productname>asks the foreign data wrapper to fetch data from the external source, or transmit data to the external source in the case of update commands."
msgstr ""

#: xml/ddl.xml:2651(para)
msgid "Accessing remote data may require authenticating to the external data source. This information can be provided by a <firstterm>user mapping</firstterm>, which can provide additional data such as user names and passwords based on the current <productname>PostgreSQL</productname>role."
msgstr ""

#: xml/ddl.xml:2657(para)
msgid "For additional information, see <xref linkend=\"sql-createforeigndatawrapper\">, <xref linkend=\"sql-createserver\">, <xref linkend=\"sql-createusermapping\">, <xref linkend=\"sql-createforeigntable\">, and <xref linkend=\"sql-importforeignschema\"> .</xref></xref></xref></xref></xref>"
msgstr ""

#: xml/ddl.xml:2666(title)
msgid "Other Database Objects"
msgstr ""

#: xml/ddl.xml:2667(para)
msgid "Tables are the central objects in a relational database structure, because they hold your data. But they are not the only objects that exist in a database. Many other kinds of objects can be created to make the use and management of the data more efficient or convenient. They are not discussed in this chapter, but we give you a list here so that you are aware of what is possible:"
msgstr ""

#: xml/ddl.xml:2676(para)
msgid "Views"
msgstr ""

#: xml/ddl.xml:2679(para)
msgid "Functions and operators"
msgstr ""

#: xml/ddl.xml:2682(para)
msgid "Data types and domains"
msgstr ""

#: xml/ddl.xml:2685(para)
msgid "Triggers and rewrite rules"
msgstr ""

#: xml/ddl.xml:2688(para)
msgid "Detailed information on these topics appears in <xref linkend=\"server-programming\">.</xref>"
msgstr ""

#: xml/ddl.xml:2692(title)
msgid "Dependency Tracking"
msgstr ""

#: xml/ddl.xml:2695(secondary) xml/ddl.xml:2699(secondary)
msgid "with DROP"
msgstr ""

#: xml/ddl.xml:2701(para)
msgid "When you create complex database structures involving many tables with foreign key constraints, views, triggers, functions, etc. you implicitly create a net of dependencies between the objects. For instance, a table with a foreign key constraint depends on the table it references."
msgstr ""

#: xml/ddl.xml:2706(para)
msgid "To ensure the integrity of the entire database structure, <productname>PostgreSQL</productname>makes sure that you cannot drop objects that other objects still depend on. For example, attempting to drop the products table we had considered in <xref linkend=\"ddl-constraints-fk\">, with the orders table depending on it, would result in an error message such as this: <screen>DROP TABLE products; NOTICE: constraint\n    orders_product_no_fkey on table orders depends on table\n    products ERROR: cannot drop table products because other\n    objects depend on it HINT: Use DROP ... CASCADE to drop the\n    dependent objects too.</screen>The error message contains a useful hint: if you do not want to bother deleting all the dependent objects individually, you can run: <screen>DROP TABLE products CASCADE;</screen>and all the dependent objects will be removed. In this case, it doesn't remove the orders table, it only removes the foreign key constraint. (If you want to check what <command>DROP ... CASCADE</command>will do, run <command>DROP</command>without <literal>CASCADE</literal>and read the <literal>NOTICE</literal>messages.)</xref>"
msgstr ""

#: xml/ddl.xml:2729(para)
msgid "All drop commands in <productname>PostgreSQL</productname>support specifying <literal>CASCADE</literal>. Of course, the nature of the possible dependencies varies with the type of the object. You can also write <literal>RESTRICT</literal>instead of <literal>CASCADE</literal>to get the default behavior, which is to prevent the dropping of objects that other objects depend on."
msgstr ""

#: xml/ddl.xml:2739(para)
msgid "According to the SQL standard, specifying either <literal>RESTRICT</literal>or <literal>CASCADE</literal>is required. No database system actually enforces that rule, but whether the default behavior is <literal>RESTRICT</literal>or <literal>CASCADE</literal>varies across systems."
msgstr ""

#: xml/ddl.xml:2748(para)
msgid "Foreign key constraint dependencies and serial column dependencies from <productname>PostgreSQL</productname>versions prior to 7.3 are <emphasis>not</emphasis>maintained or created during the upgrade process. All other dependency types will be properly created during an upgrade from a pre-7.3 database."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/ddl.xml:0(None)
msgid "translator-credits"
msgstr ""

