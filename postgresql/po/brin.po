msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/brin.xml:3(title)
msgid "BRIN Indexes"
msgstr ""

#: xml/brin.xml:5(primary)
msgid "index"
msgstr ""

#: xml/brin.xml:6(secondary)
msgid "BRIN"
msgstr ""

#: xml/brin.xml:9(title)
msgid "Introduction"
msgstr ""

#: xml/brin.xml:10(para)
msgid "<acronym>BRIN</acronym>stands for Block Range Index. <acronym>BRIN</acronym>is designed for handling very large tables in which certain columns have some natural correlation with their physical location within the table. A <firstterm>block range</firstterm>is a group of pages that are physically adjacent in the table; for each block range, some summary info is stored by the index. For example, a table storing a store's sale orders might have a date column on which each order was placed, and most of the time the entries for earlier orders will appear earlier in the table as well; a table storing a ZIP code column might have all codes for a city grouped together naturally."
msgstr ""

#: xml/brin.xml:23(para)
msgid "<acronym>BRIN</acronym>indexes can satisfy queries via regular bitmap index scans, and will return all tuples in all pages within each range if the summary info stored by the index is <firstterm>consistent</firstterm>with the query conditions. The query executor is in charge of rechecking these tuples and discarding those that do not match the query conditions in other words, these indexes are lossy. Because a <acronym>BRIN</acronym>index is very small, scanning the index adds little overhead compared to a sequential scan, but may avoid scanning large parts of the table that are known not to contain matching tuples."
msgstr ""

#: xml/brin.xml:35(para)
msgid "The specific data that a <acronym>BRIN</acronym>index will store, as well as the specific queries that the index will be able to satisfy, depend on the operator class selected for each column of the index. Data types having a linear sort order can have operator classes that store the minimum and maximum value within each block range, for instance; geometrical types might store the bounding box for all the objects in the block range."
msgstr ""

#: xml/brin.xml:43(para)
msgid "The size of the block range is determined at index creation time by the <literal>pages_per_range</literal>storage parameter. The number of index entries will be equal to the size of the relation in pages divided by the selected value for <literal>pages_per_range</literal>. Therefore, the smaller the number, the larger the index becomes (because of the need to store more index entries), but at the same time the summary data stored can be more precise and more data blocks can be skipped during an index scan."
msgstr ""

#: xml/brin.xml:54(title)
msgid "Index Maintenance"
msgstr ""

#: xml/brin.xml:55(para)
msgid "At the time of creation, all existing index pages are scanned and a summary index tuple is created for each range, including the possibly-incomplete range at the end. As new pages are filled with data, page ranges that are already summarized will cause the summary information to be updated with data from the new tuples. When a new page is created that does not fall within the last summarized range, that range does not automatically acquire a summary tuple; those tuples remain unsummarized until a summarization run is invoked later, creating initial summaries. This process can be invoked manually using the <function> brin_summarize_new_pages(regclass)</function>function, or automatically when <command>VACUUM</command>processes the table."
msgstr ""

#: xml/brin.xml:73(title)
msgid "Built-in Operator Classes"
msgstr ""

#: xml/brin.xml:74(para)
msgid "The core <productname>PostgreSQL</productname>distribution includes the <acronym>BRIN</acronym>operator classes shown in <xref linkend=\"brin-builtin-opclasses-table\">.</xref>"
msgstr ""

#: xml/brin.xml:78(para)
msgid "The <firstterm>minmax</firstterm>operator classes store the minimum and the maximum values appearing in the indexed column within the range. The <firstterm>inclusion</firstterm>operator classes store a value which includes the values in the indexed column within the range."
msgstr ""

#: xml/brin.xml:86(title)
msgid "Built-in <acronym>BRIN</acronym>Operator Classes"
msgstr ""

#: xml/brin.xml:91(entry)
msgid "Name"
msgstr ""

#: xml/brin.xml:92(entry)
msgid "Indexed Data Type"
msgstr ""

#: xml/brin.xml:93(entry)
msgid "Indexable Operators"
msgstr ""

#: xml/brin.xml:99(literal)
msgid "abstime_minmax_ops"
msgstr ""

#: xml/brin.xml:102(type)
msgid "abstime"
msgstr ""

#: xml/brin.xml:106(literal) xml/brin.xml:107(literal) xml/brin.xml:108(literal) xml/brin.xml:121(literal) xml/brin.xml:122(literal) xml/brin.xml:123(literal) xml/brin.xml:136(literal) xml/brin.xml:137(literal) xml/brin.xml:138(literal) xml/brin.xml:151(literal) xml/brin.xml:152(literal) xml/brin.xml:153(literal) xml/brin.xml:188(literal) xml/brin.xml:189(literal) xml/brin.xml:190(literal) xml/brin.xml:203(literal) xml/brin.xml:204(literal) xml/brin.xml:205(literal) xml/brin.xml:218(literal) xml/brin.xml:219(literal) xml/brin.xml:220(literal) xml/brin.xml:233(literal) xml/brin.xml:234(literal) xml/brin.xml:235(literal) xml/brin.xml:248(literal) xml/brin.xml:249(literal) xml/brin.xml:250(literal) xml/brin.xml:263(literal) xml/brin.xml:264(literal) xml/brin.xml:265(literal) xml/brin.xml:278(literal) xml/brin.xml:279(literal) xml/brin.xml:280(literal) xml/brin.xml:294(literal) xml/brin.xml:295(literal) xml/brin.xml:296(literal) xml/brin.xml:309(literal) xml/brin.xml:310(literal) xml/brin.xml:311(literal) xml/brin.xml:324(literal) xml/brin.xml:325(literal) xml/brin.xml:326(literal) xml/brin.xml:339(literal) xml/brin.xml:340(literal) xml/brin.xml:341(literal) xml/brin.xml:354(literal) xml/brin.xml:355(literal) xml/brin.xml:356(literal) xml/brin.xml:369(literal) xml/brin.xml:370(literal) xml/brin.xml:371(literal) xml/brin.xml:384(literal) xml/brin.xml:385(literal) xml/brin.xml:386(literal) xml/brin.xml:406(literal) xml/brin.xml:408(literal) xml/brin.xml:409(literal) xml/brin.xml:411(literal) xml/brin.xml:423(literal) xml/brin.xml:424(literal) xml/brin.xml:425(literal) xml/brin.xml:438(literal) xml/brin.xml:439(literal) xml/brin.xml:440(literal) xml/brin.xml:453(literal) xml/brin.xml:454(literal) xml/brin.xml:455(literal) xml/brin.xml:468(literal) xml/brin.xml:469(literal) xml/brin.xml:470(literal) xml/brin.xml:483(literal) xml/brin.xml:484(literal) xml/brin.xml:485(literal) xml/brin.xml:498(literal) xml/brin.xml:499(literal) xml/brin.xml:500(literal) xml/brin.xml:513(literal) xml/brin.xml:514(literal) xml/brin.xml:515(literal) xml/brin.xml:528(literal) xml/brin.xml:529(literal) xml/brin.xml:530(literal) xml/brin.xml:543(literal) xml/brin.xml:544(literal) xml/brin.xml:545(literal) xml/brin.xml:558(literal) xml/brin.xml:559(literal) xml/brin.xml:560(literal)
msgid "="
msgstr ""

#: xml/brin.xml:114(literal)
msgid "int8_minmax_ops"
msgstr ""

#: xml/brin.xml:117(type)
msgid "bigint"
msgstr ""

#: xml/brin.xml:129(literal)
msgid "bit_minmax_ops"
msgstr ""

#: xml/brin.xml:132(type)
msgid "bit"
msgstr ""

#: xml/brin.xml:144(literal)
msgid "varbit_minmax_ops"
msgstr ""

#: xml/brin.xml:147(type)
msgid "bit varying"
msgstr ""

#: xml/brin.xml:159(literal)
msgid "box_inclusion_ops"
msgstr ""

#: xml/brin.xml:162(type)
msgid "box"
msgstr ""

#: xml/brin.xml:170(literal)
msgid "~="
msgstr ""

#: xml/brin.xml:171(literal) xml/brin.xml:172(literal) xml/brin.xml:403(literal) xml/brin.xml:404(literal)
msgid "@"
msgstr ""

#: xml/brin.xml:173(literal) xml/brin.xml:174(literal) xml/brin.xml:175(literal) xml/brin.xml:176(literal)
msgid "|"
msgstr ""

#: xml/brin.xml:181(literal)
msgid "bytea_minmax_ops"
msgstr ""

#: xml/brin.xml:184(type)
msgid "bytea"
msgstr ""

#: xml/brin.xml:196(literal)
msgid "bpchar_minmax_ops"
msgstr ""

#: xml/brin.xml:199(type)
msgid "character"
msgstr ""

#: xml/brin.xml:211(literal)
msgid "char_minmax_ops"
msgstr ""

#: xml/brin.xml:214(type)
msgid "\"char\""
msgstr ""

#: xml/brin.xml:226(literal)
msgid "date_minmax_ops"
msgstr ""

#: xml/brin.xml:229(type)
msgid "date"
msgstr ""

#: xml/brin.xml:241(literal)
msgid "float8_minmax_ops"
msgstr ""

#: xml/brin.xml:244(type)
msgid "double precision"
msgstr ""

#: xml/brin.xml:256(literal)
msgid "inet_minmax_ops"
msgstr ""

#: xml/brin.xml:259(type) xml/brin.xml:274(type)
msgid "inet"
msgstr ""

#: xml/brin.xml:271(literal)
msgid "network_inclusion_ops"
msgstr ""

#: xml/brin.xml:287(literal)
msgid "int4_minmax_ops"
msgstr ""

#: xml/brin.xml:290(type)
msgid "integer"
msgstr ""

#: xml/brin.xml:302(literal)
msgid "interval_minmax_ops"
msgstr ""

#: xml/brin.xml:305(type)
msgid "interval"
msgstr ""

#: xml/brin.xml:317(literal)
msgid "macaddr_minmax_ops"
msgstr ""

#: xml/brin.xml:320(type)
msgid "macaddr"
msgstr ""

#: xml/brin.xml:332(literal)
msgid "name_minmax_ops"
msgstr ""

#: xml/brin.xml:335(type)
msgid "name"
msgstr ""

#: xml/brin.xml:347(literal)
msgid "numeric_minmax_ops"
msgstr ""

#: xml/brin.xml:350(type)
msgid "numeric"
msgstr ""

#: xml/brin.xml:362(literal)
msgid "pg_lsn_minmax_ops"
msgstr ""

#: xml/brin.xml:365(type)
msgid "pg_lsn"
msgstr ""

#: xml/brin.xml:377(literal)
msgid "oid_minmax_ops"
msgstr ""

#: xml/brin.xml:380(type)
msgid "oid"
msgstr ""

#: xml/brin.xml:392(literal)
msgid "range_inclusion_ops"
msgstr ""

#: xml/brin.xml:395(type)
msgid "any range type"
msgstr ""

#: xml/brin.xml:405(literal)
msgid "-|-"
msgstr ""

#: xml/brin.xml:416(literal)
msgid "float4_minmax_ops"
msgstr ""

#: xml/brin.xml:419(type)
msgid "real"
msgstr ""

#: xml/brin.xml:431(literal)
msgid "reltime_minmax_ops"
msgstr ""

#: xml/brin.xml:434(type)
msgid "reltime"
msgstr ""

#: xml/brin.xml:446(literal)
msgid "int2_minmax_ops"
msgstr ""

#: xml/brin.xml:449(type)
msgid "smallint"
msgstr ""

#: xml/brin.xml:461(literal)
msgid "text_minmax_ops"
msgstr ""

#: xml/brin.xml:464(type)
msgid "text"
msgstr ""

#: xml/brin.xml:476(literal)
msgid "tid_minmax_ops"
msgstr ""

#: xml/brin.xml:479(type)
msgid "tid"
msgstr ""

#: xml/brin.xml:491(literal)
msgid "timestamp_minmax_ops"
msgstr ""

#: xml/brin.xml:494(type)
msgid "timestamp without time zone"
msgstr ""

#: xml/brin.xml:506(literal)
msgid "timestamptz_minmax_ops"
msgstr ""

#: xml/brin.xml:509(type)
msgid "timestamp with time zone"
msgstr ""

#: xml/brin.xml:521(literal)
msgid "time_minmax_ops"
msgstr ""

#: xml/brin.xml:524(type)
msgid "time without time zone"
msgstr ""

#: xml/brin.xml:536(literal)
msgid "timetz_minmax_ops"
msgstr ""

#: xml/brin.xml:539(type)
msgid "time with time zone"
msgstr ""

#: xml/brin.xml:551(literal)
msgid "uuid_minmax_ops"
msgstr ""

#: xml/brin.xml:554(type)
msgid "uuid"
msgstr ""

#: xml/brin.xml:569(title)
msgid "Extensibility"
msgstr ""

#: xml/brin.xml:570(para)
msgid "The <acronym>BRIN</acronym>interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The <acronym>BRIN</acronym>layer itself takes care of concurrency, logging and searching the index structure."
msgstr ""

#: xml/brin.xml:576(para)
msgid "All it takes to get a <acronym>BRIN</acronym>access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, <acronym>BRIN</acronym>combines extensibility with generality, code reuse, and a clean interface."
msgstr ""

#: xml/brin.xml:588(function)
msgid "BrinOpcInfo *opcInfo(Oid type_oid)"
msgstr ""

#: xml/brin.xml:596(programlisting)
#, no-wrap
msgid "typedef struct BrinOpcInfo { /* Number of\n          columns stored in an index column of this opclass */\n          uint16 oi_nstored; /* Opaque pointer for the opclass'\n          private use */ void *oi_opaque; /* Type cache entries of\n          the stored columns */ TypeCacheEntry\n          *oi_typcache[FLEXIBLE_ARRAY_MEMBER]; }\n          BrinOpcInfo;"
msgstr ""

#: xml/brin.xml:591(para)
msgid "Returns internal information about the indexed columns' summary data. The return value must point to a palloc'd <structname>BrinOpcInfo</structname>, which has this definition: <placeholder-1/><structname>BrinOpcInfo</structname>. <structfield>oi_opaque</structfield>can be used by the operator class routines to pass information between support procedures during an index scan."
msgstr ""

#: xml/brin.xml:611(function)
msgid "bool consistent(BrinDesc *bdesc, BrinValues *column, ScanKey key)"
msgstr ""

#: xml/brin.xml:615(para)
msgid "Returns whether the ScanKey is consistent with the given indexed values for a range. The attribute number to use is passed as part of the scan key."
msgstr ""

#: xml/brin.xml:622(function)
msgid "bool addValue(BrinDesc *bdesc, BrinValues *column, Datum newval, bool isnull)"
msgstr ""

#: xml/brin.xml:626(para)
msgid "Given an index tuple and an indexed value, modifies the indicated attribute of the tuple so that it additionally represents the new value. If any modification was done to the tuple, <literal>true</literal>is returned."
msgstr ""

#: xml/brin.xml:635(function)
msgid "bool unionTuples(BrinDesc *bdesc, BrinValues *a, BrinValues *b)"
msgstr ""

#: xml/brin.xml:639(para)
msgid "Consolidates two index tuples. Given two index tuples, modifies the indicated attribute of the first of them so that it represents both tuples. The second tuple is not modified."
msgstr ""

#: xml/brin.xml:583(para)
msgid "There are four methods that an operator class for <acronym>BRIN</acronym>must provide: <placeholder-1/>The core distribution includes support for two types of operator classes: minmax and inclusion. Operator class definitions using them are shipped for in-core data types as appropriate. Additional operator classes can be defined by the user for other data types using equivalent definitions, without having to write any source code; appropriate catalog entries being declared is enough. Note that assumptions about the semantics of operator strategies are embedded in the support procedures' source code."
msgstr ""

#: xml/brin.xml:654(para)
msgid "Operator classes that implement completely different semantics are also possible, provided implementations of the four main support procedures described above are written. Note that backwards compatibility across major releases is not guaranteed: for example, additional support procedures might be required in later releases."
msgstr ""

#: xml/brin.xml:660(para)
msgid "To write an operator class for a data type that implements a totally ordered set, it is possible to use the minmax support procedures alongside the corresponding operators, as shown in <xref linkend=\"brin-extensibility-minmax-table\">. All operator class members (procedures and operators) are mandatory.</xref>"
msgstr ""

#: xml/brin.xml:668(title)
msgid "Procedure and Support Numbers for Minmax Operator Classes"
msgstr ""

#: xml/brin.xml:673(entry) xml/brin.xml:737(entry)
msgid "Operator class member"
msgstr ""

#: xml/brin.xml:674(entry) xml/brin.xml:738(entry)
msgid "Object"
msgstr ""

#: xml/brin.xml:679(entry) xml/brin.xml:744(entry)
msgid "Support Procedure 1"
msgstr ""

#: xml/brin.xml:681(function)
msgid "brin_minmax_opcinfo()"
msgstr ""

#: xml/brin.xml:680(entry) xml/brin.xml:685(entry) xml/brin.xml:690(entry) xml/brin.xml:695(entry) xml/brin.xml:745(entry) xml/brin.xml:751(entry) xml/brin.xml:757(entry) xml/brin.xml:764(entry)
msgid "internal function <placeholder-1/>"
msgstr ""

#: xml/brin.xml:684(entry) xml/brin.xml:750(entry)
msgid "Support Procedure 2"
msgstr ""

#: xml/brin.xml:686(function)
msgid "brin_minmax_add_value()"
msgstr ""

#: xml/brin.xml:689(entry) xml/brin.xml:756(entry)
msgid "Support Procedure 3"
msgstr ""

#: xml/brin.xml:691(function)
msgid "brin_minmax_consistent()"
msgstr ""

#: xml/brin.xml:694(entry) xml/brin.xml:763(entry)
msgid "Support Procedure 4"
msgstr ""

#: xml/brin.xml:696(function)
msgid "brin_minmax_union()"
msgstr ""

#: xml/brin.xml:699(entry) xml/brin.xml:792(entry) xml/brin.xml:814(entry) xml/brin.xml:864(entry) xml/brin.xml:869(entry)
msgid "Operator Strategy 1"
msgstr ""

#: xml/brin.xml:700(entry) xml/brin.xml:853(entry)
msgid "operator less-than"
msgstr ""

#: xml/brin.xml:703(entry) xml/brin.xml:797(entry) xml/brin.xml:809(entry)
msgid "Operator Strategy 2"
msgstr ""

#: xml/brin.xml:704(entry) xml/brin.xml:858(entry)
msgid "operator less-than-or-equal-to"
msgstr ""

#: xml/brin.xml:707(entry) xml/brin.xml:802(entry) xml/brin.xml:829(entry)
msgid "Operator Strategy 3"
msgstr ""

#: xml/brin.xml:708(entry)
msgid "operator equal-to"
msgstr ""

#: xml/brin.xml:711(entry) xml/brin.xml:794(entry) xml/brin.xml:807(entry) xml/brin.xml:854(entry) xml/brin.xml:859(entry)
msgid "Operator Strategy 4"
msgstr ""

#: xml/brin.xml:712(entry) xml/brin.xml:868(entry)
msgid "operator greater-than-or-equal-to"
msgstr ""

#: xml/brin.xml:715(entry) xml/brin.xml:799(entry) xml/brin.xml:812(entry)
msgid "Operator Strategy 5"
msgstr ""

#: xml/brin.xml:716(entry) xml/brin.xml:863(entry)
msgid "operator greater-than"
msgstr ""

#: xml/brin.xml:721(para)
msgid "To write an operator class for a complex datatype which has values included within another type, it's possible to use the inclusion support procedures alongside the corresponding operators, as shown in <xref linkend=\"brin-extensibility-inclusion-table\">. It requires only a single additional function, which can be written in any language. More functions can be defined for additional functionality. All operators are optional. Some operators require other operators, as shown as dependencies on the table.</xref>"
msgstr ""

#: xml/brin.xml:732(title)
msgid "Procedure and Support Numbers for Inclusion Operator Classes"
msgstr ""

#: xml/brin.xml:739(entry)
msgid "Dependency"
msgstr ""

#: xml/brin.xml:746(function)
msgid "brin_inclusion_opcinfo()"
msgstr ""

#: xml/brin.xml:752(function)
msgid "brin_inclusion_add_value()"
msgstr ""

#: xml/brin.xml:758(function)
msgid "brin_inclusion_consistent()"
msgstr ""

#: xml/brin.xml:765(function)
msgid "brin_inclusion_union()"
msgstr ""

#: xml/brin.xml:769(entry)
msgid "Support Procedure 11"
msgstr ""

#: xml/brin.xml:770(entry)
msgid "function to merge two elements"
msgstr ""

#: xml/brin.xml:774(entry)
msgid "Support Procedure 12"
msgstr ""

#: xml/brin.xml:775(entry)
msgid "optional function to check whether two elements are mergeable"
msgstr ""

#: xml/brin.xml:780(entry)
msgid "Support Procedure 13"
msgstr ""

#: xml/brin.xml:781(entry)
msgid "optional function to check if an element is contained within another"
msgstr ""

#: xml/brin.xml:786(entry)
msgid "Support Procedure 14"
msgstr ""

#: xml/brin.xml:787(entry)
msgid "optional function to check whether an element is empty"
msgstr ""

#: xml/brin.xml:793(entry)
msgid "operator left-of"
msgstr ""

#: xml/brin.xml:798(entry) xml/brin.xml:813(entry)
msgid "operator does-not-extend-to-the-right-of"
msgstr ""

#: xml/brin.xml:803(entry)
msgid "operator overlaps"
msgstr ""

#: xml/brin.xml:808(entry)
msgid "operator right-of"
msgstr ""

#: xml/brin.xml:817(entry)
msgid "Operator Strategy 6, 18"
msgstr ""

#: xml/brin.xml:818(entry)
msgid "operator same-as-or-equal-to"
msgstr ""

#: xml/brin.xml:819(entry)
msgid "Operator Strategy 7"
msgstr ""

#: xml/brin.xml:822(entry)
msgid "Operator Strategy 7, 13, 16, 24, 25"
msgstr ""

#: xml/brin.xml:823(entry)
msgid "operator contains-or-equal-to"
msgstr ""

#: xml/brin.xml:827(entry)
msgid "Operator Strategy 8, 14, 26, 27"
msgstr ""

#: xml/brin.xml:828(entry)
msgid "operator is-contained-by-or-equal-to"
msgstr ""

#: xml/brin.xml:832(entry) xml/brin.xml:844(entry)
msgid "Operator Strategy 9"
msgstr ""

#: xml/brin.xml:833(entry)
msgid "operator does-not-extend-above"
msgstr ""

#: xml/brin.xml:834(entry) xml/brin.xml:842(entry)
msgid "Operator Strategy 11"
msgstr ""

#: xml/brin.xml:837(entry) xml/brin.xml:849(entry)
msgid "Operator Strategy 10"
msgstr ""

#: xml/brin.xml:838(entry)
msgid "operator is-below"
msgstr ""

#: xml/brin.xml:839(entry) xml/brin.xml:847(entry)
msgid "Operator Strategy 12"
msgstr ""

#: xml/brin.xml:843(entry)
msgid "operator is-above"
msgstr ""

#: xml/brin.xml:848(entry)
msgid "operator does-not-extend-below"
msgstr ""

#: xml/brin.xml:852(entry)
msgid "Operator Strategy 20"
msgstr ""

#: xml/brin.xml:857(entry)
msgid "Operator Strategy 21"
msgstr ""

#: xml/brin.xml:862(entry)
msgid "Operator Strategy 22"
msgstr ""

#: xml/brin.xml:867(entry)
msgid "Operator Strategy 23"
msgstr ""

#: xml/brin.xml:874(para)
msgid "Support procedure numbers 1-10 are reserved for the BRIN internal functions, so the SQL level functions start with number 11. Support function number 11 is the main function required to build the index. It should accept two arguments with the same datatype as the opclass, and return the union of them. The inclusion opclass can store union values with different datatypes if it is defined with the <literal>STORAGE</literal>parameter. The return value of the union function should match the <literal>STORAGE</literal>datatype."
msgstr ""

#: xml/brin.xml:884(para)
msgid "Support procedure numbers 12 and 14 are provided to support irregularities of built-in datatypes. Procedure number 12 is used to support network addresses from different families which are not mergeable. Procedure number 14 is used to support empty ranges. Procedure number 13 is an optional but recommended one, which allows the new value to be checked before it is passed to the union function. As the BRIN framework can shortcut some operations when the union is not changed, using this function can improve index performance."
msgstr ""

#: xml/brin.xml:894(para)
msgid "Both minmax and inclusion opclasses support cross-datatype operators, though with these the dependencies become more complicated. The minmax opclass requires a full set of operators to be defined with both arguments having the same datatype. It allows additional datatypes to be supported by defining extra sets of operators. Inclusion opclass operator strategies are dependent on another operator strategy as shown in <xref linkend=\"brin-extensibility-inclusion-table\">, or the same operator strategy as themselves. They require the dependency operator to be defined with the <literal>STORAGE</literal>datatype as the left-hand-side argument and the other supported datatype to be the right-hand-side argument of the supported operator. See <literal>float4_minmax_ops</literal>as an example of minmax, and <literal>box_inclusion_ops</literal>as an example of inclusion.</xref>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/brin.xml:0(None)
msgid "translator-credits"
msgstr ""

