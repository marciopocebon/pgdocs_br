msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/xindex.xml:3(title)
msgid "Interfacing Extensions To Indexes"
msgstr ""

#: xml/xindex.xml:5(primary)
msgid "index"
msgstr ""

#: xml/xindex.xml:6(secondary)
msgid "for user-defined data type"
msgstr ""

#: xml/xindex.xml:8(para)
msgid "The procedures described thus far let you define new types, new functions, and new operators. However, we cannot yet define an index on a column of a new data type. To do this, we must define an <firstterm>operator class</firstterm>for the new data type. Later in this section, we will illustrate this concept in an example: a new operator class for the B-tree index method that stores and sorts complex numbers in ascending absolute value order."
msgstr ""

#: xml/xindex.xml:16(para)
msgid "Operator classes can be grouped into <firstterm>operator families</firstterm>to show the relationships between semantically compatible classes. When only a single data type is involved, an operator class is sufficient, so we'll focus on that case first and then return to operator families."
msgstr ""

#: xml/xindex.xml:22(title)
msgid "Index Methods and Operator Classes"
msgstr ""

#: xml/xindex.xml:23(para)
msgid "The <classname>pg_am</classname>table contains one row for every index method (internally known as access method). Support for regular access to tables is built into <productname>PostgreSQL</productname>, but all index methods are described in <classname>pg_am</classname>. It is possible to add a new index method by defining the required interface routines and then creating a row in <classname>pg_am</classname>but that is beyond the scope of this chapter (see <xref linkend=\"indexam\">).</xref>"
msgstr ""

#: xml/xindex.xml:35(para)
msgid "The routines for an index method do not directly know anything about the data types that the index method will operate on. Instead, an <firstterm>operator class</firstterm><indexterm><primary>operator class</primary></indexterm>identifies the set of operations that the index method needs to use to work with a particular data type. Operator classes are so called because one thing they specify is the set of <literal>WHERE</literal>-clause operators that can be used with an index (i.e., can be converted into an index-scan qualification). An operator class can also specify some <firstterm>support procedures</firstterm>that are needed by the internal operations of the index method, but do not directly correspond to any <literal>WHERE</literal>-clause operator that can be used with the index."
msgstr ""

#: xml/xindex.xml:53(para)
msgid "It is possible to define multiple operator classes for the same data type and index method. By doing this, multiple sets of indexing semantics can be defined for a single data type. For example, a B-tree index requires a sort ordering to be defined for each data type it works on. It might be useful for a complex-number data type to have one B-tree operator class that sorts the data by complex absolute value, another that sorts by real part, and so on. Typically, one of the operator classes will be deemed most commonly useful and will be marked as the default operator class for that data type and index method."
msgstr ""

#: xml/xindex.xml:64(para)
msgid "The same operator class name can be used for several different index methods (for example, both B-tree and hash index methods have operator classes named <literal>int4_ops</literal>), but each such class is an independent entity and must be defined separately."
msgstr ""

#: xml/xindex.xml:71(title)
msgid "Index Method Strategies"
msgstr ""

#: xml/xindex.xml:72(para)
msgid "The operators associated with an operator class are identified by <quote>strategy numbers</quote>, which serve to identify the semantics of each operator within the context of its operator class. For example, B-trees impose a strict ordering on keys, lesser to greater, and so operators like <quote>less than</quote>and <quote>greater than or equal to</quote>are interesting with respect to a B-tree. Because <productname>PostgreSQL</productname>allows the user to define operators, <productname>PostgreSQL</productname>cannot look at the name of an operator (e.g., <literal/>or <literal>=</literal>) and tell what kind of comparison it is. Instead, the index method defines a set of <quote>strategies</quote>, which can be thought of as generalized operators. Each operator class specifies which actual operator corresponds to each strategy for a particular data type and interpretation of the index semantics."
msgstr ""

#: xml/xindex.xml:92(para)
msgid "The B-tree index method defines five strategies, shown in <xref linkend=\"xindex-btree-strat-table\">.</xref>"
msgstr ""

#: xml/xindex.xml:96(title)
msgid "B-tree Strategies"
msgstr ""

#: xml/xindex.xml:100(entry) xml/xindex.xml:136(entry) xml/xindex.xml:166(entry) xml/xindex.xml:234(entry) xml/xindex.xml:278(entry)
msgid "Operation"
msgstr ""

#: xml/xindex.xml:101(entry) xml/xindex.xml:137(entry) xml/xindex.xml:167(entry) xml/xindex.xml:235(entry) xml/xindex.xml:279(entry)
msgid "Strategy Number"
msgstr ""

#: xml/xindex.xml:106(entry)
msgid "less than"
msgstr ""

#: xml/xindex.xml:107(entry) xml/xindex.xml:143(entry) xml/xindex.xml:173(entry) xml/xindex.xml:241(entry) xml/xindex.xml:285(entry) xml/xindex.xml:352(entry) xml/xindex.xml:378(entry) xml/xindex.xml:405(entry) xml/xindex.xml:496(entry) xml/xindex.xml:557(entry)
msgid "1"
msgstr ""

#: xml/xindex.xml:110(entry)
msgid "less than or equal"
msgstr ""

#: xml/xindex.xml:111(entry) xml/xindex.xml:177(entry) xml/xindex.xml:289(entry) xml/xindex.xml:359(entry) xml/xindex.xml:412(entry) xml/xindex.xml:504(entry) xml/xindex.xml:564(entry)
msgid "2"
msgstr ""

#: xml/xindex.xml:114(entry) xml/xindex.xml:142(entry) xml/xindex.xml:296(entry) xml/xindex.xml:449(function)
msgid "equal"
msgstr ""

#: xml/xindex.xml:115(entry) xml/xindex.xml:181(entry) xml/xindex.xml:293(entry) xml/xindex.xml:420(entry) xml/xindex.xml:512(entry) xml/xindex.xml:571(entry)
msgid "3"
msgstr ""

#: xml/xindex.xml:118(entry)
msgid "greater than or equal"
msgstr ""

#: xml/xindex.xml:119(entry) xml/xindex.xml:185(entry) xml/xindex.xml:297(entry) xml/xindex.xml:428(entry) xml/xindex.xml:520(entry) xml/xindex.xml:580(entry)
msgid "4"
msgstr ""

#: xml/xindex.xml:122(entry)
msgid "greater than"
msgstr ""

#: xml/xindex.xml:123(entry) xml/xindex.xml:189(entry) xml/xindex.xml:245(entry) xml/xindex.xml:436(entry) xml/xindex.xml:528(entry) xml/xindex.xml:591(entry)
msgid "5"
msgstr ""

#: xml/xindex.xml:128(para)
msgid "Hash indexes support only equality comparisons, and so they use only one strategy, shown in <xref linkend=\"xindex-hash-strat-table\">.</xref>"
msgstr ""

#: xml/xindex.xml:132(title)
msgid "Hash Strategies"
msgstr ""

#: xml/xindex.xml:148(para)
msgid "GiST indexes are more flexible: they do not have a fixed set of strategies at all. Instead, the <quote>consistency</quote>support routine of each particular GiST operator class interprets the strategy numbers however it likes. As an example, several of the built-in GiST index operator classes index two-dimensional geometric objects, providing the <quote>R-tree</quote>strategies shown in <xref linkend=\"xindex-rtree-strat-table\">. Four of these are true two-dimensional tests (overlaps, same, contains, contained by); four of them consider only the X direction; and the other four provide the same tests in the Y direction.</xref>"
msgstr ""

#: xml/xindex.xml:161(title)
msgid "GiST Two-Dimensional <quote>R-tree</quote>Strategies"
msgstr ""

#: xml/xindex.xml:172(entry) xml/xindex.xml:240(entry)
msgid "strictly left of"
msgstr ""

#: xml/xindex.xml:176(entry)
msgid "does not extend to right of"
msgstr ""

#: xml/xindex.xml:180(entry)
msgid "overlaps"
msgstr ""

#: xml/xindex.xml:184(entry)
msgid "does not extend to left of"
msgstr ""

#: xml/xindex.xml:188(entry) xml/xindex.xml:244(entry)
msgid "strictly right of"
msgstr ""

#: xml/xindex.xml:192(entry) xml/xindex.xml:248(entry)
msgid "same"
msgstr ""

#: xml/xindex.xml:193(entry) xml/xindex.xml:249(entry) xml/xindex.xml:445(entry) xml/xindex.xml:600(entry)
msgid "6"
msgstr ""

#: xml/xindex.xml:196(entry) xml/xindex.xml:288(entry)
msgid "contains"
msgstr ""

#: xml/xindex.xml:197(entry) xml/xindex.xml:453(entry)
msgid "7"
msgstr ""

#: xml/xindex.xml:200(entry) xml/xindex.xml:252(entry)
msgid "contained by"
msgstr ""

#: xml/xindex.xml:201(entry) xml/xindex.xml:253(entry) xml/xindex.xml:461(entry)
msgid "8"
msgstr ""

#: xml/xindex.xml:204(entry)
msgid "does not extend above"
msgstr ""

#: xml/xindex.xml:205(entry) xml/xindex.xml:469(entry)
msgid "9"
msgstr ""

#: xml/xindex.xml:208(entry) xml/xindex.xml:256(entry)
msgid "strictly below"
msgstr ""

#: xml/xindex.xml:209(entry) xml/xindex.xml:257(entry)
msgid "10"
msgstr ""

#: xml/xindex.xml:212(entry) xml/xindex.xml:260(entry)
msgid "strictly above"
msgstr ""

#: xml/xindex.xml:213(entry) xml/xindex.xml:261(entry)
msgid "11"
msgstr ""

#: xml/xindex.xml:216(entry)
msgid "does not extend below"
msgstr ""

#: xml/xindex.xml:217(entry)
msgid "12"
msgstr ""

#: xml/xindex.xml:222(para)
msgid "SP-GiST indexes are similar to GiST indexes in flexibility: they don't have a fixed set of strategies. Instead the support routines of each operator class interpret the strategy numbers according to the operator class's definition. As an example, the strategy numbers used by the built-in operator classes for points are shown in <xref linkend=\"xindex-spgist-point-strat-table\">.</xref>"
msgstr ""

#: xml/xindex.xml:230(title)
msgid "SP-GiST Point Strategies"
msgstr ""

#: xml/xindex.xml:266(para)
msgid "GIN indexes are similar to GiST and SP-GiST indexes, in that they don't have a fixed set of strategies either. Instead the support routines of each operator class interpret the strategy numbers according to the operator class's definition. As an example, the strategy numbers used by the built-in operator classes for arrays are shown in <xref linkend=\"xindex-gin-array-strat-table\">.</xref>"
msgstr ""

#: xml/xindex.xml:274(title)
msgid "GIN Array Strategies"
msgstr ""

#: xml/xindex.xml:284(entry)
msgid "overlap"
msgstr ""

#: xml/xindex.xml:292(entry)
msgid "is contained by"
msgstr ""

#: xml/xindex.xml:302(para)
msgid "Notice that all the operators listed above return Boolean values. In practice, all operators defined as index method search operators must return type <type>boolean</type>, since they must appear at the top level of a <literal>WHERE</literal>clause to be used with an index. (Some index access methods also support <firstterm>ordering operators</firstterm>, which typically don't return Boolean values; that feature is discussed in <xref linkend=\"xindex-ordering-ops\">.)</xref>"
msgstr ""

#: xml/xindex.xml:314(title)
msgid "Index Method Support Routines"
msgstr ""

#: xml/xindex.xml:315(para)
msgid "Strategies aren't usually enough information for the system to figure out how to use an index. In practice, the index methods require additional support routines in order to work. For example, the B-tree index method must be able to compare two keys and determine whether one is greater than, equal to, or less than the other. Similarly, the hash index method must be able to compute hash codes for key values. These operations do not correspond to operators used in qualifications in SQL commands; they are administrative routines used by the index methods, internally."
msgstr ""

#: xml/xindex.xml:325(para)
msgid "Just as with strategies, the operator class identifies which specific functions should play each of these roles for a given data type and semantic interpretation. The index method defines the set of functions it needs, and the operator class identifies the correct functions to use by assigning them to the <quote>support function numbers</quote>specified by the index method."
msgstr ""

#: xml/xindex.xml:333(para)
msgid "B-trees require a single support function, and allow a second one to be supplied at the operator class author's option, as shown in <xref linkend=\"xindex-btree-support-table\">.</xref>"
msgstr ""

#: xml/xindex.xml:338(title)
msgid "B-tree Support Functions"
msgstr ""

#: xml/xindex.xml:342(entry) xml/xindex.xml:371(entry) xml/xindex.xml:393(entry) xml/xindex.xml:484(entry) xml/xindex.xml:543(entry)
msgid "Function"
msgstr ""

#: xml/xindex.xml:343(entry) xml/xindex.xml:372(entry) xml/xindex.xml:395(entry) xml/xindex.xml:486(entry) xml/xindex.xml:545(entry)
msgid "Support Number"
msgstr ""

#: xml/xindex.xml:348(entry)
msgid "Compare two keys and return an integer less than zero, zero, or greater than zero, indicating whether the first key is less than, equal to, or greater than the second"
msgstr ""

#: xml/xindex.xml:357(filename)
msgid "utils/sortsupport.h"
msgstr ""

#: xml/xindex.xml:355(entry)
msgid "Return the addresses of C-callable sort support function(s), as documented in <placeholder-1/>(optional)"
msgstr ""

#: xml/xindex.xml:364(para)
msgid "Hash indexes require one support function, shown in <xref linkend=\"xindex-hash-support-table\">.</xref>"
msgstr ""

#: xml/xindex.xml:367(title)
msgid "Hash Support Functions"
msgstr ""

#: xml/xindex.xml:377(entry)
msgid "Compute the hash value for a key"
msgstr ""

#: xml/xindex.xml:383(para)
msgid "GiST indexes have nine support functions, two of which are optional, as shown in <xref linkend=\"xindex-gist-support-table\">. (For more information see <xref linkend=\"GiST\">.)</xref></xref>"
msgstr ""

#: xml/xindex.xml:389(title)
msgid "GiST Support Functions"
msgstr ""

#: xml/xindex.xml:394(entry) xml/xindex.xml:485(entry) xml/xindex.xml:544(entry)
msgid "Description"
msgstr ""

#: xml/xindex.xml:401(function) xml/xindex.xml:575(function)
msgid "consistent"
msgstr ""

#: xml/xindex.xml:403(entry) xml/xindex.xml:526(entry)
msgid "determine whether key satisfies the query qualifier"
msgstr ""

#: xml/xindex.xml:409(function)
msgid "union"
msgstr ""

#: xml/xindex.xml:411(entry)
msgid "compute union of a set of keys"
msgstr ""

#: xml/xindex.xml:416(function)
msgid "compress"
msgstr ""

#: xml/xindex.xml:418(entry)
msgid "compute a compressed representation of a key or value to be indexed"
msgstr ""

#: xml/xindex.xml:424(function)
msgid "decompress"
msgstr ""

#: xml/xindex.xml:426(entry)
msgid "compute a decompressed representation of a compressed key"
msgstr ""

#: xml/xindex.xml:432(function)
msgid "penalty"
msgstr ""

#: xml/xindex.xml:434(entry)
msgid "compute penalty for inserting new key into subtree with given subtree's key"
msgstr ""

#: xml/xindex.xml:440(function) xml/xindex.xml:508(function)
msgid "picksplit"
msgstr ""

#: xml/xindex.xml:442(entry)
msgid "determine which entries of a page are to be moved to the new page and compute the union keys for resulting pages"
msgstr ""

#: xml/xindex.xml:451(entry)
msgid "compare two keys and return true if they are equal"
msgstr ""

#: xml/xindex.xml:457(function)
msgid "distance"
msgstr ""

#: xml/xindex.xml:459(entry)
msgid "determine distance from key to query value (optional)"
msgstr ""

#: xml/xindex.xml:465(function)
msgid "fetch"
msgstr ""

#: xml/xindex.xml:467(entry)
msgid "compute original representation of a compressed key for index-only scans (optional)"
msgstr ""

#: xml/xindex.xml:474(para)
msgid "SP-GiST indexes require five support functions, as shown in <xref linkend=\"xindex-spgist-support-table\">. (For more information see <xref linkend=\"SPGiST\">.)</xref></xref>"
msgstr ""

#: xml/xindex.xml:480(title)
msgid "SP-GiST Support Functions"
msgstr ""

#: xml/xindex.xml:492(function)
msgid "config"
msgstr ""

#: xml/xindex.xml:494(entry)
msgid "provide basic information about the operator class"
msgstr ""

#: xml/xindex.xml:500(function)
msgid "choose"
msgstr ""

#: xml/xindex.xml:502(entry)
msgid "determine how to insert a new value into an inner tuple"
msgstr ""

#: xml/xindex.xml:510(entry)
msgid "determine how to partition a set of values"
msgstr ""

#: xml/xindex.xml:516(function)
msgid "inner_consistent"
msgstr ""

#: xml/xindex.xml:518(entry)
msgid "determine which sub-partitions need to be searched for a query"
msgstr ""

#: xml/xindex.xml:524(function)
msgid "leaf_consistent"
msgstr ""

#: xml/xindex.xml:533(para)
msgid "GIN indexes have six support functions, three of which are optional, as shown in <xref linkend=\"xindex-gin-support-table\">. (For more information see <xref linkend=\"GIN\">.)</xref></xref>"
msgstr ""

#: xml/xindex.xml:539(title)
msgid "GIN Support Functions"
msgstr ""

#: xml/xindex.xml:551(function)
msgid "compare"
msgstr ""

#: xml/xindex.xml:553(entry)
msgid "compare two keys and return an integer less than zero, zero, or greater than zero, indicating whether the first key is less than, equal to, or greater than the second"
msgstr ""

#: xml/xindex.xml:561(function)
msgid "extractValue"
msgstr ""

#: xml/xindex.xml:563(entry)
msgid "extract keys from a value to be indexed"
msgstr ""

#: xml/xindex.xml:568(function)
msgid "extractQuery"
msgstr ""

#: xml/xindex.xml:570(entry)
msgid "extract keys from a query condition"
msgstr ""

#: xml/xindex.xml:577(entry)
msgid "determine whether value matches query condition (Boolean variant) (optional if support function 6 is present)"
msgstr ""

#: xml/xindex.xml:584(function)
msgid "comparePartial"
msgstr ""

#: xml/xindex.xml:586(entry)
msgid "compare partial key from query and key from index, and return an integer less than zero, zero, or greater than zero, indicating whether GIN should ignore this index entry, treat the entry as a match, or stop the index scan (optional)"
msgstr ""

#: xml/xindex.xml:595(function)
msgid "triConsistent"
msgstr ""

#: xml/xindex.xml:597(entry)
msgid "determine whether value matches query condition (ternary variant) (optional if support function 4 is present)"
msgstr ""

#: xml/xindex.xml:605(para)
msgid "Unlike search operators, support functions return whichever data type the particular index method expects; for example in the case of the comparison function for B-trees, a signed integer. The number and types of the arguments to each support function are likewise dependent on the index method. For B-tree and hash the comparison and hashing support functions take the same input data types as do the operators included in the operator class, but this is not the case for most GiST, SP-GiST, and GIN support functions."
msgstr ""

#: xml/xindex.xml:616(title)
msgid "An Example"
msgstr ""

#: xml/xindex.xml:632(simpara)
msgid "absolute-value less-than (strategy 1)"
msgstr ""

#: xml/xindex.xml:635(simpara)
msgid "absolute-value less-than-or-equal (strategy 2)"
msgstr ""

#: xml/xindex.xml:639(simpara)
msgid "absolute-value equal (strategy 3)"
msgstr ""

#: xml/xindex.xml:642(simpara)
msgid "absolute-value greater-than-or-equal (strategy 4)"
msgstr ""

#: xml/xindex.xml:646(simpara)
msgid "absolute-value greater-than (strategy 5)"
msgstr ""

#: xml/xindex.xml:617(para)
msgid "Now that we have seen the ideas, here is the promised example of creating a new operator class. (You can find a working copy of this example in <filename>src/tutorial/complex.c</filename>and <filename>src/tutorial/complex.sql</filename>in the source distribution.) The operator class encapsulates operators that sort complex numbers in absolute value order, so we choose the name <literal>complex_abs_ops</literal>. First, we need a set of operators. The procedure for defining operators was discussed in <xref linkend=\"xoper\">. For an operator class on B-trees, the operators we require are: <placeholder-1/></xref>"
msgstr ""

#: xml/xindex.xml:655(programlisting)
#, no-wrap
msgid "#define Mag(c) ((c)-&gt;x*(c)-&gt;x +\n    (c)-&gt;y*(c)-&gt;y) static int\n    complex_abs_cmp_internal(Complex *a, Complex *b) { double amag\n    = Mag(a), bmag = Mag(b); if (amag &lt; bmag) return -1; if\n    (amag &gt; bmag) return 1; return 0; }"
msgstr ""

#: xml/xindex.xml:661(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(complex_abs_lt); Datum\n    complex_abs_lt(PG_FUNCTION_ARGS) { Complex *a = (Complex *)\n    PG_GETARG_POINTER(0); Complex *b = (Complex *)\n    PG_GETARG_POINTER(1);\n    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);\n    }"
msgstr ""

#: xml/xindex.xml:649(para)
msgid "The least error-prone way to define a related set of comparison operators is to write the B-tree comparison support function first, and then write the other functions as one-line wrappers around the support function. This reduces the odds of getting inconsistent results for corner cases. Following this approach, we first write: <placeholder-1/>Now the less-than function looks like: <placeholder-2/>The other four functions differ only in how they compare the internal function's result to zero."
msgstr ""

#: xml/xindex.xml:670(programlisting)
#, no-wrap
msgid "CREATE FUNCTION complex_abs_lt(complex,\n    complex) RETURNS bool AS ' \n    <replaceable>filename</replaceable>', 'complex_abs_lt' LANGUAGE\n    C IMMUTABLE STRICT; CREATE OPERATOR ( leftarg = complex,\n    rightarg = complex, procedure = complex_abs_lt, commutator = ,\n    negator = = , restrict = scalarltsel, join = scalarltjoinsel\n    );"
msgstr ""

#: xml/xindex.xml:668(para)
msgid "Next we declare the functions and the operators based on the functions to SQL: <placeholder-1/>It is important to specify the correct commutator and negator operators, as well as suitable restriction and join selectivity functions, otherwise the optimizer will be unable to make effective use of the index. Note that the less-than, equal, and greater-than cases should use different selectivity functions."
msgstr ""

#: xml/xindex.xml:685(para)
msgid "There can only be one operator named, say, <literal>=</literal>and taking type <type>complex</type>for both operands. In this case we don't have any other operator <literal>=</literal>for <type>complex</type>, but if we were building a practical data type we'd probably want <literal>=</literal>to be the ordinary equality operation for complex numbers (and not the equality of the absolute values). In that case, we'd need to use some other operator name for <function>complex_abs_eq</function>."
msgstr ""

#: xml/xindex.xml:699(para)
msgid "Although <productname>PostgreSQL</productname>can cope with functions having the same SQL name as long as they have different argument data types, C can only cope with one global function having a given name. So we shouldn't name the C function something simple like <filename>abs_eq</filename>. Usually it's a good practice to include the data type name in the C function name, so as not to conflict with functions for other data types."
msgstr ""

#: xml/xindex.xml:710(para)
msgid "We could have made the SQL name of the function <filename>abs_eq</filename>, relying on <productname>PostgreSQL</productname>to distinguish it by argument data types from any other SQL function of the same name. To keep the example simple, we make the function have the same names at the C level and SQL level."
msgstr ""

#: xml/xindex.xml:682(para)
msgid "Other things worth noting are happening here: <placeholder-1/>"
msgstr ""

#: xml/xindex.xml:722(programlisting)
#, no-wrap
msgid "CREATE FUNCTION complex_abs_cmp(complex,\n    complex) RETURNS integer AS ' \n    <replaceable>filename</replaceable>' LANGUAGE C IMMUTABLE\n    STRICT;"
msgstr ""

#: xml/xindex.xml:718(para)
msgid "The next step is the registration of the support routine required by B-trees. The example C code that implements this is in the same file that contains the operator functions. This is how we declare the function: <placeholder-1/>"
msgstr ""

#: xml/xindex.xml:728(programlisting)
#, no-wrap
msgid "CREATE OPERATOR CLASS complex_abs_ops DEFAULT\n    FOR TYPE complex USING btree AS OPERATOR 1 &lt; , OPERATOR 2\n    &lt;= , OPERATOR 3 = , OPERATOR 4 &gt;= , OPERATOR 5 &gt; ,\n    FUNCTION 1 complex_abs_cmp(complex,\n    complex);"
msgstr ""

#: xml/xindex.xml:726(para)
msgid "Now that we have the required operators and support routine, we can finally create the operator class: <placeholder-1/>"
msgstr ""

#: xml/xindex.xml:733(para)
msgid "And we're done! It should now be possible to create and use B-tree indexes on <type>complex</type>columns."
msgstr ""

#: xml/xindex.xml:738(programlisting)
#, no-wrap
msgid "OPERATOR 1 (complex, complex)\n    ,"
msgstr ""

#: xml/xindex.xml:736(para)
msgid "We could have written the operator entries more verbosely, as in: <placeholder-1/>but there is no need to do so when the operators take the same data type we are defining the operator class for."
msgstr ""

#: xml/xindex.xml:742(para)
msgid "The above example assumes that you want to make this new operator class the default B-tree operator class for the <type>complex</type>data type. If you don't, just leave out the word <literal>DEFAULT</literal>."
msgstr ""

#: xml/xindex.xml:749(title)
msgid "Operator Classes and Operator Families"
msgstr ""

#: xml/xindex.xml:750(para)
msgid "So far we have implicitly assumed that an operator class deals with only one data type. While there certainly can be only one data type in a particular index column, it is often useful to index operations that compare an indexed column to a value of a different data type. Also, if there is use for a cross-data-type operator in connection with an operator class, it is often the case that the other data type has a related operator class of its own. It is helpful to make the connections between related classes explicit, because this can aid the planner in optimizing SQL queries (particularly for B-tree operator classes, since the planner contains a great deal of knowledge about how to work with them)."
msgstr ""

#: xml/xindex.xml:762(para)
msgid "To handle these needs, <productname>PostgreSQL</productname>uses the concept of an <firstterm>operator family</firstterm><indexterm><primary>operator family</primary></indexterm>. An operator family contains one or more operator classes, and can also contain indexable operators and corresponding support functions that belong to the family as a whole but not to any single class within the family. We say that such operators and functions are <quote>loose</quote>within the family, as opposed to being bound into a specific class. Typically each operator class contains single-data-type operators while cross-data-type operators are loose in the family."
msgstr ""

#: xml/xindex.xml:776(para)
msgid "All the operators and functions in an operator family must have compatible semantics, where the compatibility requirements are set by the index method. You might therefore wonder why bother to single out particular subsets of the family as operator classes; and indeed for many purposes the class divisions are irrelevant and the family is the only interesting grouping. The reason for defining operator classes is that they specify how much of the family is needed to support any particular index. If there is an index using an operator class, then that operator class cannot be dropped without dropping the index but other parts of the operator family, namely other operator classes and loose operators, could be dropped. Thus, an operator class should be specified to contain the minimum set of operators and functions that are reasonably needed to work with an index on a specific data type, and then related but non-essential operators can be added as loose members of the operator family."
msgstr ""

#: xml/xindex.xml:811(programlisting)
#, no-wrap
msgid "CREATE OPERATOR FAMILY integer_ops USING btree;\n    CREATE OPERATOR CLASS int8_ops DEFAULT FOR TYPE int8 USING\n    btree FAMILY integer_ops AS -- standard int8 comparisons\n    OPERATOR 1 &lt; , OPERATOR 2 &lt;= , OPERATOR 3 = , OPERATOR 4\n    &gt;= , OPERATOR 5 &gt; , FUNCTION 1 btint8cmp(int8, int8) ,\n    FUNCTION 2 btint8sortsupport(internal) ; CREATE OPERATOR CLASS\n    int4_ops DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops\n    AS -- standard int4 comparisons OPERATOR 1 &lt; , OPERATOR 2\n    &lt;= , OPERATOR 3 = , OPERATOR 4 &gt;= , OPERATOR 5 &gt; ,\n    FUNCTION 1 btint4cmp(int4, int4) , FUNCTION 2\n    btint4sortsupport(internal) ; CREATE OPERATOR CLASS int2_ops\n    DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS --\n    standard int2 comparisons OPERATOR 1 &lt; , OPERATOR 2 &lt;= ,\n    OPERATOR 3 = , OPERATOR 4 &gt;= , OPERATOR 5 &gt; , FUNCTION 1\n    btint2cmp(int2, int2) , FUNCTION 2 btint2sortsupport(internal)\n    ; ALTER OPERATOR FAMILY integer_ops USING btree ADD --\n    cross-type comparisons int8 vs int2 OPERATOR 1 &lt; (int8,\n    int2) , OPERATOR 2 &lt;= (int8, int2) , OPERATOR 3 = (int8,\n    int2) , OPERATOR 4 &gt;= (int8, int2) , OPERATOR 5 &gt; (int8,\n    int2) , FUNCTION 1 btint82cmp(int8, int2) , -- cross-type\n    comparisons int8 vs int4 OPERATOR 1 &lt; (int8, int4) ,\n    OPERATOR 2 &lt;= (int8, int4) , OPERATOR 3 = (int8, int4) ,\n    OPERATOR 4 &gt;= (int8, int4) , OPERATOR 5 &gt; (int8, int4) ,\n    FUNCTION 1 btint84cmp(int8, int4) , -- cross-type comparisons\n    int4 vs int2 OPERATOR 1 &lt; (int4, int2) , OPERATOR 2 &lt;=\n    (int4, int2) , OPERATOR 3 = (int4, int2) , OPERATOR 4 &gt;=\n    (int4, int2) , OPERATOR 5 &gt; (int4, int2) , FUNCTION 1\n    btint42cmp(int4, int2) , -- cross-type comparisons int4 vs int8\n    OPERATOR 1 &lt; (int4, int8) , OPERATOR 2 &lt;= (int4, int8) ,\n    OPERATOR 3 = (int4, int8) , OPERATOR 4 &gt;= (int4, int8) ,\n    OPERATOR 5 &gt; (int4, int8) , FUNCTION 1 btint48cmp(int4,\n    int8) , -- cross-type comparisons int2 vs int8 OPERATOR 1 &lt;\n    (int2, int8) , OPERATOR 2 &lt;= (int2, int8) , OPERATOR 3 =\n    (int2, int8) , OPERATOR 4 &gt;= (int2, int8) , OPERATOR 5 &gt;\n    (int2, int8) , FUNCTION 1 btint28cmp(int2, int8) , --\n    cross-type comparisons int2 vs int4 OPERATOR 1 &lt; (int2,\n    int4) , OPERATOR 2 &lt;= (int2, int4) , OPERATOR 3 = (int2,\n    int4) , OPERATOR 4 &gt;= (int2, int4) , OPERATOR 5 &gt; (int2,\n    int4) , FUNCTION 1 btint24cmp(int2, int4)\n    ;"
msgstr ""

#: xml/xindex.xml:793(para)
msgid "As an example, <productname>PostgreSQL</productname>has a built-in B-tree operator family <literal>integer_ops</literal>, which includes operator classes <literal>int8_ops</literal>, <literal>int4_ops</literal>, and <literal>int2_ops</literal>for indexes on <type>bigint</type>( <type>int8</type>), <type>integer</type>( <type>int4</type>), and <type>smallint</type>( <type>int2</type>) columns respectively. The family also contains cross-data-type comparison operators allowing any two of these types to be compared, so that an index on one of these types can be searched using a comparison value of another type. The family could be duplicated by these definitions: <placeholder-1/>Notice that this definition <quote>overloads</quote>the operator strategy and support function numbers: each number occurs multiple times within the family. This is allowed so long as each instance of a particular number has distinct input data types. The instances that have both input types equal to an operator class's input type are the primary operators and support functions for that operator class, and in most cases should be declared as part of the operator class rather than as loose members of the family."
msgstr ""

#: xml/xindex.xml:860(para)
msgid "In a B-tree operator family, all the operators in the family must sort compatibly, meaning that the transitive laws hold across all the data types supported by the family: <quote>if A = B and B = C, then A = C</quote>, and <quote>if A B and B C, then A C</quote>. Moreover, implicit or binary coercion casts between types represented in the operator family must not change the associated sort ordering. For each operator in the family there must be a support function having the same two input data types as the operator. It is recommended that a family be complete, i.e., for each combination of data types, all operators are included. Each operator class should include just the non-cross-type operators and support function for its data type."
msgstr ""

#: xml/xindex.xml:873(para)
msgid "To build a multiple-data-type hash operator family, compatible hash support functions must be created for each data type supported by the family. Here compatibility means that the functions are guaranteed to return the same hash code for any two values that are considered equal by the family's equality operators, even when the values are of different types. This is usually difficult to accomplish when the types have different physical representations, but it can be done in some cases. Furthermore, casting a value from one data type represented in the operator family to another data type also represented in the operator family via an implicit or binary coercion cast must not change the computed hash value. Notice that there is only one support function per data type, not one per equality operator. It is recommended that a family be complete, i.e., provide an equality operator for each combination of data types. Each operator class should include just the non-cross-type equality operator and the support function for its data type."
msgstr ""

#: xml/xindex.xml:891(para)
msgid "GiST, SP-GiST, and GIN indexes do not have any explicit notion of cross-data-type operations. The set of operators supported is just whatever the primary support functions for a given operator class can handle."
msgstr ""

#: xml/xindex.xml:896(para)
msgid "Prior to <productname>PostgreSQL</productname>8.3, there was no concept of operator families, and so any cross-data-type operators intended to be used with an index had to be bound directly into the index's operator class. While this approach still works, it is deprecated because it makes an index's dependencies too broad, and because the planner can handle cross-data-type comparisons more effectively when both data types have operators in the same operator family."
msgstr ""

#: xml/xindex.xml:908(title)
msgid "System Dependencies on Operator Classes"
msgstr ""

#: xml/xindex.xml:910(primary)
msgid "ordering operator"
msgstr ""

#: xml/xindex.xml:912(para)
msgid "<productname>PostgreSQL</productname>uses operator classes to infer the properties of operators in more ways than just whether they can be used with indexes. Therefore, you might want to create operator classes even if you have no intention of indexing any columns of your data type."
msgstr ""

#: xml/xindex.xml:918(para)
msgid "In particular, there are SQL features such as <literal>ORDER BY</literal>and <literal>DISTINCT</literal>that require comparison and sorting of values. To implement these features on a user-defined data type, <productname>PostgreSQL</productname>looks for the default B-tree operator class for the data type. The <quote>equals</quote>member of this operator class defines the system's notion of equality of values for <literal>GROUP BY</literal>and <literal>DISTINCT</literal>, and the sort ordering imposed by the operator class defines the default <literal>ORDER BY</literal>ordering."
msgstr ""

#: xml/xindex.xml:931(para)
msgid "Comparison of arrays of user-defined types also relies on the semantics defined by the default B-tree operator class."
msgstr ""

#: xml/xindex.xml:934(para)
msgid "If there is no default B-tree operator class for a data type, the system will look for a default hash operator class. But since that kind of operator class only provides equality, in practice it is only enough to support array equality."
msgstr ""

#: xml/xindex.xml:938(para)
msgid "When there is no default operator class for a data type, you will get errors like <quote>could not identify an ordering operator</quote>if you try to use these SQL features with the data type."
msgstr ""

#: xml/xindex.xml:943(para)
msgid "In <productname>PostgreSQL</productname>versions before 7.4, sorting and grouping operations would implicitly use operators named <literal>=</literal>, <literal/>, and <literal/>. The new behavior of relying on default operator classes avoids having to make any assumption about the behavior of operators with particular names."
msgstr ""

#: xml/xindex.xml:953(para)
msgid "Another important point is that an operator that appears in a hash operator family is a candidate for hash joins, hash aggregation, and related optimizations. The hash operator family is essential here since it identifies the hash function(s) to use."
msgstr ""

#: xml/xindex.xml:960(title)
msgid "Ordering Operators"
msgstr ""

#: xml/xindex.xml:984(programlisting)
#, no-wrap
msgid "SELECT * FROM places ORDER BY location\n    &lt;-&gt; point '(101,456)' LIMIT 10;"
msgstr ""

#: xml/xindex.xml:961(para)
msgid "Some index access methods (currently, only GiST) support the concept of <firstterm>ordering operators</firstterm>. What we have been discussing so far are <firstterm>search operators</firstterm>. A search operator is one for which the index can be searched to find all rows satisfying <literal>WHERE</literal><replaceable>indexed_column</replaceable><replaceable>operator</replaceable><replaceable>constant</replaceable>. Note that nothing is promised about the order in which the matching rows will be returned. In contrast, an ordering operator does not restrict the set of rows that can be returned, but instead determines their order. An ordering operator is one for which the index can be scanned to return rows in the order represented by <literal>ORDER BY</literal><replaceable>indexed_column</replaceable><replaceable>operator</replaceable><replaceable>constant</replaceable>. The reason for defining ordering operators that way is that it supports nearest-neighbor searches, if the operator is one that measures distance. For example, a query like <placeholder-1/>finds the ten places closest to a given target point. A GiST index on the location column can do this efficiently because <literal>-</literal>is an ordering operator."
msgstr ""

#: xml/xindex.xml:1003(programlisting)
#, no-wrap
msgid "OPERATOR 15 &lt;-&gt; (point, point) FOR ORDER\n    BY float_ops"
msgstr ""

#: xml/xindex.xml:989(para)
msgid "While search operators have to return Boolean results, ordering operators usually return some other type, such as float or numeric for distances. This type is normally not the same as the data type being indexed. To avoid hard-wiring assumptions about the behavior of different data types, the definition of an ordering operator is required to name a B-tree operator family that specifies the sort ordering of the result data type. As was stated in the previous section, B-tree operator families define <productname>PostgreSQL</productname>'s notion of ordering, so this is a natural representation. Since the point <literal>-</literal>operator returns <type>float8</type>, it could be specified in an operator class creation command like this: <placeholder-1/>where <literal>float_ops</literal>is the built-in operator family that includes operations on <type>float8</type>. This declaration states that the index is able to return rows in order of increasing values of the <literal>-</literal>operator."
msgstr ""

#: xml/xindex.xml:1012(title)
msgid "Special Features of Operator Classes"
msgstr ""

#: xml/xindex.xml:1013(para)
msgid "There are two special features of operator classes that we have not discussed yet, mainly because they are not useful with the most commonly used index methods."
msgstr ""

#: xml/xindex.xml:1021(programlisting)
#, no-wrap
msgid "SELECT * FROM table WHERE integer_column\n    4;"
msgstr ""

#: xml/xindex.xml:1016(para)
msgid "Normally, declaring an operator as a member of an operator class (or family) means that the index method can retrieve exactly the set of rows that satisfy a <literal>WHERE</literal>condition using the operator. For example: <placeholder-1/>can be satisfied exactly by a B-tree index on the integer column. But there are cases where an index is useful as an inexact guide to the matching rows. For example, if a GiST index stores only bounding boxes for geometric objects, then it cannot exactly satisfy a <literal>WHERE</literal>condition that tests overlap between nonrectangular objects such as polygons. Yet we could use the index to find objects whose bounding box overlaps the bounding box of the target object, and then do the exact overlap test only on the objects found by the index. If this scenario applies, the index is said to be <quote>lossy</quote>for the operator. Lossy index searches are implemented by having the index method return a <firstterm>recheck</firstterm>flag when a row might or might not really satisfy the query condition. The core system will then test the original query condition on the retrieved row to see whether it should be returned as a valid match. This approach works if the index is guaranteed to return all the required rows, plus perhaps some additional rows, which can be eliminated by performing the original operator invocation. The index methods that support lossy searches (currently, GiST, SP-GiST and GIN) allow the support functions of individual operator classes to set the recheck flag, and so this is essentially an operator-class feature."
msgstr ""

#: xml/xindex.xml:1055(programlisting)
#, no-wrap
msgid "CREATE OPERATOR CLASS polygon_ops DEFAULT FOR\n    TYPE polygon USING gist AS ... STORAGE box;"
msgstr ""

#: xml/xindex.xml:1046(para)
msgid "Consider again the situation where we are storing in the index only the bounding box of a complex object such as a polygon. In this case there's not much value in storing the whole polygon in the index entry we might as well store just a simpler object of type <type>box</type>. This situation is expressed by the <literal>STORAGE</literal>option in <command>CREATE OPERATOR CLASS</command>: we'd write something like: <placeholder-1/>At present, only the GiST and GIN index methods support a <literal>STORAGE</literal>type that's different from the column data type. The GiST <function>compress</function>and <function>decompress</function>support routines must deal with data-type conversion when <literal>STORAGE</literal>is used. In GIN, the <literal>STORAGE</literal>type identifies the type of the <quote>key</quote>values, which normally is different from the type of the indexed column for example, an operator class for integer-array columns might have keys that are just integers. The GIN <function>extractValue</function>and <function>extractQuery</function>support routines are responsible for extracting keys from indexed values."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/xindex.xml:0(None)
msgid "translator-credits"
msgstr ""

