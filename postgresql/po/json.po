msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/json.xml:3(title)
msgid "<acronym>JSON</acronym>Types"
msgstr ""

#: xml/json.xml:6(primary)
msgid "JSON"
msgstr ""

#: xml/json.xml:9(primary)
msgid "JSONB"
msgstr ""

#: xml/json.xml:11(para)
msgid "JSON data types are for storing JSON (JavaScript Object Notation) data, as specified in <ulink url=\"http://rfc7159.net/rfc7159\">RFC 7159</ulink>. Such data can also be stored as <type>text</type>, but the JSON data types have the advantage of enforcing that each stored value is valid according to the JSON rules. There are also assorted JSON-specific functions and operators available for data stored in these data types; see <xref linkend=\"functions-json\">.</xref>"
msgstr ""

#: xml/json.xml:20(para)
msgid "There are two JSON data types: <type>json</type>and <type>jsonb</type>. They accept <emphasis>almost</emphasis>identical sets of values as input. The major practical difference is one of efficiency. The <type>json</type>data type stores an exact copy of the input text, which processing functions must reparse on each execution; while <type>jsonb</type>data is stored in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. <type>jsonb</type>also supports indexing, which can be a significant advantage."
msgstr ""

#: xml/json.xml:34(para)
msgid "Because the <type>json</type>type stores an exact copy of the input text, it will preserve semantically-insignificant white space between tokens, as well as the order of keys within JSON objects. Also, if a JSON object within the value contains the same key more than once, all the key/value pairs are kept. (The processing functions consider the last value as the operative one.) By contrast, <type>jsonb</type>does not preserve white space, does not preserve the order of object keys, and does not keep duplicate object keys. If duplicate keys are specified in the input, only the last value is kept."
msgstr ""

#: xml/json.xml:45(para)
msgid "In general, most applications should prefer to store JSON data as <type>jsonb</type>, unless there are quite specialized needs, such as legacy assumptions about ordering of object keys."
msgstr ""

#: xml/json.xml:49(para)
msgid "<productname>PostgreSQL</productname>allows only one character set encoding per database. It is therefore not possible for the JSON types to conform rigidly to the JSON specification unless the database encoding is UTF8. Attempts to directly include characters that cannot be represented in the database encoding will fail; conversely, characters that can be represented in the database encoding but not in UTF8 will be allowed."
msgstr ""

#: xml/json.xml:57(para)
msgid "RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by <literal>\\u <replaceable>XXXX</replaceable></literal>. In the input function for the <type>json</type>type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness (that is, that four hex digits follow <literal>\\u</literal>). However, the input function for <type>jsonb</type>is stricter: it disallows Unicode escapes for non-ASCII characters (those above <literal>U+007F</literal>) unless the database encoding is UTF8. The <type>jsonb</type>type also rejects <literal>\\u0000</literal>(because that cannot be represented in <productname>PostgreSQL</productname>'s <type>text</type>type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct. Valid Unicode escapes are converted to the equivalent ASCII or UTF8 character for storage; this includes folding surrogate pairs into a single character."
msgstr ""

#: xml/json.xml:80(para)
msgid "Many of the JSON processing functions described in <xref linkend=\"functions-json\">will convert Unicode escapes to regular characters, and will therefore throw the same types of errors just described even if their input is of type <type>json</type>not <type>jsonb</type>. The fact that the <type>json</type>input function does not make these checks may be considered a historical artifact, although it does allow for simple storage (without processing) of JSON Unicode escapes in a non-UTF8 database encoding. In general, it is best to avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding, if possible.</xref>"
msgstr ""

#: xml/json.xml:93(para)
msgid "When converting textual JSON input into <type>jsonb</type>, the primitive types described by <acronym>RFC</acronym>7159 are effectively mapped onto native <productname>PostgreSQL</productname>types, as shown in <xref linkend=\"json-type-mapping-table\">. Therefore, there are some minor additional constraints on what constitutes valid <type>jsonb</type>data that do not apply to the <type>json</type>type, nor to JSON in the abstract, corresponding to limits on what can be represented by the underlying data type. Notably, <type>jsonb</type>will reject numbers that are outside the range of the <productname>PostgreSQL</productname><type>numeric</type>data type, while <type>json</type>will not. Such implementation-defined restrictions are permitted by <acronym>RFC</acronym>7159. However, in practice such problems are far more likely to occur in other implementations, as it is common to represent JSON's <type>number</type>primitive type as IEEE 754 double precision floating point (which <acronym>RFC</acronym>7159 explicitly anticipates and allows for). When using JSON as an interchange format with such systems, the danger of losing numeric precision compared to data originally stored by <productname>PostgreSQL</productname>should be considered.</xref>"
msgstr ""

#: xml/json.xml:120(para)
msgid "Conversely, as noted in the table there are some minor restrictions on the input format of JSON primitive types that do not apply to the corresponding <productname>PostgreSQL</productname>types."
msgstr ""

#: xml/json.xml:125(title)
msgid "JSON primitive types and corresponding <productname>PostgreSQL</productname>types"
msgstr ""

#: xml/json.xml:130(entry)
msgid "JSON primitive type"
msgstr ""

#: xml/json.xml:132(productname)
msgid "PostgreSQL"
msgstr ""

#: xml/json.xml:131(entry)
msgid "<placeholder-1/>type"
msgstr ""

#: xml/json.xml:133(entry)
msgid "Notes"
msgstr ""

#: xml/json.xml:139(type)
msgid "string"
msgstr ""

#: xml/json.xml:142(type)
msgid "text"
msgstr ""

#: xml/json.xml:145(literal)
msgid "\\u0000"
msgstr ""

#: xml/json.xml:144(entry)
msgid "<placeholder-1/>is disallowed, as are non-ASCII Unicode escapes if database encoding is not UTF8"
msgstr ""

#: xml/json.xml:150(type)
msgid "number"
msgstr ""

#: xml/json.xml:153(type)
msgid "numeric"
msgstr ""

#: xml/json.xml:156(literal)
msgid "NaN"
msgstr ""

#: xml/json.xml:157(literal)
msgid "infinity"
msgstr ""

#: xml/json.xml:155(entry)
msgid "<placeholder-1/>and <placeholder-2/>values are disallowed"
msgstr ""

#: xml/json.xml:161(type) xml/json.xml:164(type)
msgid "boolean"
msgstr ""

#: xml/json.xml:167(literal)
msgid "true"
msgstr ""

#: xml/json.xml:168(literal)
msgid "false"
msgstr ""

#: xml/json.xml:166(entry)
msgid "Only lowercase <placeholder-1/>and <placeholder-2/>spellings are accepted"
msgstr ""

#: xml/json.xml:172(type)
msgid "null"
msgstr ""

#: xml/json.xml:174(entry)
msgid "(none)"
msgstr ""

#: xml/json.xml:176(literal)
msgid "NULL"
msgstr ""

#: xml/json.xml:175(entry)
msgid "SQL <placeholder-1/>is a different concept"
msgstr ""

#: xml/json.xml:182(title)
msgid "JSON Input and Output Syntax"
msgstr ""

#: xml/json.xml:183(para)
msgid "The input/output syntax for the JSON data types is as specified in <acronym>RFC</acronym>7159."
msgstr ""

#: xml/json.xml:189(programlisting)
#, no-wrap
msgid "-- Simple scalar/primitive value -- Primitive\n    values can be numbers, quoted strings, true, false, or null\n    SELECT '5'::json; -- Array of zero or more elements (elements\n    need not be of same type) SELECT '[1, 2, \"foo\", null]'::json;\n    -- Object containing pairs of keys and values -- Note that\n    object keys must always be quoted strings SELECT '{\"bar\":\n    \"baz\", \"balance\": 7.77, \"active\": false}'::json; -- Arrays and\n    objects can be nested arbitrarily SELECT '{\"foo\": [true,\n    \"bar\"], \"tags\": {\"a\": 1, \"b\":\n    null}}'::json;"
msgstr ""

#: xml/json.xml:186(para)
msgid "The following are all valid <type>json</type>(or <type>jsonb</type>) expressions: <placeholder-1/>"
msgstr ""

#: xml/json.xml:205(programlisting)
#, no-wrap
msgid "SELECT '{\"bar\": \"baz\", \"balance\": 7.77,\n    \"active\":false}'::json; json\n    ------------------------------------------------- {\"bar\":\n    \"baz\", \"balance\": 7.77, \"active\":false} (1 row) SELECT '{\"bar\":\n    \"baz\", \"balance\": 7.77, \"active\":false}'::jsonb; jsonb\n    -------------------------------------------------- {\"bar\":\n    \"baz\", \"active\": false, \"balance\": 7.77} (1\n    row)"
msgstr ""

#: xml/json.xml:220(programlisting)
#, no-wrap
msgid "SELECT '{\"reading\": 1.230e-5}'::json,\n    '{\"reading\": 1.230e-5}'::jsonb; json | jsonb\n    -----------------------+------------------------- {\"reading\":\n    1.230e-5} | {\"reading\": 0.00001230} (1\n    row)"
msgstr ""

#: xml/json.xml:199(para)
msgid "As previously stated, when a JSON value is input and then printed without any additional processing, <type>json</type>outputs the same text that was input, while <type>jsonb</type>does not preserve semantically-insignificant details such as whitespace. For example, note the differences here: <placeholder-1/>One semantically-insignificant detail worth noting is that in <type>jsonb</type>, numbers will be printed according to the behavior of the underlying <type>numeric</type>type. In practice this means that numbers entered with <literal>E</literal>notation will be printed without it, for example: <placeholder-2/>However, <type>jsonb</type>will preserve trailing fractional zeroes, as seen in this example, even though those are semantically insignificant for purposes such as equality checks."
msgstr ""

#: xml/json.xml:230(title)
msgid "Designing JSON documents effectively"
msgstr ""

#: xml/json.xml:231(para)
msgid "Representing data as JSON can be considerably more flexible than the traditional relational data model, which is compelling in environments where requirements are fluid. It is quite possible for both approaches to co-exist and complement each other within the same application. However, even for applications where maximal flexibility is desired, it is still recommended that JSON documents have a somewhat fixed structure. The structure is typically unenforced (though enforcing some business rules declaratively is possible), but having a predictable structure makes it easier to write queries that usefully summarize a set of <quote>documents</quote>(datums) in a table."
msgstr ""

#: xml/json.xml:243(para)
msgid "JSON data is subject to the same concurrency-control considerations as any other data type when stored in a table. Although storing large documents is practicable, keep in mind that any update acquires a row-level lock on the whole row. Consider limiting JSON documents to a manageable size in order to decrease lock contention among updating transactions. Ideally, JSON documents should each represent an atomic datum that business rules dictate cannot reasonably be further subdivided into smaller datums that could be modified independently."
msgstr ""

#: xml/json.xml:255(title)
msgid "<type>jsonb</type>Containment and Existence"
msgstr ""

#: xml/json.xml:258(primary) xml/json.xml:262(primary) xml/json.xml:365(primary)
msgid "jsonb"
msgstr ""

#: xml/json.xml:259(secondary)
msgid "containment"
msgstr ""

#: xml/json.xml:263(secondary)
msgid "existence"
msgstr ""

#: xml/json.xml:265(para)
msgid "Testing <firstterm>containment</firstterm>is an important capability of <type>jsonb</type>. There is no parallel set of facilities for the <type>json</type>type. Containment tests whether one <type>jsonb</type>document has contained within it another one. These examples return true except as noted:"
msgstr ""

#: xml/json.xml:273(programlisting)
#, no-wrap
msgid "-- Simple scalar/primitive values contain only\n    the identical value: SELECT '\"foo\"'::jsonb @ '\"foo\"'::jsonb; --\n    The array on the right side is contained within the one on the\n    left: SELECT '[1, 2, 3]'::jsonb @ '[1, 3]'::jsonb; -- Order of\n    array elements is not significant, so this is also true: SELECT\n    '[1, 2, 3]'::jsonb @ '[3, 1]'::jsonb; -- Duplicate array\n    elements don't matter either: SELECT '[1, 2, 3]'::jsonb @ '[1,\n    2, 2]'::jsonb; -- The object with a single pair on the right\n    side is contained -- within the object on the left side: SELECT\n    '{\"product\": \"PostgreSQL\", \"version\": 9.4, \"jsonb\":\n    true}'::jsonb @ '{\"version\": 9.4}'::jsonb; -- The array on the\n    right side is \n    <emphasis>not</emphasis>considered contained within the --\n    array on the left, even though a similar array is nested within\n    it: SELECT '[1, 2, [1, 3]]'::jsonb @ '[1, 3]'::jsonb; -- yields\n    false -- But with a layer of nesting, it is contained: SELECT\n    '[1, 2, [1, 3]]'::jsonb @ '[[1, 3]]'::jsonb; -- Similarly,\n    containment is not reported here: SELECT '{\"foo\": {\"bar\":\n    \"baz\"}}'::jsonb @ '{\"bar\": \"baz\"}'::jsonb; -- yields false -- A\n    top-level key and an empty object is contained: SELECT '{\"foo\":\n    {\"bar\": \"baz\"}}'::jsonb @ '{\"foo\":\n    {}}'::jsonb;"
msgstr ""

#: xml/json.xml:295(para)
msgid "The general principle is that the contained object must match the containing object as to structure and data contents, possibly after discarding some non-matching array elements or object key/value pairs from the containing object. But remember that the order of array elements is not significant when doing a containment match, and duplicate array elements are effectively considered only once."
msgstr ""

#: xml/json.xml:302(para)
msgid "As a special exception to the general principle that the structures must match, an array may contain a primitive value:"
msgstr ""

#: xml/json.xml:305(programlisting)
#, no-wrap
msgid "-- This array contains the primitive string\n    value: SELECT '[\"foo\", \"bar\"]'::jsonb @ '\"bar\"'::jsonb; -- This\n    exception is not reciprocal -- non-containment is reported\n    here: SELECT '\"bar\"'::jsonb @ '[\"bar\"]'::jsonb; -- yields\n    false"
msgstr ""

#: xml/json.xml:310(para)
msgid "<type>jsonb</type>also has an <firstterm>existence</firstterm>operator, which is a variation on the theme of containment: it tests whether a string (given as a <type>text</type>value) appears as an object key or array element at the top level of the <type>jsonb</type>value. These examples return true except as noted:"
msgstr ""

#: xml/json.xml:319(programlisting)
#, no-wrap
msgid "-- String exists as array element: SELECT\n    '[\"foo\", \"bar\", \"baz\"]'::jsonb ? 'bar'; -- String exists as\n    object key: SELECT '{\"foo\": \"bar\"}'::jsonb ? 'foo'; -- Object\n    values are not considered: SELECT '{\"foo\": \"bar\"}'::jsonb ?\n    'bar'; -- yields false -- As with containment, existence must\n    match at the top level: SELECT '{\"foo\": {\"bar\": \"baz\"}}'::jsonb\n    ? 'bar'; -- yields false -- A string is considered to exist if\n    it matches a primitive JSON string: SELECT '\"foo\"'::jsonb ?\n    'foo';"
msgstr ""

#: xml/json.xml:328(para)
msgid "JSON objects are better suited than arrays for testing containment or existence when there are many keys or elements involved, because unlike arrays they are internally optimized for searching, and do not need to be searched linearly."
msgstr ""

#: xml/json.xml:345(programlisting)
#, no-wrap
msgid "SELECT doc-'site_name' FROM websites WHERE\n      doc @ '{\"tags\":[{\"term\":\"paris\"},\n      {\"term\":\"food\"}]}';"
msgstr ""

#: xml/json.xml:349(programlisting)
#, no-wrap
msgid "SELECT doc-'site_name' FROM websites WHERE\n      doc-'tags' @ '[{\"term\":\"paris\"},\n      {\"term\":\"food\"}]';"
msgstr ""

#: xml/json.xml:333(para)
msgid "Because JSON containment is nested, an appropriate query can skip explicit selection of sub-objects. As an example, suppose that we have a <structfield>doc</structfield>column containing objects at the top level, with most objects containing <literal>tags</literal>fields that contain arrays of sub-objects. This query finds entries in which sub-objects containing both <literal>\"term\":\"paris\"</literal>and <literal>\"term\":\"food\"</literal>appear, while ignoring any such keys outside the <literal>tags</literal>array: <placeholder-1/>One could accomplish the same thing with, say, <placeholder-2/>but that approach is less flexible, and often less efficient as well."
msgstr ""

#: xml/json.xml:353(para)
msgid "On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value."
msgstr ""

#: xml/json.xml:357(para)
msgid "The various containment and existence operators, along with all other JSON operators and functions are documented in <xref linkend=\"functions-json\">.</xref>"
msgstr ""

#: xml/json.xml:362(title)
msgid "<type>jsonb</type>Indexing"
msgstr ""

#: xml/json.xml:366(secondary)
msgid "indexes on"
msgstr ""

#: xml/json.xml:368(para)
msgid "GIN indexes can be used to efficiently search for keys or key/value pairs occurring within a large number of <type>jsonb</type>documents (datums). Two GIN <quote>operator classes</quote>are provided, offering different performance and flexibility trade-offs."
msgstr ""

#: xml/json.xml:383(programlisting)
#, no-wrap
msgid "CREATE INDEX idxgin ON api USING GIN\n    (jdoc);"
msgstr ""

#: xml/json.xml:388(programlisting)
#, no-wrap
msgid "CREATE INDEX idxginp ON api USING GIN (jdoc\n    jsonb_path_ops);"
msgstr ""

#: xml/json.xml:373(para)
msgid "The default GIN operator class for <type>jsonb</type>supports queries with top-level key-exists operators <literal>?</literal>, <literal>?</literal>and <literal>?|</literal>operators and path/value-exists operator <literal>@</literal>. (For details of the semantics that these operators implement, see <xref linkend=\"functions-jsonb-op-table\">.) An example of creating an index with this operator class is: <placeholder-1/>The non-default GIN operator class <literal>jsonb_path_ops</literal>supports indexing the <literal>@</literal>operator only. An example of creating an index with this operator class is: <placeholder-2/></xref>"
msgstr ""

#: xml/json.xml:393(programlisting)
#, no-wrap
msgid "{ \"guid\":\n    \"9c36adc1-7fb5-4d5b-83b4-90356a46061a\", \"name\": \"Angela\n    Barton\", \"is_active\": true, \"company\": \"Magnafone\", \"address\":\n    \"178 Howard Place, Gulf, Washington, 702\", \"registered\":\n    \"2009-11-07T08:53:22 +08:00\", \"latitude\": 19.793713,\n    \"longitude\": 86.513373, \"tags\": [ \"enim\", \"aliquip\", \"qui\" ]\n    }"
msgstr ""

#: xml/json.xml:405(programlisting)
#, no-wrap
msgid "-- Find documents in which the key \"company\"\n    has value \"Magnafone\" SELECT jdoc-'guid', jdoc-'name' FROM api\n    WHERE jdoc @ '{\"company\":\n    \"Magnafone\"}';"
msgstr ""

#: xml/json.xml:414(programlisting)
#, no-wrap
msgid "-- Find documents in which the key \"tags\"\n    contains key or array element \"qui\" SELECT jdoc-'guid',\n    jdoc-'name' FROM api WHERE jdoc - 'tags' ?\n    'qui';"
msgstr ""

#: xml/json.xml:422(programlisting)
#, no-wrap
msgid "CREATE INDEX idxgintags ON api USING GIN ((jdoc\n    - 'tags'));"
msgstr ""

#: xml/json.xml:390(para)
msgid "Consider the example of a table that stores JSON documents retrieved from a third-party web service, with a documented schema definition. A typical document is: <placeholder-1/>We store these documents in a table named <structname>api</structname>, in a <type>jsonb</type>column named <structfield>jdoc</structfield>. If a GIN index is created on this column, queries like the following can make use of the index: <placeholder-2/>However, the index could not be used for queries like the following, because though the operator <literal>?</literal>is indexable, it is not applied directly to the indexed column <structfield>jdoc</structfield>: <placeholder-3/>Still, with appropriate use of expression indexes, the above query can use an index. If querying for particular items within the <literal>\"tags\"</literal>key is common, defining an index like this may be worthwhile: <placeholder-4/>Now, the <literal>WHERE</literal>clause <literal>jdoc - 'tags' ? 'qui'</literal>will be recognized as an application of the indexable operator <literal>?</literal>to the indexed expression <literal>jdoc - 'tags'</literal>. (More information on expression indexes can be found in <xref linkend=\"indexes-expressional\">.)</xref>"
msgstr ""

#: xml/json.xml:433(programlisting)
#, no-wrap
msgid "-- Find documents in which the key \"tags\"\n    contains array element \"qui\" SELECT jdoc-'guid', jdoc-'name'\n    FROM api WHERE jdoc @ '{\"tags\": [\"qui\"]}';"
msgstr ""

#: xml/json.xml:431(para)
msgid "Another approach to querying is to exploit containment, for example: <placeholder-1/>A simple GIN index on the <structfield>jdoc</structfield>column can support this query. But note that such an index will store copies of every key and value in the <structfield>jdoc</structfield>column, whereas the expression index of the previous example stores only data found under the <literal>tags</literal>key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index."
msgstr ""

#: xml/json.xml:446(para)
msgid "Although the <literal>jsonb_path_ops</literal>operator class supports only queries with the <literal>@</literal>operator, it has notable performance advantages over the default operator class <literal>jsonb_ops</literal>. A <literal>jsonb_path_ops</literal>index is usually much smaller than a <literal>jsonb_ops</literal>index over the same data, and the specificity of searches is better, particularly when queries contain keys that appear frequently in the data. Therefore search operations typically perform better than with the default operator class."
msgstr ""

#: xml/json.xml:466(para)
msgid "For this purpose, the term <quote>value</quote>includes array elements, though JSON terminology sometimes considers array elements distinct from values within objects."
msgstr ""

#: xml/json.xml:459(para)
msgid "The technical difference between a <literal>jsonb_ops</literal>and a <literal>jsonb_path_ops</literal>GIN index is that the former creates independent index items for each key and value in the data, while the latter creates index items only for each value in the data. <placeholder-1/>Basically, each <literal>jsonb_path_ops</literal>index item is a hash of the value and the key(s) leading to it; for example to index <literal>{\"foo\": {\"bar\": \"baz\"}}</literal>, a single index item would be created incorporating all three of <literal>foo</literal>, <literal>bar</literal>, and <literal>baz</literal>into the hash value. Thus a containment query looking for this structure would result in an extremely specific index search; but there is no way at all to find out whether <literal>foo</literal>appears as a key. On the other hand, a <literal>jsonb_ops</literal>index would create three index items representing <literal>foo</literal>, <literal>bar</literal>, and <literal>baz</literal>separately; then to do the containment query, it would look for rows containing all three of these items. While GIN indexes can perform such an AND search fairly efficiently, it will still be less specific and slower than the equivalent <literal>jsonb_path_ops</literal>search, especially if there are a very large number of rows containing any single one of the three index items."
msgstr ""

#: xml/json.xml:494(para)
msgid "A disadvantage of the <literal>jsonb_path_ops</literal>approach is that it produces no index entries for JSON structures not containing any values, such as <literal>{\"a\": {}}</literal>. If a search for documents containing such a structure is requested, it will require a full-index scan, which is quite slow. <literal>jsonb_path_ops</literal>is therefore ill-suited for applications that often perform such searches."
msgstr ""

#: xml/json.xml:532(programlisting)
#, no-wrap
msgid "{ \"aa\": 1, \"c\": 1} &gt; {\"b\": 1, \"d\":\n    1}"
msgstr ""

#: xml/json.xml:503(para)
msgid "<type>jsonb</type>also supports <literal>btree</literal>and <literal>hash</literal>indexes. These are usually useful only if it's important to check equality of complete JSON documents. The <literal>btree</literal>ordering for <type>jsonb</type>datums is seldom of great interest, but for completeness it is: <synopsis>\n    <replaceable>Object</replaceable>&gt; \n    <replaceable>Array</replaceable>&gt; \n    <replaceable>Boolean</replaceable>&gt; \n    <replaceable>Number</replaceable>&gt; \n    <replaceable>String</replaceable>&gt; \n    <replaceable>Null</replaceable>\n    <replaceable>Object with n pairs</replaceable>&gt; \n    <replaceable>object with n - 1 pairs</replaceable>\n    <replaceable>Array with n elements</replaceable>&gt; \n    <replaceable>array with n - 1\n    elements</replaceable></synopsis>Objects with equal numbers of pairs are compared in the order: <synopsis>\n    <replaceable>key-1</replaceable>, \n    <replaceable>value-1</replaceable>, \n    <replaceable>key-2</replaceable>...</synopsis>Note that object keys are compared in their storage order; in particular, since shorter keys are stored before longer keys, this can lead to results that might be unintuitive, such as: <placeholder-1/>Similarly, arrays with equal numbers of elements are compared in the order: <synopsis>\n    <replaceable>element-1</replaceable>, \n    <replaceable>element-2</replaceable>...</synopsis>Primitive JSON values are compared using the same comparison rules as for the underlying <productname>PostgreSQL</productname>data type. Strings are compared using the default database collation."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/json.xml:0(None)
msgid "translator-credits"
msgstr ""

