msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/gist.xml:3(title)
msgid "GiST Indexes"
msgstr ""

#: xml/gist.xml:5(primary)
msgid "index"
msgstr ""

#: xml/gist.xml:6(secondary)
msgid "GiST"
msgstr ""

#: xml/gist.xml:9(title)
msgid "Introduction"
msgstr ""

#: xml/gist.xml:10(para)
msgid "<acronym>GiST</acronym>stands for Generalized Search Tree. It is a balanced, tree-structured access method, that acts as a base template in which to implement arbitrary indexing schemes. B-trees, R-trees and many other indexing schemes can be implemented in <acronym>GiST</acronym>."
msgstr ""

#: xml/gist.xml:17(para)
msgid "One advantage of <acronym>GiST</acronym>is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert."
msgstr ""

#: xml/gist.xml:22(para)
msgid "Some of the information here is derived from the University of California at Berkeley's GiST Indexing Project <ulink url=\"http://gist.cs.berkeley.edu/\">web site</ulink>and Marcel Kornacker's thesis, <ulink url=\"http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz\"> Access Methods for Next-Generation Database Systems</ulink>. The <acronym>GiST</acronym>implementation in <productname>PostgreSQL</productname>is primarily maintained by Teodor Sigaev and Oleg Bartunov, and there is more information on their <ulink url=\"http://www.sai.msu.su/~megera/postgres/gist/\">web site</ulink>."
msgstr ""

#: xml/gist.xml:37(title)
msgid "Built-in Operator Classes"
msgstr ""

#: xml/gist.xml:38(para)
msgid "The core <productname>PostgreSQL</productname>distribution includes the <acronym>GiST</acronym>operator classes shown in <xref linkend=\"gist-builtin-opclasses-table\">. (Some of the optional modules described in <xref linkend=\"contrib\">provide additional <acronym>GiST</acronym>operator classes.)</xref></xref>"
msgstr ""

#: xml/gist.xml:46(title)
msgid "Built-in <acronym>GiST</acronym>Operator Classes"
msgstr ""

#: xml/gist.xml:51(entry)
msgid "Name"
msgstr ""

#: xml/gist.xml:52(entry)
msgid "Indexed Data Type"
msgstr ""

#: xml/gist.xml:53(entry)
msgid "Indexable Operators"
msgstr ""

#: xml/gist.xml:54(entry)
msgid "Ordering Operators"
msgstr ""

#: xml/gist.xml:60(literal)
msgid "box_ops"
msgstr ""

#: xml/gist.xml:63(type)
msgid "box"
msgstr ""

#: xml/gist.xml:69(literal) xml/gist.xml:72(literal) xml/gist.xml:76(literal) xml/gist.xml:77(literal) xml/gist.xml:94(literal) xml/gist.xml:97(literal) xml/gist.xml:101(literal) xml/gist.xml:102(literal) xml/gist.xml:164(literal) xml/gist.xml:167(literal) xml/gist.xml:171(literal) xml/gist.xml:172(literal)
msgid "|"
msgstr ""

#: xml/gist.xml:73(literal) xml/gist.xml:74(literal) xml/gist.xml:75(literal) xml/gist.xml:98(literal) xml/gist.xml:99(literal) xml/gist.xml:100(literal) xml/gist.xml:143(literal) xml/gist.xml:144(literal) xml/gist.xml:145(literal) xml/gist.xml:168(literal) xml/gist.xml:169(literal) xml/gist.xml:170(literal) xml/gist.xml:191(literal) xml/gist.xml:194(literal) xml/gist.xml:195(literal) xml/gist.xml:207(literal) xml/gist.xml:208(literal)
msgid "@"
msgstr ""

#: xml/gist.xml:78(literal) xml/gist.xml:103(literal) xml/gist.xml:173(literal)
msgid "~"
msgstr ""

#: xml/gist.xml:79(literal) xml/gist.xml:104(literal) xml/gist.xml:147(literal) xml/gist.xml:174(literal)
msgid "~="
msgstr ""

#: xml/gist.xml:85(literal)
msgid "circle_ops"
msgstr ""

#: xml/gist.xml:88(type)
msgid "circle"
msgstr ""

#: xml/gist.xml:107(literal) xml/gist.xml:150(literal) xml/gist.xml:177(literal)
msgid "-"
msgstr ""

#: xml/gist.xml:112(literal)
msgid "inet_ops"
msgstr ""

#: xml/gist.xml:115(type)
msgid "inet"
msgstr ""

#: xml/gist.xml:116(type)
msgid "cidr"
msgstr ""

#: xml/gist.xml:114(entry)
msgid "<placeholder-1/>, <placeholder-2/>"
msgstr ""

#: xml/gist.xml:120(literal) xml/gist.xml:122(literal) xml/gist.xml:125(literal) xml/gist.xml:127(literal) xml/gist.xml:128(literal) xml/gist.xml:193(literal)
msgid "="
msgstr ""

#: xml/gist.xml:134(literal)
msgid "point_ops"
msgstr ""

#: xml/gist.xml:137(type)
msgid "point"
msgstr ""

#: xml/gist.xml:141(literal) xml/gist.xml:146(literal)
msgid "^"
msgstr ""

#: xml/gist.xml:155(literal)
msgid "poly_ops"
msgstr ""

#: xml/gist.xml:158(type)
msgid "polygon"
msgstr ""

#: xml/gist.xml:182(literal)
msgid "range_ops"
msgstr ""

#: xml/gist.xml:184(entry)
msgid "any range type"
msgstr ""

#: xml/gist.xml:192(literal)
msgid "-|-"
msgstr ""

#: xml/gist.xml:201(literal)
msgid "tsquery_ops"
msgstr ""

#: xml/gist.xml:204(type)
msgid "tsquery"
msgstr ""

#: xml/gist.xml:214(literal)
msgid "tsvector_ops"
msgstr ""

#: xml/gist.xml:217(type)
msgid "tsvector"
msgstr ""

#: xml/gist.xml:220(literal)
msgid "@@"
msgstr ""

#: xml/gist.xml:233(programlisting)
#, no-wrap
msgid "CREATE INDEX ON my_table USING GIST\n    (my_inet_column inet_ops);"
msgstr ""

#: xml/gist.xml:227(para)
msgid "For historical reasons, the <literal>inet_ops</literal>operator class is not the default class for types <type>inet</type>and <type>cidr</type>. To use it, mention the class name in <command>CREATE INDEX</command>, for example <placeholder-1/>"
msgstr ""

#: xml/gist.xml:237(title)
msgid "Extensibility"
msgstr ""

#: xml/gist.xml:238(para)
msgid "Traditionally, implementing a new index access method meant a lot of difficult work. It was necessary to understand the inner workings of the database, such as the lock manager and Write-Ahead Log. The <acronym>GiST</acronym>interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The <acronym>GiST</acronym>layer itself takes care of concurrency, logging and searching the tree structure."
msgstr ""

#: xml/gist.xml:247(para)
msgid "This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, <productname>PostgreSQL</productname>supports extensible B-trees and hash indexes. That means that you can use <productname>PostgreSQL</productname>to build a B-tree or hash over any data type you want. But B-trees only support range predicates ( <literal/>, <literal>=</literal>, <literal/>), and hash indexes only support equality queries."
msgstr ""

#: xml/gist.xml:259(para)
msgid "So if you index, say, an image collection with a <productname>PostgreSQL</productname>B-tree, you can only issue queries such as <quote>is imagex equal to imagey</quote>, <quote>is imagex less than imagey</quote>and <quote>is imagex greater than imagey</quote>. Depending on how you define <quote>equals</quote>, <quote>less than</quote>and <quote>greater than</quote>in this context, this could be useful. However, by using a <acronym>GiST</acronym>based index, you could create ways to ask domain-specific questions, perhaps <quote>find all images of horses</quote>or <quote>find all over-exposed images</quote>."
msgstr ""

#: xml/gist.xml:274(para)
msgid "All it takes to get a <acronym>GiST</acronym>access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, <acronym>GiST</acronym>combines extensibility along with generality, code reuse, and a clean interface."
msgstr ""

#: xml/gist.xml:283(para)
msgid "There are seven methods that an index operator class for <acronym>GiST</acronym>must provide, and two that are optional. Correctness of the index is ensured by proper implementation of the <function>same</function>, <function>consistent</function>and <function>union</function>methods, while efficiency (size and speed) of the index will depend on the <function>penalty</function>and <function>picksplit</function>methods. The remaining two basic methods are <function>compress</function>and <function>decompress</function>, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow <productname>PostgreSQL</productname>data type rules here, see about <literal>varlena</literal>for variable sized data). If the tree's internal data type exists at the SQL level, the <literal>STORAGE</literal>option of the <command>CREATE OPERATOR CLASS</command>command can be used. The optional eighth method is <function>distance</function>, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method <function>fetch</function>is needed if the operator class wishes to support index-only scans."
msgstr ""

#: xml/gist.xml:315(function)
msgid "consistent"
msgstr ""

#: xml/gist.xml:318(para)
msgid "Given an index entry <literal>p</literal>and a query value <literal>q</literal>, this function determines whether the index entry is <quote>consistent</quote>with the query; that is, could the predicate <quote><replaceable>indexed_column</replaceable><replaceable>indexable_operator</replaceable><literal>q</literal></quote>be true for any row represented by the index entry? For a leaf index entry this is equivalent to testing the indexable condition, while for an internal tree node this determines whether it is necessary to scan the subtree of the index represented by the tree node. When the result is <literal>true</literal>, a <literal>recheck</literal>flag must also be returned. This indicates whether the predicate is certainly true or only possibly true. If <literal>recheck</literal>= <literal>false</literal>then the index has tested the predicate condition exactly, whereas if <literal>recheck</literal>= <literal>true</literal>the row is only a candidate match. In that case the system will automatically evaluate the <replaceable>indexable_operator</replaceable>against the actual row value to see if it is really a match. This convention allows <acronym>GiST</acronym>to support both lossless and lossy index structures."
msgstr ""

#: xml/gist.xml:352(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_consistent(internal, data_type, smallint, oid,\n          internal) RETURNS bool AS 'MODULE_PATHNAME' LANGUAGE C\n          STRICT;"
msgstr ""

#: xml/gist.xml:357(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_consistent); Datum\n          my_consistent(PG_FUNCTION_ARGS) { GISTENTRY *entry =\n          (GISTENTRY *) PG_GETARG_POINTER(0); data_type *query =\n          PG_GETARG_DATA_TYPE_P(1); StrategyNumber strategy =\n          (StrategyNumber) PG_GETARG_UINT16(2); /* Oid subtype =\n          PG_GETARG_OID(3); */ bool *recheck = (bool *)\n          PG_GETARG_POINTER(4); data_type *key =\n          DatumGetDataType(entry-key); bool retval; /* * determine\n          return value as a function of strategy, key and query. *\n          * Use GIST_LEAF(entry) to know where you're called in the\n          index tree, * which comes handy when supporting the =\n          operator for example (you could * check for non empty\n          union() in non-leaf nodes and equality in leaf * nodes).\n          */ *recheck = true; /* or false if check is exact */\n          PG_RETURN_BOOL(retval); }"
msgstr ""

#: xml/gist.xml:349(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>And the matching code in the C module could then follow this skeleton: <placeholder-2/>Here, <varname>key</varname>is an element in the index and <varname>query</varname>the value being looked up in the index. The <literal>StrategyNumber</literal>parameter indicates which operator of your operator class is being applied it matches one of the operator numbers in the <command>CREATE OPERATOR CLASS</command>command. Depending on what operators you have included in the class, the data type of <varname>query</varname>could vary with the operator, but the above skeleton assumes it doesn't."
msgstr ""

#: xml/gist.xml:387(function)
msgid "union"
msgstr ""

#: xml/gist.xml:390(para)
msgid "This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries."
msgstr ""

#: xml/gist.xml:396(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_union(internal, internal) RETURNS internal AS\n          'MODULE_PATHNAME' LANGUAGE C STRICT;"
msgstr ""

#: xml/gist.xml:401(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_union); Datum\n          my_union(PG_FUNCTION_ARGS) { GistEntryVector *entryvec =\n          (GistEntryVector *) PG_GETARG_POINTER(0); GISTENTRY *ent\n          = entryvec-vector; data_type *out, *tmp, *old; int\n          numranges, i = 0; numranges = entryvec-n; tmp =\n          DatumGetDataType(ent[0].key); out = tmp; if (numranges ==\n          1) { out = data_type_deep_copy(tmp);\n          PG_RETURN_DATA_TYPE_P(out); } for (i = 1; i numranges;\n          i++) { old = out; tmp = DatumGetDataType(ent[i].key); out\n          = my_union_implementation(out, tmp); }\n          PG_RETURN_DATA_TYPE_P(out); }"
msgstr ""

#: xml/gist.xml:393(para) xml/gist.xml:433(para) xml/gist.xml:498(para) xml/gist.xml:534(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>And the matching code in the C module could then follow this skeleton: <placeholder-2/>"
msgstr ""

#: xml/gist.xml:412(para)
msgid "As you can see, in this skeleton we're dealing with a data type where <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this <acronym>GiST</acronym>support method."
msgstr ""

#: xml/gist.xml:419(para)
msgid "The <function>union</function>implementation function should return a pointer to newly <function>palloc()</function>ed memory. You can't just return whatever the input is."
msgstr ""

#: xml/gist.xml:428(function)
msgid "compress"
msgstr ""

#: xml/gist.xml:431(para)
msgid "Converts the data item into a format suitable for physical storage in an index page."
msgstr ""

#: xml/gist.xml:436(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_compress(internal) RETURNS internal AS\n          'MODULE_PATHNAME' LANGUAGE C STRICT;"
msgstr ""

#: xml/gist.xml:441(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_compress); Datum\n          my_compress(PG_FUNCTION_ARGS) { GISTENTRY *entry =\n          (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY *retval; if\n          (entry-leafkey) { /* replace entry-key with a compressed\n          version */ compressed_data_type *compressed_data =\n          palloc(sizeof(compressed_data_type)); /* fill\n          *compressed_data from entry-key ... */ retval =\n          palloc(sizeof(GISTENTRY)); gistentryinit(*retval,\n          PointerGetDatum(compressed_data), entry-rel, entry-page,\n          entry-offset, FALSE); } else { /* typically we needn't do\n          anything with non-leaf entries */ retval = entry; }\n          PG_RETURN_POINTER(retval); }"
msgstr ""

#: xml/gist.xml:453(para)
msgid "You have to adapt <replaceable>compressed_data_type</replaceable>to the specific type you're converting to in order to compress your leaf nodes, of course."
msgstr ""

#: xml/gist.xml:461(function)
msgid "decompress"
msgstr ""

#: xml/gist.xml:464(para)
msgid "The reverse of the <function>compress</function>method. Converts the index representation of the data item into a format that can be manipulated by the other GiST methods in the operator class."
msgstr ""

#: xml/gist.xml:472(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_decompress(internal) RETURNS internal AS\n          'MODULE_PATHNAME' LANGUAGE C STRICT;"
msgstr ""

#: xml/gist.xml:477(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_decompress); Datum\n          my_decompress(PG_FUNCTION_ARGS) {\n          PG_RETURN_POINTER(PG_GETARG_POINTER(0));\n          }"
msgstr ""

#: xml/gist.xml:469(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>And the matching code in the C module could then follow this skeleton: <placeholder-2/>The above skeleton is suitable for the case where no decompression is needed."
msgstr ""

#: xml/gist.xml:486(function)
msgid "penalty"
msgstr ""

#: xml/gist.xml:489(para)
msgid "Returns a value indicating the <quote>cost</quote>of inserting the new entry into a particular branch of the tree. Items will be inserted down the path of least <function>penalty</function>in the tree. Values returned by <function>penalty</function>should be non-negative. If a negative value is returned, it will be treated as zero."
msgstr ""

#: xml/gist.xml:501(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_penalty(internal, internal, internal) RETURNS internal\n          AS 'MODULE_PATHNAME' LANGUAGE C STRICT; -- in some cases\n          penalty functions need not be strict"
msgstr ""

#: xml/gist.xml:507(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_penalty); Datum\n          my_penalty(PG_FUNCTION_ARGS) { GISTENTRY *origentry =\n          (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY *newentry =\n          (GISTENTRY *) PG_GETARG_POINTER(1); float *penalty =\n          (float *) PG_GETARG_POINTER(2); data_type *orig =\n          DatumGetDataType(origentry-key); data_type *new =\n          DatumGetDataType(newentry-key); *penalty =\n          my_penalty_implementation(orig, new);\n          PG_RETURN_POINTER(penalty); }"
msgstr ""

#: xml/gist.xml:516(para)
msgid "The <function>penalty</function>function is crucial to good performance of the index. It'll get used at insertion time to determine which branch to follow when choosing where to add the new entry in the tree. At query time, the more balanced the index, the quicker the lookup."
msgstr ""

#: xml/gist.xml:527(function)
msgid "picksplit"
msgstr ""

#: xml/gist.xml:530(para)
msgid "When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page."
msgstr ""

#: xml/gist.xml:537(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_picksplit(internal, internal) RETURNS internal AS\n          'MODULE_PATHNAME' LANGUAGE C STRICT;"
msgstr ""

#: xml/gist.xml:542(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_picksplit); Datum\n          my_picksplit(PG_FUNCTION_ARGS) { GistEntryVector\n          *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n          OffsetNumber maxoff = entryvec-n - 1; GISTENTRY *ent =\n          entryvec-vector; GIST_SPLITVEC *v = (GIST_SPLITVEC *)\n          PG_GETARG_POINTER(1); int i, nbytes; OffsetNumber *left,\n          *right; data_type *tmp_union; data_type *unionL;\n          data_type *unionR; GISTENTRY **raw_entryvec; maxoff =\n          entryvec-n - 1; nbytes = (maxoff + 1) *\n          sizeof(OffsetNumber); v-spl_left = (OffsetNumber *)\n          palloc(nbytes); left = v-spl_left; v-spl_nleft = 0;\n          v-spl_right = (OffsetNumber *) palloc(nbytes); right =\n          v-spl_right; v-spl_nright = 0; unionL = NULL; unionR =\n          NULL; /* Initialize the raw entry vector. */ raw_entryvec\n          = (GISTENTRY **) malloc(entryvec-n * sizeof(void *)); for\n          (i = FirstOffsetNumber; i = maxoff; i =\n          OffsetNumberNext(i)) raw_entryvec[i] =\n          (entryvec-vector[i]); for (i = FirstOffsetNumber; i =\n          maxoff; i = OffsetNumberNext(i)) { int real_index =\n          raw_entryvec[i] - entryvec-vector; tmp_union =\n          DatumGetDataType(entryvec-vector[real_index].key);\n          Assert(tmp_union != NULL); /* * Choose where to put the\n          index entries and update unionL and unionR * accordingly.\n          Append the entries to either v_spl_left or * v_spl_right,\n          and care about the counters. */ if\n          (my_choice_is_left(unionL, curl, unionR, curr)) { if\n          (unionL == NULL) unionL = tmp_union; else unionL =\n          my_union_implementation(unionL, tmp_union); *left =\n          real_index; ++left; ++(v-spl_nleft); } else { /* * Same\n          on the right */ } } v-spl_ldatum =\n          DataTypeGetDatum(unionL); v-spl_rdatum =\n          DataTypeGetDatum(unionR); PG_RETURN_POINTER(v);\n          }"
msgstr ""

#: xml/gist.xml:575(para)
msgid "Like <function>penalty</function>, the <function>picksplit</function>function is crucial to good performance of the index. Designing suitable <function>penalty</function>and <function>picksplit</function>implementations is where the challenge of implementing well-performing <acronym>GiST</acronym>indexes lies."
msgstr ""

#: xml/gist.xml:587(function)
msgid "same"
msgstr ""

#: xml/gist.xml:590(para)
msgid "Returns true if two index entries are identical, false otherwise."
msgstr ""

#: xml/gist.xml:595(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_same(internal, internal, internal) RETURNS internal AS\n          'MODULE_PATHNAME' LANGUAGE C STRICT;"
msgstr ""

#: xml/gist.xml:600(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_same); Datum\n          my_same(PG_FUNCTION_ARGS) { prefix_range *v1 =\n          PG_GETARG_PREFIX_RANGE_P(0); prefix_range *v2 =\n          PG_GETARG_PREFIX_RANGE_P(1); bool *result = (bool *)\n          PG_GETARG_POINTER(2); *result = my_eq(v1, v2);\n          PG_RETURN_POINTER(result); }"
msgstr ""

#: xml/gist.xml:592(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>And the matching code in the C module could then follow this skeleton: <placeholder-2/>For historical reasons, the <function>same</function>function doesn't just return a Boolean result; instead it has to store the flag at the location indicated by the third argument."
msgstr ""

#: xml/gist.xml:614(function)
msgid "distance"
msgstr ""

#: xml/gist.xml:617(para)
msgid "Given an index entry <literal>p</literal>and a query value <literal>q</literal>, this function determines the index entry's <quote>distance</quote>from the query value. This function must be supplied if the operator class contains any ordering operators. A query using the ordering operator will be implemented by returning index entries with the smallest <quote>distance</quote>values first, so the results must be consistent with the operator's semantics. For a leaf index entry the result just represents the distance to the index entry; for an internal tree node, the result must be the smallest distance that any child entry could have."
msgstr ""

#: xml/gist.xml:635(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_distance(internal, data_type, smallint, oid) RETURNS\n          float8 AS 'MODULE_PATHNAME' LANGUAGE C\n          STRICT;"
msgstr ""

#: xml/gist.xml:640(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_distance); Datum\n          my_distance(PG_FUNCTION_ARGS) { GISTENTRY *entry =\n          (GISTENTRY *) PG_GETARG_POINTER(0); data_type *query =\n          PG_GETARG_DATA_TYPE_P(1); StrategyNumber strategy =\n          (StrategyNumber) PG_GETARG_UINT16(2); /* Oid subtype =\n          PG_GETARG_OID(3); */ /* bool *recheck = (bool *)\n          PG_GETARG_POINTER(4); */ data_type *key =\n          DatumGetDataType(entry-key); double retval; /* *\n          determine return value as a function of strategy, key and\n          query. */ PG_RETURN_FLOAT8(retval); }"
msgstr ""

#: xml/gist.xml:632(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>And the matching code in the C module could then follow this skeleton: <placeholder-2/>The arguments to the <function>distance</function>function are identical to the arguments of the <function>consistent</function>function."
msgstr ""

#: xml/gist.xml:654(para)
msgid "Some approximation is allowed when determining the distance, so long as the result is never greater than the entry's actual distance. Thus, for example, distance to a bounding box is usually sufficient in geometric applications. For an internal tree node, the distance returned must not be greater than the distance to any of the child nodes. If the returned distance is not exact, the function must set <literal>*recheck</literal>to true. (This is not necessary for internal tree nodes; for them, the calculation is always assumed to be inexact.) In this case the executor will calculate the accurate distance after fetching the tuple from the heap, and reorder the tuples if necessary."
msgstr ""

#: xml/gist.xml:668(para)
msgid "If the distance function returns <literal>*recheck = true</literal>for any leaf node, the original ordering operator's return type must be <type>float8</type>or <type>float4</type>, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite <type>float8</type>values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that <function>distance</function>functions return these values.)"
msgstr ""

#: xml/gist.xml:689(function)
msgid "fetch"
msgstr ""

#: xml/gist.xml:692(para)
msgid "Converts the compressed index representation of the data item into the original data type, for index-only scans. The returned data must be an exact, non-lossy copy of the originally indexed value."
msgstr ""

#: xml/gist.xml:699(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n          my_fetch(internal) RETURNS internal AS 'MODULE_PATHNAME'\n          LANGUAGE C STRICT;"
msgstr ""

#: xml/gist.xml:696(para)
msgid "The <acronym>SQL</acronym>declaration of the function must look like this: <placeholder-1/>The argument is a pointer to a <structname>GISTENTRY</structname>struct. On entry, its 'key' field contains a non-NULL leaf datum in its compressed form. The return value is another <structname>GISTENTRY</structname>struct, whose 'key' field contains the same datum in the original, uncompressed form. If the opclass' compress function does nothing for leaf entries, the fetch method can return the argument as is."
msgstr ""

#: xml/gist.xml:713(programlisting)
#, no-wrap
msgid "PG_FUNCTION_INFO_V1(my_fetch); Datum\n          my_fetch(PG_FUNCTION_ARGS) { GISTENTRY *entry =\n          (GISTENTRY *) PG_GETARG_POINTER(0); input_data_type *in =\n          DatumGetP(entry-&gt;key); fetched_data_type\n          *fetched_data; GISTENTRY *retval; retval =\n          palloc(sizeof(GISTENTRY)); fetched_data =\n          palloc(sizeof(fetched_data_type)); /* * Convert\n          'fetched_data' into the a Datum of the original datatype.\n          */ /* fill *retval from fetch_data. */\n          gistentryinit(*retval, PointerGetDatum(converted_datum),\n          entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);\n          PG_RETURN_POINTER(retval); }"
msgstr ""

#: xml/gist.xml:711(para)
msgid "The matching code in the C module could then follow this skeleton: <placeholder-1/>"
msgstr ""

#: xml/gist.xml:725(para)
msgid "If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a 'fetch' function."
msgstr ""

#: xml/gist.xml:731(para)
msgid "All the GiST support methods are normally called in short-lived memory contexts; that is, <varname>CurrentMemoryContext</varname>will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in <literal>fcinfo-flinfo-fn_mcxt</literal>, and keep a pointer to it in <literal>fcinfo-flinfo-fn_extra</literal>. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a <literal>fn_extra</literal>value, or the leak will accumulate for the duration of the operation."
msgstr ""

#: xml/gist.xml:748(title)
msgid "Implementation"
msgstr ""

#: xml/gist.xml:750(title)
msgid "GiST buffering build"
msgstr ""

#: xml/gist.xml:751(para)
msgid "Building large GiST indexes by simply inserting all the tuples tends to be slow, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, the insertions need to perform a lot of random I/O. Beginning in version 9.2, PostgreSQL supports a more efficient method to build GiST indexes based on buffering, which can dramatically reduce the number of random I/Os needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as whole does not."
msgstr ""

#: xml/gist.xml:763(para)
msgid "However, buffering index build needs to call the <function>penalty</function>function more often, which consumes some extra CPU resources. Also, the buffers used in the buffering build need temporary disk space, up to the size of the resulting index. Buffering can also influence the quality of the resulting index, in both positive and negative directions. That influence depends on various factors, like the distribution of the input data and the operator class implementation."
msgstr ""

#: xml/gist.xml:772(para)
msgid "By default, a GiST index build switches to the buffering method when the index size reaches <xref linkend=\"guc-effective-cache-size\">. It can be manually turned on or off by the <literal>buffering</literal>parameter to the CREATE INDEX command. The default behavior is good for most cases, but turning buffering off might speed up the build somewhat if the input data is ordered.</xref>"
msgstr ""

#: xml/gist.xml:783(title)
msgid "Examples"
msgstr ""

#: xml/gist.xml:800(filename)
msgid "btree_gist"
msgstr ""

#: xml/gist.xml:803(para)
msgid "B-tree equivalent functionality for several data types"
msgstr ""

#: xml/gist.xml:809(filename)
msgid "cube"
msgstr ""

#: xml/gist.xml:812(para)
msgid "Indexing for multidimensional cubes"
msgstr ""

#: xml/gist.xml:817(filename)
msgid "hstore"
msgstr ""

#: xml/gist.xml:820(para)
msgid "Module for storing (key, value) pairs"
msgstr ""

#: xml/gist.xml:825(filename)
msgid "intarray"
msgstr ""

#: xml/gist.xml:828(para)
msgid "RD-Tree for one-dimensional array of int4 values"
msgstr ""

#: xml/gist.xml:834(filename)
msgid "ltree"
msgstr ""

#: xml/gist.xml:837(para)
msgid "Indexing for tree-like structures"
msgstr ""

#: xml/gist.xml:842(filename)
msgid "pg_trgm"
msgstr ""

#: xml/gist.xml:845(para)
msgid "Text similarity using trigram matching"
msgstr ""

#: xml/gist.xml:850(filename)
msgid "seg"
msgstr ""

#: xml/gist.xml:853(para)
msgid "Indexing for <quote>float ranges</quote>"
msgstr ""

#: xml/gist.xml:784(para)
msgid "The <productname>PostgreSQL</productname>source distribution includes several examples of index methods implemented using <acronym>GiST</acronym>. The core system currently provides text search support (indexing for <type>tsvector</type>and <type>tsquery</type>) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see <filename>src/backend/access/gist/gistproc.c</filename>). The following <filename>contrib</filename>modules also contain <acronym>GiST</acronym>operator classes: <placeholder-1/>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/gist.xml:0(None)
msgid "translator-credits"
msgstr ""

