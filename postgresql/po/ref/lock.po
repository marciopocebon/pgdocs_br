msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/ref/lock.xml:4(primary) xml/ref/lock.xml:7(refentrytitle) xml/ref/lock.xml:12(refname)
msgid "LOCK"
msgstr ""

#: xml/ref/lock.xml:8(manvolnum)
msgid "7"
msgstr ""

#: xml/ref/lock.xml:9(refmiscinfo)
msgid "SQL - Language Statements"
msgstr ""

#: xml/ref/lock.xml:13(refpurpose)
msgid "lock a table"
msgstr ""

#: xml/ref/lock.xml:17(replaceable) xml/ref/lock.xml:109(replaceable)
msgid "name"
msgstr ""

#: xml/ref/lock.xml:19(replaceable) xml/ref/lock.xml:22(replaceable) xml/ref/lock.xml:132(replaceable)
msgid "lockmode"
msgstr ""

#: xml/ref/lock.xml:21(phrase)
msgid "where <placeholder-1/>is one of:"
msgstr ""

#: xml/ref/lock.xml:16(synopsis)
#, no-wrap
msgid "LOCK [ TABLE ] [ ONLY ] \n    <placeholder-1/>[ * ] [, ...]\n    [ IN \n    <placeholder-2/>MODE ] [\n    NOWAIT ] \n    <placeholder-3/>ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE\n    UPDATE EXCLUSIVE | SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE |\n    ACCESS EXCLUSIVE"
msgstr ""

#: xml/ref/lock.xml:28(title)
msgid "Description"
msgstr ""

#: xml/ref/lock.xml:29(para)
msgid "<command>LOCK TABLE</command>obtains a table-level lock, waiting if necessary for any conflicting locks to be released. If <literal>NOWAIT</literal>is specified, <command>LOCK TABLE</command>does not wait to acquire the desired lock: if it cannot be acquired immediately, the command is aborted and an error is emitted. Once obtained, the lock is held for the remainder of the current transaction. (There is no <command>UNLOCK TABLE</command>command; locks are always released at transaction end.)"
msgstr ""

#: xml/ref/lock.xml:41(para)
msgid "When acquiring locks automatically for commands that reference tables, <productname>PostgreSQL</productname>always uses the least restrictive lock mode possible. <command>LOCK TABLE</command>provides for cases when you might need more restrictive locking. For example, suppose an application runs a transaction at the <literal>READ COMMITTED</literal>isolation level and needs to ensure that data in a table remains stable for the duration of the transaction. To achieve this you could obtain <literal>SHARE</literal>lock mode over the table before querying. This will prevent concurrent data changes and ensure subsequent reads of the table see a stable view of committed data, because <literal>SHARE</literal>lock mode conflicts with the <literal>ROW EXCLUSIVE</literal>lock acquired by writers, and your <command>LOCK TABLE <replaceable class=\"PARAMETER\">name</replaceable>IN SHARE MODE</command>statement will wait until any concurrent holders of <literal>ROW EXCLUSIVE</literal>mode locks commit or roll back. Thus, once you obtain the lock, there are no uncommitted writes outstanding; furthermore none can begin until you release the lock."
msgstr ""

#: xml/ref/lock.xml:66(para)
msgid "To achieve a similar effect when running a transaction at the <literal>REPEATABLE READ</literal>or <literal>SERIALIZABLE</literal>isolation level, you have to execute the <command>LOCK TABLE</command>statement before executing any <command>SELECT</command>or data modification statement. A <literal>REPEATABLE READ</literal>or <literal>SERIALIZABLE</literal>transaction's view of data will be frozen when its first <command>SELECT</command>or data modification statement begins. A <command>LOCK TABLE</command>later in the transaction will still prevent concurrent writes but it won't ensure that what the transaction reads corresponds to the latest committed values."
msgstr ""

#: xml/ref/lock.xml:82(para)
msgid "If a transaction of this sort is going to change the data in the table, then it should use <literal>SHARE ROW EXCLUSIVE</literal>lock mode instead of <literal>SHARE</literal>mode. This ensures that only one transaction of this type runs at a time. Without this, a deadlock is possible: two transactions might both acquire <literal>SHARE</literal>mode, and then be unable to also acquire <literal>ROW EXCLUSIVE</literal>mode to actually perform their updates. (Note that a transaction's own locks never conflict, so a transaction can acquire <literal>ROW EXCLUSIVE</literal>mode when it holds <literal>SHARE</literal>mode but not if anyone else holds <literal>SHARE</literal>mode.) To avoid deadlocks, make sure all transactions acquire locks on the same objects in the same order, and if multiple lock modes are involved for a single object, then transactions should always acquire the most restrictive mode first."
msgstr ""

#: xml/ref/lock.xml:100(para)
msgid "More information about the lock modes and locking strategies can be found in <xref linkend=\"explicit-locking\">.</xref>"
msgstr ""

#: xml/ref/lock.xml:105(title)
msgid "Parameters"
msgstr ""

#: xml/ref/lock.xml:112(para)
msgid "The name (optionally schema-qualified) of an existing table to lock. If <literal>ONLY</literal>is specified before the table name, only that table is locked. If <literal>ONLY</literal>is not specified, the table and all its descendant tables (if any) are locked. Optionally, <literal>*</literal>can be specified after the table name to explicitly indicate that descendant tables are included."
msgstr ""

#: xml/ref/lock.xml:122(para)
msgid "The command <literal>LOCK TABLE a, b;</literal>is equivalent to <literal>LOCK TABLE a; LOCK TABLE b;</literal>. The tables are locked one-by-one in the order specified in the <command>LOCK TABLE</command>command."
msgstr ""

#: xml/ref/lock.xml:135(para)
msgid "The lock mode specifies which locks this lock conflicts with. Lock modes are described in <xref linkend=\"explicit-locking\">.</xref>"
msgstr ""

#: xml/ref/lock.xml:138(para)
msgid "If no lock mode is specified, then <literal>ACCESS EXCLUSIVE</literal>, the most restrictive mode, is used."
msgstr ""

#: xml/ref/lock.xml:145(literal)
msgid "NOWAIT"
msgstr ""

#: xml/ref/lock.xml:148(para)
msgid "Specifies that <command>LOCK TABLE</command>should not wait for any conflicting locks to be released: if the specified lock(s) cannot be acquired immediately without waiting, the transaction is aborted."
msgstr ""

#: xml/ref/lock.xml:158(title)
msgid "Notes"
msgstr ""

#: xml/ref/lock.xml:159(para)
msgid "<literal>LOCK TABLE ... IN ACCESS SHARE MODE</literal>requires <literal>SELECT</literal>privileges on the target table. <literal>LOCK TABLE ... IN ROW EXCLUSIVE MODE</literal>requires <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</literal>privileges on the target table. All other forms of <command>LOCK</command>require table-level <literal>UPDATE</literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</literal>privileges."
msgstr ""

#: xml/ref/lock.xml:173(para)
msgid "<command>LOCK TABLE</command>is useless outside a transaction block: the lock would remain held only to the completion of the statement. Therefore <productname>PostgreSQL</productname>reports an error if <command>LOCK</command>is used outside a transaction block. Use <xref linkend=\"sql-begin\">and <xref linkend=\"sql-commit\">(or <xref linkend=\"sql-rollback\">) to define a transaction block.</xref></xref></xref>"
msgstr ""

#: xml/ref/lock.xml:184(para)
msgid "<command>LOCK TABLE</command>only deals with table-level locks, and so the mode names involving <literal>ROW</literal>are all misnomers. These mode names should generally be read as indicating the intention of the user to acquire row-level locks within the locked table. Also, <literal>ROW EXCLUSIVE</literal>mode is a shareable table lock. Keep in mind that all the lock modes have identical semantics so far as <command>LOCK TABLE</command>is concerned, differing only in the rules about which modes conflict with which. For information on how to acquire an actual row-level lock, see <xref linkend=\"locking-rows\">and the <xref linkend=\"sql-for-update-share\" endterm=\"sql-for-update-share-title\">in the <command>SELECT</command>reference documentation.</xref></xref>"
msgstr ""

#: xml/ref/lock.xml:203(title)
msgid "Examples"
msgstr ""

#: xml/ref/lock.xml:207(programlisting)
#, no-wrap
msgid "BEGIN WORK; LOCK TABLE films IN SHARE MODE;\n    SELECT id FROM films WHERE name = 'Star Wars: Episode I - The\n    Phantom Menace'; -- Do ROLLBACK if record was not returned\n    INSERT INTO films_user_comments VALUES (_id_, 'GREAT! I was\n    waiting for it for so long!'); COMMIT\n    WORK;"
msgstr ""

#: xml/ref/lock.xml:204(para)
msgid "Obtain a <literal>SHARE</literal>lock on a primary key table when going to perform inserts into a foreign key table: <placeholder-1/>"
msgstr ""

#: xml/ref/lock.xml:216(programlisting)
#, no-wrap
msgid "BEGIN WORK; LOCK TABLE films IN SHARE ROW\n    EXCLUSIVE MODE; DELETE FROM films_user_comments WHERE id IN\n    (SELECT id FROM films WHERE rating 5); DELETE FROM films WHERE\n    rating 5; COMMIT WORK;"
msgstr ""

#: xml/ref/lock.xml:213(para)
msgid "Take a <literal>SHARE ROW EXCLUSIVE</literal>lock on a primary key table when going to perform a delete operation: <placeholder-1/>"
msgstr ""

#: xml/ref/lock.xml:222(title)
msgid "Compatibility"
msgstr ""

#: xml/ref/lock.xml:223(para)
msgid "There is no <command>LOCK TABLE</command>in the SQL standard, which instead uses <command>SET TRANSACTION</command>to specify concurrency levels on transactions. <productname>PostgreSQL</productname>supports that too; see <xref linkend=\"SQL-SET-TRANSACTION\">for details.</xref>"
msgstr ""

#: xml/ref/lock.xml:230(para)
msgid "Except for <literal>ACCESS SHARE</literal>, <literal>ACCESS EXCLUSIVE</literal>, and <literal>SHARE UPDATE EXCLUSIVE</literal>lock modes, the <productname>PostgreSQL</productname>lock modes and the <command>LOCK TABLE</command>syntax are compatible with those present in <productname>Oracle</productname>."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/ref/lock.xml:0(None)
msgid "translator-credits"
msgstr ""

