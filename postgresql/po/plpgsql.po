msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2016-04-29 18:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: xml/plpgsql.xml:3(title)
msgid "<application>PL/pgSQL</application>- <acronym>SQL</acronym>Procedural Language"
msgstr ""

#: xml/plpgsql.xml:7(primary) xml/plpgsql.xml:3406(application) xml/plpgsql.xml:3636(application) xml/plpgsql.xml:4249(application) xml/plpgsql.xml:4380(application)
msgid "PL/pgSQL"
msgstr ""

#: xml/plpgsql.xml:10(title)
msgid "Overview"
msgstr ""

#: xml/plpgsql.xml:20(para)
msgid "can be used to create functions and trigger procedures,"
msgstr ""

#: xml/plpgsql.xml:24(para)
msgid "adds control structures to the <acronym>SQL</acronym>language,"
msgstr ""

#: xml/plpgsql.xml:28(para)
msgid "can perform complex computations,"
msgstr ""

#: xml/plpgsql.xml:31(para)
msgid "inherits all user-defined types, functions, and operators,"
msgstr ""

#: xml/plpgsql.xml:35(para)
msgid "can be defined to be trusted by the server,"
msgstr ""

#: xml/plpgsql.xml:38(para)
msgid "is easy to use."
msgstr ""

#: xml/plpgsql.xml:11(para)
msgid "<application>PL/pgSQL</application>is a loadable procedural language for the <productname>PostgreSQL</productname>database system. The design goals of <application>PL/pgSQL</application>were to create a loadable procedural language that <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:41(para)
msgid "Functions created with <application>PL/pgSQL</application>can be used anywhere that built-in functions could be used. For example, it is possible to create complex conditional computation functions and later use them to define operators or use them in index expressions."
msgstr ""

#: xml/plpgsql.xml:47(para)
msgid "In <productname>PostgreSQL</productname>9.0 and later, <application>PL/pgSQL</application>is installed by default. However it is still a loadable module, so especially security-conscious administrators could choose to remove it."
msgstr ""

#: xml/plpgsql.xml:54(title)
msgid "Advantages of Using <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:56(para)
msgid "<acronym>SQL</acronym>is the language <productname>PostgreSQL</productname>and most other relational databases use as query language. It's portable and easy to learn. But every <acronym>SQL</acronym>statement must be executed individually by the database server."
msgstr ""

#: xml/plpgsql.xml:63(para)
msgid "That means that your client application must send each query to the database server, wait for it to be processed, receive and process the results, do some computation, then send further queries to the server. All this incurs interprocess communication and will also incur network overhead if your client is on a different machine than the database server."
msgstr ""

#: xml/plpgsql.xml:70(para)
msgid "With <application>PL/pgSQL</application>you can group a block of computation and a series of queries <emphasis>inside</emphasis>the database server, thus having the power of a procedural language and the ease of use of SQL, but with considerable savings of client/server communication overhead."
msgstr ""

#: xml/plpgsql.xml:79(para)
msgid "Extra round trips between client and server are eliminated"
msgstr ""

#: xml/plpgsql.xml:83(para)
msgid "Intermediate results that the client does not need do not have to be marshaled or transferred between server and client"
msgstr ""

#: xml/plpgsql.xml:88(para)
msgid "Multiple rounds of query parsing can be avoided"
msgstr ""

#: xml/plpgsql.xml:92(para)
msgid "This can result in a considerable performance increase as compared to an application that does not use stored functions."
msgstr ""

#: xml/plpgsql.xml:95(para)
msgid "Also, with <application>PL/pgSQL</application>you can use all the data types, operators and functions of SQL."
msgstr ""

#: xml/plpgsql.xml:100(title)
msgid "Supported Argument and Result Data Types"
msgstr ""

#: xml/plpgsql.xml:101(para)
msgid "Functions written in <application>PL/pgSQL</application>can accept as arguments any scalar or array data type supported by the server, and they can return a result of any of these types. They can also accept or return any composite type (row type) specified by name. It is also possible to declare a <application>PL/pgSQL</application>function as returning <type>record</type>, which means that the result is a row type whose columns are determined by specification in the calling query, as discussed in <xref linkend=\"queries-tablefunctions\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:112(para)
msgid "<application>PL/pgSQL</application>functions can be declared to accept a variable number of arguments by using the <literal>VARIADIC</literal>marker. This works exactly the same way as for SQL functions, as discussed in <xref linkend=\"xfunc-sql-variadic-functions\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:118(para)
msgid "<application>PL/pgSQL</application>functions can also be declared to accept and return the polymorphic types <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>, and <type>anyrange</type>. The actual data types handled by a polymorphic function can vary from call to call, as discussed in <xref linkend=\"extend-types-polymorphic\">. An example is shown in <xref linkend=\"plpgsql-declaration-parameters\"> .</xref></xref>"
msgstr ""

#: xml/plpgsql.xml:132(para)
msgid "<application>PL/pgSQL</application>functions can also be declared to return a <quote>set</quote>(or table) of any data type that can be returned as a single instance. Such a function generates its output by executing <command>RETURN NEXT</command>for each desired element of the result set, or by using <command>RETURN QUERY</command>to output the result of evaluating a query."
msgstr ""

#: xml/plpgsql.xml:142(para)
msgid "Finally, a <application>PL/pgSQL</application>function can be declared to return <type>void</type>if it has no useful return value."
msgstr ""

#: xml/plpgsql.xml:146(para)
msgid "<application>PL/pgSQL</application>functions can also be declared with output parameters in place of an explicit specification of the return type. This does not add any fundamental capability to the language, but it is often convenient, especially for returning multiple values. The <literal>RETURNS TABLE</literal>notation can also be used in place of <literal>RETURNS SETOF</literal>."
msgstr ""

#: xml/plpgsql.xml:155(para)
msgid "Specific examples appear in <xref linkend=\"plpgsql-declaration-parameters\">and <xref linkend=\"plpgsql-statements-returning\"> .</xref></xref>"
msgstr ""

#: xml/plpgsql.xml:162(title)
msgid "Structure of <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:164(para)
msgid "<application>PL/pgSQL</application>is a block-structured language. The complete text of a function definition must be a <firstterm>block</firstterm>. A block is defined as: <synopsis>\n    <optional>\n      <replaceable>label</replaceable>\n    </optional>\n    <optional>DECLARE \n    <replaceable>declarations</replaceable></optional>BEGIN \n    <replaceable>statements</replaceable>END \n    <optional>\n      <replaceable>label</replaceable>\n    </optional>;</synopsis>"
msgstr ""

#: xml/plpgsql.xml:178(para)
msgid "Each declaration and each statement within a block is terminated by a semicolon. A block that appears within another block must have a semicolon after <literal>END</literal>, as shown above; however the final <literal>END</literal>that concludes a function body does not require a semicolon."
msgstr ""

#: xml/plpgsql.xml:185(para)
msgid "A common mistake is to write a semicolon immediately after <literal>BEGIN</literal>. This is incorrect and will result in a syntax error."
msgstr ""

#: xml/plpgsql.xml:190(para)
msgid "A <replaceable>label</replaceable>is only needed if you want to identify the block for use in an <literal>EXIT</literal>statement, or to qualify the names of the variables declared in the block. If a label is given after <literal>END</literal>, it must match the label at the block's beginning."
msgstr ""

#: xml/plpgsql.xml:197(para)
msgid "All key words are case-insensitive. Identifiers are implicitly converted to lower case unless double-quoted, just as they are in ordinary SQL commands."
msgstr ""

#: xml/plpgsql.xml:200(para)
msgid "Comments work the same way in <application>PL/pgSQL</application>code as in ordinary SQL. A double dash ( <literal>--</literal>) starts a comment that extends to the end of the line. A <literal>/*</literal>starts a block comment that extends to the matching occurrence of <literal>*/</literal>. Block comments nest."
msgstr ""

#: xml/plpgsql.xml:216(programlisting)
#, no-wrap
msgid "CREATE FUNCTION somefunc() RETURNS integer AS\n    $$ outerblock DECLARE quantity integer := 30; BEGIN RAISE\n    NOTICE 'Quantity here is %', quantity; -- Prints 30 quantity :=\n    50; -- -- Create a subblock -- DECLARE quantity integer := 80;\n    BEGIN RAISE NOTICE 'Quantity here is %', quantity; -- Prints 80\n    RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;\n    -- Prints 50 END; RAISE NOTICE 'Quantity here is %', quantity;\n    -- Prints 50 RETURN quantity; END; $$ LANGUAGE\n    plpgsql;"
msgstr ""

#: xml/plpgsql.xml:208(para)
msgid "Any statement in the statement section of a block can be a <firstterm>subblock</firstterm>. Subblocks can be used for logical grouping or to localize variables to a small group of statements. Variables declared in a subblock mask any similarly-named variables of outer blocks for the duration of the subblock; but you can access the outer variables anyway if you qualify their names with their block's label. For example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:226(para)
msgid "There is actually a hidden <quote>outer block</quote>surrounding the body of any <application>PL/pgSQL</application>function. This block provides the declarations of the function's parameters (if any), as well as some special variables such as <literal>FOUND</literal>(see <xref linkend=\"plpgsql-statements-diagnostics\">). The outer block is labeled with the function's name, meaning that parameters and special variables can be qualified with the function's name.</xref>"
msgstr ""

#: xml/plpgsql.xml:237(para)
msgid "It is important not to confuse the use of <command>BEGIN</command>/ <command>END</command>for grouping statements in <application>PL/pgSQL</application>with the similarly-named SQL commands for transaction control. <application>PL/pgSQL</application>'s <command>BEGIN</command>/ <command>END</command>are only for grouping; they do not start or end a transaction. Functions and trigger procedures are always executed within a transaction established by an outer query they cannot start or commit that transaction, since there would be no context for them to execute in. However, a block containing an <literal>EXCEPTION</literal>clause effectively forms a subtransaction that can be rolled back without affecting the outer transaction. For more about that see <xref linkend=\"plpgsql-error-trapping\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:256(title)
msgid "Declarations"
msgstr ""

#: xml/plpgsql.xml:257(para)
msgid "All variables used in a block must be declared in the declarations section of the block. (The only exceptions are that the loop variable of a <literal>FOR</literal>loop iterating over a range of integer values is automatically declared as an integer variable, and likewise the loop variable of a <literal>FOR</literal>loop iterating over a cursor's result is automatically declared as a record variable.)"
msgstr ""

#: xml/plpgsql.xml:265(para)
msgid "<application>PL/pgSQL</application>variables can have any SQL data type, such as <type>integer</type>, <type>varchar</type>, and <type>char</type>."
msgstr ""

#: xml/plpgsql.xml:272(programlisting)
#, no-wrap
msgid "user_id integer; quantity numeric(5); url\n    varchar; myrow tablename%ROWTYPE; myfield\n    tablename.columnname%TYPE; arow RECORD;"
msgstr ""

#: xml/plpgsql.xml:271(para)
msgid "Here are some examples of variable declarations: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:275(para)
msgid "The general syntax of a variable declaration is: <synopsis>\n    <replaceable>name</replaceable>\n    <optional>CONSTANT</optional>\n    <replaceable>type</replaceable>\n    <optional>COLLATE \n    <replaceable>collation_name</replaceable></optional>\n    <optional>NOT NULL</optional>\n    <optional>{ DEFAULT | := | = } \n    <replaceable>expression</replaceable></optional>;</synopsis>The <literal>DEFAULT</literal>clause, if given, specifies the initial value assigned to the variable when the block is entered. If the <literal>DEFAULT</literal>clause is not given then the variable is initialized to the <acronym>SQL</acronym>null value. The <literal>CONSTANT</literal>option prevents the variable from being assigned to after initialization, so that its value will remain constant for the duration of the block. The <literal>COLLATE</literal>option specifies a collation to use for the variable (see <xref linkend=\"plpgsql-declaration-collation\">). If <literal>NOT NULL</literal>is specified, an assignment of a null value results in a run-time error. All variables declared as <literal>NOT NULL</literal>must have a nonnull default value specified. Equal ( <literal>=</literal>) can be used instead of PL/SQL-compliant <literal>:=</literal>.</xref>"
msgstr ""

#: xml/plpgsql.xml:305(para)
msgid "A variable's default value is evaluated and assigned to the variable each time the block is entered (not just once per function call). So, for example, assigning <literal>now()</literal>to a variable of type <type>timestamp</type>causes the variable to have the time of the current function call, not the time when the function was precompiled."
msgstr ""

#: xml/plpgsql.xml:313(programlisting)
#, no-wrap
msgid "quantity integer DEFAULT 32; url varchar :=\n    'http://mysite.com'; user_id CONSTANT integer :=\n    10;"
msgstr ""

#: xml/plpgsql.xml:312(para) xml/plpgsql.xml:449(para) xml/plpgsql.xml:718(para) xml/plpgsql.xml:1824(para) xml/plpgsql.xml:1867(para) xml/plpgsql.xml:2694(para) xml/plpgsql.xml:2745(para)
msgid "Examples: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:317(title)
msgid "Declaring Function Parameters"
msgstr ""

#: xml/plpgsql.xml:318(para)
msgid "Parameters passed to functions are named with the identifiers <literal>$1</literal>, <literal>$2</literal>, etc. Optionally, aliases can be declared for <literal>$ <replaceable>n</replaceable></literal>parameter names for increased readability. Either the alias or the numeric identifier can then be used to refer to the parameter value."
msgstr ""

#: xml/plpgsql.xml:331(programlisting)
#, no-wrap
msgid "CREATE FUNCTION sales_tax(subtotal real)\n      RETURNS real AS $$ BEGIN RETURN subtotal * 0.06; END; $$\n      LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:339(programlisting)
#, no-wrap
msgid "CREATE FUNCTION sales_tax(real) RETURNS real\n      AS $$ DECLARE subtotal ALIAS FOR $1; BEGIN RETURN subtotal *\n      0.06; END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:328(para)
msgid "There are two ways to create an alias. The preferred way is to give a name to the parameter in the <command>CREATE FUNCTION</command>command, for example: <placeholder-1/>The other way is to explicitly declare an alias, using the declaration syntax <synopsis>\n      <replaceable>name</replaceable>ALIAS FOR $ \n      <replaceable>n</replaceable>;</synopsis>The same example in this style looks like: <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:343(para)
msgid "These two examples are not perfectly equivalent. In the first case, <literal>subtotal</literal>could be referenced as <literal>sales_tax.subtotal</literal>, but in the second case it could not. (Had we attached a label to the inner block, <literal>subtotal</literal>could be qualified with that label, instead.)"
msgstr ""

#: xml/plpgsql.xml:353(programlisting)
#, no-wrap
msgid "CREATE FUNCTION instr(varchar, integer)\n      RETURNS integer AS $$ DECLARE v_string ALIAS FOR $1; index\n      ALIAS FOR $2; BEGIN -- some computations using v_string and\n      index here END; $$ LANGUAGE plpgsql; CREATE FUNCTION\n      concat_selected_fields(in_t sometablename) RETURNS text AS $$\n      BEGIN RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7; END;\n      $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:352(para)
msgid "Some more examples: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:371(programlisting)
#, no-wrap
msgid "CREATE FUNCTION sales_tax(subtotal real, OUT\n      tax real) AS $$ BEGIN tax := subtotal * 0.06; END; $$\n      LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:360(para)
msgid "When a <application>PL/pgSQL</application>function is declared with output parameters, the output parameters are given <literal>$ <replaceable>n</replaceable></literal>names and optional aliases in just the same way as the normal input parameters. An output parameter is effectively a variable that starts out NULL; it should be assigned to during the execution of the function. The final value of the parameter is what is returned. For instance, the sales-tax example could also be done this way: <placeholder-1/>Notice that we omitted <literal>RETURNS real</literal>we could have included it, but it would be redundant."
msgstr ""

#: xml/plpgsql.xml:378(programlisting)
#, no-wrap
msgid "CREATE FUNCTION sum_n_product(x int, y int,\n      OUT sum int, OUT prod int) AS $$ BEGIN sum := x + y; prod :=\n      x * y; END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:376(para)
msgid "Output parameters are most useful when returning multiple values. A trivial example is: <placeholder-1/>As discussed in <xref linkend=\"xfunc-output-parameters\">, this effectively creates an anonymous record type for the function's results. If a <literal>RETURNS</literal>clause is given, it must say <literal>RETURNS record</literal>.</xref>"
msgstr ""

#: xml/plpgsql.xml:390(programlisting)
#, no-wrap
msgid "CREATE FUNCTION extended_sales(p_itemno int)\n      RETURNS TABLE(quantity int, total numeric) AS $$ BEGIN RETURN\n      QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s\n      WHERE s.itemno = p_itemno; END; $$ LANGUAGE\n      plpgsql;"
msgstr ""

#: xml/plpgsql.xml:387(para)
msgid "Another way to declare a <application>PL/pgSQL</application>function is with <literal>RETURNS TABLE</literal>, for example: <placeholder-1/>This is exactly equivalent to declaring one or more <literal>OUT</literal>parameters and specifying <literal>RETURNS SETOF <replaceable>sometype</replaceable></literal>."
msgstr ""

#: xml/plpgsql.xml:419(programlisting)
#, no-wrap
msgid "CREATE FUNCTION add_three_values(v1\n      anyelement, v2 anyelement, v3 anyelement) RETURNS anyelement\n      AS $$ DECLARE result ALIAS FOR $0; BEGIN result := v1 + v2 +\n      v3; RETURN result; END; $$ LANGUAGE\n      plpgsql;"
msgstr ""

#: xml/plpgsql.xml:399(para)
msgid "When the return type of a <application>PL/pgSQL</application>function is declared as a polymorphic type ( <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>, or <type>anyrange</type>), a special parameter <literal>$0</literal>is created. Its data type is the actual return type of the function, as deduced from the actual input types (see <xref linkend=\"extend-types-polymorphic\">). This allows the function to access its actual return type as shown in <xref linkend=\"plpgsql-declaration-type\">. <literal>$0</literal>is initialized to null and can be modified by the function, so it can be used to hold the return value if desired, though that is not required. <literal>$0</literal>can also be given an alias. For example, this function works on any data type that has a <literal>+</literal>operator: <placeholder-1/></xref></xref>"
msgstr ""

#: xml/plpgsql.xml:429(programlisting)
#, no-wrap
msgid "CREATE FUNCTION add_three_values(v1\n      anyelement, v2 anyelement, v3 anyelement, OUT sum anyelement)\n      AS $$ BEGIN sum := v1 + v2 + v3; END; $$ LANGUAGE\n      plpgsql;"
msgstr ""

#: xml/plpgsql.xml:424(para)
msgid "The same effect can be had by declaring one or more output parameters as polymorphic types. In this case the special <literal>$0</literal>parameter is not used; the output parameters themselves serve the same purpose. For example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:436(literal)
msgid "ALIAS"
msgstr ""

#: xml/plpgsql.xml:439(replaceable)
msgid "newname"
msgstr ""

#: xml/plpgsql.xml:440(replaceable)
msgid "oldname"
msgstr ""

#: xml/plpgsql.xml:438(synopsis)
#, no-wrap
msgid "\n      <placeholder-1/>ALIAS FOR \n      <placeholder-2/>;"
msgstr ""

#: xml/plpgsql.xml:441(para)
msgid "The <literal>ALIAS</literal>syntax is more general than is suggested in the previous section: you can declare an alias for any variable, not just function parameters. The main practical use for this is to assign a different name for variables with predetermined names, such as <varname>NEW</varname>or <varname>OLD</varname>within a trigger procedure."
msgstr ""

#: xml/plpgsql.xml:450(programlisting)
#, no-wrap
msgid "DECLARE prior ALIAS FOR old; updated ALIAS\n      FOR new;"
msgstr ""

#: xml/plpgsql.xml:452(para)
msgid "Since <literal>ALIAS</literal>creates two different ways to name the same object, unrestricted use can be confusing. It's best to use it only for the purpose of overriding predetermined names."
msgstr ""

#: xml/plpgsql.xml:459(title)
msgid "Copying Types"
msgstr ""

#: xml/plpgsql.xml:461(replaceable) xml/plpgsql.xml:2395(replaceable)
msgid "variable"
msgstr ""

#: xml/plpgsql.xml:460(synopsis)
#, no-wrap
msgid "\n      <placeholder-1/>%TYPE"
msgstr ""

#: xml/plpgsql.xml:471(programlisting)
#, no-wrap
msgid "user_id\n      users.user_id%TYPE;"
msgstr ""

#: xml/plpgsql.xml:462(para)
msgid "<literal>%TYPE</literal>provides the data type of a variable or table column. You can use this to declare variables that will hold database values. For example, let's say you have a column named <literal>user_id</literal>in your <literal>users</literal>table. To declare a variable with the same data type as <literal>users.user_id</literal>you write: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:473(para)
msgid "By using <literal>%TYPE</literal>you don't need to know the data type of the structure you are referencing, and most importantly, if the data type of the referenced item changes in the future (for instance: you change the type of <literal>user_id</literal>from <type>integer</type>to <type>real</type>), you might not need to change your function definition."
msgstr ""

#: xml/plpgsql.xml:482(para)
msgid "<literal>%TYPE</literal>is particularly valuable in polymorphic functions, since the data types needed for internal variables can change from one call to the next. Appropriate variables can be created by applying <literal>%TYPE</literal>to the function's arguments or result placeholders."
msgstr ""

#: xml/plpgsql.xml:491(title)
msgid "Row Types"
msgstr ""

#: xml/plpgsql.xml:493(replaceable) xml/plpgsql.xml:496(replaceable) xml/plpgsql.xml:546(replaceable) xml/plpgsql.xml:1908(replaceable)
msgid "name"
msgstr ""

#: xml/plpgsql.xml:494(replaceable)
msgid "table_name"
msgstr ""

#: xml/plpgsql.xml:495(literal)
msgid "%ROWTYPE"
msgstr ""

#: xml/plpgsql.xml:497(replaceable)
msgid "composite_type_name"
msgstr ""

#: xml/plpgsql.xml:492(synopsis)
#, no-wrap
msgid "\n      <placeholder-1/>\n      <placeholder-2/>\n      <placeholder-3/>; \n      <placeholder-4/>\n      <placeholder-5/>;"
msgstr ""

#: xml/plpgsql.xml:498(para)
msgid "A variable of a composite type is called a <firstterm>row</firstterm>variable (or <firstterm>row-type</firstterm>variable). Such a variable can hold a whole row of a <command>SELECT</command>or <command>FOR</command>query result, so long as that query's column set matches the declared type of the variable. The individual fields of the row value are accessed using the usual dot notation, for example <literal>rowvar.field</literal>."
msgstr ""

#: xml/plpgsql.xml:508(para)
msgid "A row variable can be declared to have the same type as the rows of an existing table or view, by using the <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>notation; or it can be declared by giving a composite type's name. (Since every table has an associated composite type of the same name, it actually does not matter in <productname>PostgreSQL</productname>whether you write <literal>%ROWTYPE</literal>or not. But the form with <literal>%ROWTYPE</literal>is more portable.)"
msgstr ""

#: xml/plpgsql.xml:518(para)
msgid "Parameters to a function can be composite types (complete table rows). In that case, the corresponding identifier <literal>$ <replaceable>n</replaceable></literal>will be a row variable, and fields can be selected from it, for example <literal>$1.user_id</literal>."
msgstr ""

#: xml/plpgsql.xml:525(para)
msgid "Only the user-defined columns of a table row are accessible in a row-type variable, not the OID or other system columns (because the row could be from a view). The fields of the row type inherit the table's field size or precision for data types such as <type>char( <replaceable>n</replaceable>)</type>."
msgstr ""

#: xml/plpgsql.xml:536(programlisting)
#, no-wrap
msgid "CREATE FUNCTION merge_fields(t_row table1)\n      RETURNS text AS $$ DECLARE t2_row table2%ROWTYPE; BEGIN\n      SELECT * INTO t2_row FROM table2 WHERE ... ; RETURN t_row.f1\n      || t2_row.f3 || t_row.f5 || t2_row.f7; END; $$ LANGUAGE\n      plpgsql; SELECT merge_fields(t.*) FROM table1 t WHERE ...\n      ;"
msgstr ""

#: xml/plpgsql.xml:532(para)
msgid "Here is an example of using composite types. <structname>table1</structname>and <structname>table2</structname>are existing tables having at least the mentioned fields: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:544(title)
msgid "Record Types"
msgstr ""

#: xml/plpgsql.xml:545(synopsis)
#, no-wrap
msgid "\n      <placeholder-1/>RECORD;"
msgstr ""

#: xml/plpgsql.xml:547(para)
msgid "Record variables are similar to row-type variables, but they have no predefined structure. They take on the actual row structure of the row they are assigned during a <command>SELECT</command>or <command>FOR</command>command. The substructure of a record variable can change each time it is assigned to. A consequence of this is that until a record variable is first assigned to, it has no substructure, and any attempt to access a field in it will draw a run-time error."
msgstr ""

#: xml/plpgsql.xml:556(para)
msgid "Note that <literal>RECORD</literal>is not a true data type, only a placeholder. One should also realize that when a <application>PL/pgSQL</application>function is declared to return type <type>record</type>, this is not quite the same concept as a record variable, even though such a function might use a record variable to hold its result. In both cases the actual row structure is unknown when the function is written, but for a function returning <type>record</type>the actual structure is determined when the calling query is parsed, whereas a record variable can change its row structure on-the-fly."
msgstr ""

#: xml/plpgsql.xml:571(title)
msgid "Collation of <application>PL/pgSQL</application>Variables"
msgstr ""

#: xml/plpgsql.xml:574(primary)
msgid "collation"
msgstr ""

#: xml/plpgsql.xml:575(secondary) xml/plpgsql.xml:790(secondary) xml/plpgsql.xml:794(secondary) xml/plpgsql.xml:1407(secondary) xml/plpgsql.xml:1411(secondary) xml/plpgsql.xml:1744(secondary) xml/plpgsql.xml:1784(secondary) xml/plpgsql.xml:1839(secondary) xml/plpgsql.xml:1878(secondary) xml/plpgsql.xml:2108(secondary) xml/plpgsql.xml:2423(secondary) xml/plpgsql.xml:2893(secondary) xml/plpgsql.xml:2897(secondary) xml/plpgsql.xml:3116(secondary) xml/plpgsql.xml:3120(secondary) xml/plpgsql.xml:3173(secondary)
msgid "in PL/pgSQL"
msgstr ""

#: xml/plpgsql.xml:588(programlisting)
#, no-wrap
msgid "CREATE FUNCTION less_than(a text, b text)\n      RETURNS boolean AS $$ BEGIN RETURN a b; END; $$ LANGUAGE\n      plpgsql; SELECT less_than(text_field_1, text_field_2) FROM\n      table1; SELECT less_than(text_field_1, text_field_2 COLLATE\n      \"C\") FROM table1;"
msgstr ""

#: xml/plpgsql.xml:577(para)
msgid "When a <application>PL/pgSQL</application>function has one or more parameters of collatable data types, a collation is identified for each function call depending on the collations assigned to the actual arguments, as described in <xref linkend=\"collation\">. If a collation is successfully identified (i.e., there are no conflicts of implicit collations among the arguments) then all the collatable parameters are treated as having that collation implicitly. This will affect the behavior of collation-sensitive operations within the function. For example, consider <placeholder-1/>The first use of <function>less_than</function>will use the common collation of <structfield>text_field_1</structfield>and <structfield>text_field_2</structfield>for the comparison, while the second use will use <literal>C</literal>collation.</xref>"
msgstr ""

#: xml/plpgsql.xml:603(programlisting)
#, no-wrap
msgid "CREATE FUNCTION less_than(a text, b text)\n      RETURNS boolean AS $$ DECLARE local_a text := a; local_b text\n      := b; BEGIN RETURN local_a local_b; END; $$ LANGUAGE\n      plpgsql;"
msgstr ""

#: xml/plpgsql.xml:599(para)
msgid "Furthermore, the identified collation is also assumed as the collation of any local variables that are of collatable types. Thus this function would not work any differently if it were written as <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:607(para)
msgid "If there are no parameters of collatable data types, or no common collation can be identified for them, then parameters and local variables use the default collation of their data type (which is usually the database's default collation, but could be different for variables of domain types)."
msgstr ""

#: xml/plpgsql.xml:617(programlisting)
#, no-wrap
msgid "DECLARE local_a text COLLATE\n      \"en_US\";"
msgstr ""

#: xml/plpgsql.xml:613(para)
msgid "A local variable of a collatable data type can have a different collation associated with it by including the <literal>COLLATE</literal>option in its declaration, for example <placeholder-1/>This option overrides the collation that would otherwise be given to the variable according to the rules above."
msgstr ""

#: xml/plpgsql.xml:625(programlisting)
#, no-wrap
msgid "CREATE FUNCTION less_than_c(a text, b text)\n      RETURNS boolean AS $$ BEGIN RETURN a b COLLATE \"C\"; END; $$\n      LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:621(para)
msgid "Also, of course explicit <literal>COLLATE</literal>clauses can be written inside a function if it is desired to force a particular collation to be used in a particular operation. For example, <placeholder-1/>This overrides the collations associated with the table columns, parameters, or local variables used in the expression, just as would happen in a plain SQL command."
msgstr ""

#: xml/plpgsql.xml:634(title)
msgid "Expressions"
msgstr ""

#: xml/plpgsql.xml:660(programlisting)
#, no-wrap
msgid "IF x y THEN ..."
msgstr ""

#: xml/plpgsql.xml:662(programlisting)
#, no-wrap
msgid "PREPARE \n    <replaceable>statement_name</replaceable>(integer, integer) AS\n    SELECT $1 $2;"
msgstr ""

#: xml/plpgsql.xml:635(para)
msgid "All expressions used in <application>PL/pgSQL</application>statements are processed using the server's main <acronym>SQL</acronym>executor. For example, when you write a <application>PL/pgSQL</application>statement like <synopsis>IF \n    <replaceable>expression</replaceable>THEN ...</synopsis><application>PL/pgSQL</application>will evaluate the expression by feeding a query like <synopsis>SELECT \n    <replaceable>expression</replaceable></synopsis>to the main SQL engine. While forming the <command>SELECT</command>command, any occurrences of <application>PL/pgSQL</application>variable names are replaced by parameters, as discussed in detail in <xref linkend=\"plpgsql-var-subst\">. This allows the query plan for the <command>SELECT</command>to be prepared just once and then reused for subsequent evaluations with different values of the variables. Thus, what really happens on first use of an expression is essentially a <command>PREPARE</command>command. For example, if we have declared two integer variables <literal>x</literal>and <literal>y</literal>, and we write <placeholder-1/>what happens behind the scenes is equivalent to <placeholder-2/>and then this prepared statement is <command>EXECUTE</command>d for each execution of the <command>IF</command>statement, with the current values of the <application>PL/pgSQL</application>variables supplied as parameter values. Normally these details are not important to a <application>PL/pgSQL</application>user, but they are useful to know when trying to diagnose a problem. More information appears in <xref linkend=\"plpgsql-plan-caching\">.</xref></xref>"
msgstr ""

#: xml/plpgsql.xml:677(title)
msgid "Basic Statements"
msgstr ""

#: xml/plpgsql.xml:678(para)
msgid "In this section and the following ones, we describe all the statement types that are explicitly understood by <application>PL/pgSQL</application>. Anything not recognized as one of these statement types is presumed to be an SQL command and is sent to the main database engine to execute, as described in <xref linkend=\"plpgsql-statements-sql-noresult\">and <xref linkend=\"plpgsql-statements-sql-onerow\"> .</xref></xref>"
msgstr ""

#: xml/plpgsql.xml:688(title)
msgid "Assignment"
msgstr ""

#: xml/plpgsql.xml:689(para)
msgid "An assignment of a value to a <application>PL/pgSQL</application>variable is written as: <synopsis>\n      <replaceable>variable</replaceable>{ := | = } \n      <replaceable>expression</replaceable>;</synopsis>As explained previously, the expression in such a statement is evaluated by means of an SQL <command>SELECT</command>command sent to the main database engine. The expression must yield a single value (possibly a row value, if the variable is a row or record variable). The target variable can be a simple variable (optionally qualified with a block name), a field of a row or record variable, or an element of an array that is a simple variable or field. Equal ( <literal>=</literal>) can be used instead of PL/SQL-compliant <literal>:=</literal>."
msgstr ""

#: xml/plpgsql.xml:706(para)
msgid "If the expression's result data type doesn't match the variable's data type, the value will be coerced as though by an assignment cast (see <xref linkend=\"typeconv-query\">). If no assignment cast is known for the pair of data types involved, the <application>PL/pgSQL</application>interpreter will attempt to convert the result value textually, that is by applying the result type's output function followed by the variable type's input function. Note that this could result in run-time errors generated by the input function, if the string form of the result value is not acceptable to the input function.</xref>"
msgstr ""

#: xml/plpgsql.xml:719(programlisting)
#, no-wrap
msgid "tax := subtotal * 0.06; my_record.user_id :=\n      20;"
msgstr ""

#: xml/plpgsql.xml:723(title)
msgid "Executing a Command With No Result"
msgstr ""

#: xml/plpgsql.xml:724(para)
msgid "For any SQL command that does not return rows, for example <command>INSERT</command>without a <literal>RETURNING</literal>clause, you can execute the command within a <application>PL/pgSQL</application>function just by writing the command."
msgstr ""

#: xml/plpgsql.xml:731(para)
msgid "Any <application>PL/pgSQL</application>variable name appearing in the command text is treated as a parameter, and then the current value of the variable is provided as the parameter value at run time. This is exactly like the processing described earlier for expressions; for details see <xref linkend=\"plpgsql-var-subst\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:738(para)
msgid "When executing a SQL command in this way, <application>PL/pgSQL</application>may cache and re-use the execution plan for the command, as discussed in <xref linkend=\"plpgsql-plan-caching\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:742(para)
msgid "Sometimes it is useful to evaluate an expression or <command>SELECT</command>query but discard the result, for example when calling a function that has side-effects but no useful result value. To do this in <application>PL/pgSQL</application>, use the <command>PERFORM</command>statement: <synopsis>PERFORM \n      <replaceable>query</replaceable>;</synopsis>This executes <replaceable>query</replaceable>and discards the result. Write the <replaceable>query</replaceable>the same way you would write an SQL <command>SELECT</command>command, but replace the initial keyword <command>SELECT</command>with <command>PERFORM</command>. For <command>WITH</command>queries, use <command>PERFORM</command>and then place the query in parentheses. (In this case, the query can only return one row.) <application>PL/pgSQL</application>variables will be substituted into the query just as for commands that return no result, and the plan is cached in the same way. Also, the special variable <literal>FOUND</literal>is set to true if the query produced at least one row, or false if it produced no rows (see <xref linkend=\"plpgsql-statements-diagnostics\"> ).</xref>"
msgstr ""

#: xml/plpgsql.xml:771(para)
msgid "One might expect that writing <command>SELECT</command>directly would accomplish this result, but at present the only accepted way to do it is <command>PERFORM</command>. A SQL command that can return rows, such as <command>SELECT</command>, will be rejected as an error unless it has an <literal>INTO</literal>clause as discussed in the next section."
msgstr ""

#: xml/plpgsql.xml:782(programlisting)
#, no-wrap
msgid "PERFORM\n      create_mv('cs_session_page_requests_mv',\n      my_query);"
msgstr ""

#: xml/plpgsql.xml:781(para) xml/plpgsql.xml:1239(para) xml/plpgsql.xml:2534(para) xml/plpgsql.xml:2766(para) xml/plpgsql.xml:2781(para)
msgid "An example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:787(title)
msgid "Executing a Query with a Single-row Result"
msgstr ""

#: xml/plpgsql.xml:789(primary)
msgid "SELECT INTO"
msgstr ""

#: xml/plpgsql.xml:793(primary)
msgid "RETURNING INTO"
msgstr ""

#: xml/plpgsql.xml:796(para)
msgid "The result of a SQL command yielding a single row (possibly of multiple columns) can be assigned to a record variable, row-type variable, or list of scalar variables. This is done by writing the base SQL command and adding an <literal>INTO</literal>clause. For example, <synopsis>SELECT \n      <replaceable>select_expressions</replaceable>INTO \n      <optional>STRICT</optional>\n      <replaceable>target</replaceable>FROM ...; INSERT ...\n      RETURNING \n      <replaceable>expressions</replaceable>INTO \n      <optional>STRICT</optional>\n      <replaceable>target</replaceable>; UPDATE ... RETURNING \n      <replaceable>expressions</replaceable>INTO \n      <optional>STRICT</optional>\n      <replaceable>target</replaceable>; DELETE ... RETURNING \n      <replaceable>expressions</replaceable>INTO \n      <optional>STRICT</optional>\n      <replaceable>target</replaceable>;</synopsis>where <replaceable>target</replaceable>can be a record variable, a row variable, or a comma-separated list of simple variables and record/row fields. <application>PL/pgSQL</application>variables will be substituted into the rest of the query, and the plan is cached, just as described above for commands that do not return rows. This works for <command>SELECT</command>, <command>INSERT</command>/ <command>UPDATE</command>/ <command>DELETE</command>with <literal>RETURNING</literal>, and utility commands that return row-set results (such as <command>EXPLAIN</command>). Except for the <literal>INTO</literal>clause, the SQL command is the same as it would be written outside <application>PL/pgSQL</application>."
msgstr ""

#: xml/plpgsql.xml:833(para)
msgid "Note that this interpretation of <command>SELECT</command>with <literal>INTO</literal>is quite different from <productname>PostgreSQL</productname>'s regular <command>SELECT INTO</command>command, wherein the <literal>INTO</literal>target is a newly created table. If you want to create a table from a <command>SELECT</command>result inside a <application>PL/pgSQL</application>function, use the syntax <command>CREATE TABLE ... AS SELECT</command>."
msgstr ""

#: xml/plpgsql.xml:845(para)
msgid "If a row or a variable list is used as target, the query's result columns must exactly match the structure of the target as to number and data types, or else a run-time error occurs. When a record variable is the target, it automatically configures itself to the row type of the query result columns."
msgstr ""

#: xml/plpgsql.xml:851(para)
msgid "The <literal>INTO</literal>clause can appear almost anywhere in the SQL command. Customarily it is written either just before or just after the list of <replaceable>select_expressions</replaceable>in a <command>SELECT</command>command, or at the end of the command for other command types. It is recommended that you follow this convention in case the <application>PL/pgSQL</application>parser becomes stricter in future versions."
msgstr ""

#: xml/plpgsql.xml:874(programlisting)
#, no-wrap
msgid "SELECT * INTO myrec FROM emp WHERE empname =\n      myname; IF NOT FOUND THEN RAISE EXCEPTION 'employee % not\n      found', myname; END IF;"
msgstr ""

#: xml/plpgsql.xml:884(programlisting)
#, no-wrap
msgid "BEGIN SELECT * INTO STRICT myrec FROM emp\n      WHERE empname = myname; EXCEPTION WHEN NO_DATA_FOUND THEN\n      RAISE EXCEPTION 'employee % not found', myname; WHEN\n      TOO_MANY_ROWS THEN RAISE EXCEPTION 'employee % not unique',\n      myname; END;"
msgstr ""

#: xml/plpgsql.xml:861(para)
msgid "If <literal>STRICT</literal>is not specified in the <literal>INTO</literal>clause, then <replaceable>target</replaceable>will be set to the first row returned by the query, or to nulls if the query returned no rows. (Note that <quote>the first row</quote>is not well-defined unless you've used <literal>ORDER BY</literal>.) Any result rows after the first row are discarded. You can check the special <literal>FOUND</literal>variable (see <xref linkend=\"plpgsql-statements-diagnostics\">) to determine whether a row was returned: <placeholder-1/>If the <literal>STRICT</literal>option is specified, the query must return exactly one row or a run-time error will be reported, either <literal>NO_DATA_FOUND</literal>(no rows) or <literal>TOO_MANY_ROWS</literal>(more than one row). You can use an exception block if you wish to catch the error, for example: <placeholder-2/>Successful execution of a command with <literal>STRICT</literal>always sets <literal>FOUND</literal>to true.</xref>"
msgstr ""

#: xml/plpgsql.xml:892(para)
msgid "For <command>INSERT</command>/ <command>UPDATE</command>/ <command>DELETE</command>with <literal>RETURNING</literal>, <application>PL/pgSQL</application>reports an error for more than one returned row, even when <literal>STRICT</literal>is not specified. This is because there is no option such as <literal>ORDER BY</literal>with which to determine which affected row should be returned."
msgstr ""

#: xml/plpgsql.xml:917(programlisting)
#, no-wrap
msgid "CREATE FUNCTION get_userid(username text)\n      RETURNS int AS $$ #print_strict_params on DECLARE userid int;\n      BEGIN SELECT users.userid INTO STRICT userid FROM users WHERE\n      users.username = get_userid.username; RETURN userid; END $$\n      LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:923(programlisting)
#, no-wrap
msgid "ERROR: query returned no rows DETAIL:\n      parameters: $1 = 'nosuchuser' CONTEXT: PL/pgSQL function\n      get_userid(text) line 6 at SQL\n      statement"
msgstr ""

#: xml/plpgsql.xml:903(para)
msgid "If <literal>print_strict_params</literal>is enabled for the function, then when an error is thrown because the requirements of <literal>STRICT</literal>are not met, the <literal>DETAIL</literal>part of the error message will include information about the parameters passed to the query. You can change the <literal>print_strict_params</literal>setting for all functions by setting <varname>plpgsql.print_strict_params</varname>, though only subsequent function compilations will be affected. You can also enable it on a per-function basis by using a compiler option, for example: <placeholder-1/>On failure, this function might produce an error message such as <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:928(para)
msgid "The <literal>STRICT</literal>option matches the behavior of Oracle PL/SQL's <command>SELECT INTO</command>and related statements."
msgstr ""

#: xml/plpgsql.xml:934(para)
msgid "To handle cases where you need to process multiple result rows from a SQL query, see <xref linkend=\"plpgsql-records-iterating\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:939(title)
msgid "Executing Dynamic Commands"
msgstr ""

#: xml/plpgsql.xml:940(para)
msgid "Oftentimes you will want to generate dynamic commands inside your <application>PL/pgSQL</application>functions, that is, commands that will involve different tables or different data types each time they are executed. <application>PL/pgSQL</application>'s normal attempts to cache plans for commands (as discussed in <xref linkend=\"plpgsql-plan-caching\">) will not work in such scenarios. To handle this sort of problem, the <command>EXECUTE</command>statement is provided: <synopsis>EXECUTE \n      <replaceable class=\"command\">command-string</replaceable>\n      <optional>INTO \n      <optional>STRICT</optional>\n      <replaceable>target</replaceable></optional>\n      <optional>USING \n      <replaceable>expression</replaceable>\n      <optional>, ...</optional></optional>;</synopsis>where <replaceable>command-string</replaceable>is an expression yielding a string (of type <type>text</type>) containing the command to be executed. The optional <replaceable>target</replaceable>is a record variable, a row variable, or a comma-separated list of simple variables and record/row fields, into which the results of the command will be stored. The optional <literal>USING</literal>expressions supply values to be inserted into the command.</xref>"
msgstr ""

#: xml/plpgsql.xml:968(para)
msgid "No substitution of <application>PL/pgSQL</application>variables is done on the computed command string. Any required variable values must be inserted in the command string as it is constructed; or you can use parameters as described below."
msgstr ""

#: xml/plpgsql.xml:973(para)
msgid "Also, there is no plan caching for commands executed via <command>EXECUTE</command>. Instead, the command is always planned each time the statement is run. Thus the command string can be dynamically created within the function to perform actions on different tables and columns."
msgstr ""

#: xml/plpgsql.xml:979(para)
msgid "The <literal>INTO</literal>clause specifies where the results of a SQL command returning rows should be assigned. If a row or variable list is provided, it must exactly match the structure of the query's results (when a record variable is used, it will configure itself to match the result structure automatically). If multiple rows are returned, only the first will be assigned to the <literal>INTO</literal>variable. If no rows are returned, NULL is assigned to the <literal>INTO</literal>variable(s). If no <literal>INTO</literal>clause is specified, the query results are discarded."
msgstr ""

#: xml/plpgsql.xml:992(para)
msgid "If the <literal>STRICT</literal>option is given, an error is reported unless the query produces exactly one row."
msgstr ""

#: xml/plpgsql.xml:1006(programlisting)
#, no-wrap
msgid "EXECUTE 'SELECT count(*) FROM mytable WHERE\n      inserted_by = $1 AND inserted = $2' INTO c USING\n      checked_user, checked_date;"
msgstr ""

#: xml/plpgsql.xml:995(para)
msgid "The command string can use parameter values, which are referenced in the command as <literal>$1</literal>, <literal>$2</literal>, etc. These symbols refer to values supplied in the <literal>USING</literal>clause. This method is often preferable to inserting data values into the command string as text: it avoids run-time overhead of converting the values to text and back, and it is much less prone to SQL-injection attacks since there is no need for quoting or escaping. An example is: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1015(programlisting)
#, no-wrap
msgid "EXECUTE 'SELECT count(*) FROM ' ||\n      quote_ident(tabname) || ' WHERE inserted_by = $1 AND inserted\n      = $2' INTO c USING checked_user,\n      checked_date;"
msgstr ""

#: xml/plpgsql.xml:1022(programlisting)
#, no-wrap
msgid "EXECUTE format('SELECT count(*) FROM %I '\n      'WHERE inserted_by = $1 AND inserted = $2', tabname) INTO c\n      USING checked_user, checked_date;"
msgstr ""

#: xml/plpgsql.xml:1009(para)
msgid "Note that parameter symbols can only be used for data values if you want to use dynamically determined table or column names, you must insert them into the command string textually. For example, if the preceding query needed to be done against a dynamically selected table, you could do this: <placeholder-1/>A cleaner approach is to use <function>format()</function>'s <literal>%I</literal>specification for table or column names (strings separated by a newline are concatenated): <placeholder-2/>Another restriction on parameter symbols is that they only work in <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command>commands. In other statement types (generically called utility statements), you must insert values textually even if they are just data values."
msgstr ""

#: xml/plpgsql.xml:1032(para)
msgid "An <command>EXECUTE</command>with a simple constant command string and some <literal>USING</literal>parameters, as in the first example above, is functionally equivalent to just writing the command directly in <application>PL/pgSQL</application>and allowing replacement of <application>PL/pgSQL</application>variables to happen automatically. The important difference is that <command>EXECUTE</command>will re-plan the command on each execution, generating a plan that is specific to the current parameter values; whereas <application>PL/pgSQL</application>may otherwise create a generic plan and cache it for re-use. In situations where the best plan depends strongly on the parameter values, it can be helpful to use <command>EXECUTE</command>to positively ensure that a generic plan is not selected."
msgstr ""

#: xml/plpgsql.xml:1051(para)
msgid "<command>SELECT INTO</command>is not currently supported within <command>EXECUTE</command>; instead, execute a plain <command>SELECT</command>command and specify <literal>INTO</literal>as part of the <command>EXECUTE</command>itself."
msgstr ""

#: xml/plpgsql.xml:1059(para)
msgid "The <application>PL/pgSQL</application><command>EXECUTE</command>statement is not related to the <xref linkend=\"sql-execute\">SQL statement supported by the <productname>PostgreSQL</productname>server. The server's <command>EXECUTE</command>statement cannot be used directly within <application>PL/pgSQL</application>functions (and is not needed).</xref>"
msgstr ""

#: xml/plpgsql.xml:1070(title)
msgid "Quoting Values In Dynamic Queries"
msgstr ""

#: xml/plpgsql.xml:1072(primary)
msgid "quote_ident"
msgstr ""

#: xml/plpgsql.xml:1073(secondary) xml/plpgsql.xml:1077(secondary) xml/plpgsql.xml:1081(secondary) xml/plpgsql.xml:1085(secondary)
msgid "use in PL/pgSQL"
msgstr ""

#: xml/plpgsql.xml:1076(primary)
msgid "quote_literal"
msgstr ""

#: xml/plpgsql.xml:1080(primary)
msgid "quote_nullable"
msgstr ""

#: xml/plpgsql.xml:1084(primary)
msgid "format"
msgstr ""

#: xml/plpgsql.xml:1087(para)
msgid "When working with dynamic commands you will often have to handle escaping of single quotes. The recommended method for quoting fixed text in your function body is dollar quoting. (If you have legacy code that does not use dollar quoting, please refer to the overview in <xref linkend=\"plpgsql-quote-tips\">, which can save you some effort when translating said code to a more reasonable scheme.)</xref>"
msgstr ""

#: xml/plpgsql.xml:1100(programlisting)
#, no-wrap
msgid "EXECUTE format('UPDATE tbl SET %I = $1 '\n        'WHERE key = $2', colname) USING newvalue,\n        keyvalue;"
msgstr ""

#: xml/plpgsql.xml:1104(programlisting)
#, no-wrap
msgid "EXECUTE 'UPDATE tbl SET ' ||\n        quote_ident(colname) || ' = ' || quote_literal(newvalue) ||\n        ' WHERE key = ' ||\n        quote_literal(keyvalue);"
msgstr ""

#: xml/plpgsql.xml:1095(para)
msgid "Dynamic values require careful handling since they might contain quote characters. An example using <function>format()</function>(this assumes that you are dollar quoting the function body so quote marks need not be doubled): <placeholder-1/>It is also possible to call the quoting functions directly: <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:1108(para)
msgid "This example demonstrates the use of the <function>quote_ident</function>and <function>quote_literal</function>functions (see <xref linkend=\"functions-string\">). For safety, expressions containing column or table identifiers should be passed through <function>quote_ident</function>before insertion in a dynamic query. Expressions containing values that should be literal strings in the constructed command should be passed through <function>quote_literal</function>. These functions take the appropriate steps to return the input text enclosed in double or single quotes respectively, with any embedded special characters properly escaped.</xref>"
msgstr ""

#: xml/plpgsql.xml:1136(programlisting)
#, no-wrap
msgid "EXECUTE 'UPDATE tbl SET ' ||\n        quote_ident(colname) || ' = ' || quote_nullable(newvalue)\n        || ' WHERE key = ' ||\n        quote_nullable(keyvalue);"
msgstr ""

#: xml/plpgsql.xml:1122(para)
msgid "Because <function>quote_literal</function>is labeled <literal>STRICT</literal>, it will always return null when called with a null argument. In the above example, if <literal>newvalue</literal>or <literal>keyvalue</literal>were null, the entire dynamic query string would become null, leading to an error from <command>EXECUTE</command>. You can avoid this problem by using the <function>quote_nullable</function>function, which works the same as <function>quote_literal</function>except that when called with a null argument it returns the string <literal>NULL</literal>. For example, <placeholder-1/>If you are dealing with values that might be null, you should usually use <function>quote_nullable</function>in place of <function>quote_literal</function>."
msgstr ""

#: xml/plpgsql.xml:1148(programlisting)
#, no-wrap
msgid "'WHERE key = ' ||\n        quote_nullable(keyvalue)"
msgstr ""

#: xml/plpgsql.xml:1156(programlisting)
#, no-wrap
msgid "'WHERE key IS NOT DISTINCT FROM ' ||\n        quote_nullable(keyvalue)"
msgstr ""

#: xml/plpgsql.xml:1144(para)
msgid "As always, care must be taken to ensure that null values in a query do not deliver unintended results. For example the <literal>WHERE</literal>clause <placeholder-1/>will never succeed if <literal>keyvalue</literal>is null, because the result of using the equality operator <literal>=</literal>with a null operand is always null. If you wish null to work like an ordinary key value, you would need to rewrite the above as <placeholder-2/>(At present, <literal>IS NOT DISTINCT FROM</literal>is handled much less efficiently than <literal>=</literal>, so don't do this unless you must. See <xref linkend=\"functions-comparison\">for more information on nulls and <literal>IS DISTINCT</literal>.)</xref>"
msgstr ""

#: xml/plpgsql.xml:1168(programlisting)
#, no-wrap
msgid "EXECUTE 'UPDATE tbl SET ' ||\n        quote_ident(colname) || ' = $$' || newvalue || '$$ WHERE\n        key = ' || quote_literal(keyvalue);"
msgstr ""

#: xml/plpgsql.xml:1165(para)
msgid "Note that dollar quoting is only useful for quoting fixed text. It would be a very bad idea to try to write this example as: <placeholder-1/>because it would break if the contents of <literal>newvalue</literal>happened to contain <literal>$$</literal>. The same objection would apply to any other dollar-quoting delimiter you might pick. So, to safely quote text that is not known in advance, you <emphasis>must</emphasis>use <function>quote_literal</function>, <function>quote_nullable</function>, or <function>quote_ident</function>, as appropriate."
msgstr ""

#: xml/plpgsql.xml:1184(programlisting)
#, no-wrap
msgid "EXECUTE format('UPDATE tbl SET %I = %L '\n        'WHERE key = %L', colname, newvalue,\n        keyvalue);"
msgstr ""

#: xml/plpgsql.xml:1194(programlisting)
#, no-wrap
msgid "EXECUTE format('UPDATE tbl SET %I = $1\n        WHERE key = $2', colname) USING newvalue,\n        keyvalue;"
msgstr ""

#: xml/plpgsql.xml:1180(para)
msgid "Dynamic SQL statements can also be safely constructed using the <function>format</function>function (see <xref linkend=\"functions-string\">). For example: <placeholder-1/><literal>%I</literal>is equivalent to <function>quote_ident</function>, and <literal>%L</literal>is equivalent to <function>quote_nullable</function>. The <function>format</function>function can be used in conjunction with the <literal>USING</literal>clause: <placeholder-2/>This form is better because the variables are handled in their native data type format, rather than unconditionally converting them to text and quoting them via <literal>%L</literal>. It is also more efficient.</xref>"
msgstr ""

#: xml/plpgsql.xml:1203(para)
msgid "A much larger example of a dynamic command and <command>EXECUTE</command>can be seen in <xref linkend=\"plpgsql-porting-ex2\">, which builds and executes a <command>CREATE FUNCTION</command>command to define a new function.</xref>"
msgstr ""

#: xml/plpgsql.xml:1211(title)
msgid "Obtaining the Result Status"
msgstr ""

#: xml/plpgsql.xml:1212(para)
msgid "There are several ways to determine the effect of a command. The first method is to use the <command>GET DIAGNOSTICS</command>command, which has the form: <synopsis>GET \n      <optional>CURRENT</optional>DIAGNOSTICS \n      <replaceable>variable</replaceable>{ = | := } \n      <replaceable>item</replaceable>\n      <optional>, ...</optional>;</synopsis>This command allows retrieval of system status indicators. Each <replaceable>item</replaceable>is a key word identifying a status value to be assigned to the specified variable (which should be of the right data type to receive it). The currently available status items are <varname>ROW_COUNT</varname>, the number of rows processed by the last <acronym>SQL</acronym>command sent to the <acronym>SQL</acronym>engine, and <varname>RESULT_OID</varname>, the OID of the last row inserted by the most recent <acronym>SQL</acronym>command. Note that <varname>RESULT_OID</varname>is only useful after an <command>INSERT</command>command into a table containing OIDs. Colon-equal ( <literal>:=</literal>) can be used instead of SQL-standard <literal>=</literal>for <command>GET DIAGNOSTICS</command>."
msgstr ""

#: xml/plpgsql.xml:1240(programlisting)
#, no-wrap
msgid "GET DIAGNOSTICS integer_var =\n      ROW_COUNT;"
msgstr ""

#: xml/plpgsql.xml:1251(para)
msgid "A <command>SELECT INTO</command>statement sets <literal>FOUND</literal>true if a row is assigned, false if no row is returned."
msgstr ""

#: xml/plpgsql.xml:1257(para)
msgid "A <command>PERFORM</command>statement sets <literal>FOUND</literal>true if it produces (and discards) one or more rows, false if no row is produced."
msgstr ""

#: xml/plpgsql.xml:1264(para)
msgid "<command>UPDATE</command>, <command>INSERT</command>, and <command>DELETE</command>statements set <literal>FOUND</literal>true if at least one row is affected, false if no row is affected."
msgstr ""

#: xml/plpgsql.xml:1272(para)
msgid "A <command>FETCH</command>statement sets <literal>FOUND</literal>true if it returns a row, false if no row is returned."
msgstr ""

#: xml/plpgsql.xml:1278(para)
msgid "A <command>MOVE</command>statement sets <literal>FOUND</literal>true if it successfully repositions the cursor, false otherwise."
msgstr ""

#: xml/plpgsql.xml:1284(para)
msgid "A <command>FOR</command>or <command>FOREACH</command>statement sets <literal>FOUND</literal>true if it iterates one or more times, else false. <literal>FOUND</literal>is set this way when the loop exits; inside the execution of the loop, <literal>FOUND</literal>is not modified by the loop statement, although it might be changed by the execution of other statements within the loop body."
msgstr ""

#: xml/plpgsql.xml:1296(para)
msgid "<command>RETURN QUERY</command>and <command>RETURN QUERY EXECUTE</command>statements set <literal>FOUND</literal>true if the query returns at least one row, false if no row is returned."
msgstr ""

#: xml/plpgsql.xml:1242(para)
msgid "The second method to determine the effects of a command is to check the special variable named <literal>FOUND</literal>, which is of type <type>boolean</type>. <literal>FOUND</literal>starts out false within each <application>PL/pgSQL</application>function call. It is set by each of the following types of statements: <placeholder-1/>Other <application>PL/pgSQL</application>statements do not change the state of <literal>FOUND</literal>. Note in particular that <command>EXECUTE</command>changes the output of <command>GET DIAGNOSTICS</command>, but does not change <literal>FOUND</literal>."
msgstr ""

#: xml/plpgsql.xml:1309(para)
msgid "<literal>FOUND</literal>is a local variable within each <application>PL/pgSQL</application>function; any changes to it affect only the current function."
msgstr ""

#: xml/plpgsql.xml:1315(title)
msgid "Doing Nothing At All"
msgstr ""

#: xml/plpgsql.xml:1316(para)
msgid "Sometimes a placeholder statement that does nothing is useful. For example, it can indicate that one arm of an if/then/else chain is deliberately empty. For this purpose, use the <command>NULL</command>statement: <synopsis>NULL;</synopsis>"
msgstr ""

#: xml/plpgsql.xml:1324(programlisting)
#, no-wrap
msgid "BEGIN y := x / 0; EXCEPTION WHEN\n      division_by_zero THEN NULL; -- ignore the error\n      END;"
msgstr ""

#: xml/plpgsql.xml:1327(programlisting)
#, no-wrap
msgid "BEGIN y := x / 0; EXCEPTION WHEN\n      division_by_zero THEN -- ignore the error\n      END;"
msgstr ""

#: xml/plpgsql.xml:1322(para)
msgid "For example, the following two fragments of code are equivalent: <placeholder-1/><placeholder-2/>Which is preferable is a matter of taste."
msgstr ""

#: xml/plpgsql.xml:1332(para)
msgid "In Oracle's PL/SQL, empty statement lists are not allowed, and so <command>NULL</command>statements are <emphasis>required</emphasis>for situations such as this. <application>PL/pgSQL</application>allows you to just write nothing, instead."
msgstr ""

#: xml/plpgsql.xml:1342(title)
msgid "Control Structures"
msgstr ""

#: xml/plpgsql.xml:1343(para)
msgid "Control structures are probably the most useful (and important) part of <application>PL/pgSQL</application>. With <application>PL/pgSQL</application>'s control structures, you can manipulate <productname>PostgreSQL</productname>data in a very flexible and powerful way."
msgstr ""

#: xml/plpgsql.xml:1351(title)
msgid "Returning From a Function"
msgstr ""

#: xml/plpgsql.xml:1352(para)
msgid "There are two commands available that allow you to return data from a function: <command>RETURN</command>and <command>RETURN NEXT</command>."
msgstr ""

#: xml/plpgsql.xml:1358(command)
msgid "RETURN"
msgstr ""

#: xml/plpgsql.xml:1361(replaceable) xml/plpgsql.xml:1414(replaceable) xml/plpgsql.xml:1418(replaceable) xml/plpgsql.xml:1661(replaceable) xml/plpgsql.xml:1663(replaceable) xml/plpgsql.xml:1667(replaceable) xml/plpgsql.xml:1669(replaceable) xml/plpgsql.xml:1910(replaceable) xml/plpgsql.xml:1911(replaceable) xml/plpgsql.xml:1913(replaceable) xml/plpgsql.xml:2548(replaceable)
msgid "expression"
msgstr ""

#: xml/plpgsql.xml:1360(synopsis)
#, no-wrap
msgid "RETURN \n        <placeholder-1/>;"
msgstr ""

#: xml/plpgsql.xml:1362(para)
msgid "<command>RETURN</command>with an expression terminates the function and returns the value of <replaceable>expression</replaceable>to the caller. This form is used for <application>PL/pgSQL</application>functions that do not return a set."
msgstr ""

#: xml/plpgsql.xml:1369(para)
msgid "In a function that returns a scalar type, the expression's result will automatically be cast into the function's return type as described for assignments. But to return a composite (row) value, you must write an expression delivering exactly the requested column set. This may require use of explicit casting."
msgstr ""

#: xml/plpgsql.xml:1375(para)
msgid "If you declared the function with output parameters, write just <command>RETURN</command>with no expression. The current values of the output parameter variables will be returned."
msgstr ""

#: xml/plpgsql.xml:1380(para)
msgid "If you declared the function to return <type>void</type>, a <command>RETURN</command>statement can be used to exit the function early; but do not write an expression following <command>RETURN</command>."
msgstr ""

#: xml/plpgsql.xml:1385(para)
msgid "The return value of a function cannot be left undefined. If control reaches the end of the top-level block of the function without hitting a <command>RETURN</command>statement, a run-time error will occur. This restriction does not apply to functions with output parameters and functions returning <type>void</type>, however. In those cases a <command>RETURN</command>statement is automatically executed if the top-level block finishes."
msgstr ""

#: xml/plpgsql.xml:1395(programlisting)
#, no-wrap
msgid "-- functions returning a scalar type RETURN\n        1 + 2; RETURN scalar_var; -- functions returning a\n        composite type RETURN composite_type_var; RETURN (1, 2,\n        'three'::text); -- must cast columns to correct\n        types"
msgstr ""

#: xml/plpgsql.xml:1394(para)
msgid "Some examples: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1402(title)
msgid "<command>RETURN NEXT</command>and <command>RETURN QUERY</command>"
msgstr ""

#: xml/plpgsql.xml:1406(primary)
msgid "RETURN NEXT"
msgstr ""

#: xml/plpgsql.xml:1410(primary)
msgid "RETURN QUERY"
msgstr ""

#: xml/plpgsql.xml:1415(replaceable) xml/plpgsql.xml:2506(replaceable) xml/plpgsql.xml:2512(replaceable)
msgid "query"
msgstr ""

#: xml/plpgsql.xml:1416(replaceable)
msgid "command-string"
msgstr ""

#: xml/plpgsql.xml:1419(optional) xml/plpgsql.xml:2397(optional) xml/plpgsql.xml:2549(optional) xml/plpgsql.xml:2587(optional)
msgid ", ..."
msgstr ""

#: xml/plpgsql.xml:1417(optional) xml/plpgsql.xml:2547(optional)
msgid "USING <placeholder-1/><placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:1413(synopsis)
#, no-wrap
msgid "RETURN NEXT \n        <placeholder-1/>; RETURN QUERY \n        <placeholder-2/>; RETURN QUERY EXECUTE \n        <placeholder-3/>\n        <placeholder-4/>;"
msgstr ""

#: xml/plpgsql.xml:1420(para)
msgid "When a <application>PL/pgSQL</application>function is declared to return <literal>SETOF <replaceable>sometype</replaceable></literal>, the procedure to follow is slightly different. In that case, the individual items to return are specified by a sequence of <command>RETURN NEXT</command>or <command>RETURN QUERY</command>commands, and then a final <command>RETURN</command>command with no argument is used to indicate that the function has finished executing. <command>RETURN NEXT</command>can be used with both scalar and composite data types; with a composite result type, an entire <quote>table</quote>of results will be returned. <command>RETURN QUERY</command>appends the results of executing a query to the function's result set. <command>RETURN NEXT</command>and <command>RETURN QUERY</command>can be freely intermixed in a single set-returning function, in which case their results will be concatenated."
msgstr ""

#: xml/plpgsql.xml:1442(para)
msgid "<command>RETURN NEXT</command>and <command>RETURN QUERY</command>do not actually return from the function they simply append zero or more rows to the function's result set. Execution then continues with the next statement in the <application>PL/pgSQL</application>function. As successive <command>RETURN NEXT</command>or <command>RETURN QUERY</command>commands are executed, the result set is built up. A final <command>RETURN</command>, which should have no argument, causes control to exit the function (or you can just let control reach the end of the function)."
msgstr ""

#: xml/plpgsql.xml:1455(para)
msgid "<command>RETURN QUERY</command>has a variant <command>RETURN QUERY EXECUTE</command>, which specifies the query to be executed dynamically. Parameter expressions can be inserted into the computed query string via <literal>USING</literal>, in just the same way as in the <command>EXECUTE</command>command."
msgstr ""

#: xml/plpgsql.xml:1462(para)
msgid "If you declared the function with output parameters, write just <command>RETURN NEXT</command>with no expression. On each execution, the current values of the output parameter variable(s) will be saved for eventual return as a row of the result. Note that you must declare the function as returning <literal>SETOF record</literal>when there are multiple output parameters, or <literal>SETOF <replaceable>sometype</replaceable></literal>when there is just one output parameter of type <replaceable>sometype</replaceable>, in order to create a set-returning function with output parameters."
msgstr ""

#: xml/plpgsql.xml:1478(programlisting)
#, no-wrap
msgid "CREATE TABLE foo (fooid INT, foosubid INT,\n        fooname TEXT); INSERT INTO foo VALUES (1, 2, 'three');\n        INSERT INTO foo VALUES (4, 5, 'six'); CREATE OR REPLACE\n        FUNCTION get_all_foo() RETURNS SETOF foo AS $BODY$ DECLARE\n        r foo%rowtype; BEGIN FOR r IN SELECT * FROM foo WHERE fooid\n        0 LOOP -- can do some processing here RETURN NEXT r; --\n        return current row of SELECT END LOOP; RETURN; END $BODY$\n        LANGUAGE plpgsql; SELECT * FROM\n        get_all_foo();"
msgstr ""

#: xml/plpgsql.xml:1476(para)
msgid "Here is an example of a function using <command>RETURN NEXT</command>: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1489(programlisting)
#, no-wrap
msgid "CREATE FUNCTION\n        get_available_flightid(date) RETURNS SETOF integer AS\n        $BODY$ BEGIN RETURN QUERY SELECT flightid FROM flight WHERE\n        flightdate &gt;= $1 AND flightdate &lt; ($1 + 1); -- Since\n        execution is not finished, we can check whether rows were\n        returned -- and raise exception if not. IF NOT FOUND THEN\n        RAISE EXCEPTION 'No flight at %.', $1; END IF; RETURN; END\n        $BODY$ LANGUAGE plpgsql; -- Returns available flights or\n        raises exception if there are no -- available flights.\n        SELECT * FROM\n        get_available_flightid(CURRENT_DATE);"
msgstr ""

#: xml/plpgsql.xml:1487(para)
msgid "Here is an example of a function using <command>RETURN QUERY</command>: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1501(para)
msgid "The current implementation of <command>RETURN NEXT</command>and <command>RETURN QUERY</command>stores the entire result set before returning from the function, as discussed above. That means that if a <application>PL/pgSQL</application>function produces a very large result set, performance might be poor: data will be written to disk to avoid memory exhaustion, but the function itself will not return until the entire result set has been generated. A future version of <application>PL/pgSQL</application>might allow users to define set-returning functions that do not have this limitation. Currently, the point at which data begins being written to disk is controlled by the <xref linkend=\"guc-work-mem\">configuration variable. Administrators who have sufficient memory to store larger result sets in memory should consider increasing this parameter.</xref>"
msgstr ""

#: xml/plpgsql.xml:1523(title)
msgid "Conditionals"
msgstr ""

#: xml/plpgsql.xml:1533(literal)
msgid "IF ... THEN"
msgstr ""

#: xml/plpgsql.xml:1538(literal)
msgid "IF ... THEN ... ELSE"
msgstr ""

#: xml/plpgsql.xml:1543(literal)
msgid "IF ... THEN ... ELSIF ... THEN ... ELSE"
msgstr ""

#: xml/plpgsql.xml:1552(literal)
msgid "CASE ... WHEN ... THEN ... ELSE ... END CASE"
msgstr ""

#: xml/plpgsql.xml:1558(literal)
msgid "CASE WHEN ... THEN ... ELSE ... END CASE"
msgstr ""

#: xml/plpgsql.xml:1524(para)
msgid "<command>IF</command>and <command>CASE</command>statements let you execute alternative commands based on certain conditions. <application>PL/pgSQL</application>has three forms of <command>IF</command>: <placeholder-1/>and two forms of <command>CASE</command>: <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:1565(literal)
msgid "IF-THEN"
msgstr ""

#: xml/plpgsql.xml:1568(replaceable) xml/plpgsql.xml:1587(replaceable) xml/plpgsql.xml:1609(replaceable) xml/plpgsql.xml:1612(replaceable) xml/plpgsql.xml:1615(replaceable) xml/plpgsql.xml:1702(replaceable) xml/plpgsql.xml:1705(replaceable) xml/plpgsql.xml:1791(replaceable) xml/plpgsql.xml:1846(replaceable) xml/plpgsql.xml:1884(replaceable)
msgid "boolean-expression"
msgstr ""

#: xml/plpgsql.xml:1569(replaceable) xml/plpgsql.xml:1588(replaceable) xml/plpgsql.xml:1589(replaceable) xml/plpgsql.xml:1610(replaceable) xml/plpgsql.xml:1613(replaceable) xml/plpgsql.xml:1616(replaceable) xml/plpgsql.xml:1619(replaceable) xml/plpgsql.xml:1665(replaceable) xml/plpgsql.xml:1671(replaceable) xml/plpgsql.xml:1673(replaceable) xml/plpgsql.xml:1703(replaceable) xml/plpgsql.xml:1706(replaceable) xml/plpgsql.xml:1708(replaceable) xml/plpgsql.xml:1764(replaceable) xml/plpgsql.xml:1885(replaceable) xml/plpgsql.xml:1914(replaceable)
msgid "statements"
msgstr ""

#: xml/plpgsql.xml:1567(synopsis)
#, no-wrap
msgid "IF \n        <placeholder-1/>THEN \n        <placeholder-2/>END IF;"
msgstr ""

#: xml/plpgsql.xml:1570(para)
msgid "<literal>IF-THEN</literal>statements are the simplest form of <literal>IF</literal>. The statements between <literal>THEN</literal>and <literal>END IF</literal>will be executed if the condition is true. Otherwise, they are skipped."
msgstr ""

#: xml/plpgsql.xml:1578(programlisting)
#, no-wrap
msgid "IF v_user_id 0 THEN UPDATE users SET email\n        = v_email WHERE user_id = v_user_id; END\n        IF;"
msgstr ""

#: xml/plpgsql.xml:1577(para)
msgid "Example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1584(literal)
msgid "IF-THEN-ELSE"
msgstr ""

#: xml/plpgsql.xml:1586(synopsis)
#, no-wrap
msgid "IF \n        <placeholder-1/>THEN \n        <placeholder-2/>ELSE \n        <placeholder-3/>END IF;"
msgstr ""

#: xml/plpgsql.xml:1590(para)
msgid "<literal>IF-THEN-ELSE</literal>statements add to <literal>IF-THEN</literal>by letting you specify an alternative set of statements that should be executed if the condition is not true. (Note this includes the case where the condition evaluates to NULL.)"
msgstr ""

#: xml/plpgsql.xml:1597(programlisting)
#, no-wrap
msgid "IF parentid IS NULL OR parentid = '' THEN\n        RETURN fullname; ELSE RETURN hp_true_filename(parentid) ||\n        '/' || fullname; END IF;"
msgstr ""

#: xml/plpgsql.xml:1600(programlisting)
#, no-wrap
msgid "IF v_count 0 THEN INSERT INTO users_count\n        (count) VALUES (v_count); RETURN 't'; ELSE RETURN 'f'; END\n        IF;"
msgstr ""

#: xml/plpgsql.xml:1596(para)
msgid "Examples: <placeholder-1/><placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:1606(literal)
msgid "IF-THEN-ELSIF"
msgstr ""

#: xml/plpgsql.xml:1614(optional)
msgid "ELSIF <placeholder-1/>THEN <placeholder-2/>..."
msgstr ""

#: xml/plpgsql.xml:1611(optional)
msgid "ELSIF <placeholder-1/>THEN <placeholder-2/><placeholder-3/>"
msgstr ""

#: xml/plpgsql.xml:1618(optional) xml/plpgsql.xml:1672(optional) xml/plpgsql.xml:1707(optional)
msgid "ELSE <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1608(synopsis)
#, no-wrap
msgid "IF \n        <placeholder-1/>THEN \n        <placeholder-2/>\n        <placeholder-3/>\n        <placeholder-4/>END\n        IF;"
msgstr ""

#: xml/plpgsql.xml:1621(para)
msgid "Sometimes there are more than just two alternatives. <literal>IF-THEN-ELSIF</literal>provides a convenient method of checking several alternatives in turn. The <literal>IF</literal>conditions are tested successively until the first one that is true is found. Then the associated statement(s) are executed, after which control passes to the next statement after <literal>END IF</literal>. (Any subsequent <literal>IF</literal>conditions are <emphasis>not</emphasis>tested.) If none of the <literal>IF</literal>conditions is true, then the <literal>ELSE</literal>block (if any) is executed."
msgstr ""

#: xml/plpgsql.xml:1634(programlisting)
#, no-wrap
msgid "IF number = 0 THEN result := 'zero'; ELSIF\n        number 0 THEN result := 'positive'; ELSIF number 0 THEN\n        result := 'negative'; ELSE -- hmm, the only other\n        possibility is that number is null result := 'NULL'; END\n        IF;"
msgstr ""

#: xml/plpgsql.xml:1633(para) xml/plpgsql.xml:1727(para) xml/plpgsql.xml:2374(para)
msgid "Here is an example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1639(para)
msgid "The key word <literal>ELSIF</literal>can also be spelled <literal>ELSEIF</literal>."
msgstr ""

#: xml/plpgsql.xml:1646(programlisting)
#, no-wrap
msgid "IF demo_row.sex = 'm' THEN pretty_sex :=\n        'man'; ELSE IF demo_row.sex = 'f' THEN pretty_sex :=\n        'woman'; END IF; END IF;"
msgstr ""

#: xml/plpgsql.xml:1642(para)
msgid "An alternative way of accomplishing the same task is to nest <literal>IF-THEN-ELSE</literal>statements, as in the following example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1649(para)
msgid "However, this method requires writing a matching <literal>END IF</literal>for each <literal>IF</literal>, so it is much more cumbersome than using <literal>ELSIF</literal>when there are many alternatives."
msgstr ""

#: xml/plpgsql.xml:1657(title)
msgid "Simple <literal>CASE</literal>"
msgstr ""

#: xml/plpgsql.xml:1660(replaceable)
msgid "search-expression"
msgstr ""

#: xml/plpgsql.xml:1664(optional) xml/plpgsql.xml:1670(optional)
msgid "..."
msgstr ""

#: xml/plpgsql.xml:1662(optional) xml/plpgsql.xml:1668(optional)
msgid ", <placeholder-1/><placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:1666(optional)
msgid "WHEN <placeholder-1/><placeholder-2/>THEN <placeholder-3/>..."
msgstr ""

#: xml/plpgsql.xml:1659(synopsis)
#, no-wrap
msgid "CASE \n        <placeholder-1/>WHEN \n        <placeholder-2/>\n        <placeholder-3/>THEN \n        <placeholder-4/>\n        <placeholder-5/>\n        <placeholder-6/>END\n        CASE;"
msgstr ""

#: xml/plpgsql.xml:1675(para)
msgid "The simple form of <command>CASE</command>provides conditional execution based on equality of operands. The <replaceable>search-expression</replaceable>is evaluated (once) and successively compared to each <replaceable>expression</replaceable>in the <literal>WHEN</literal>clauses. If a match is found, then the corresponding <replaceable>statements</replaceable>are executed, and then control passes to the next statement after <literal>END CASE</literal>. (Subsequent <literal>WHEN</literal>expressions are not evaluated.) If no match is found, the <literal>ELSE</literal><replaceable>statements</replaceable>are executed; but if <literal>ELSE</literal>is not present, then a <literal>CASE_NOT_FOUND</literal>exception is raised."
msgstr ""

#: xml/plpgsql.xml:1694(programlisting)
#, no-wrap
msgid "CASE x WHEN 1, 2 THEN msg := 'one or two';\n        ELSE msg := 'other value than one or two'; END\n        CASE;"
msgstr ""

#: xml/plpgsql.xml:1693(para)
msgid "Here is a simple example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1699(title)
msgid "Searched <literal>CASE</literal>"
msgstr ""

#: xml/plpgsql.xml:1704(optional)
msgid "WHEN <placeholder-1/>THEN <placeholder-2/>..."
msgstr ""

#: xml/plpgsql.xml:1701(synopsis)
#, no-wrap
msgid "CASE WHEN \n        <placeholder-1/>THEN \n        <placeholder-2/>\n        <placeholder-3/>\n        <placeholder-4/>END\n        CASE;"
msgstr ""

#: xml/plpgsql.xml:1710(para)
msgid "The searched form of <command>CASE</command>provides conditional execution based on truth of Boolean expressions. Each <literal>WHEN</literal>clause's <replaceable>boolean-expression</replaceable>is evaluated in turn, until one is found that yields <literal>true</literal>. Then the corresponding <replaceable>statements</replaceable>are executed, and then control passes to the next statement after <literal>END CASE</literal>. (Subsequent <literal>WHEN</literal>expressions are not evaluated.) If no true result is found, the <literal>ELSE</literal><replaceable>statements</replaceable>are executed; but if <literal>ELSE</literal>is not present, then a <literal>CASE_NOT_FOUND</literal>exception is raised."
msgstr ""

#: xml/plpgsql.xml:1728(programlisting)
#, no-wrap
msgid "CASE WHEN x BETWEEN 0 AND 10 THEN msg :=\n        'value is between zero and ten'; WHEN x BETWEEN 11 AND 20\n        THEN msg := 'value is between eleven and twenty'; END\n        CASE;"
msgstr ""

#: xml/plpgsql.xml:1732(para)
msgid "This form of <command>CASE</command>is entirely equivalent to <literal>IF-THEN-ELSIF</literal>, except for the rule that reaching an omitted <literal>ELSE</literal>clause results in an error rather than doing nothing."
msgstr ""

#: xml/plpgsql.xml:1741(title)
msgid "Simple Loops"
msgstr ""

#: xml/plpgsql.xml:1743(primary)
msgid "loop"
msgstr ""

#: xml/plpgsql.xml:1746(para)
msgid "With the <literal>LOOP</literal>, <literal>EXIT</literal>, <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal>, and <literal>FOREACH</literal>statements, you can arrange for your <application>PL/pgSQL</application>function to repeat a series of commands."
msgstr ""

#: xml/plpgsql.xml:1758(literal)
msgid "LOOP"
msgstr ""

#: xml/plpgsql.xml:1762(replaceable) xml/plpgsql.xml:1766(replaceable) xml/plpgsql.xml:1788(replaceable) xml/plpgsql.xml:1843(replaceable) xml/plpgsql.xml:1882(replaceable) xml/plpgsql.xml:1887(replaceable) xml/plpgsql.xml:1906(replaceable) xml/plpgsql.xml:1916(replaceable)
msgid "label"
msgstr ""

#: xml/plpgsql.xml:1760(synopsis)
#, no-wrap
msgid "\n        <optional>\n          <placeholder-1/>\n        </optional>LOOP \n        <placeholder-2/>END LOOP \n        <optional>\n          <placeholder-3/>\n        </optional>;"
msgstr ""

#: xml/plpgsql.xml:1768(para)
msgid "<literal>LOOP</literal>defines an unconditional loop that is repeated indefinitely until terminated by an <literal>EXIT</literal>or <command>RETURN</command>statement. The optional <replaceable>label</replaceable>can be used by <literal>EXIT</literal>and <literal>CONTINUE</literal>statements within nested loops to specify which loop those statements refer to."
msgstr ""

#: xml/plpgsql.xml:1780(literal) xml/plpgsql.xml:1783(primary)
msgid "EXIT"
msgstr ""

#: xml/plpgsql.xml:1790(optional) xml/plpgsql.xml:1845(optional)
msgid "WHEN <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1786(synopsis)
#, no-wrap
msgid "EXIT \n        <optional>\n          <placeholder-1/>\n        </optional>\n        <placeholder-2/>;"
msgstr ""

#: xml/plpgsql.xml:1793(para)
msgid "If no <replaceable>label</replaceable>is given, the innermost loop is terminated and the statement following <literal>END LOOP</literal>is executed next. If <replaceable>label</replaceable>is given, it must be the label of the current or some outer level of nested loop or block. Then the named loop or block is terminated and control continues with the statement after the loop's/block's corresponding <literal>END</literal>."
msgstr ""

#: xml/plpgsql.xml:1803(para)
msgid "If <literal>WHEN</literal>is specified, the loop exit occurs only if <replaceable>boolean-expression</replaceable>is true. Otherwise, control passes to the statement after <literal>EXIT</literal>."
msgstr ""

#: xml/plpgsql.xml:1809(para)
msgid "<literal>EXIT</literal>can be used with all types of loops; it is not limited to use with unconditional loops."
msgstr ""

#: xml/plpgsql.xml:1812(para)
msgid "When used with a <literal>BEGIN</literal>block, <literal>EXIT</literal>passes control to the next statement after the end of the block. Note that a label must be used for this purpose; an unlabeled <literal>EXIT</literal>is never considered to match a <literal>BEGIN</literal>block. (This is a change from pre-8.4 releases of <productname>PostgreSQL</productname>, which would allow an unlabeled <literal>EXIT</literal>to match a <literal>BEGIN</literal>block.)"
msgstr ""

#: xml/plpgsql.xml:1825(programlisting)
#, no-wrap
msgid "LOOP -- some computations IF count 0 THEN\n        EXIT; -- exit loop END IF; END LOOP; LOOP -- some\n        computations EXIT WHEN count 0; -- same result as previous\n        example END LOOP; ablock BEGIN -- some computations IF\n        stocks 100000 THEN EXIT ablock; -- causes exit from the\n        BEGIN block END IF; -- computations here will be skipped\n        when stocks 100000 END;"
msgstr ""

#: xml/plpgsql.xml:1835(literal) xml/plpgsql.xml:1838(primary)
msgid "CONTINUE"
msgstr ""

#: xml/plpgsql.xml:1841(synopsis)
#, no-wrap
msgid "CONTINUE \n        <optional>\n          <placeholder-1/>\n        </optional>\n        <placeholder-2/>;"
msgstr ""

#: xml/plpgsql.xml:1848(para)
msgid "If no <replaceable>label</replaceable>is given, the next iteration of the innermost loop is begun. That is, all statements remaining in the loop body are skipped, and control returns to the loop control expression (if any) to determine whether another loop iteration is needed. If <replaceable>label</replaceable>is present, it specifies the label of the loop whose execution will be continued."
msgstr ""

#: xml/plpgsql.xml:1857(para)
msgid "If <literal>WHEN</literal>is specified, the next iteration of the loop is begun only if <replaceable>boolean-expression</replaceable>is true. Otherwise, control passes to the statement after <literal>CONTINUE</literal>."
msgstr ""

#: xml/plpgsql.xml:1863(para)
msgid "<literal>CONTINUE</literal>can be used with all types of loops; it is not limited to use with unconditional loops."
msgstr ""

#: xml/plpgsql.xml:1868(programlisting)
#, no-wrap
msgid "LOOP -- some computations EXIT WHEN count\n        100; CONTINUE WHEN count 50; -- some computations for count\n        IN [50 .. 100] END LOOP;"
msgstr ""

#: xml/plpgsql.xml:1874(literal) xml/plpgsql.xml:1877(primary)
msgid "WHILE"
msgstr ""

#: xml/plpgsql.xml:1880(synopsis)
#, no-wrap
msgid "\n        <optional>\n          <placeholder-1/>\n        </optional>WHILE \n        <placeholder-2/>LOOP \n        <placeholder-3/>END LOOP \n        <optional>\n          <placeholder-4/>\n        </optional>;"
msgstr ""

#: xml/plpgsql.xml:1889(para)
msgid "The <literal>WHILE</literal>statement repeats a sequence of statements so long as the <replaceable>boolean-expression</replaceable>evaluates to true. The expression is checked just before each entry to the loop body."
msgstr ""

#: xml/plpgsql.xml:1896(programlisting)
#, no-wrap
msgid "WHILE amount_owed 0 AND\n        gift_certificate_balance 0 LOOP -- some computations here\n        END LOOP; WHILE NOT done LOOP -- some computations here END\n        LOOP;"
msgstr ""

#: xml/plpgsql.xml:1895(para)
msgid "For example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1902(title)
msgid "<literal>FOR</literal>(Integer Variant)"
msgstr ""

#: xml/plpgsql.xml:1909(optional)
msgid "REVERSE"
msgstr ""

#: xml/plpgsql.xml:1912(optional)
msgid "BY <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1904(synopsis)
#, no-wrap
msgid "\n        <optional>\n          <placeholder-1/>\n        </optional>FOR \n        <placeholder-2/>IN \n        <placeholder-3/>\n        <placeholder-4/>.. \n        <placeholder-5/>\n        <placeholder-6/>LOOP \n        <placeholder-7/>END LOOP \n        <optional>\n          <placeholder-8/>\n        </optional>;"
msgstr ""

#: xml/plpgsql.xml:1918(para)
msgid "This form of <literal>FOR</literal>creates a loop that iterates over a range of integer values. The variable <replaceable>name</replaceable>is automatically defined as type <type>integer</type>and exists only inside the loop (any existing definition of the variable name is ignored within the loop). The two expressions giving the lower and upper bound of the range are evaluated once when entering the loop. If the <literal>BY</literal>clause isn't specified the iteration step is 1, otherwise it's the value specified in the <literal>BY</literal>clause, which again is evaluated once on loop entry. If <literal>REVERSE</literal>is specified then the step value is subtracted, rather than added, after each iteration."
msgstr ""

#: xml/plpgsql.xml:1937(programlisting)
#, no-wrap
msgid "FOR i IN 1..10 LOOP -- i will take on the\n        values 1,2,3,4,5,6,7,8,9,10 within the loop END LOOP; FOR i\n        IN REVERSE 10..1 LOOP -- i will take on the values\n        10,9,8,7,6,5,4,3,2,1 within the loop END LOOP; FOR i IN\n        REVERSE 10..1 BY 2 LOOP -- i will take on the values\n        10,8,6,4,2 within the loop END\n        LOOP;"
msgstr ""

#: xml/plpgsql.xml:1935(para)
msgid "Some examples of integer <literal>FOR</literal>loops: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:1944(para)
msgid "If the lower bound is greater than the upper bound (or less than, in the <literal>REVERSE</literal>case), the loop body is not executed at all. No error is raised."
msgstr ""

#: xml/plpgsql.xml:1948(para)
msgid "If a <replaceable>label</replaceable>is attached to the <literal>FOR</literal>loop then the integer loop variable can be referenced with a qualified name, using that <replaceable>label</replaceable>."
msgstr ""

#: xml/plpgsql.xml:1956(title)
msgid "Looping Through Query Results"
msgstr ""

#: xml/plpgsql.xml:1977(programlisting)
#, no-wrap
msgid "CREATE FUNCTION cs_refresh_mviews() RETURNS\n      integer AS $$ DECLARE mviews RECORD; BEGIN RAISE NOTICE\n      'Refreshing materialized views...'; FOR mviews IN SELECT *\n      FROM cs_materialized_views ORDER BY sort_key LOOP -- Now\n      \"mviews\" has one record from cs_materialized_views RAISE\n      NOTICE 'Refreshing materialized view %s ...',\n      quote_ident(mviews.mv_name); EXECUTE format('TRUNCATE TABLE\n      %I', mviews.mv_name); EXECUTE format('INSERT INTO %I %s',\n      mviews.mv_name, mviews.mv_query); END LOOP; RAISE NOTICE\n      'Done refreshing materialized views.'; RETURN 1; END; $$\n      LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:1957(para)
msgid "Using a different type of <literal>FOR</literal>loop, you can iterate through the results of a query and manipulate that data accordingly. The syntax is: <synopsis>\n      <optional>\n        <replaceable>label</replaceable>\n      </optional>FOR \n      <replaceable>target</replaceable>IN \n      <replaceable>query</replaceable>LOOP \n      <replaceable>statements</replaceable>END LOOP \n      <optional>\n        <replaceable>label</replaceable>\n      </optional>;</synopsis>The <replaceable>target</replaceable>is a record variable, row variable, or comma-separated list of scalar variables. The <replaceable>target</replaceable>is successively assigned each row resulting from the <replaceable>query</replaceable>and the loop body is executed for each row. Here is an example: <placeholder-1/>If the loop is terminated by an <literal>EXIT</literal>statement, the last assigned row value is still accessible after the loop."
msgstr ""

#: xml/plpgsql.xml:1991(para)
msgid "The <replaceable>query</replaceable>used in this type of <literal>FOR</literal>statement can be any SQL command that returns rows to the caller: <command>SELECT</command>is the most common case, but you can also use <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>with a <literal>RETURNING</literal>clause. Some utility commands such as <command>EXPLAIN</command>will work too."
msgstr ""

#: xml/plpgsql.xml:2003(para)
msgid "<application>PL/pgSQL</application>variables are substituted into the query text, and the query plan is cached for possible re-use, as discussed in detail in <xref linkend=\"plpgsql-var-subst\">and <xref linkend=\"plpgsql-plan-caching\">.</xref></xref>"
msgstr ""

#: xml/plpgsql.xml:2009(para)
msgid "The <literal>FOR-IN-EXECUTE</literal>statement is another way to iterate over rows: <synopsis>\n      <optional>\n        <replaceable>label</replaceable>\n      </optional>FOR \n      <replaceable>target</replaceable>IN EXECUTE \n      <replaceable>text_expression</replaceable>\n      <optional>USING \n      <replaceable>expression</replaceable>\n      <optional>, ...</optional></optional>LOOP \n      <replaceable>statements</replaceable>END LOOP \n      <optional>\n        <replaceable>label</replaceable>\n      </optional>;</synopsis>This is like the previous form, except that the source query is specified as a string expression, which is evaluated and replanned on each entry to the <literal>FOR</literal>loop. This allows the programmer to choose the speed of a preplanned query or the flexibility of a dynamic query, just as with a plain <command>EXECUTE</command>statement. As with <command>EXECUTE</command>, parameter values can be inserted into the dynamic command via <literal>USING</literal>."
msgstr ""

#: xml/plpgsql.xml:2034(para)
msgid "Another way to specify the query whose results should be iterated through is to declare it as a cursor. This is described in <xref linkend=\"plpgsql-cursor-for-loop\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:2040(title)
msgid "Looping Through Arrays"
msgstr ""

#: xml/plpgsql.xml:2041(para)
msgid "The <literal>FOREACH</literal>loop is much like a <literal>FOR</literal>loop, but instead of iterating through the rows returned by a SQL query, it iterates through the elements of an array value. (In general, <literal>FOREACH</literal>is meant for looping through components of a composite-valued expression; variants for looping through composites besides arrays may be added in future.) The <literal>FOREACH</literal>statement to loop over an array is: <synopsis>\n      <optional>\n        <replaceable>label</replaceable>\n      </optional>FOREACH \n      <replaceable>target</replaceable>\n      <optional>SLICE \n      <replaceable>number</replaceable></optional>IN ARRAY \n      <replaceable>expression</replaceable>LOOP \n      <replaceable>statements</replaceable>END LOOP \n      <optional>\n        <replaceable>label</replaceable>\n      </optional>;</synopsis>"
msgstr ""

#: xml/plpgsql.xml:2074(programlisting)
#, no-wrap
msgid "CREATE FUNCTION sum(int[]) RETURNS int8 AS $$\n      DECLARE s int8 := 0; x int; BEGIN FOREACH x IN ARRAY $1 LOOP\n      s := s + x; END LOOP; RETURN s; END; $$ LANGUAGE\n      plpgsql;"
msgstr ""

#: xml/plpgsql.xml:2064(para)
msgid "Without <literal>SLICE</literal>, or if <literal>SLICE 0</literal>is specified, the loop iterates through individual elements of the array produced by evaluating the <replaceable>expression</replaceable>. The <replaceable>target</replaceable>variable is assigned each element value in sequence, and the loop body is executed for each element. Here is an example of looping through the elements of an integer array: <placeholder-1/>The elements are visited in storage order, regardless of the number of array dimensions. Although the <replaceable>target</replaceable>is usually just a single variable, it can be a list of variables when looping through an array of composite values (records). In that case, for each array element, the variables are assigned from successive columns of the composite value."
msgstr ""

#: xml/plpgsql.xml:2096(programlisting)
#, no-wrap
msgid "CREATE FUNCTION scan_rows(int[]) RETURNS void\n      AS $$ DECLARE x int[]; BEGIN FOREACH x SLICE 1 IN ARRAY $1\n      LOOP RAISE NOTICE 'row = %', x; END LOOP; END; $$ LANGUAGE\n      plpgsql; SELECT\n      scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]); NOTICE:\n      row = {1,2,3} NOTICE: row = {4,5,6} NOTICE: row = {7,8,9}\n      NOTICE: row = {10,11,12}"
msgstr ""

#: xml/plpgsql.xml:2085(para)
msgid "With a positive <literal>SLICE</literal>value, <literal>FOREACH</literal>iterates through slices of the array rather than single elements. The <literal>SLICE</literal>value must be an integer constant not larger than the number of dimensions of the array. The <replaceable>target</replaceable>variable must be an array, and it receives successive slices of the array value, where each slice is of the number of dimensions specified by <literal>SLICE</literal>. Here is an example of iterating through one-dimensional slices: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2105(title)
msgid "Trapping Errors"
msgstr ""

#: xml/plpgsql.xml:2107(primary)
msgid "exceptions"
msgstr ""

#: xml/plpgsql.xml:2110(para)
msgid "By default, any error occurring in a <application>PL/pgSQL</application>function aborts execution of the function, and indeed of the surrounding transaction as well. You can trap errors and recover from them by using a <command>BEGIN</command>block with an <literal>EXCEPTION</literal>clause. The syntax is an extension of the normal syntax for a <command>BEGIN</command>block: <synopsis>\n      <optional>\n        <replaceable>label</replaceable>\n      </optional>\n      <optional>DECLARE \n      <replaceable>declarations</replaceable></optional>BEGIN \n      <replaceable>statements</replaceable>EXCEPTION WHEN \n      <replaceable>condition</replaceable>\n      <optional>OR \n      <replaceable>condition</replaceable>...</optional>THEN \n      <replaceable>handler_statements</replaceable>\n      <optional>WHEN \n      <replaceable>condition</replaceable>\n      <optional>OR \n      <replaceable>condition</replaceable>...</optional>THEN \n      <replaceable>\n      handler_statements</replaceable>...</optional>END;</synopsis>"
msgstr ""

#: xml/plpgsql.xml:2135(para)
msgid "If no error occurs, this form of block simply executes all the <replaceable>statements</replaceable>, and then control passes to the next statement after <literal>END</literal>. But if an error occurs within the <replaceable>statements</replaceable>, further processing of the <replaceable>statements</replaceable>is abandoned, and control passes to the <literal>EXCEPTION</literal>list. The list is searched for the first <replaceable>condition</replaceable>matching the error that occurred. If a match is found, the corresponding <replaceable>handler_statements</replaceable>are executed, and then control passes to the next statement after <literal>END</literal>. If no match is found, the error propagates out as though the <literal>EXCEPTION</literal>clause were not there at all: the error can be caught by an enclosing block with <literal>EXCEPTION</literal>, or if there is none it aborts processing of the function."
msgstr ""

#: xml/plpgsql.xml:2169(programlisting)
#, no-wrap
msgid "WHEN division_by_zero THEN ... WHEN SQLSTATE\n      '22012' THEN ..."
msgstr ""

#: xml/plpgsql.xml:2156(para)
msgid "The <replaceable>condition</replaceable>names can be any of those shown in <xref linkend=\"errcodes-appendix\">. A category name matches any error within its category. The special condition name <literal>OTHERS</literal>matches every error type except <literal>QUERY_CANCELED</literal>and <literal>ASSERT_FAILURE</literal>. (It is possible, but often unwise, to trap those two error types by name.) Condition names are not case-sensitive. Also, an error condition can be specified by <literal>SQLSTATE</literal>code; for example these are equivalent: <placeholder-1/></xref>"
msgstr ""

#: xml/plpgsql.xml:2171(para)
msgid "If a new error occurs within the selected <replaceable>handler_statements</replaceable>, it cannot be caught by this <literal>EXCEPTION</literal>clause, but is propagated out. A surrounding <literal>EXCEPTION</literal>clause could catch it."
msgstr ""

#: xml/plpgsql.xml:2184(programlisting)
#, no-wrap
msgid "INSERT INTO mytab(firstname, lastname)\n      VALUES('Tom', 'Jones'); BEGIN UPDATE mytab SET firstname =\n      'Joe' WHERE lastname = 'Jones'; x := x + 1; y := x / 0;\n      EXCEPTION WHEN division_by_zero THEN RAISE NOTICE 'caught\n      division_by_zero'; RETURN x; END;"
msgstr ""

#: xml/plpgsql.xml:2177(para)
msgid "When an error is caught by an <literal>EXCEPTION</literal>clause, the local variables of the <application>PL/pgSQL</application>function remain as they were when the error occurred, but all changes to persistent database state within the block are rolled back. As an example, consider this fragment: <placeholder-1/>When control reaches the assignment to <literal>y</literal>, it will fail with a <literal>division_by_zero</literal>error. This will be caught by the <literal>EXCEPTION</literal>clause. The value returned in the <command>RETURN</command>statement will be the incremented value of <literal>x</literal>, but the effects of the <command>UPDATE</command>command will have been rolled back. The <command>INSERT</command>command preceding the block is not rolled back, however, so the end result is that the database contains <literal>Tom Jones</literal>not <literal>Joe Jones</literal>."
msgstr ""

#: xml/plpgsql.xml:2206(para)
msgid "A block containing an <literal>EXCEPTION</literal>clause is significantly more expensive to enter and exit than a block without one. Therefore, don't use <literal>EXCEPTION</literal>without need."
msgstr ""

#: xml/plpgsql.xml:2213(title)
msgid "Exceptions with <command>UPDATE</command>/ <command>INSERT</command>"
msgstr ""

#: xml/plpgsql.xml:2227(programlisting)
#, no-wrap
msgid "CREATE TABLE db (a INT PRIMARY KEY, b\n        TEXT); CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS\n        VOID AS $$ BEGIN LOOP -- first try to update the key UPDATE\n        db SET b = data WHERE a = key; IF found THEN RETURN; END\n        IF; -- not there, so try to insert the key -- if someone\n        else inserts the same key concurrently, -- we could get a\n        unique-key failure BEGIN INSERT INTO db(a,b) VALUES (key,\n        data); RETURN; EXCEPTION WHEN unique_violation THEN -- Do\n        nothing, and loop to try the UPDATE again. END; END LOOP;\n        END; $$ LANGUAGE plpgsql; SELECT merge_db(1, 'david');\n        SELECT merge_db(1, 'dennis');"
msgstr ""

#: xml/plpgsql.xml:2216(para)
msgid "This example uses exception handling to perform either <command>UPDATE</command>or <command>INSERT</command>, as appropriate. It is recommended that applications use <command>INSERT</command>with <literal>ON CONFLICT DO UPDATE</literal>rather than actually using this pattern. This example serves primarily to illustrate use of <application>PL/pgSQL</application>control flow structures: <placeholder-1/>This coding assumes the <literal>unique_violation</literal>error is caused by the <command>INSERT</command>, and not by, say, an <command>INSERT</command>in a trigger function on the table. It might also misbehave if there is more than one unique index on the table, since it will retry the operation regardless of which index caused the error. More safety could be had by using the features discussed next to check that the trapped error was the one expected."
msgstr ""

#: xml/plpgsql.xml:2249(title)
msgid "Obtaining Information About an Error"
msgstr ""

#: xml/plpgsql.xml:2250(para)
msgid "Exception handlers frequently need to identify the specific error that occurred. There are two ways to get information about the current exception in <application>PL/pgSQL</application>: special variables and the <command>GET STACKED DIAGNOSTICS</command>command."
msgstr ""

#: xml/plpgsql.xml:2256(para)
msgid "Within an exception handler, the special variable <varname>SQLSTATE</varname>contains the error code that corresponds to the exception that was raised (refer to <xref linkend=\"errcodes-table\">for a list of possible error codes). The special variable <varname>SQLERRM</varname>contains the error message associated with the exception. These variables are undefined outside exception handlers.</xref>"
msgstr ""

#: xml/plpgsql.xml:2264(para)
msgid "Within an exception handler, one may also retrieve information about the current exception by using the <command>GET STACKED DIAGNOSTICS</command>command, which has the form: <synopsis>GET STACKED DIAGNOSTICS \n        <replaceable>variable</replaceable>{ = | := } \n        <replaceable>item</replaceable>\n        <optional>, ...</optional>;</synopsis>Each <replaceable>item</replaceable>is a key word identifying a status value to be assigned to the specified variable (which should be of the right data type to receive it). The currently available status items are shown in <xref linkend=\"plpgsql-exception-diagnostics-values\"> .</xref>"
msgstr ""

#: xml/plpgsql.xml:2279(title)
msgid "Error Diagnostics Values"
msgstr ""

#: xml/plpgsql.xml:2283(entry)
msgid "Name"
msgstr ""

#: xml/plpgsql.xml:2284(entry)
msgid "Type"
msgstr ""

#: xml/plpgsql.xml:2285(entry)
msgid "Description"
msgstr ""

#: xml/plpgsql.xml:2291(literal)
msgid "RETURNED_SQLSTATE"
msgstr ""

#: xml/plpgsql.xml:2293(entry) xml/plpgsql.xml:2301(entry) xml/plpgsql.xml:2309(entry) xml/plpgsql.xml:2317(entry) xml/plpgsql.xml:2325(entry) xml/plpgsql.xml:2333(entry) xml/plpgsql.xml:2341(entry) xml/plpgsql.xml:2349(entry) xml/plpgsql.xml:2357(entry) xml/plpgsql.xml:2365(entry)
msgid "text"
msgstr ""

#: xml/plpgsql.xml:2294(entry)
msgid "the SQLSTATE error code of the exception"
msgstr ""

#: xml/plpgsql.xml:2299(literal)
msgid "COLUMN_NAME"
msgstr ""

#: xml/plpgsql.xml:2302(entry)
msgid "the name of the column related to exception"
msgstr ""

#: xml/plpgsql.xml:2307(literal)
msgid "CONSTRAINT_NAME"
msgstr ""

#: xml/plpgsql.xml:2310(entry)
msgid "the name of the constraint related to exception"
msgstr ""

#: xml/plpgsql.xml:2315(literal)
msgid "PG_DATATYPE_NAME"
msgstr ""

#: xml/plpgsql.xml:2318(entry)
msgid "the name of the data type related to exception"
msgstr ""

#: xml/plpgsql.xml:2323(literal)
msgid "MESSAGE_TEXT"
msgstr ""

#: xml/plpgsql.xml:2326(entry)
msgid "the text of the exception's primary message"
msgstr ""

#: xml/plpgsql.xml:2331(literal)
msgid "TABLE_NAME"
msgstr ""

#: xml/plpgsql.xml:2334(entry)
msgid "the name of the table related to exception"
msgstr ""

#: xml/plpgsql.xml:2339(literal)
msgid "SCHEMA_NAME"
msgstr ""

#: xml/plpgsql.xml:2342(entry)
msgid "the name of the schema related to exception"
msgstr ""

#: xml/plpgsql.xml:2347(literal)
msgid "PG_EXCEPTION_DETAIL"
msgstr ""

#: xml/plpgsql.xml:2350(entry)
msgid "the text of the exception's detail message, if any"
msgstr ""

#: xml/plpgsql.xml:2355(literal)
msgid "PG_EXCEPTION_HINT"
msgstr ""

#: xml/plpgsql.xml:2358(entry)
msgid "the text of the exception's hint message, if any"
msgstr ""

#: xml/plpgsql.xml:2363(literal)
msgid "PG_EXCEPTION_CONTEXT"
msgstr ""

#: xml/plpgsql.xml:2366(entry)
msgid "line(s) of text describing the call stack"
msgstr ""

#: xml/plpgsql.xml:2372(para)
msgid "If the exception did not set a value for an item, an empty string will be returned."
msgstr ""

#: xml/plpgsql.xml:2375(programlisting)
#, no-wrap
msgid "DECLARE text_var1 text; text_var2 text;\n        text_var3 text; BEGIN -- some processing which might cause\n        an exception ... EXCEPTION WHEN OTHERS THEN GET STACKED\n        DIAGNOSTICS text_var1 = MESSAGE_TEXT, text_var2 =\n        PG_EXCEPTION_DETAIL, text_var3 = PG_EXCEPTION_HINT;\n        END;"
msgstr ""

#: xml/plpgsql.xml:2384(title)
msgid "Obtaining Current Execution Information"
msgstr ""

#: xml/plpgsql.xml:2385(para)
msgid "The <command>GET <optional>CURRENT</optional>DIAGNOSTICS</command>command retrieves information about current execution state (whereas the <command>GET STACKED DIAGNOSTICS</command>command discussed above reports information about the execution state as of a previous error). This command has the form:"
msgstr ""

#: xml/plpgsql.xml:2394(optional)
msgid "CURRENT"
msgstr ""

#: xml/plpgsql.xml:2396(replaceable)
msgid "item"
msgstr ""

#: xml/plpgsql.xml:2393(synopsis)
#, no-wrap
msgid "GET \n      <placeholder-1/>DIAGNOSTICS \n      <placeholder-2/>{ = | := } \n      <placeholder-3/>\n      <placeholder-4/>;"
msgstr ""

#: xml/plpgsql.xml:2406(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION outer_func()\n      RETURNS integer AS $$ BEGIN RETURN inner_func(); END; $$\n      LANGUAGE plpgsql; CREATE OR REPLACE FUNCTION inner_func()\n      RETURNS integer AS $$ DECLARE stack text; BEGIN GET\n      DIAGNOSTICS stack = PG_CONTEXT; RAISE NOTICE E'--- Call Stack\n      ---\\n%', stack; RETURN 1; END; $$ LANGUAGE plpgsql; SELECT\n      outer_func(); NOTICE: --- Call Stack --- PL/pgSQL function\n      inner_func() line 5 at GET DIAGNOSTICS PL/pgSQL function\n      outer_func() line 3 at RETURN CONTEXT: PL/pgSQL function\n      outer_func() line 3 at RETURN outer_func ------------ 1 (1\n      row)"
msgstr ""

#: xml/plpgsql.xml:2398(para)
msgid "Currently only one information item is supported. Status item <literal>PG_CONTEXT</literal>will return a text string with line(s) of text describing the call stack. The first line refers to the current function and currently executing <command>GET DIAGNOSTICS</command>command. The second and any subsequent lines refer to calling functions further up the call stack. For example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2420(title)
msgid "Cursors"
msgstr ""

#: xml/plpgsql.xml:2422(primary) xml/plpgsql.xml:2656(replaceable) xml/plpgsql.xml:2707(replaceable) xml/plpgsql.xml:2756(replaceable) xml/plpgsql.xml:2758(replaceable) xml/plpgsql.xml:2775(replaceable)
msgid "cursor"
msgstr ""

#: xml/plpgsql.xml:2425(para)
msgid "Rather than executing a whole query at once, it is possible to set up a <firstterm>cursor</firstterm>that encapsulates the query, and then read the query result a few rows at a time. One reason for doing this is to avoid memory overrun when the result contains a large number of rows. (However, <application>PL/pgSQL</application>users do not normally need to worry about that, since <literal>FOR</literal>loops automatically use a cursor internally to avoid memory problems.) A more interesting usage is to return a reference to a cursor that a function has created, allowing the caller to read the rows. This provides an efficient way to return large row sets from functions."
msgstr ""

#: xml/plpgsql.xml:2439(title)
msgid "Declaring Cursor Variables"
msgstr ""

#: xml/plpgsql.xml:2440(para)
msgid "All access to cursors in <application>PL/pgSQL</application>goes through cursor variables, which are always of the special data type <type>refcursor</type>. One way to create a cursor variable is just to declare it as a variable of type <type>refcursor</type>. Another way is to use the cursor declaration syntax, which in general is: <synopsis>\n      <replaceable>name</replaceable>\n      <optional>\n      <optional>NO</optional>SCROLL</optional>CURSOR \n      <optional>( \n      <replaceable>arguments</replaceable>)</optional>FOR \n      <replaceable>query</replaceable>;</synopsis>( <literal>FOR</literal>can be replaced by <literal>IS</literal>for <productname>Oracle</productname>compatibility.) If <literal>SCROLL</literal>is specified, the cursor will be capable of scrolling backward; if <literal>NO SCROLL</literal>is specified, backward fetches will be rejected; if neither specification appears, it is query-dependent whether backward fetches will be allowed. <replaceable>arguments</replaceable>, if specified, is a comma-separated list of pairs <literal><replaceable>name</replaceable><replaceable>datatype</replaceable></literal>that define names to be replaced by parameter values in the given query. The actual values to substitute for these names will be specified later, when the cursor is opened."
msgstr ""

#: xml/plpgsql.xml:2472(programlisting)
#, no-wrap
msgid "DECLARE curs1 refcursor; curs2 CURSOR FOR\n      SELECT * FROM tenk1; curs3 CURSOR (key integer) FOR SELECT *\n      FROM tenk1 WHERE unique1 = key;"
msgstr ""

#: xml/plpgsql.xml:2471(para)
msgid "Some examples: <placeholder-1/>All three of these variables have the data type <type>refcursor</type>, but the first can be used with any query, while the second has a fully specified query already <firstterm>bound</firstterm>to it, and the last has a parameterized query bound to it. ( <literal>key</literal>will be replaced by an integer parameter value when the cursor is opened.) The variable <literal>curs1</literal>is said to be <firstterm>unbound</firstterm>since it is not bound to any particular query."
msgstr ""

#: xml/plpgsql.xml:2487(title)
msgid "Opening Cursors"
msgstr ""

#: xml/plpgsql.xml:2488(para)
msgid "Before a cursor can be used to retrieve rows, it must be <firstterm>opened</firstterm>. (This is the equivalent action to the SQL command <command>DECLARE CURSOR</command>.) <application>PL/pgSQL</application>has three forms of the <command>OPEN</command>statement, two of which use unbound cursor variables while the third uses a bound cursor variable."
msgstr ""

#: xml/plpgsql.xml:2498(para)
msgid "Bound cursor variables can also be used without explicitly opening the cursor, via the <command>FOR</command>statement described in <xref linkend=\"plpgsql-cursor-for-loop\">.</xref>"
msgstr ""

#: xml/plpgsql.xml:2505(command)
msgid "OPEN FOR"
msgstr ""

#: xml/plpgsql.xml:2509(replaceable) xml/plpgsql.xml:2543(replaceable)
msgid "unbound_cursorvar"
msgstr ""

#: xml/plpgsql.xml:2511(optional) xml/plpgsql.xml:2545(optional)
msgid "NO"
msgstr ""

#: xml/plpgsql.xml:2510(optional) xml/plpgsql.xml:2544(optional)
msgid "<placeholder-1/>SCROLL"
msgstr ""

#: xml/plpgsql.xml:2508(synopsis)
#, no-wrap
msgid "OPEN \n        <placeholder-1/>\n        <placeholder-2/>FOR \n        <placeholder-3/>;"
msgstr ""

#: xml/plpgsql.xml:2513(para)
msgid "The cursor variable is opened and given the specified query to execute. The cursor cannot be open already, and it must have been declared as an unbound cursor variable (that is, as a simple <type>refcursor</type>variable). The query must be a <command>SELECT</command>, or something else that returns rows (such as <command>EXPLAIN</command>). The query is treated in the same way as other SQL commands in <application>PL/pgSQL</application>: <application>PL/pgSQL</application>variable names are substituted, and the query plan is cached for possible reuse. When a <application>PL/pgSQL</application>variable is substituted into the cursor query, the value that is substituted is the one it has at the time of the <command>OPEN</command>; subsequent changes to the variable will not affect the cursor's behavior. The <literal>SCROLL</literal>and <literal>NO SCROLL</literal>options have the same meanings as for a bound cursor."
msgstr ""

#: xml/plpgsql.xml:2535(programlisting)
#, no-wrap
msgid "OPEN curs1 FOR SELECT * FROM foo WHERE key\n        = mykey;"
msgstr ""

#: xml/plpgsql.xml:2540(command)
msgid "OPEN FOR EXECUTE"
msgstr ""

#: xml/plpgsql.xml:2546(replaceable)
msgid "query_string"
msgstr ""

#: xml/plpgsql.xml:2542(synopsis)
#, no-wrap
msgid "OPEN \n        <placeholder-1/>\n        <placeholder-2/>FOR EXECUTE \n        <placeholder-3/>\n        <placeholder-4/>;"
msgstr ""

#: xml/plpgsql.xml:2550(para)
msgid "The cursor variable is opened and given the specified query to execute. The cursor cannot be open already, and it must have been declared as an unbound cursor variable (that is, as a simple <type>refcursor</type>variable). The query is specified as a string expression, in the same way as in the <command>EXECUTE</command>command. As usual, this gives flexibility so the query plan can vary from one run to the next (see <xref linkend=\"plpgsql-plan-caching\">), and it also means that variable substitution is not done on the command string. As with <command>EXECUTE</command>, parameter values can be inserted into the dynamic command via <literal>format()</literal>and <literal>USING</literal>. The <literal>SCROLL</literal>and <literal>NO SCROLL</literal>options have the same meanings as for a bound cursor.</xref>"
msgstr ""

#: xml/plpgsql.xml:2570(programlisting)
#, no-wrap
msgid "OPEN curs1 FOR EXECUTE format('SELECT *\n        FROM %I WHERE col1 = $1',tabname) USING\n        keyvalue;"
msgstr ""

#: xml/plpgsql.xml:2569(para)
msgid "An example: <placeholder-1/>In this example, the table name is inserted into the query via <function>format()</function>. The comparison value for <literal>col1</literal>is inserted via a <literal>USING</literal>parameter, so it needs no quoting."
msgstr ""

#: xml/plpgsql.xml:2580(title)
msgid "Opening a Bound Cursor"
msgstr ""

#: xml/plpgsql.xml:2582(replaceable)
msgid "bound_cursorvar"
msgstr ""

#: xml/plpgsql.xml:2585(replaceable)
msgid "argument_name"
msgstr ""

#: xml/plpgsql.xml:2584(optional)
msgid "<placeholder-1/>:="
msgstr ""

#: xml/plpgsql.xml:2586(replaceable)
msgid "argument_value"
msgstr ""

#: xml/plpgsql.xml:2583(optional)
msgid "( <placeholder-1/><placeholder-2/><placeholder-3/>)"
msgstr ""

#: xml/plpgsql.xml:2581(synopsis)
#, no-wrap
msgid "OPEN \n        <placeholder-1/>\n        <placeholder-2/>;"
msgstr ""

#: xml/plpgsql.xml:2588(para)
msgid "This form of <command>OPEN</command>is used to open a cursor variable whose query was bound to it when it was declared. The cursor cannot be open already. A list of actual argument value expressions must appear if and only if the cursor was declared to take arguments. These values will be substituted in the query."
msgstr ""

#: xml/plpgsql.xml:2595(para)
msgid "The query plan for a bound cursor is always considered cacheable; there is no equivalent of <command>EXECUTE</command>in this case. Notice that <literal>SCROLL</literal>and <literal>NO SCROLL</literal>cannot be specified in <command>OPEN</command>, as the cursor's scrolling behavior was already determined."
msgstr ""

#: xml/plpgsql.xml:2602(para)
msgid "Argument values can be passed using either <firstterm>positional</firstterm>or <firstterm>named</firstterm>notation. In positional notation, all arguments are specified in order. In named notation, each argument's name is specified using <literal>:=</literal>to separate it from the argument expression. Similar to calling functions, described in <xref linkend=\"sql-syntax-calling-funcs\">, it is also allowed to mix positional and named notation.</xref>"
msgstr ""

#: xml/plpgsql.xml:2613(programlisting)
#, no-wrap
msgid "OPEN curs2; OPEN curs3(42); OPEN curs3(key\n        := 42);"
msgstr ""

#: xml/plpgsql.xml:2611(para)
msgid "Examples (these use the cursor declaration examples above): <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2626(programlisting)
#, no-wrap
msgid "DECLARE key integer; curs4 CURSOR FOR\n        SELECT * FROM tenk1 WHERE unique1 = key; BEGIN key := 42;\n        OPEN curs4;"
msgstr ""

#: xml/plpgsql.xml:2615(para)
msgid "Because variable substitution is done on a bound cursor's query, there are really two ways to pass values into the cursor: either with an explicit argument to <command>OPEN</command>, or implicitly by referencing a <application>PL/pgSQL</application>variable in the query. However, only variables declared before the bound cursor was declared will be substituted into it. In either case the value to be passed is determined at the time of the <command>OPEN</command>. For example, another way to get the same effect as the <literal>curs3</literal>example above is <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2632(title)
msgid "Using Cursors"
msgstr ""

#: xml/plpgsql.xml:2633(para)
msgid "Once a cursor has been opened, it can be manipulated with the statements described here."
msgstr ""

#: xml/plpgsql.xml:2635(para)
msgid "These manipulations need not occur in the same function that opened the cursor to begin with. You can return a <type>refcursor</type>value out of a function and let the caller operate on the cursor. (Internally, a <type>refcursor</type>value is simply the string name of a so-called portal containing the active query for the cursor. This name can be passed around, assigned to other <type>refcursor</type>variables, and so on, without disturbing the portal.)"
msgstr ""

#: xml/plpgsql.xml:2644(para)
msgid "All portals are implicitly closed at transaction end. Therefore a <type>refcursor</type>value is usable to reference an open cursor only until the end of the transaction."
msgstr ""

#: xml/plpgsql.xml:2650(literal)
msgid "FETCH"
msgstr ""

#: xml/plpgsql.xml:2654(replaceable) xml/plpgsql.xml:2705(replaceable)
msgid "direction"
msgstr ""

#: xml/plpgsql.xml:2653(optional) xml/plpgsql.xml:2704(optional)
msgid "<placeholder-1/>{ FROM | IN }"
msgstr ""

#: xml/plpgsql.xml:2657(replaceable)
msgid "target"
msgstr ""

#: xml/plpgsql.xml:2652(synopsis)
#, no-wrap
msgid "FETCH \n        <placeholder-1/>\n        <placeholder-2/>INTO \n        <placeholder-3/>;"
msgstr ""

#: xml/plpgsql.xml:2658(para)
msgid "<command>FETCH</command>retrieves the next row from the cursor into a target, which might be a row variable, a record variable, or a comma-separated list of simple variables, just like <command>SELECT INTO</command>. If there is no next row, the target is set to NULL(s). As with <command>SELECT INTO</command>, the special variable <literal>FOUND</literal>can be checked to see whether a row was obtained or not."
msgstr ""

#: xml/plpgsql.xml:2668(para)
msgid "The <replaceable>direction</replaceable>clause can be any of the variants allowed in the SQL <xref linkend=\"sql-fetch\">command except the ones that can fetch more than one row; namely, it can be <literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, <literal>ABSOLUTE</literal><replaceable>count</replaceable>, <literal>RELATIVE</literal><replaceable>count</replaceable>, <literal>FORWARD</literal>, or <literal>BACKWARD</literal>. Omitting <replaceable>direction</replaceable>is the same as specifying <literal>NEXT</literal>. <replaceable>direction</replaceable>values that require moving backward are likely to fail unless the cursor was declared or opened with the <literal>SCROLL</literal>option.</xref>"
msgstr ""

#: xml/plpgsql.xml:2690(para)
msgid "<replaceable>cursor</replaceable>must be the name of a <type>refcursor</type>variable that references an open cursor portal."
msgstr ""

#: xml/plpgsql.xml:2695(programlisting)
#, no-wrap
msgid "FETCH curs1 INTO rowvar; FETCH curs2 INTO\n        foo, bar, baz; FETCH LAST FROM curs3 INTO x, y; FETCH\n        RELATIVE -2 FROM curs4 INTO x;"
msgstr ""

#: xml/plpgsql.xml:2701(literal)
msgid "MOVE"
msgstr ""

#: xml/plpgsql.xml:2703(synopsis)
#, no-wrap
msgid "MOVE \n        <placeholder-1/>\n        <placeholder-2/>;"
msgstr ""

#: xml/plpgsql.xml:2708(para)
msgid "<command>MOVE</command>repositions a cursor without retrieving any data. <command>MOVE</command>works exactly like the <command>FETCH</command>command, except it only repositions the cursor and does not return the row moved to. As with <command>SELECT INTO</command>, the special variable <literal>FOUND</literal>can be checked to see whether there was a next row to move to."
msgstr ""

#: xml/plpgsql.xml:2717(para)
msgid "The <replaceable>direction</replaceable>clause can be any of the variants allowed in the SQL <xref linkend=\"sql-fetch\">command, namely <literal>NEXT</literal>, <literal>PRIOR</literal>, <literal>FIRST</literal>, <literal>LAST</literal>, <literal>ABSOLUTE</literal><replaceable>count</replaceable>, <literal>RELATIVE</literal><replaceable>count</replaceable>, <literal>ALL</literal>, <literal>FORWARD</literal><optional><replaceable>count</replaceable>| <literal>ALL</literal></optional>, or <literal>BACKWARD</literal><optional><replaceable>count</replaceable>| <literal>ALL</literal></optional>. Omitting <replaceable>direction</replaceable>is the same as specifying <literal>NEXT</literal>. <replaceable>direction</replaceable>values that require moving backward are likely to fail unless the cursor was declared or opened with the <literal>SCROLL</literal>option.</xref>"
msgstr ""

#: xml/plpgsql.xml:2746(programlisting)
#, no-wrap
msgid "MOVE curs1; MOVE LAST FROM curs3; MOVE\n        RELATIVE -2 FROM curs4; MOVE FORWARD 2 FROM\n        curs4;"
msgstr ""

#: xml/plpgsql.xml:2752(literal)
msgid "UPDATE/DELETE WHERE CURRENT OF"
msgstr ""

#: xml/plpgsql.xml:2755(replaceable) xml/plpgsql.xml:2757(replaceable)
msgid "table"
msgstr ""

#: xml/plpgsql.xml:2754(synopsis)
#, no-wrap
msgid "UPDATE \n        <placeholder-1/>SET ... WHERE CURRENT OF \n        <placeholder-2/>; DELETE FROM \n        <placeholder-3/>WHERE CURRENT OF \n        <placeholder-4/>;"
msgstr ""

#: xml/plpgsql.xml:2759(para)
msgid "When a cursor is positioned on a table row, that row can be updated or deleted using the cursor to identify the row. There are restrictions on what the cursor's query can be (in particular, no grouping) and it's best to use <literal>FOR UPDATE</literal>in the cursor. For more information see the <xref linkend=\"sql-declare\">reference page.</xref>"
msgstr ""

#: xml/plpgsql.xml:2767(programlisting)
#, no-wrap
msgid "UPDATE foo SET dataval = myval WHERE\n        CURRENT OF curs1;"
msgstr ""

#: xml/plpgsql.xml:2772(literal)
msgid "CLOSE"
msgstr ""

#: xml/plpgsql.xml:2774(synopsis)
#, no-wrap
msgid "CLOSE \n        <placeholder-1/>;"
msgstr ""

#: xml/plpgsql.xml:2776(para)
msgid "<command>CLOSE</command>closes the portal underlying an open cursor. This can be used to release resources earlier than end of transaction, or to free up the cursor variable to be opened again."
msgstr ""

#: xml/plpgsql.xml:2782(programlisting)
#, no-wrap
msgid "CLOSE curs1;"
msgstr ""

#: xml/plpgsql.xml:2785(title)
msgid "Returning Cursors"
msgstr ""

#: xml/plpgsql.xml:2786(para)
msgid "<application>PL/pgSQL</application>functions can return cursors to the caller. This is useful to return multiple rows or columns, especially with very large result sets. To do this, the function opens the cursor and returns the cursor name to the caller (or simply opens the cursor using a portal name specified by or otherwise known to the caller). The caller can then fetch rows from the cursor. The cursor can be closed by the caller, or it will be closed automatically when the transaction closes."
msgstr ""

#: xml/plpgsql.xml:2796(para)
msgid "The portal name used for a cursor can be specified by the programmer or automatically generated. To specify a portal name, simply assign a string to the <type>refcursor</type>variable before opening it. The string value of the <type>refcursor</type>variable will be used by <command>OPEN</command>as the name of the underlying portal. However, if the <type>refcursor</type>variable is null, <command>OPEN</command>automatically generates a name that does not conflict with any existing portal, and assigns it to the <type>refcursor</type>variable."
msgstr ""

#: xml/plpgsql.xml:2810(para)
msgid "A bound cursor variable is initialized to the string value representing its name, so that the portal name is the same as the cursor variable name, unless the programmer overrides it by assignment before opening the cursor. But an unbound cursor variable defaults to the null value initially, so it will receive an automatically-generated unique name, unless overridden."
msgstr ""

#: xml/plpgsql.xml:2821(programlisting)
#, no-wrap
msgid "CREATE TABLE test (col text); INSERT INTO\n        test VALUES ('123'); CREATE FUNCTION reffunc(refcursor)\n        RETURNS refcursor AS ' BEGIN OPEN $1 FOR SELECT col FROM\n        test; RETURN $1; END; ' LANGUAGE plpgsql; BEGIN; SELECT\n        reffunc('funccursor'); FETCH ALL IN funccursor;\n        COMMIT;"
msgstr ""

#: xml/plpgsql.xml:2819(para)
msgid "The following example shows one way a cursor name can be supplied by the caller: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2829(programlisting)
#, no-wrap
msgid "CREATE FUNCTION reffunc2() RETURNS\n        refcursor AS ' DECLARE ref refcursor; BEGIN OPEN ref FOR\n        SELECT col FROM test; RETURN ref; END; ' LANGUAGE plpgsql;\n        -- need to be in a transaction to use cursors. BEGIN;\n        SELECT reffunc2(); reffunc2 -------------------- unnamed\n        cursor 1 (1 row) FETCH ALL IN \"unnamed cursor 1\";\n        COMMIT;"
msgstr ""

#: xml/plpgsql.xml:2827(para)
msgid "The following example uses automatic cursor name generation: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2838(programlisting)
#, no-wrap
msgid "CREATE FUNCTION myfunc(refcursor,\n        refcursor) RETURNS SETOF refcursor AS $$ BEGIN OPEN $1 FOR\n        SELECT * FROM table_1; RETURN NEXT $1; OPEN $2 FOR SELECT *\n        FROM table_2; RETURN NEXT $2; END; $$ LANGUAGE plpgsql; --\n        need to be in a transaction to use cursors. BEGIN; SELECT *\n        FROM myfunc('a', 'b'); FETCH ALL FROM a; FETCH ALL FROM b;\n        COMMIT;"
msgstr ""

#: xml/plpgsql.xml:2836(para)
msgid "The following example shows one way to return multiple cursors from a single function: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2848(title)
msgid "Looping Through a Cursor's Result"
msgstr ""

#: xml/plpgsql.xml:2849(para)
msgid "There is a variant of the <command>FOR</command>statement that allows iterating through the rows returned by a cursor. The syntax is: <synopsis>\n      <optional>\n        <replaceable>label</replaceable>\n      </optional>FOR \n      <replaceable>recordvar</replaceable>IN \n      <replaceable>bound_cursorvar</replaceable>\n      <optional>( \n      <optional>\n      <replaceable>argument_name</replaceable>:=</optional>\n      <replaceable>argument_value</replaceable>\n      <optional>, ...</optional>)</optional>LOOP \n      <replaceable>statements</replaceable>END LOOP \n      <optional>\n        <replaceable>label</replaceable>\n      </optional>;</synopsis>The cursor variable must have been bound to some query when it was declared, and it <emphasis>cannot</emphasis>be open already. The <command>FOR</command>statement automatically opens the cursor, and it closes the cursor again when the loop exits. A list of actual argument value expressions must appear if and only if the cursor was declared to take arguments. These values will be substituted in the query, in just the same way as during an <command>OPEN</command>(see <xref linkend=\"plpgsql-open-bound-cursor\">).</xref>"
msgstr ""

#: xml/plpgsql.xml:2877(para)
msgid "The variable <replaceable>recordvar</replaceable>is automatically defined as type <type>record</type>and exists only inside the loop (any existing definition of the variable name is ignored within the loop). Each row returned by the cursor is successively assigned to this record variable and the loop body is executed."
msgstr ""

#: xml/plpgsql.xml:2888(title)
msgid "Errors and Messages"
msgstr ""

#: xml/plpgsql.xml:2890(title)
msgid "Reporting Errors and Messages"
msgstr ""

#: xml/plpgsql.xml:2892(primary)
msgid "RAISE"
msgstr ""

#: xml/plpgsql.xml:2896(primary)
msgid "reporting errors"
msgstr ""

#: xml/plpgsql.xml:2899(para)
msgid "Use the <command>RAISE</command>statement to report messages and raise errors. <synopsis>RAISE \n      <optional>\n        <replaceable class=\"parameter\">level</replaceable>\n      </optional>' \n      <replaceable class=\"parameter\">format</replaceable>' \n      <optional>, \n      <replaceable class=\"parameter\">expression</replaceable>\n      <optional>, ...</optional></optional>\n      <optional>USING \n      <replaceable class=\"parameter\">option</replaceable>= \n      <replaceable class=\"parameter\">expression</replaceable>\n      <optional>, ...</optional></optional>; RAISE \n      <optional>\n        <replaceable class=\"parameter\">level</replaceable>\n      </optional>\n      <replaceable class=\"parameter\">condition_name</replaceable>\n      <optional>USING \n      <replaceable class=\"parameter\">option</replaceable>= \n      <replaceable class=\"parameter\">expression</replaceable>\n      <optional>, ...</optional></optional>; RAISE \n      <optional>\n        <replaceable class=\"parameter\">level</replaceable>\n      </optional>SQLSTATE ' \n      <replaceable class=\"parameter\">sqlstate</replaceable>' \n      <optional>USING \n      <replaceable class=\"parameter\">option</replaceable>= \n      <replaceable class=\"parameter\">expression</replaceable>\n      <optional>, ...</optional></optional>; RAISE \n      <optional>\n        <replaceable class=\"parameter\">level</replaceable>\n      </optional>USING \n      <replaceable class=\"parameter\">option</replaceable>= \n      <replaceable class=\"parameter\">expression</replaceable>\n      <optional>, ...</optional>; RAISE ;</synopsis>The <replaceable class=\"parameter\">level</replaceable>option specifies the error severity. Allowed levels are <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, <literal>WARNING</literal>, and <literal>EXCEPTION</literal>, with <literal>EXCEPTION</literal>being the default. <literal>EXCEPTION</literal>raises an error (which normally aborts the current transaction); the other levels only generate messages of different priority levels. Whether messages of a particular priority are reported to the client, written to the server log, or both is controlled by the <xref linkend=\"guc-log-min-messages\">and <xref linkend=\"guc-client-min-messages\">configuration variables. See <xref linkend=\"runtime-config\">for more information.</xref></xref></xref>"
msgstr ""

#: xml/plpgsql.xml:2955(para)
msgid "After <replaceable class=\"parameter\">level</replaceable>if any, you can write a <replaceable class=\"parameter\">format</replaceable>(which must be a simple string literal, not an expression). The format string specifies the error message text to be reported. The format string can be followed by optional argument expressions to be inserted into the message. Inside the format string, <literal>%</literal>is replaced by the string representation of the next optional argument's value. Write <literal>%%</literal>to emit a literal <literal>%</literal>. The number of arguments must match the number of <literal>%</literal>placeholders in the format string, or an error is raised during the compilation of the function."
msgstr ""

#: xml/plpgsql.xml:2975(programlisting)
#, no-wrap
msgid "RAISE NOTICE 'Calling cs_create_job(%)',\n      v_job_id;"
msgstr ""

#: xml/plpgsql.xml:2972(para)
msgid "In this example, the value of <literal>v_job_id</literal>will replace the <literal>%</literal>in the string: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:2990(literal)
msgid "MESSAGE"
msgstr ""

#: xml/plpgsql.xml:2993(para)
msgid "Sets the error message text. This option can't be used in the form of <command>RAISE</command>that includes a format string before <literal>USING</literal>."
msgstr ""

#: xml/plpgsql.xml:3002(literal)
msgid "DETAIL"
msgstr ""

#: xml/plpgsql.xml:3005(para)
msgid "Supplies an error detail message."
msgstr ""

#: xml/plpgsql.xml:3010(literal)
msgid "HINT"
msgstr ""

#: xml/plpgsql.xml:3013(para)
msgid "Supplies a hint message."
msgstr ""

#: xml/plpgsql.xml:3018(literal)
msgid "ERRCODE"
msgstr ""

#: xml/plpgsql.xml:3021(para)
msgid "Specifies the error code (SQLSTATE) to report, either by condition name, as shown in <xref linkend=\"errcodes-appendix\">, or directly as a five-character SQLSTATE code.</xref>"
msgstr ""

#: xml/plpgsql.xml:3029(literal)
msgid "COLUMN"
msgstr ""

#: xml/plpgsql.xml:3032(literal)
msgid "CONSTRAINT"
msgstr ""

#: xml/plpgsql.xml:3035(literal)
msgid "DATATYPE"
msgstr ""

#: xml/plpgsql.xml:3038(literal)
msgid "TABLE"
msgstr ""

#: xml/plpgsql.xml:3041(literal)
msgid "SCHEMA"
msgstr ""

#: xml/plpgsql.xml:3044(para)
msgid "Supplies the name of a related object."
msgstr ""

#: xml/plpgsql.xml:2977(para)
msgid "You can attach additional information to the error report by writing <literal>USING</literal>followed by <replaceable class=\"parameter\">option</replaceable>= <replaceable class=\"parameter\">expression</replaceable>items. Each <replaceable class=\"parameter\">expression</replaceable>can be any string-valued expression. The allowed <replaceable class=\"parameter\">option</replaceable>key words are: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:3050(programlisting)
#, no-wrap
msgid "RAISE EXCEPTION 'Nonexistent ID --&gt; %',\n      user_id USING HINT = 'Please check your user\n      ID';"
msgstr ""

#: xml/plpgsql.xml:3048(para)
msgid "This example will abort the transaction with the given error message and hint: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:3055(programlisting)
#, no-wrap
msgid "RAISE 'Duplicate user ID: %', user_id USING\n      ERRCODE = 'unique_violation'; RAISE 'Duplicate user ID: %',\n      user_id USING ERRCODE = '23505';"
msgstr ""

#: xml/plpgsql.xml:3053(para)
msgid "These two examples show equivalent ways of setting the SQLSTATE: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:3061(programlisting)
#, no-wrap
msgid "RAISE division_by_zero; RAISE SQLSTATE\n      '22012';"
msgstr ""

#: xml/plpgsql.xml:3066(programlisting)
#, no-wrap
msgid "RAISE unique_violation USING MESSAGE =\n      'Duplicate user ID: ' || user_id;"
msgstr ""

#: xml/plpgsql.xml:3058(para)
msgid "There is a second <command>RAISE</command>syntax in which the main argument is the condition name or SQLSTATE to be reported, for example: <placeholder-1/>In this syntax, <literal>USING</literal>can be used to supply a custom error message, detail, or hint. Another way to do the earlier example is <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:3068(para)
msgid "Still another variant is to write <literal>RAISE USING</literal>or <literal>RAISE <replaceable class=\"parameter\"> level</replaceable>USING</literal>and put everything else into the <literal>USING</literal>list."
msgstr ""

#: xml/plpgsql.xml:3075(para)
msgid "The last variant of <command>RAISE</command>has no parameters at all. This form can only be used inside a <literal>BEGIN</literal>block's <literal>EXCEPTION</literal>clause; it causes the error currently being handled to be re-thrown."
msgstr ""

#: xml/plpgsql.xml:3082(para)
msgid "Before <productname>PostgreSQL</productname>9.1, <command>RAISE</command>without parameters was interpreted as re-throwing the error from the block containing the active exception handler. Thus an <literal>EXCEPTION</literal>clause nested within that handler could not catch it, even if the <command>RAISE</command>was within the nested <literal>EXCEPTION</literal>clause's block. This was deemed surprising as well as being incompatible with Oracle's PL/SQL."
msgstr ""

#: xml/plpgsql.xml:3094(para)
msgid "If no condition name nor SQLSTATE is specified in a <command>RAISE EXCEPTION</command>command, the default is to use <literal>RAISE_EXCEPTION</literal>( <literal>P0001</literal>). If no message text is specified, the default is to use the condition name or SQLSTATE as message text."
msgstr ""

#: xml/plpgsql.xml:3102(para)
msgid "When specifying an error code by SQLSTATE code, you are not limited to the predefined error codes, but can select any error code consisting of five digits and/or upper-case ASCII letters, other than <literal>00000</literal>. It is recommended that you avoid throwing error codes that end in three zeroes, because these are category codes and can only be trapped by trapping the whole category."
msgstr ""

#: xml/plpgsql.xml:3113(title)
msgid "Checking Assertions"
msgstr ""

#: xml/plpgsql.xml:3115(primary)
msgid "ASSERT"
msgstr ""

#: xml/plpgsql.xml:3119(primary)
msgid "assertions"
msgstr ""

#: xml/plpgsql.xml:3124(varname)
msgid "plpgsql.check_asserts"
msgstr ""

#: xml/plpgsql.xml:3123(primary) xml/plpgsql.xml:3746(primary)
msgid "<placeholder-1/>configuration parameter"
msgstr ""

#: xml/plpgsql.xml:3127(para)
msgid "The <command>ASSERT</command>statement is a convenient shorthand for inserting debugging checks into <application>PL/pgSQL</application>functions. <synopsis>ASSERT \n      <replaceable class=\"parameter\">condition</replaceable>\n      <optional>, \n      <replaceable class=\"parameter\">\n      message</replaceable></optional>;</synopsis>The <replaceable class=\"parameter\">condition</replaceable>is a Boolean expression that is expected to always evaluate to true; if it does, the <command>ASSERT</command>statement does nothing further. If the result is false or null, then an <literal>ASSERT_FAILURE</literal>exception is raised. (If an error occurs while evaluating the <replaceable class=\"parameter\">condition</replaceable>, it is reported as a normal error.)"
msgstr ""

#: xml/plpgsql.xml:3145(para)
msgid "If the optional <replaceable class=\"parameter\">message</replaceable>is provided, it is an expression whose result (if not null) replaces the default error message text <quote>assertion failed</quote>, should the <replaceable class=\"parameter\">condition</replaceable>fail. The <replaceable class=\"parameter\"> message</replaceable>expression is not evaluated in the normal case where the assertion succeeds."
msgstr ""

#: xml/plpgsql.xml:3155(para)
msgid "Testing of assertions can be enabled or disabled via the configuration parameter <literal>plpgsql.check_asserts</literal>, which takes a Boolean value; the default is <literal>on</literal>. If this parameter is <literal>off</literal>then <command>ASSERT</command>statements do nothing."
msgstr ""

#: xml/plpgsql.xml:3162(para)
msgid "Note that <command>ASSERT</command>is meant for detecting program bugs, not for reporting ordinary error conditions. Use the <command>RAISE</command>statement, described above, for that."
msgstr ""

#: xml/plpgsql.xml:3170(title)
msgid "Trigger Procedures"
msgstr ""

#: xml/plpgsql.xml:3172(primary)
msgid "trigger"
msgstr ""

#: xml/plpgsql.xml:3176(title)
msgid "Triggers on Data Changes"
msgstr ""

#: xml/plpgsql.xml:3177(para)
msgid "<application>PL/pgSQL</application>can be used to define trigger procedures. A trigger procedure is created with the <command>CREATE FUNCTION</command>command, declaring it as a function with no arguments and a return type of <type>trigger</type>. Note that the function must be declared with no arguments even if it expects to receive arguments specified in <command>CREATE TRIGGER</command>trigger arguments are passed via <varname>TG_ARGV</varname>, as described below."
msgstr ""

#: xml/plpgsql.xml:3195(varname)
msgid "NEW"
msgstr ""

#: xml/plpgsql.xml:3198(para)
msgid "Data type <type>RECORD</type>; variable holding the new database row for <command>INSERT</command>/ <command>UPDATE</command>operations in row-level triggers. This variable is unassigned in statement-level triggers and for <command>DELETE</command>operations."
msgstr ""

#: xml/plpgsql.xml:3210(varname)
msgid "OLD"
msgstr ""

#: xml/plpgsql.xml:3213(para)
msgid "Data type <type>RECORD</type>; variable holding the old database row for <command>UPDATE</command>/ <command>DELETE</command>operations in row-level triggers. This variable is unassigned in statement-level triggers and for <command>INSERT</command>operations."
msgstr ""

#: xml/plpgsql.xml:3225(varname)
msgid "TG_NAME"
msgstr ""

#: xml/plpgsql.xml:3228(para)
msgid "Data type <type>name</type>; variable that contains the name of the trigger actually fired."
msgstr ""

#: xml/plpgsql.xml:3235(varname)
msgid "TG_WHEN"
msgstr ""

#: xml/plpgsql.xml:3238(para)
msgid "Data type <type>text</type>; a string of <literal>BEFORE</literal>, <literal>AFTER</literal>, or <literal>INSTEAD OF</literal>, depending on the trigger's definition."
msgstr ""

#: xml/plpgsql.xml:3248(varname)
msgid "TG_LEVEL"
msgstr ""

#: xml/plpgsql.xml:3251(para)
msgid "Data type <type>text</type>; a string of either <literal>ROW</literal>or <literal>STATEMENT</literal>depending on the trigger's definition."
msgstr ""

#: xml/plpgsql.xml:3260(varname)
msgid "TG_OP"
msgstr ""

#: xml/plpgsql.xml:3263(para)
msgid "Data type <type>text</type>; a string of <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, or <literal>TRUNCATE</literal>telling for which operation the trigger was fired."
msgstr ""

#: xml/plpgsql.xml:3274(varname)
msgid "TG_RELID"
msgstr ""

#: xml/plpgsql.xml:3277(para)
msgid "Data type <type>oid</type>; the object ID of the table that caused the trigger invocation."
msgstr ""

#: xml/plpgsql.xml:3284(varname)
msgid "TG_RELNAME"
msgstr ""

#: xml/plpgsql.xml:3287(para)
msgid "Data type <type>name</type>; the name of the table that caused the trigger invocation. This is now deprecated, and could disappear in a future release. Use <literal>TG_TABLE_NAME</literal>instead."
msgstr ""

#: xml/plpgsql.xml:3296(varname)
msgid "TG_TABLE_NAME"
msgstr ""

#: xml/plpgsql.xml:3299(para)
msgid "Data type <type>name</type>; the name of the table that caused the trigger invocation."
msgstr ""

#: xml/plpgsql.xml:3306(varname)
msgid "TG_TABLE_SCHEMA"
msgstr ""

#: xml/plpgsql.xml:3309(para)
msgid "Data type <type>name</type>; the name of the schema of the table that caused the trigger invocation."
msgstr ""

#: xml/plpgsql.xml:3316(varname)
msgid "TG_NARGS"
msgstr ""

#: xml/plpgsql.xml:3319(para)
msgid "Data type <type>integer</type>; the number of arguments given to the trigger procedure in the <command>CREATE TRIGGER</command>statement."
msgstr ""

#: xml/plpgsql.xml:3327(varname)
msgid "TG_ARGV[]"
msgstr ""

#: xml/plpgsql.xml:3330(para)
msgid "Data type array of <type>text</type>; the arguments from the <command>CREATE TRIGGER</command>statement. The index counts from 0. Invalid indexes (less than 0 or greater than or equal to <varname>tg_nargs</varname>) result in a null value."
msgstr ""

#: xml/plpgsql.xml:3188(para)
msgid "When a <application>PL/pgSQL</application>function is called as a trigger, several special variables are created automatically in the top-level block. They are: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:3340(para)
msgid "A trigger function must return either <symbol>NULL</symbol>or a record/row value having exactly the structure of the table the trigger was fired for."
msgstr ""

#: xml/plpgsql.xml:3343(para)
msgid "Row-level triggers fired <literal>BEFORE</literal>can return null to signal the trigger manager to skip the rest of the operation for this row (i.e., subsequent triggers are not fired, and the <command>INSERT</command>/ <command>UPDATE</command>/ <command>DELETE</command>does not occur for this row). If a nonnull value is returned then the operation proceeds with that row value. Returning a row value different from the original value of <varname>NEW</varname>alters the row that will be inserted or updated. Thus, if the trigger function wants the triggering action to succeed normally without altering the row value, <varname>NEW</varname>(or a value equal thereto) has to be returned. To alter the row to be stored, it is possible to replace single values directly in <varname>NEW</varname>and return the modified <varname>NEW</varname>, or to build a complete new record/row to return. In the case of a before-trigger on <command>DELETE</command>, the returned value has no direct effect, but it has to be nonnull to allow the trigger action to proceed. Note that <varname>NEW</varname>is null in <command>DELETE</command>triggers, so returning that is usually not sensible. The usual idiom in <command>DELETE</command>triggers is to return <varname>OLD</varname>."
msgstr ""

#: xml/plpgsql.xml:3370(para)
msgid "<literal>INSTEAD OF</literal>triggers (which are always row-level triggers, and may only be used on views) can return null to signal that they did not perform any updates, and that the rest of the operation for this row should be skipped (i.e., subsequent triggers are not fired, and the row is not counted in the rows-affected status for the surrounding <command>INSERT</command>/ <command>UPDATE</command>/ <command>DELETE</command>). Otherwise a nonnull value should be returned, to signal that the trigger performed the requested operation. For <command>INSERT</command>and <command>UPDATE</command>operations, the return value should be <varname>NEW</varname>, which the trigger function may modify to support <command>INSERT RETURNING</command>and <command>UPDATE RETURNING</command>(this will also affect the row value passed to any subsequent triggers, or passed to a special <varname>EXCLUDED</varname>alias reference within an <command>INSERT</command>statement with an <literal>ON CONFLICT DO UPDATE</literal>clause). For <command>DELETE</command>operations, the return value should be <varname>OLD</varname>."
msgstr ""

#: xml/plpgsql.xml:3397(para)
msgid "The return value of a row-level trigger fired <literal>AFTER</literal>or a statement-level trigger fired <literal>BEFORE</literal>or <literal>AFTER</literal>is always ignored; it might as well be null. However, any of these types of triggers might still abort the entire operation by raising an error."
msgstr ""

#: xml/plpgsql.xml:3404(xref)
msgid "shows an example of a trigger procedure in <placeholder-1/>."
msgstr ""

#: xml/plpgsql.xml:3409(title)
msgid "A <application>PL/pgSQL</application>Trigger Procedure"
msgstr ""

#: xml/plpgsql.xml:3412(para)
msgid "This example trigger ensures that any time a row is inserted or updated in the table, the current user name and time are stamped into the row. And it checks that an employee's name is given and that the salary is a positive value."
msgstr ""

#: xml/plpgsql.xml:3417(programlisting)
#, no-wrap
msgid "CREATE TABLE emp ( empname text, salary\n        integer, last_date timestamp, last_user text ); CREATE\n        FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$ BEGIN\n        -- Check that empname and salary are given IF NEW.empname\n        IS NULL THEN RAISE EXCEPTION 'empname cannot be null'; END\n        IF; IF NEW.salary IS NULL THEN RAISE EXCEPTION '% cannot\n        have null salary', NEW.empname; END IF; -- Who works for us\n        when she must pay for it? IF NEW.salary 0 THEN RAISE\n        EXCEPTION '% cannot have a negative salary', NEW.empname;\n        END IF; -- Remember who changed the payroll when\n        NEW.last_date := current_timestamp; NEW.last_user :=\n        current_user; RETURN NEW; END; $emp_stamp$ LANGUAGE\n        plpgsql; CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE\n        ON emp FOR EACH ROW EXECUTE PROCEDURE\n        emp_stamp();"
msgstr ""

#: xml/plpgsql.xml:3433(para)
msgid "Another way to log changes to a table involves creating a new table that holds a row for each insert, update, or delete that occurs. This approach can be thought of as auditing changes to a table. <xref linkend=\"plpgsql-trigger-audit-example\">shows an example of an audit trigger procedure in <application>PL/pgSQL</application>.</xref>"
msgstr ""

#: xml/plpgsql.xml:3441(title)
msgid "A <application>PL/pgSQL</application>Trigger Procedure For Auditing"
msgstr ""

#: xml/plpgsql.xml:3444(para)
msgid "This example trigger ensures that any insert, update or delete of a row in the <literal>emp</literal>table is recorded (i.e., audited) in the <literal>emp_audit</literal>table. The current time and user name are stamped into the row, together with the type of operation performed on it."
msgstr ""

#: xml/plpgsql.xml:3451(programlisting)
#, no-wrap
msgid "CREATE TABLE emp ( empname text NOT NULL,\n        salary integer ); CREATE TABLE emp_audit( operation char(1)\n        NOT NULL, stamp timestamp NOT NULL, userid text NOT NULL,\n        empname text NOT NULL, salary integer ); CREATE OR REPLACE\n        FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n        BEGIN -- -- Create a row in emp_audit to reflect the\n        operation performed on emp, -- make use of the special\n        variable TG_OP to work out the operation. -- IF (TG_OP =\n        'DELETE') THEN INSERT INTO emp_audit SELECT 'D', now(),\n        user, OLD.*; RETURN OLD; ELSIF (TG_OP = 'UPDATE') THEN\n        INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n        RETURN NEW; ELSIF (TG_OP = 'INSERT') THEN INSERT INTO\n        emp_audit SELECT 'I', now(), user, NEW.*; RETURN NEW; END\n        IF; RETURN NULL; -- result is ignored since this is an\n        AFTER trigger END; $emp_audit$ LANGUAGE plpgsql; CREATE\n        TRIGGER emp_audit AFTER INSERT OR UPDATE OR DELETE ON emp\n        FOR EACH ROW EXECUTE PROCEDURE\n        process_emp_audit();"
msgstr ""

#: xml/plpgsql.xml:3470(para)
msgid "A variation of the previous example uses a view joining the main table to the audit table, to show when each entry was last modified. This approach still records the full audit trail of changes to the table, but also presents a simplified view of the audit trail, showing just the last modified timestamp derived from the audit trail for each entry. <xref linkend=\"plpgsql-view-trigger-audit-example\">shows an example of an audit trigger on a view in <application>PL/pgSQL</application>.</xref>"
msgstr ""

#: xml/plpgsql.xml:3480(title)
msgid "A <application>PL/pgSQL</application>View Trigger Procedure For Auditing"
msgstr ""

#: xml/plpgsql.xml:3483(para)
msgid "This example uses a trigger on the view to make it updatable, and ensure that any insert, update or delete of a row in the view is recorded (i.e., audited) in the <literal>emp_audit</literal>table. The current time and user name are recorded, together with the type of operation performed, and the view displays the last modified time of each row."
msgstr ""

#: xml/plpgsql.xml:3490(programlisting)
#, no-wrap
msgid "CREATE TABLE emp ( empname text PRIMARY\n        KEY, salary integer ); CREATE TABLE emp_audit( operation\n        char(1) NOT NULL, userid text NOT NULL, empname text NOT\n        NULL, salary integer, stamp timestamp NOT NULL ); CREATE\n        VIEW emp_view AS SELECT e.empname, e.salary, max(ea.stamp)\n        AS last_updated FROM emp e LEFT JOIN emp_audit ea ON\n        ea.empname = e.empname GROUP BY 1, 2; CREATE OR REPLACE\n        FUNCTION update_emp_view() RETURNS TRIGGER AS $$ BEGIN --\n        -- Perform the required operation on emp, and create a row\n        in emp_audit -- to reflect the change made to emp. -- IF\n        (TG_OP = 'DELETE') THEN DELETE FROM emp WHERE empname =\n        OLD.empname; IF NOT FOUND THEN RETURN NULL; END IF;\n        OLD.last_updated = now(); INSERT INTO emp_audit VALUES('D',\n        user, OLD.*); RETURN OLD; ELSIF (TG_OP = 'UPDATE') THEN\n        UPDATE emp SET salary = NEW.salary WHERE empname =\n        OLD.empname; IF NOT FOUND THEN RETURN NULL; END IF;\n        NEW.last_updated = now(); INSERT INTO emp_audit VALUES('U',\n        user, NEW.*); RETURN NEW; ELSIF (TG_OP = 'INSERT') THEN\n        INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n        NEW.last_updated = now(); INSERT INTO emp_audit VALUES('I',\n        user, NEW.*); RETURN NEW; END IF; END; $$ LANGUAGE plpgsql;\n        CREATE TRIGGER emp_audit INSTEAD OF INSERT OR UPDATE OR\n        DELETE ON emp_view FOR EACH ROW EXECUTE PROCEDURE\n        update_emp_view();"
msgstr ""

#: xml/plpgsql.xml:3515(para)
msgid "One use of triggers is to maintain a summary table of another table. The resulting summary can be used in place of the original table for certain queries often with vastly reduced run times. This technique is commonly used in Data Warehousing, where the tables of measured or observed data (called fact tables) might be extremely large. <xref linkend=\"plpgsql-trigger-summary-example\">shows an example of a trigger procedure in <application>PL/pgSQL</application>that maintains a summary table for a fact table in a data warehouse.</xref>"
msgstr ""

#: xml/plpgsql.xml:3526(title)
msgid "A <application>PL/pgSQL</application>Trigger Procedure For Maintaining A Summary Table"
msgstr ""

#: xml/plpgsql.xml:3529(para)
msgid "The schema detailed here is partly based on the <emphasis>Grocery Store</emphasis>example from <emphasis>The Data Warehouse Toolkit</emphasis>by Ralph Kimball."
msgstr ""

#: xml/plpgsql.xml:3533(programlisting)
#, no-wrap
msgid "-- -- Main tables - time dimension and\n        sales fact. -- CREATE TABLE time_dimension ( time_key\n        integer NOT NULL, day_of_week integer NOT NULL,\n        day_of_month integer NOT NULL, month integer NOT NULL,\n        quarter integer NOT NULL, year integer NOT NULL ); CREATE\n        UNIQUE INDEX time_dimension_key ON\n        time_dimension(time_key); CREATE TABLE sales_fact (\n        time_key integer NOT NULL, product_key integer NOT NULL,\n        store_key integer NOT NULL, amount_sold numeric(12,2) NOT\n        NULL, units_sold integer NOT NULL, amount_cost\n        numeric(12,2) NOT NULL ); CREATE INDEX sales_fact_time ON\n        sales_fact(time_key); -- -- Summary table - sales by time.\n        -- CREATE TABLE sales_summary_bytime ( time_key integer NOT\n        NULL, amount_sold numeric(15,2) NOT NULL, units_sold\n        numeric(12) NOT NULL, amount_cost numeric(15,2) NOT NULL );\n        CREATE UNIQUE INDEX sales_summary_bytime_key ON\n        sales_summary_bytime(time_key); -- -- Function and trigger\n        to amend summarized column(s) on UPDATE, INSERT, DELETE. --\n        CREATE OR REPLACE FUNCTION maint_sales_summary_bytime()\n        RETURNS TRIGGER AS $maint_sales_summary_bytime$ DECLARE\n        delta_time_key integer; delta_amount_sold numeric(15,2);\n        delta_units_sold numeric(12); delta_amount_cost\n        numeric(15,2); BEGIN -- Work out the increment/decrement\n        amount(s). IF (TG_OP = 'DELETE') THEN delta_time_key =\n        OLD.time_key; delta_amount_sold = -1 * OLD.amount_sold;\n        delta_units_sold = -1 * OLD.units_sold; delta_amount_cost =\n        -1 * OLD.amount_cost; ELSIF (TG_OP = 'UPDATE') THEN --\n        forbid updates that change the time_key - -- (probably not\n        too onerous, as DELETE + INSERT is how most -- changes will\n        be made). IF ( OLD.time_key != NEW.time_key) THEN RAISE\n        EXCEPTION 'Update of time_key : % - % not allowed',\n        OLD.time_key, NEW.time_key; END IF; delta_time_key =\n        OLD.time_key; delta_amount_sold = NEW.amount_sold -\n        OLD.amount_sold; delta_units_sold = NEW.units_sold -\n        OLD.units_sold; delta_amount_cost = NEW.amount_cost -\n        OLD.amount_cost; ELSIF (TG_OP = 'INSERT') THEN\n        delta_time_key = NEW.time_key; delta_amount_sold =\n        NEW.amount_sold; delta_units_sold = NEW.units_sold;\n        delta_amount_cost = NEW.amount_cost; END IF; -- Insert or\n        update the summary row with the new values. insert_update\n        LOOP UPDATE sales_summary_bytime SET amount_sold =\n        amount_sold + delta_amount_sold, units_sold = units_sold +\n        delta_units_sold, amount_cost = amount_cost +\n        delta_amount_cost WHERE time_key = delta_time_key; EXIT\n        insert_update WHEN found; BEGIN INSERT INTO\n        sales_summary_bytime ( time_key, amount_sold, units_sold,\n        amount_cost) VALUES ( delta_time_key, delta_amount_sold,\n        delta_units_sold, delta_amount_cost ); EXIT insert_update;\n        EXCEPTION WHEN UNIQUE_VIOLATION THEN -- do nothing END; END\n        LOOP insert_update; RETURN NULL; END;\n        $maint_sales_summary_bytime$ LANGUAGE plpgsql; CREATE\n        TRIGGER maint_sales_summary_bytime AFTER INSERT OR UPDATE\n        OR DELETE ON sales_fact FOR EACH ROW EXECUTE PROCEDURE\n        maint_sales_summary_bytime(); INSERT INTO sales_fact\n        VALUES(1,1,1,10,3,15); INSERT INTO sales_fact\n        VALUES(1,2,1,20,5,35); INSERT INTO sales_fact\n        VALUES(2,2,1,40,15,135); INSERT INTO sales_fact\n        VALUES(2,3,1,10,1,13); SELECT * FROM sales_summary_bytime;\n        DELETE FROM sales_fact WHERE product_key = 1; SELECT * FROM\n        sales_summary_bytime; UPDATE sales_fact SET units_sold =\n        units_sold * 2; SELECT * FROM\n        sales_summary_bytime;"
msgstr ""

#: xml/plpgsql.xml:3598(title)
msgid "Triggers on Events"
msgstr ""

#: xml/plpgsql.xml:3599(para)
msgid "<application>PL/pgSQL</application>can be used to define event triggers. <productname>PostgreSQL</productname>requires that a procedure that is to be called as an event trigger must be declared as a function with no arguments and a return type of <literal>event_trigger</literal>."
msgstr ""

#: xml/plpgsql.xml:3614(varname)
msgid "TG_EVENT"
msgstr ""

#: xml/plpgsql.xml:3617(para)
msgid "Data type <type>text</type>; a string representing the event the trigger is fired for."
msgstr ""

#: xml/plpgsql.xml:3624(varname)
msgid "TG_TAG"
msgstr ""

#: xml/plpgsql.xml:3627(para)
msgid "Data type <type>text</type>; variable that contains the command tag for which the trigger is fired."
msgstr ""

#: xml/plpgsql.xml:3607(para)
msgid "When a <application>PL/pgSQL</application>function is called as a event trigger, several special variables are created automatically in the top-level block. They are: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:3634(xref)
msgid "shows an example of a event trigger procedure in <placeholder-1/>."
msgstr ""

#: xml/plpgsql.xml:3639(title)
msgid "A <application>PL/pgSQL</application>Event Trigger Procedure"
msgstr ""

#: xml/plpgsql.xml:3642(para)
msgid "This example trigger simply raises a <literal>NOTICE</literal>message each time a supported command is executed."
msgstr ""

#: xml/plpgsql.xml:3645(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION snitch() RETURNS\n        event_trigger AS $$ BEGIN RAISE NOTICE 'snitch: % %',\n        tg_event, tg_tag; END; $$ LANGUAGE plpgsql; CREATE EVENT\n        TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE\n        snitch();"
msgstr ""

#: xml/plpgsql.xml:3654(title)
msgid "<application>PL/pgSQL</application>Under the Hood"
msgstr ""

#: xml/plpgsql.xml:3656(para)
msgid "This section discusses some implementation details that are frequently important for <application>PL/pgSQL</application>users to know."
msgstr ""

#: xml/plpgsql.xml:3660(title)
msgid "Variable Substitution"
msgstr ""

#: xml/plpgsql.xml:3669(programlisting)
#, no-wrap
msgid "INSERT INTO foo (foo) VALUES\n      (foo);"
msgstr ""

#: xml/plpgsql.xml:3661(para)
msgid "SQL statements and expressions within a <application>PL/pgSQL</application>function can refer to variables and parameters of the function. Behind the scenes, <application>PL/pgSQL</application>substitutes query parameters for such references. Parameters will only be substituted in places where a parameter or column reference is syntactically allowed. As an extreme case, consider this example of poor programming style: <placeholder-1/>The first occurrence of <literal>foo</literal>must syntactically be a table name, so it will not be substituted, even if the function has a variable named <literal>foo</literal>. The second occurrence must be the name of a column of the table, so it will not be substituted either. Only the third occurrence is a candidate to be a reference to the function's variable."
msgstr ""

#: xml/plpgsql.xml:3679(para)
msgid "<productname>PostgreSQL</productname>versions before 9.0 would try to substitute the variable in all three cases, leading to syntax errors."
msgstr ""

#: xml/plpgsql.xml:3689(programlisting)
#, no-wrap
msgid "INSERT INTO dest (col) SELECT foo + bar FROM\n      src;"
msgstr ""

#: xml/plpgsql.xml:3684(para)
msgid "Since the names of variables are syntactically no different from the names of table columns, there can be ambiguity in statements that also refer to tables: is a given name meant to refer to a table column, or a variable? Let's change the previous example to <placeholder-1/>Here, <literal>dest</literal>and <literal>src</literal>must be table names, and <literal>col</literal>must be a column of <literal>dest</literal>, but <literal>foo</literal>and <literal>bar</literal>might reasonably be either variables of the function or columns of <literal>src</literal>."
msgstr ""

#: xml/plpgsql.xml:3699(para)
msgid "By default, <application>PL/pgSQL</application>will report an error if a name in a SQL statement could refer to either a variable or a table column. You can fix such a problem by renaming the variable or column, or by qualifying the ambiguous reference, or by telling <application>PL/pgSQL</application>which interpretation to prefer."
msgstr ""

#: xml/plpgsql.xml:3707(para)
msgid "The simplest solution is to rename the variable or column. A common coding rule is to use a different naming convention for <application>PL/pgSQL</application>variables than you use for column names. For example, if you consistently name function variables <literal>v_ <replaceable>something</replaceable></literal>while none of your column names start with <literal>v_</literal>, no conflicts will occur."
msgstr ""

#: xml/plpgsql.xml:3724(programlisting)
#, no-wrap
msgid "block DECLARE foo int; BEGIN foo := ...;\n      INSERT INTO dest (col) SELECT block.foo + bar FROM\n      src;"
msgstr ""

#: xml/plpgsql.xml:3717(para)
msgid "Alternatively you can qualify ambiguous references to make them clear. In the above example, <literal>src.foo</literal>would be an unambiguous reference to the table column. To create an unambiguous reference to a variable, declare it in a labeled block and use the block's label (see <xref linkend=\"plpgsql-structure\">). For example, <placeholder-1/>Here <literal>block.foo</literal>means the variable even if there is a column <literal>foo</literal>in <literal>src</literal>. Function parameters, as well as special variables such as <literal>FOUND</literal>, can be qualified by the function's name, because they are implicitly declared in an outer block labeled with the function's name.</xref>"
msgstr ""

#: xml/plpgsql.xml:3735(para)
msgid "Sometimes it is impractical to fix all the ambiguous references in a large body of <application>PL/pgSQL</application>code. In such cases you can specify that <application>PL/pgSQL</application>should resolve ambiguous references as the variable (which is compatible with <application>PL/pgSQL</application>'s behavior before <productname>PostgreSQL</productname>9.0), or as the table column (which is compatible with some other systems such as <productname>Oracle</productname>)."
msgstr ""

#: xml/plpgsql.xml:3747(varname)
msgid "plpgsql.variable_conflict"
msgstr ""

#: xml/plpgsql.xml:3750(para)
msgid "To change this behavior on a system-wide basis, set the configuration parameter <literal>plpgsql.variable_conflict</literal>to one of <literal>error</literal>, <literal>use_variable</literal>, or <literal>use_column</literal>(where <literal>error</literal>is the factory default). This parameter affects subsequent compilations of statements in <application>PL/pgSQL</application>functions, but not statements already compiled in the current session. Because changing this setting can cause unexpected changes in the behavior of <application>PL/pgSQL</application>functions, it can only be changed by a superuser."
msgstr ""

#: xml/plpgsql.xml:3767(programlisting)
#, no-wrap
msgid "#variable_conflict error #variable_conflict\n      use_variable #variable_conflict\n      use_column"
msgstr ""

#: xml/plpgsql.xml:3772(programlisting)
#, no-wrap
msgid "CREATE FUNCTION stamp_user(id int, comment\n      text) RETURNS void AS $$ #variable_conflict use_variable\n      DECLARE curtime timestamp := now(); BEGIN UPDATE users SET\n      last_modified = curtime, comment = comment WHERE users.id =\n      id; END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:3793(programlisting)
#, no-wrap
msgid "CREATE FUNCTION stamp_user(id int, comment\n      text) RETURNS void AS $$ fn DECLARE curtime timestamp :=\n      now(); BEGIN UPDATE users SET last_modified = fn.curtime,\n      comment = stamp_user.comment WHERE users.id = stamp_user.id;\n      END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:3764(para)
msgid "You can also set the behavior on a function-by-function basis, by inserting one of these special commands at the start of the function text: <placeholder-1/>These commands affect only the function they are written in, and override the setting of <literal>plpgsql.variable_conflict</literal>. An example is <placeholder-2/>In the <literal>UPDATE</literal>command, <literal>curtime</literal>, <literal>comment</literal>, and <literal>id</literal>will refer to the function's variable and parameters whether or not <literal>users</literal>has columns of those names. Notice that we had to qualify the reference to <literal>users.id</literal>in the <literal>WHERE</literal>clause to make it refer to the table column. But we did not have to qualify the reference to <literal>comment</literal>as a target in the <literal>UPDATE</literal>list, because syntactically that must be a column of <literal>users</literal>. We could write the same function without depending on the <literal>variable_conflict</literal>setting in this way: <placeholder-3/>"
msgstr ""

#: xml/plpgsql.xml:3798(para)
msgid "Variable substitution does not happen in the command string given to <command>EXECUTE</command>or one of its variants. If you need to insert a varying value into such a command, do so as part of constructing the string value, or use <literal>USING</literal>, as illustrated in <xref linkend=\"plpgsql-statements-executing-dyn\"> .</xref>"
msgstr ""

#: xml/plpgsql.xml:3806(para)
msgid "Variable substitution currently works only in <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command>commands, because the main SQL engine allows query parameters only in these commands. To use a non-constant name or value in other statement types (generically called utility statements), you must construct the utility statement as a string and <command>EXECUTE</command>it."
msgstr ""

#: xml/plpgsql.xml:3818(title)
msgid "Plan Caching"
msgstr ""

#: xml/plpgsql.xml:3819(para)
msgid "The <application>PL/pgSQL</application>interpreter parses the function's source text and produces an internal binary instruction tree the first time the function is called (within each session). The instruction tree fully translates the <application>PL/pgSQL</application>statement structure, but individual <acronym>SQL</acronym>expressions and <acronym>SQL</acronym>commands used in the function are not translated immediately."
msgstr ""

#: xml/plpgsql.xml:3830(para)
msgid "<indexterm><primary>preparing a query</primary><secondary>in PL/pgSQL</secondary></indexterm>As each expression and <acronym>SQL</acronym>command is first executed in the function, the <application>PL/pgSQL</application>interpreter parses and analyzes the command to create a prepared statement, using the <acronym>SPI</acronym>manager's <function>SPI_prepare</function>function. Subsequent visits to that expression or command reuse the prepared statement. Thus, a function with conditional code paths that are seldom visited will never incur the overhead of analyzing those commands that are never executed within the current session. A disadvantage is that errors in a specific expression or command cannot be detected until that part of the function is reached in execution. (Trivial syntax errors will be detected during the initial parsing pass, but anything deeper will not be detected until execution.)"
msgstr ""

#: xml/plpgsql.xml:3851(para)
msgid "<application>PL/pgSQL</application>(or more precisely, the SPI manager) can furthermore attempt to cache the execution plan associated with any particular prepared statement. If a cached plan is not used, then a fresh execution plan is generated on each visit to the statement, and the current parameter values (that is, <application>PL/pgSQL</application>variable values) can be used to optimize the selected plan. If the statement has no parameters, or is executed many times, the SPI manager will consider creating a <firstterm>generic</firstterm>plan that is not dependent on specific parameter values, and caching that for re-use. Typically this will happen only if the execution plan is not very sensitive to the values of the <application>PL/pgSQL</application>variables referenced in it. If it is, generating a plan each time is a net win. See <xref linkend=\"sql-prepare\">for more information about the behavior of prepared statements.</xref>"
msgstr ""

#: xml/plpgsql.xml:3870(para)
msgid "Because <application>PL/pgSQL</application>saves prepared statements and sometimes execution plans in this way, SQL commands that appear directly in a <application>PL/pgSQL</application>function must refer to the same tables and columns on every execution; that is, you cannot use a parameter as the name of a table or column in an SQL command. To get around this restriction, you can construct dynamic commands using the <application>PL/pgSQL</application><command>EXECUTE</command>statement at the price of performing new parse analysis and constructing a new execution plan on every execution."
msgstr ""

#: xml/plpgsql.xml:3883(para)
msgid "The mutable nature of record variables presents another problem in this connection. When fields of a record variable are used in expressions or statements, the data types of the fields must not change from one call of the function to the next, since each expression will be analyzed using the data type that is present when the expression is first reached. <command>EXECUTE</command>can be used to get around this problem when necessary."
msgstr ""

#: xml/plpgsql.xml:3891(para)
msgid "If the same function is used as a trigger for more than one table, <application>PL/pgSQL</application>prepares and caches statements independently for each such table that is, there is a cache for each trigger function and table combination, not just for each function. This alleviates some of the problems with varying data types; for instance, a trigger function will be able to work successfully with a column named <literal>key</literal>even if it happens to have different types in different tables."
msgstr ""

#: xml/plpgsql.xml:3902(para)
msgid "Likewise, functions having polymorphic argument types have a separate statement cache for each combination of actual argument types they have been invoked for, so that data type differences do not cause unexpected failures."
msgstr ""

#: xml/plpgsql.xml:3910(programlisting)
#, no-wrap
msgid "CREATE FUNCTION logfunc1(logtxt text) RETURNS\n      void AS $$ BEGIN INSERT INTO logtable VALUES (logtxt, 'now');\n      END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:3913(programlisting)
#, no-wrap
msgid "CREATE FUNCTION logfunc2(logtxt text) RETURNS\n      void AS $$ DECLARE curtime timestamp; BEGIN curtime := 'now';\n      INSERT INTO logtable VALUES (logtxt, curtime); END; $$\n      LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:3907(para)
msgid "Statement caching can sometimes have surprising effects on the interpretation of time-sensitive values. For example there is a difference between what these two functions do: <placeholder-1/>and: <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:3917(para)
msgid "In the case of <function>logfunc1</function>, the <productname>PostgreSQL</productname>main parser knows when analyzing the <command>INSERT</command>that the string <literal>'now'</literal>should be interpreted as <type>timestamp</type>, because the target column of <classname>logtable</classname>is of that type. Thus, <literal>'now'</literal>will be converted to a <type>timestamp</type>constant when the <command>INSERT</command>is analyzed, and then used in all invocations of <function>logfunc1</function>during the lifetime of the session. Needless to say, this isn't what the programmer wanted. A better idea is to use the <literal>now()</literal>or <literal>current_timestamp</literal>function."
msgstr ""

#: xml/plpgsql.xml:3934(para)
msgid "In the case of <function>logfunc2</function>, the <productname>PostgreSQL</productname>main parser does not know what type <literal>'now'</literal>should become and therefore it returns a data value of type <type>text</type>containing the string <literal>now</literal>. During the ensuing assignment to the local variable <varname>curtime</varname>, the <application>PL/pgSQL</application>interpreter casts this string to the <type>timestamp</type>type by calling the <function>text_out</function>and <function>timestamp_in</function>functions for the conversion. So, the computed time stamp is updated on each execution as the programmer expects. Even though this happens to work as expected, it's not terribly efficient, so use of the <literal>now()</literal>function would still be a better idea."
msgstr ""

#: xml/plpgsql.xml:3958(title)
msgid "Tips for Developing in <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:3970(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION testfunc(integer)\n    RETURNS integer AS $$ .... $$ LANGUAGE\n    plpgsql;"
msgstr ""

#: xml/plpgsql.xml:3960(para)
msgid "One good way to develop in <application>PL/pgSQL</application>is to use the text editor of your choice to create your functions, and in another window, use <application>psql</application>to load and test those functions. If you are doing it this way, it is a good idea to write the function using <command>CREATE OR REPLACE FUNCTION</command>. That way you can just reload the file to update the function definition. For example: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:3976(programlisting)
#, no-wrap
msgid "\\i filename.sql"
msgstr ""

#: xml/plpgsql.xml:3973(para)
msgid "While running <application>psql</application>, you can load or reload such a function definition file with: <placeholder-1/>and then immediately issue SQL commands to test the function."
msgstr ""

#: xml/plpgsql.xml:3978(para)
msgid "Another good way to develop in <application>PL/pgSQL</application>is with a GUI database access tool that facilitates development in a procedural language. One example of such a tool is <application>pgAdmin</application>, although others exist. These tools often provide convenient features such as escaping single quotes and making it easier to recreate and debug functions."
msgstr ""

#: xml/plpgsql.xml:3987(title)
msgid "Handling of Quotation Marks"
msgstr ""

#: xml/plpgsql.xml:4007(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION testfunc(integer)\n      RETURNS integer AS $PROC$ .... $PROC$ LANGUAGE\n      plpgsql;"
msgstr ""

#: xml/plpgsql.xml:3988(para)
msgid "The code of a <application>PL/pgSQL</application>function is specified in <command>CREATE FUNCTION</command>as a string literal. If you write the string literal in the ordinary way with surrounding single quotes, then any single quotes inside the function body must be doubled; likewise any backslashes must be doubled (assuming escape string syntax is used). Doubling quotes is at best tedious, and in more complicated cases the code can become downright incomprehensible, because you can easily find yourself needing half a dozen or more adjacent quote marks. It's recommended that you instead write the function body as a <quote>dollar-quoted</quote>string literal (see <xref linkend=\"sql-syntax-dollar-quoting\">). In the dollar-quoting approach, you never double any quote marks, but instead take care to choose a different dollar-quoting delimiter for each level of nesting you need. For example, you might write the <command>CREATE FUNCTION</command>command as: <placeholder-1/>Within this, you might use quote marks for simple literal strings in SQL commands and <literal>$$</literal>to delimit fragments of SQL commands that you are assembling as strings. If you need to quote text that includes <literal>$$</literal>, you could use <literal>$Q$</literal>, and so on.</xref>"
msgstr ""

#: xml/plpgsql.xml:4016(para)
msgid "The following chart shows what you have to do when writing quote marks without dollar quoting. It might be useful when translating pre-dollar quoting code into something more comprehensible."
msgstr ""

#: xml/plpgsql.xml:4022(term)
msgid "1 quotation mark"
msgstr ""

#: xml/plpgsql.xml:4025(programlisting)
#, no-wrap
msgid "CREATE FUNCTION foo() RETURNS integer\n            AS ' .... ' LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:4024(para)
msgid "To begin and end the function body, for example: <placeholder-1/>Anywhere within a single-quoted function body, quote marks <emphasis>must</emphasis>appear in pairs."
msgstr ""

#: xml/plpgsql.xml:4032(term)
msgid "2 quotation marks"
msgstr ""

#: xml/plpgsql.xml:4036(programlisting)
#, no-wrap
msgid "a_output := ''Blah''; SELECT * FROM\n            users WHERE f_name=''foobar'';"
msgstr ""

#: xml/plpgsql.xml:4039(programlisting)
#, no-wrap
msgid "a_output := 'Blah'; SELECT * FROM users\n            WHERE f_name='foobar';"
msgstr ""

#: xml/plpgsql.xml:4034(para)
msgid "For string literals inside the function body, for example: <placeholder-1/>In the dollar-quoting approach, you'd just write: <placeholder-2/>which is exactly what the <application>PL/pgSQL</application>parser would see in either case."
msgstr ""

#: xml/plpgsql.xml:4047(term)
msgid "4 quotation marks"
msgstr ""

#: xml/plpgsql.xml:4051(programlisting)
#, no-wrap
msgid "a_output := a_output || '' AND name\n            LIKE ''''foobar'''' AND xyz''"
msgstr ""

#: xml/plpgsql.xml:4049(para)
msgid "When you need a single quotation mark in a string constant inside the function body, for example: <placeholder-1/>The value actually appended to <literal>a_output</literal>would be: <literal>AND name LIKE 'foobar' AND xyz</literal>."
msgstr ""

#: xml/plpgsql.xml:4058(programlisting)
#, no-wrap
msgid "a_output := a_output || $$ AND name\n            LIKE 'foobar' AND xyz$$"
msgstr ""

#: xml/plpgsql.xml:4057(para)
msgid "In the dollar-quoting approach, you'd write: <placeholder-1/>being careful that any dollar-quote delimiters around this are not just <literal>$$</literal>."
msgstr ""

#: xml/plpgsql.xml:4066(term)
msgid "6 quotation marks"
msgstr ""

#: xml/plpgsql.xml:4071(programlisting)
#, no-wrap
msgid "a_output := a_output || '' AND name\n            LIKE ''''foobar''''''"
msgstr ""

#: xml/plpgsql.xml:4068(para)
msgid "When a single quotation mark in a string inside the function body is adjacent to the end of that string constant, for example: <placeholder-1/>The value appended to <literal>a_output</literal>would then be: <literal>AND name LIKE 'foobar'</literal>."
msgstr ""

#: xml/plpgsql.xml:4077(programlisting)
#, no-wrap
msgid "a_output := a_output || $$ AND name\n            LIKE 'foobar'$$"
msgstr ""

#: xml/plpgsql.xml:4076(para)
msgid "In the dollar-quoting approach, this becomes: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4082(term)
msgid "10 quotation marks"
msgstr ""

#: xml/plpgsql.xml:4091(programlisting)
#, no-wrap
msgid "a_output := a_output || '' if v_'' ||\n            referrer_keys.kind || '' like '''''''''' ||\n            referrer_keys.key_string || '''''''''' then return\n            '''''' || referrer_keys.referrer_type || ''''''; end\n            if;'';"
msgstr ""

#: xml/plpgsql.xml:4097(programlisting)
#, no-wrap
msgid "if v_... like ''...'' then return\n            ''...''; end if;"
msgstr ""

#: xml/plpgsql.xml:4084(para)
msgid "When you want two single quotation marks in a string constant (which accounts for 8 quotation marks) and this is adjacent to the end of that string constant (2 more). You will probably only need that if you are writing a function that generates other functions, as in <xref linkend=\"plpgsql-porting-ex2\">. For example: <placeholder-1/>The value of <literal>a_output</literal>would then be: <placeholder-2/></xref>"
msgstr ""

#: xml/plpgsql.xml:4100(programlisting)
#, no-wrap
msgid "a_output := a_output || $$ if v_$$ ||\n            referrer_keys.kind || $$ like '$$ ||\n            referrer_keys.key_string || $$' then return '$$ ||\n            referrer_keys.referrer_type || $$'; end\n            if;$$;"
msgstr ""

#: xml/plpgsql.xml:4099(para)
msgid "In the dollar-quoting approach, this becomes: <placeholder-1/>where we assume we only need to put single quote marks into <literal>a_output</literal>, because it will be re-quoted before use."
msgstr ""

#: xml/plpgsql.xml:4113(title)
msgid "Additional Compile-time Checks"
msgstr ""

#: xml/plpgsql.xml:4114(para)
msgid "To aid the user in finding instances of simple but common problems before they cause harm, <application>PL/PgSQL</application>provides additional <replaceable>checks</replaceable>. When enabled, depending on the configuration, they can be used to emit either a <literal>WARNING</literal>or an <literal>ERROR</literal>during the compilation of a function. A function which has received a <literal>WARNING</literal>can be executed without producing further messages, so you are advised to test in a separate development environment."
msgstr ""

#: xml/plpgsql.xml:4137(varname)
msgid "shadowed_variables"
msgstr ""

#: xml/plpgsql.xml:4140(para)
msgid "Checks if a declaration shadows a previously defined variable."
msgstr ""

#: xml/plpgsql.xml:4147(programlisting)
#, no-wrap
msgid "SET plpgsql.extra_warnings TO\n      'shadowed_variables'; CREATE FUNCTION foo(f1 int) RETURNS int\n      AS $$ DECLARE f1 int; BEGIN RETURN f1; END $$ LANGUAGE\n      plpgsql; WARNING: variable \"f1\" shadows a previously defined\n      variable LINE 3: f1 int; ^ CREATE\n      FUNCTION"
msgstr ""

#: xml/plpgsql.xml:4125(para)
msgid "These additional checks are enabled through the configuration variables <varname>plpgsql.extra_warnings</varname>for warnings and <varname>plpgsql.extra_errors</varname>for errors. Both can be set either to a comma-separated list of checks, <literal>\"none\"</literal>or <literal>\"all\"</literal>. The default is <literal>\"none\"</literal>. Currently the list of available checks includes only one: <placeholder-1/>The following example shows the effect of <varname>plpgsql.extra_warnings</varname>set to <varname>shadowed_variables</varname>: <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:4156(title)
msgid "Porting from <productname>Oracle</productname>PL/SQL"
msgstr ""

#: xml/plpgsql.xml:4159(primary)
msgid "Oracle"
msgstr ""

#: xml/plpgsql.xml:4160(secondary)
msgid "porting from PL/SQL to PL/pgSQL"
msgstr ""

#: xml/plpgsql.xml:4163(primary)
msgid "PL/SQL (Oracle)"
msgstr ""

#: xml/plpgsql.xml:4164(secondary)
msgid "porting to PL/pgSQL"
msgstr ""

#: xml/plpgsql.xml:4166(para)
msgid "This section explains differences between <productname>PostgreSQL</productname>'s <application>PL/pgSQL</application>language and Oracle's <application>PL/SQL</application>language, to help developers who port applications from <trademark class=\"registered\">Oracle</trademark>to <productname>PostgreSQL</productname>."
msgstr ""

#: xml/plpgsql.xml:4183(para)
msgid "If a name used in a SQL command could be either a column name of a table or a reference to a variable of the function, <application>PL/SQL</application>treats it as a column name. This corresponds to <application>PL/pgSQL</application>'s <literal>plpgsql.variable_conflict</literal>= <literal>use_column</literal>behavior, which is not the default, as explained in <xref linkend=\"plpgsql-var-subst\">. It's often best to avoid such ambiguities in the first place, but if you have to port a large amount of code that depends on this behavior, setting <literal>variable_conflict</literal>may be the best solution.</xref>"
msgstr ""

#: xml/plpgsql.xml:4200(para)
msgid "In <productname>PostgreSQL</productname>the function body must be written as a string literal. Therefore you need to use dollar quoting or escape single quotes in the function body. (See <xref linkend=\"plpgsql-quote-tips\">.)</xref>"
msgstr ""

#: xml/plpgsql.xml:4208(para)
msgid "Instead of packages, use schemas to organize your functions into groups."
msgstr ""

#: xml/plpgsql.xml:4212(para)
msgid "Since there are no packages, there are no package-level variables either. This is somewhat annoying. You can keep per-session state in temporary tables instead."
msgstr ""

#: xml/plpgsql.xml:4218(para)
msgid "Integer <command>FOR</command>loops with <literal>REVERSE</literal>work differently: <application>PL/SQL</application>counts down from the second number to the first, while <application>PL/pgSQL</application>counts down from the first number to the second, requiring the loop bounds to be swapped when porting. This incompatibility is unfortunate but is unlikely to be changed. (See <xref linkend=\"plpgsql-integer-for\">.)</xref>"
msgstr ""

#: xml/plpgsql.xml:4230(para)
msgid "<command>FOR</command>loops over queries (other than cursors) also work differently: the target variable(s) must have been declared, whereas <application>PL/SQL</application>always declares them implicitly. An advantage of this is that the variable values are still accessible after the loop exits."
msgstr ""

#: xml/plpgsql.xml:4239(para)
msgid "There are various notational differences for the use of cursor variables."
msgstr ""

#: xml/plpgsql.xml:4173(para)
msgid "<application>PL/pgSQL</application>is similar to PL/SQL in many aspects. It is a block-structured, imperative language, and all variables have to be declared. Assignments, loops, conditionals are similar. The main differences you should keep in mind when porting from <application>PL/SQL</application>to <application>PL/pgSQL</application>are: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4244(title)
msgid "Porting Examples"
msgstr ""

#: xml/plpgsql.xml:4248(application)
msgid "PL/SQL"
msgstr ""

#: xml/plpgsql.xml:4246(xref)
msgid "shows how to port a simple function from <placeholder-1/>to <placeholder-2/>."
msgstr ""

#: xml/plpgsql.xml:4252(title)
msgid "Porting a Simple Function from <application>PL/SQL</application>to <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:4258(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n        cs_fmt_browser_version(v_name varchar, v_version varchar)\n        RETURN varchar IS BEGIN IF v_version IS NULL THEN RETURN\n        v_name; END IF; RETURN v_name || '/' || v_version; END; /\n        show errors;"
msgstr ""

#: xml/plpgsql.xml:4255(para)
msgid "Here is an <productname>Oracle</productname><application>PL/SQL</application>function: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4268(para)
msgid "The <literal>RETURN</literal>key word in the function prototype (not the function body) becomes <literal>RETURNS</literal>in <productname>PostgreSQL</productname>. Also, <literal>IS</literal>becomes <literal>AS</literal>, and you need to add a <literal>LANGUAGE</literal>clause because <application>PL/pgSQL</application>is not the only possible function language."
msgstr ""

#: xml/plpgsql.xml:4280(para)
msgid "In <productname>PostgreSQL</productname>, the function body is considered to be a string literal, so you need to use quote marks or dollar quotes around it. This substitutes for the terminating <literal>/</literal>in the Oracle approach."
msgstr ""

#: xml/plpgsql.xml:4288(para)
msgid "The <literal>show errors</literal>command does not exist in <productname>PostgreSQL</productname>, and is not needed since errors are reported automatically."
msgstr ""

#: xml/plpgsql.xml:4263(para)
msgid "Let's go through this function and see the differences compared to <application>PL/pgSQL</application>: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4297(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n        cs_fmt_browser_version(v_name varchar, v_version varchar)\n        RETURNS varchar AS $$ BEGIN IF v_version IS NULL THEN\n        RETURN v_name; END IF; RETURN v_name || '/' || v_version;\n        END; $$ LANGUAGE plpgsql;"
msgstr ""

#: xml/plpgsql.xml:4295(para)
msgid "This is how this function would look when ported to <productname>PostgreSQL</productname>: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4304(xref)
msgid "shows how to port a function that creates another function and how to handle the ensuing quoting problems."
msgstr ""

#: xml/plpgsql.xml:4309(title)
msgid "Porting a Function that Creates Another Function from <application>PL/SQL</application>to <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:4313(para)
msgid "The following procedure grabs rows from a <command>SELECT</command>statement and builds a large function with the results in <literal>IF</literal>statements, for the sake of efficiency."
msgstr ""

#: xml/plpgsql.xml:4319(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE PROCEDURE\n        cs_update_referrer_type_proc IS CURSOR referrer_keys IS\n        SELECT * FROM cs_referrer_keys ORDER BY try_order; func_cmd\n        VARCHAR(4000); BEGIN func_cmd := 'CREATE OR REPLACE\n        FUNCTION cs_find_referrer_type(v_host IN VARCHAR, v_domain\n        IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN'; FOR\n        referrer_key IN referrer_keys LOOP func_cmd := func_cmd ||\n        ' IF v_' || referrer_key.kind || ' LIKE ''' ||\n        referrer_key.key_string || ''' THEN RETURN ''' ||\n        referrer_key.referrer_type || '''; END IF;'; END LOOP;\n        func_cmd := func_cmd || ' RETURN NULL; END;'; EXECUTE\n        IMMEDIATE func_cmd; END; / show\n        errors;"
msgstr ""

#: xml/plpgsql.xml:4318(para) xml/plpgsql.xml:4393(para)
msgid "This is the Oracle version: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4334(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n        cs_update_referrer_type_proc() RETURNS void AS $func$\n        DECLARE referrer_keys CURSOR IS SELECT * FROM\n        cs_referrer_keys ORDER BY try_order; func_body text;\n        func_cmd text; BEGIN func_body := 'BEGIN'; FOR referrer_key\n        IN referrer_keys LOOP func_body := func_body || ' IF v_' ||\n        referrer_key.kind || ' LIKE ' ||\n        quote_literal(referrer_key.key_string) || ' THEN RETURN '\n        || quote_literal(referrer_key.referrer_type) || '; END IF;'\n        ; END LOOP; func_body := func_body || ' RETURN NULL; END;';\n        func_cmd := 'CREATE OR REPLACE FUNCTION\n        cs_find_referrer_type(v_host varchar, v_domain varchar,\n        v_url varchar) RETURNS varchar AS ' ||\n        quote_literal(func_body) || ' LANGUAGE plpgsql;' ; EXECUTE\n        func_cmd; END; $func$ LANGUAGE\n        plpgsql;"
msgstr ""

#: xml/plpgsql.xml:4332(para)
msgid "Here is how this function would end up in <productname>PostgreSQL</productname>: <placeholder-1/>Notice how the body of the function is built separately and passed through <literal>quote_literal</literal>to double any quote marks in it. This technique is needed because we cannot safely use dollar quoting for defining the new function: we do not know for sure what strings will be interpolated from the <structfield>referrer_key.key_string</structfield>field. (We are assuming here that <structfield>referrer_key.kind</structfield>can be trusted to always be <literal>host</literal>, <literal>domain</literal>, or <literal>url</literal>, but <structfield>referrer_key.key_string</structfield>might be anything, in particular it might contain dollar signs.) This function is actually an improvement on the Oracle original, because it will not generate broken code when <structfield>referrer_key.key_string</structfield>or <structfield> referrer_key.referrer_type</structfield>contain quote marks."
msgstr ""

#: xml/plpgsql.xml:4374(literal)
msgid "OUT"
msgstr ""

#: xml/plpgsql.xml:4375(productname)
msgid "PostgreSQL"
msgstr ""

#: xml/plpgsql.xml:4377(function) xml/plpgsql.xml:4381(function) xml/plpgsql.xml:4607(function)
msgid "instr"
msgstr ""

#: xml/plpgsql.xml:4379(xref)
msgid "there is a <placeholder-1/>implementation of <placeholder-2/>that you can use to make your porting easier."
msgstr ""

#: xml/plpgsql.xml:4372(xref)
msgid "shows how to port a function with <placeholder-1/>parameters and string manipulation. <placeholder-2/>does not have a built-in <placeholder-3/>function, but you can create one using a combination of other functions. In <placeholder-4/>"
msgstr ""

#: xml/plpgsql.xml:4385(title)
msgid "Porting a Procedure With String Manipulation and <literal>OUT</literal>Parameters from <application>PL/SQL</application>to <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:4389(para)
msgid "The following <productname>Oracle</productname>PL/SQL procedure is used to parse a URL and return several elements (host, path, and query)."
msgstr ""

#: xml/plpgsql.xml:4394(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE PROCEDURE cs_parse_url(\n        v_url IN VARCHAR, v_host OUT VARCHAR, -- This will be\n        passed back v_path OUT VARCHAR, -- This one too v_query OUT\n        VARCHAR) -- And this one IS a_pos1 INTEGER; a_pos2 INTEGER;\n        BEGIN v_host := NULL; v_path := NULL; v_query := NULL;\n        a_pos1 := instr(v_url, '//'); IF a_pos1 = 0 THEN RETURN;\n        END IF; a_pos2 := instr(v_url, '/', a_pos1 + 2); IF a_pos2\n        = 0 THEN v_host := substr(v_url, a_pos1 + 2); v_path :=\n        '/'; RETURN; END IF; v_host := substr(v_url, a_pos1 + 2,\n        a_pos2 - a_pos1 - 2); a_pos1 := instr(v_url, '?', a_pos2 +\n        1); IF a_pos1 = 0 THEN v_path := substr(v_url, a_pos2);\n        RETURN; END IF; v_path := substr(v_url, a_pos2, a_pos1 -\n        a_pos2); v_query := substr(v_url, a_pos1 + 1); END; / show\n        errors;"
msgstr ""

#: xml/plpgsql.xml:4410(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION cs_parse_url(\n        v_url IN VARCHAR, v_host OUT VARCHAR, -- This will be\n        passed back v_path OUT VARCHAR, -- This one too v_query OUT\n        VARCHAR) -- And this one AS $$ DECLARE a_pos1 INTEGER;\n        a_pos2 INTEGER; BEGIN v_host := NULL; v_path := NULL;\n        v_query := NULL; a_pos1 := instr(v_url, '//'); IF a_pos1 =\n        0 THEN RETURN; END IF; a_pos2 := instr(v_url, '/', a_pos1 +\n        2); IF a_pos2 = 0 THEN v_host := substr(v_url, a_pos1 + 2);\n        v_path := '/'; RETURN; END IF; v_host := substr(v_url,\n        a_pos1 + 2, a_pos2 - a_pos1 - 2); a_pos1 := instr(v_url,\n        '?', a_pos2 + 1); IF a_pos1 = 0 THEN v_path :=\n        substr(v_url, a_pos2); RETURN; END IF; v_path :=\n        substr(v_url, a_pos2, a_pos1 - a_pos2); v_query :=\n        substr(v_url, a_pos1 + 1); END; $$ LANGUAGE\n        plpgsql;"
msgstr ""

#: xml/plpgsql.xml:4426(programlisting)
#, no-wrap
msgid "SELECT * FROM\n        cs_parse_url('http://foobar.com/query.cgi?baz');"
msgstr ""

#: xml/plpgsql.xml:4408(para)
msgid "Here is a possible translation into <application>PL/pgSQL</application>: <placeholder-1/>This function could be used like this: <placeholder-2/>"
msgstr ""

#: xml/plpgsql.xml:4430(xref)
msgid "shows how to port a procedure that uses numerous features that are specific to Oracle."
msgstr ""

#: xml/plpgsql.xml:4435(title)
msgid "Porting a Procedure from <application>PL/SQL</application>to <application>PL/pgSQL</application>"
msgstr ""

#: xml/plpgsql.xml:4439(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE PROCEDURE\n        cs_create_job(v_job_id IN INTEGER) IS a_running_job_count\n        INTEGER; PRAGMA AUTONOMOUS_TRANSACTION; \n        <co id=\"co.plpgsql-porting-pragma\">BEGIN LOCK TABLE cs_jobs\n        IN EXCLUSIVE MODE; \n        <co id=\"co.plpgsql-porting-locktable\">SELECT count(*) INTO\n        a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n        IF a_running_job_count 0 THEN COMMIT; -- free lock \n        <co id=\"co.plpgsql-porting-commit\">\n        raise_application_error(-20000, 'Unable to create a new\n        job: a job is currently running.'); END IF; DELETE FROM\n        cs_active_job; INSERT INTO cs_active_job(job_id) VALUES\n        (v_job_id); BEGIN INSERT INTO cs_jobs (job_id, start_stamp)\n        VALUES (v_job_id, sysdate); EXCEPTION WHEN dup_val_on_index\n        THEN NULL; -- don't worry if it already exists END; COMMIT;\n        END; / show errors</co></co></co>"
msgstr ""

#: xml/plpgsql.xml:4438(para)
msgid "The Oracle version: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4461(para)
msgid "There is no <literal>PRAGMA</literal>statement in <productname>PostgreSQL</productname>."
msgstr ""

#: xml/plpgsql.xml:4466(para)
msgid "If you do a <command>LOCK TABLE</command>in <application>PL/pgSQL</application>, the lock will not be released until the calling transaction is finished."
msgstr ""

#: xml/plpgsql.xml:4473(para)
msgid "You cannot issue <command>COMMIT</command>in a <application>PL/pgSQL</application>function. The function is running within some outer transaction and so <command>COMMIT</command>would imply terminating the function's execution. However, in this particular case it is not necessary anyway, because the lock obtained by the <command>LOCK TABLE</command>will be released when we raise an error."
msgstr ""

#: xml/plpgsql.xml:4455(para)
msgid "Procedures like this can easily be converted into <productname>PostgreSQL</productname>functions returning <type>void</type>. This procedure in particular is interesting because it can teach us some things: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4488(programlisting)
#, no-wrap
msgid "CREATE OR REPLACE FUNCTION\n        cs_create_job(v_job_id integer) RETURNS void AS $$ DECLARE\n        a_running_job_count integer; BEGIN LOCK TABLE cs_jobs IN\n        EXCLUSIVE MODE; SELECT count(*) INTO a_running_job_count\n        FROM cs_jobs WHERE end_stamp IS NULL; IF\n        a_running_job_count 0 THEN RAISE EXCEPTION 'Unable to\n        create a new job: a job is currently running'; \n        <co id=\"co.plpgsql-porting-raise\">END IF; DELETE FROM\n        cs_active_job; INSERT INTO cs_active_job(job_id) VALUES\n        (v_job_id); BEGIN INSERT INTO cs_jobs (job_id, start_stamp)\n        VALUES (v_job_id, now()); EXCEPTION WHEN unique_violation\n        THEN \n        <co id=\"co.plpgsql-porting-exception\">-- don't worry if it\n        already exists END; END; $$ LANGUAGE\n        plpgsql;</co></co>"
msgstr ""

#: xml/plpgsql.xml:4505(para)
msgid "The syntax of <literal>RAISE</literal>is considerably different from Oracle's statement, although the basic case <literal>RAISE</literal><replaceable class=\"parameter\"> exception_name</replaceable>works similarly."
msgstr ""

#: xml/plpgsql.xml:4513(para)
msgid "The exception names supported by <application>PL/pgSQL</application>are different from Oracle's. The set of built-in exception names is much larger (see <xref linkend=\"errcodes-appendix\">). There is not currently a way to declare user-defined exception names, although you can throw user-chosen SQLSTATE values instead.</xref>"
msgstr ""

#: xml/plpgsql.xml:4486(para)
msgid "This is how we could port this procedure to <application>PL/pgSQL</application>: <placeholder-1/><placeholder-2/>The main functional difference between this procedure and the Oracle equivalent is that the exclusive lock on the <literal>cs_jobs</literal>table will be held until the calling transaction completes. Also, if the caller later aborts (for example due to an error), the effects of this procedure will be rolled back."
msgstr ""

#: xml/plpgsql.xml:4532(title)
msgid "Other Things to Watch For"
msgstr ""

#: xml/plpgsql.xml:4533(para)
msgid "This section explains a few other things to watch for when porting Oracle <application>PL/SQL</application>functions to <productname>PostgreSQL</productname>."
msgstr ""

#: xml/plpgsql.xml:4538(title)
msgid "Implicit Rollback after Exceptions"
msgstr ""

#: xml/plpgsql.xml:4547(programlisting)
#, no-wrap
msgid "BEGIN SAVEPOINT s1; ... code here ...\n        EXCEPTION WHEN ... THEN ROLLBACK TO s1; ... code here ...\n        WHEN ... THEN ROLLBACK TO s1; ... code here ...\n        END;"
msgstr ""

#: xml/plpgsql.xml:4539(para)
msgid "In <application>PL/pgSQL</application>, when an exception is caught by an <literal>EXCEPTION</literal>clause, all database changes since the block's <literal>BEGIN</literal>are automatically rolled back. That is, the behavior is equivalent to what you'd get in Oracle with: <placeholder-1/>If you are translating an Oracle procedure that uses <command>SAVEPOINT</command>and <command>ROLLBACK TO</command>in this style, your task is easy: just omit the <command>SAVEPOINT</command>and <command>ROLLBACK TO</command>. If you have a procedure that uses <command>SAVEPOINT</command>and <command>ROLLBACK TO</command>in a different way then some actual thought will be required."
msgstr ""

#: xml/plpgsql.xml:4564(command)
msgid "EXECUTE"
msgstr ""

#: xml/plpgsql.xml:4566(para)
msgid "The <application>PL/pgSQL</application>version of <command>EXECUTE</command>works similarly to the <application>PL/SQL</application>version, but you have to remember to use <function>quote_literal</function>and <function>quote_ident</function>as described in <xref linkend=\"plpgsql-statements-executing-dyn\">. Constructs of the type <literal>EXECUTE 'SELECT * FROM $1';</literal>will not work reliably unless you use these functions.</xref>"
msgstr ""

#: xml/plpgsql.xml:4579(title)
msgid "Optimizing <application>PL/pgSQL</application>Functions"
msgstr ""

#: xml/plpgsql.xml:4581(para)
msgid "<productname>PostgreSQL</productname>gives you two function creation modifiers to optimize execution: <quote>volatility</quote>(whether the function always returns the same result when given the same arguments) and <quote>strictness</quote>(whether the function returns null if any argument is null). Consult the <xref linkend=\"sql-createfunction\">reference page for details.</xref>"
msgstr ""

#: xml/plpgsql.xml:4594(programlisting)
#, no-wrap
msgid "CREATE FUNCTION foo(...) RETURNS integer AS\n        $$ ... $$ LANGUAGE plpgsql STRICT\n        IMMUTABLE;"
msgstr ""

#: xml/plpgsql.xml:4590(para)
msgid "When making use of these optimization attributes, your <command>CREATE FUNCTION</command>statement might look something like this: <placeholder-1/>"
msgstr ""

#: xml/plpgsql.xml:4600(title)
msgid "Appendix"
msgstr ""

#: xml/plpgsql.xml:4601(para)
msgid "This section contains the code for a set of Oracle-compatible <function>instr</function>functions that you can use to simplify your porting efforts."
msgstr ""

#: xml/plpgsql.xml:4606(primary)
msgid "<placeholder-1/>function"
msgstr ""

#: xml/plpgsql.xml:4609(programlisting)
#, no-wrap
msgid "-- -- instr functions that mimic Oracle's\n      counterpart -- Syntax: instr(string1, string2, [n], [m])\n      where [] denotes optional parameters. -- -- Searches string1\n      beginning at the nth character for the mth occurrence -- of\n      string2. If n is negative, search backwards. If m is not\n      passed, -- assume 1 (search starts at first character). --\n      CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$\n      DECLARE pos integer; BEGIN pos:= instr($1, $2, 1); RETURN\n      pos; END; $$ LANGUAGE plpgsql STRICT IMMUTABLE; CREATE\n      FUNCTION instr(string varchar, string_to_search varchar,\n      beg_index integer) RETURNS integer AS $$ DECLARE pos integer\n      NOT NULL DEFAULT 0; temp_str varchar; beg integer; length\n      integer; ss_length integer; BEGIN IF beg_index 0 THEN\n      temp_str := substring(string FROM beg_index); pos :=\n      position(string_to_search IN temp_str); IF pos = 0 THEN\n      RETURN 0; ELSE RETURN pos + beg_index - 1; END IF; ELSIF\n      beg_index 0 THEN ss_length := char_length(string_to_search);\n      length := char_length(string); beg := length + beg_index -\n      ss_length + 2; WHILE beg 0 LOOP temp_str := substring(string\n      FROM beg FOR ss_length); pos := position(string_to_search IN\n      temp_str); IF pos 0 THEN RETURN beg; END IF; beg := beg - 1;\n      END LOOP; RETURN 0; ELSE RETURN 0; END IF; END; $$ LANGUAGE\n      plpgsql STRICT IMMUTABLE; CREATE FUNCTION instr(string\n      varchar, string_to_search varchar, beg_index integer,\n      occur_index integer) RETURNS integer AS $$ DECLARE pos\n      integer NOT NULL DEFAULT 0; occur_number integer NOT NULL\n      DEFAULT 0; temp_str varchar; beg integer; i integer; length\n      integer; ss_length integer; BEGIN IF beg_index 0 THEN beg :=\n      beg_index; temp_str := substring(string FROM beg_index); FOR\n      i IN 1..occur_index LOOP pos := position(string_to_search IN\n      temp_str); IF i = 1 THEN beg := beg + pos - 1; ELSE beg :=\n      beg + pos; END IF; temp_str := substring(string FROM beg +\n      1); END LOOP; IF pos = 0 THEN RETURN 0; ELSE RETURN beg; END\n      IF; ELSIF beg_index 0 THEN ss_length :=\n      char_length(string_to_search); length := char_length(string);\n      beg := length + beg_index - ss_length + 2; WHILE beg 0 LOOP\n      temp_str := substring(string FROM beg FOR ss_length); pos :=\n      position(string_to_search IN temp_str); IF pos 0 THEN\n      occur_number := occur_number + 1; IF occur_number =\n      occur_index THEN RETURN beg; END IF; END IF; beg := beg - 1;\n      END LOOP; RETURN 0; ELSE RETURN 0; END IF; END; $$ LANGUAGE\n      plpgsql STRICT IMMUTABLE;"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xml/plpgsql.xml:0(None)
msgid "translator-credits"
msgstr ""

